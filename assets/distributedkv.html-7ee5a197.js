import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o,c as d,a as e,b as i,e as r,f as s}from"./app-42738461.js";const n="/assets/Aspose.Words.e09b303e-1219-4cbf-a363-faf8f14eb196.001-e46fc771.jpeg",h="/assets/Aspose.Words.e09b303e-1219-4cbf-a363-faf8f14eb196.002-829be597.jpeg",p="/assets/Aspose.Words.e09b303e-1219-4cbf-a363-faf8f14eb196.003-042f811c.jpeg",c="/assets/Aspose.Words.e09b303e-1219-4cbf-a363-faf8f14eb196.004-ec16d798.png",u="/assets/dkv1-bc0d4496.png",b="/assets/dkv2-e2aa184c.png",_="/assets/dkv3-45a9f32a.png",f="/assets/dkv4-c3d5c560.png",m={},k=s('<p><em>旨在探索分布式缓存的设计与实现</em></p><h2 id="架构设计" tabindex="-1"><a class="header-anchor" href="#架构设计" aria-hidden="true">#</a> 架构设计</h2><h3 id="目标" tabindex="-1"><a class="header-anchor" href="#目标" aria-hidden="true">#</a> 目标</h3><ul><li>支持大容量缓存、持久化，PB 级别；</li><li>支持哈希槽分片，动态收缩；</li><li>支持 List，Set，String，Hash，Sorted set 等数据结构；</li><li>集成 Deno，支持脚本事务；</li><li>使用简单，redis-cli 客户端可直接使用，直连代理节点；</li><li>二次封装 redis 客户端，支持代理模式自动切换；</li></ul><h3 id="整体架构" tabindex="-1"><a class="header-anchor" href="#整体架构" aria-hidden="true">#</a> 整体架构</h3><p>distributed-kv 基于 Tikv 实现，并提供兼容 redis 数据结构的 API，支持基本 5 种基本类型数据结构，不支持 Pub/Sub，Pipeline 等高级特性，旨在探索超大容量缓存的架构实践。</p><p>整体如下：</p><p><img src="'+n+'" alt=""></p><ul><li>Client：客户端；</li><li>Discover：服务发现；</li><li>Proxy Cluster：服务代理集群；</li><li>Server Cluster：缓存服务集群，按照哈希槽分片；</li><li>Tikv Cluster：Tikv 集群，提供 KV 服务；</li><li>PD Cluster：Tikv 调度器、元数据管理集群，与 Tikv 并存；</li></ul><h3 id="客户端" tabindex="-1"><a class="header-anchor" href="#客户端" aria-hidden="true">#</a> 客户端</h3><p>distributed-kv 提供两种客户端访问模式：</p><ol><li>原生 redis 客户端通过 proxy 地址访问；</li><li>二次封装 redis 客户端通过 discover 服务发现访问；</li></ol><p>原生客户端兼容已有 redis 客户端访问模式，但 proxy 服务宕机需要手动切换地址；二次封装客户端基于服务发现 proxy 集群，proxy 单点故障后，由服务发现通知更换，避免二次编码、配置更改发布。</p><h3 id="代理服务" tabindex="-1"><a class="header-anchor" href="#代理服务" aria-hidden="true">#</a> 代理服务</h3><p>由于 distributed-kv 有多个缓存服务节点，这些节点可能分布在不同集群、区域中。客户端直接访问缓存服务有诸多不便：</p><ol><li>节点变更，客户端需感知变更；</li><li>多集群访问需要多个不同连接池；</li><li>缓存分片信息重度冗余在客户端等；</li></ol><p>基于此，distributed-kv 加了一层代理服务，客户端无需过多关注缓存服务集群信息，只需直连代理服务就能访问到不同集群的数据，连接管理更加简单方便，降低客户端使用难度。</p><p>代理服务是多个 proxy 节点组成的集群，proxy 节点注册到 ETCD，客户端通过拉取和监听 proxy 列表，然后再向访问单节点 redis 一样访问每个 proxy 即可。</p><p>由于 proxy 集群部署，因此其中有节点宕机也并无关系，客户端会选择其它节点继续使用。</p><p>这样访问 distributed-kv 就跟访问普通 redis 一样了，其架构图如下：</p><p><img src="'+h+'" alt=""></p><h3 id="缓存服务" tabindex="-1"><a class="header-anchor" href="#缓存服务" aria-hidden="true">#</a> 缓存服务</h3><p>缓存服务是 distributed-kv 的心脏，缓存集群负责处理 redis 协议请求，并将其转化为 Tikv 所支持的 KV API，操作 Tikv 集群后返回结果。</p><p><img src="'+p+'" alt=""></p><p>每个服务节点中 Transform 模块来负责完成 redis 5 种数据结构与基础 KV 的转换。</p><p>缓存服务通过哈希槽方式来实现分片，共有 1024 个哈希槽（slot），按照 crc32 哈希算法来分区，每个节点都有其特有的哈希槽，proxy 接到请求后，根据 key 的哈希计算得到 slot，然后转发到对应的缓存节点中。</p><h3 id="tikv-pd" tabindex="-1"><a class="header-anchor" href="#tikv-pd" aria-hidden="true">#</a> Tikv &amp; PD</h3><p>Tikv 是 Tidb 开源的一款分布式 KV 存储数据库，支持海量数据扩容，支持事务等多种特性，是 distributed-kv 的存储底座。</p><p>Tikv 本身架构就比较复杂，如下：</p><p><img src="'+c+'" alt=""></p>',30),v={href:"https://github.com/tikv/tikv",target:"_blank",rel:"noopener noreferrer"},g=s('<h2 id="详细设计" tabindex="-1"><a class="header-anchor" href="#详细设计" aria-hidden="true">#</a> 详细设计</h2><p>下面就每个模块详细阐述其设计。</p><h3 id="客户端-1" tabindex="-1"><a class="header-anchor" href="#客户端-1" aria-hidden="true">#</a> 客户端</h3><h4 id="原生客户端" tabindex="-1"><a class="header-anchor" href="#原生客户端" aria-hidden="true">#</a> 原生客户端</h4><p>指定 proxy 地址，直接使用 redis-cli 就可以直连，兼容 redis 生态，但：</p><ul><li>不支持<strong>除</strong>5 种基本类型的数据结构；</li><li>不支持代理集群自动切换等高级功能，代理节点宕机需手动更改地址；</li></ul><h4 id="代理客户端" tabindex="-1"><a class="header-anchor" href="#代理客户端" aria-hidden="true">#</a> 代理客户端</h4><p>兼容 redis 协议的新客户端，只需指定 Discover 服务发现组件的地址就能自动连接到 proxy 集群，支持：</p><ul><li>proxy 宕机自动切换；</li><li>proxy 集群动态收缩；</li><li>读写分离；</li></ul><h3 id="代理服务-1" tabindex="-1"><a class="header-anchor" href="#代理服务-1" aria-hidden="true">#</a> 代理服务</h3><p>代理服务最大的特点是 IO 密集，主要有如下功能：</p><ul><li>网络连接管理；</li><li>协议解析；</li><li>协议转发；</li><li>命令监控；</li></ul><p>另外代理节点启动时，需要向 Discover 中注册自身地址，供客户端使用；节点宕机后，注册信息自动失效，代理节点开启后台线程定点检查注册信息是否存在和正确。</p><h3 id="缓存服务-1" tabindex="-1"><a class="header-anchor" href="#缓存服务-1" aria-hidden="true">#</a> 缓存服务</h3><p>缓存服务主要有如下功能：</p><ul><li>协议解析、数据处理；</li><li>redis 命令转化为 Tikv API；</li></ul><p>缓存服务也需要将自己地址、哈希槽位等信息注册到 Discover 中，proxy 转发时会根据信息转发到正确的缓存节点上。</p><p>Tikv 只提供了单值的键值对类型，而 redis 键值对中的值还可以是集合类型，Transform 模块就需要处理这二者之间的转换。</p><p>对于 redis 的 String 类型来说，它本身就是单值的键值对，我们直接用 Tikv 保存就行。但是，对于集合类型来说，就无法直接把集合保存为单值的键值对，而是需要进行转换操作。</p><p>为了保持和 Redis 的兼容性，Transform 模块就负责把 redis 的集合类型转换成单值的键值对。简单来说，可以把 Redis 的集合类型分成两类：</p><ol><li>一类是 List 和 Set 类型，它们的集合中也只有单值；</li><li>另一类是 Hash 和 Sorted Set 类型，它们的集合中的元素是成对的，其中，Hash 集合元素是 field-value 类型，而 Sorted Set 集合元素是 member-score 类型。</li></ol><p>具体怎么转换呢？下面分别看下每种类型的转换。</p><h4 id="list-类型" tabindex="-1"><a class="header-anchor" href="#list-类型" aria-hidden="true">#</a> List 类型</h4><p>List 集合的 key 被嵌入到了单值键值对的键当中，用 key 字段表示；而 List 集合的元素值，则被嵌入到单值键值对的值当中，用 value 字段表示。</p><p>因为 List 集合中的元素是有序的，所以，Transform 模块还在单值键值对的 key 后面增加了 sequence 字段，表示当前元素在 List 中的顺序，同时，还在 value 的前面增加了 previous sequence 和 next sequence 这两个字段，分别表示当前元素的前一个元素和后一个元素。</p><p>此外，在单值键值对的 key 前面，Transform 模块还增加了一个值“l”，表示当前数据是 List 类型，以及增加了一个 1 字节的 size 字段，表示 List 集合 key 的大小。</p><p>在单值键值对的 value 后面，Transform 模块还增加了 version 和 ttl 字段，分别表示当前数据的版本号和剩余存活时间（用来支持过期 key 功能），如下图所示：</p><p><img src="'+u+'" alt=""></p><h4 id="set-集合" tabindex="-1"><a class="header-anchor" href="#set-集合" aria-hidden="true">#</a> Set 集合</h4><p>Set 集合的 key 和元素 member 值，都被嵌入到了 Pika 单值键值对的键当中，分别用 key 和 member 字段表示。同时，和 List 集合类似，单值键值对的 key 前面有值“s”，用来表示数据是 Set 类型，同时还有 size 字段，用来表示 key 的大小。Pika 单值键值对的值只保存了数据的版本信息和剩余存活时间，如下图所示：</p><p><img src="'+b+'" alt=""></p><h4 id="hash-集合" tabindex="-1"><a class="header-anchor" href="#hash-集合" aria-hidden="true">#</a> Hash 集合</h4><p>对于 Hash 类型来说，Hash 集合的 key 被嵌入到单值键值对的键当中，用 key 字段表示，而 Hash 集合元素的 field 也被嵌入到单值键值对的键当中，紧接着 key 字段，用 field 字段表示。Hash 集合元素的 value 则是嵌入到单值键值对的值当中，并且也带有版本信息和剩余存活时间，如下图所示：</p><p><img src="'+_+'" alt=""></p><h4 id="sorted-set-类型" tabindex="-1"><a class="header-anchor" href="#sorted-set-类型" aria-hidden="true">#</a> Sorted Set 类型</h4><p>Sorted Set 类型需要能够按照集合元素的 score 值排序的，而 RocksDB 只支持按照单值键值对的键来排序。所以，Nemo 模块在转换数据时，就把 Sorted Set 集合 key、元素的 score 和 member 值都嵌入到了单值键值对的键当中，此时，单值键值对中的值只保存了数据的版本信息和剩余存活时间，如下图所示：</p><p><img src="'+f+'" alt=""></p><p>采用了上面的转换方式之后，Transform 不仅能兼容支持 Redis 的数据类型，而且还保留了这些数据类型的特征，例如 List 的元素保序、Sorted Set 的元素按 score 排序。</p><p><em>Transform 转换方案并不是自己独有的，而是参考了 Pika，包括 rockskv 也使用了类似方案。</em></p><h2 id="what-s-next" tabindex="-1"><a class="header-anchor" href="#what-s-next" aria-hidden="true">#</a> What&#39;s Next</h2><p>实现 distributed-kv 😂，然后再完善文档。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',42),x=e("li",null,"https://github.com/pedrogao/rust-kv",-1),y={href:"https://www.cnblogs.com/Finley/category/1598973.html",target:"_blank",rel:"noopener noreferrer"},S=e("li",null,"https://github.com/seppo0010/rsedis",-1),T=e("li",null,"https://github.com/erikgrinaker/toydb",-1),L={href:"https://pdos.csail.mit.edu/6.824/labs/lab-shard.html",target:"_blank",rel:"noopener noreferrer"},P=e("li",null,"https://github.com/lotusdblabs/lotusdb",-1),D=e("li",null,"https://github.com/tidb-incubator/tidis",-1),V=e("li",null,"https://github.com/yongman/tidis",-1),H=e("li",null,"https://github.com/ledisdb/xcodis",-1),j=e("li",null,"https://github.com/dgraph-io/badger",-1),C=e("li",null,"https://github.com/talent-plan/tinykv",-1),A=e("li",null,"https://github.com/etcd-io/raft",-1),I=e("li",null,"https://github.com/HDT3213/godis",-1),R={href:"https://zhuanlan.zhihu.com/p/325745018",target:"_blank",rel:"noopener noreferrer"},w=e("li",null,"https://mp.weixin.qq.com/s/jsJ3_E_5IOs4_rPDM5axzQ",-1),K={href:"https://cn.pingcap.com/blog/the-design-and-implementation-of-multi-raft#raftstore",target:"_blank",rel:"noopener noreferrer"},N={href:"https://juejin.cn/post/6844904134550749191",target:"_blank",rel:"noopener noreferrer"},q={href:"https://juejin.cn/post/6844903850529259528",target:"_blank",rel:"noopener noreferrer"};function z(B,E){const t=l("ExternalLinkIcon");return o(),d("div",null,[k,e("p",null,[i("Tikv 具有优越的性能，良好的工程设计以及丰富的特性，十分适合作为分布式存储底座，这里就不赘述，可参考"),e("a",v,[i("这里"),r(t)]),i("。")]),g,e("ul",null,[x,e("li",null,[e("a",y,[i("用 Golang 实现 Redis - 随笔分类 - -Finley- - 博客园"),r(t)])]),S,T,e("li",null,[e("a",L,[i("6.5840 Lab 4: Sharded Key/Value Service"),r(t)])]),P,D,V,H,j,C,A,I,e("li",null,[e("a",R,[i("实践篇（08）Pika: 如何基于 SSD 实现大容量 Redis？"),r(t)])]),w,e("li",null,[e("a",K,[i("TiKV 源码解析系列 - multi-raft 设计与实现"),r(t)])]),e("li",null,[e("a",N,[i("开源|如何开发一个高性能的 redis cluster proxy? - 掘金"),r(t)])]),e("li",null,[e("a",q,[i("Redis Cluster 的数据分片机制 - 掘金"),r(t)])])])])}const O=a(m,[["render",z],["__file","distributedkv.html.vue"]]);export{O as default};
