import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as c,c as l,a as s,b as n,e,f as a}from"./app-42738461.js";const i={},u=a(`<h1 id="go-pool-池化学习、实践总结" tabindex="-1"><a class="header-anchor" href="#go-pool-池化学习、实践总结" aria-hidden="true">#</a> go pool 池化学习、实践总结</h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>最近在业务性能优化过程中，大量使用到了 pool 池化、缓存等技术。在用 pool 的时候一知半解<br> 地怼了上去，待上线过后就得抽时间系统学习、总结一下，于是就有了这篇文章。</p><p>首先，我们从一个场景出发，在一个简单的 http 接口服务中，如下：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">handleV1</span><span class="token punctuation">(</span>writer http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> <span class="token punctuation">(</span>
		err  <span class="token builtin">error</span>
		data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
	<span class="token punctuation">)</span>
    <span class="token comment">// ....</span>
	data<span class="token punctuation">,</span> err <span class="token operator">=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// ...... json.Unmarshal 之类的</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>都避免不了从请求体中读取数据，然后将其解析为 json 处理。每次服务收到请求调用 <code>handleV1</code>函数<br> 都避免不了在堆中(如果数据量很小，可能在栈中)开辟新的 <code>data []byte</code> 数据，而 <code>data</code> 数据在<br> 请求完毕后就成为了垃圾数据待回收。</p><p>在并发量、请求体都很大的情况下，内存就会迅速被占满，从而无法开启新的内存接受新的请求。</p><p>一般遇到这种内存大量开辟且迅速消亡的场景，做性能优化的时，可以采用对象池的方式，<br> 把不用的对象回收起来，避免被垃圾回收掉，这样使用的时候就不必重新创建。</p><p>类似的情况还有：数据库连接、TCP 长连接、HTTP 客户端连接等，这些连接在创建的时候是一个非常耗时的操作。</p><p>如果每次都创建一个新的连接对象，耗时较长，很可能整个业务的大部分耗时都花在了创建连接上。<br> 如果把这些连接保存下来，避免每次使用的时候都重新创建，不仅可以减少业务的耗时，还能提高应用程序的整体性能。</p><h2 id="go-pool" tabindex="-1"><a class="header-anchor" href="#go-pool" aria-hidden="true">#</a> Go pool</h2><p>Go 标准库中提供了一个通用的 pool 数据结构，也就是 sync.Pool，来帮助我们来处理这类问题。</p><p>但，Go pool 也有不适合的场景，它池化的对象可能会被垃圾回收掉，<br> 这对于数据库长连接等场景是不合适的，因此我们可以使用其它的池化方式，<br> 后面我们再来谈这个。</p><p>sync.Pool 用来保存一组可独立访问的<strong>临时</strong>对象。</p><p>注意这里的“临时”这两个字，它说明 pool 中的对象可能会被垃圾回收(GC)给干掉。</p><p>pool 可以有效地减少新对象的申请，提升内存的应用效率，所以 Go 标准库也用到了 pool。<br> 在 fmt 包中，使用了一个动态大小的 buffer 池做输出缓存，当大量的 goroutine 并发输出的时候，<br> 就会创建比较多的 buffer，并且在不需要的时候回收掉。</p><p>pool 有两个重要的知识点：</p><ul><li>pool 本身就是线程安全的，多个 goroutine 可以并发地调用它的方法存取对象；</li><li>pool 不可在使用之后再复制使用，内嵌了 <code>noCopy</code> 结构体，<code>go vet</code> 时检查。</li></ul><p>另外，pool API 非常易用，对外提供了三个方法，分别是 <code>New</code>，<code>Put</code> 和 <code>Get</code>。</p><ul><li>New：struct Pool 包含了一个 New 字段，这个字段的类型是函数 func() interface{}。<br> 当调用 pool 的 Get 方法从池中获取元素，没有更多的空闲元素可返回时，就会调用这个 New 方法来创建新的元素。<br> 如果没有设置 New 字段，没有更多的空闲元素可返回时，Get 方法将返回 nil，表明当前没有可用的元素。</li><li>Get：调用该方法，就会从 pool 取走一个元素，该元素会从 pool 中移除，返回给调用者。<br> 不过，除了返回值是正常实例化的元素，Get 方法的返回值还可能会是一个 nil(Pool.New 字段没有设置，又没有空闲元素可以返回)，<br> 所以在使用的时候，可能需要判断。</li><li>Put：将一个元素返还给 pool，pool 会把这个元素保存到池中(内部队列)，并且可以复用。<br> 但如果 Put 一个 nil 值，Pool 就会忽略这个值。</li></ul><h2 id="缓存池-bufferpool" tabindex="-1"><a class="header-anchor" href="#缓存池-bufferpool" aria-hidden="true">#</a> 缓存池 bufferPool</h2><p>回到刚才的业务场景上，字节切片(byte slice) data 被频繁创建然后销毁，<br> 浪费了大量内存。我们使用 pool 来优化这些场景，如下：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">var</span> bufferPool <span class="token operator">=</span> sync<span class="token punctuation">.</span>Pool<span class="token punctuation">{</span>
    New<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">GetBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer <span class="token punctuation">{</span>
    <span class="token keyword">return</span> bufferPool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">PutBuffer</span><span class="token punctuation">(</span>buf <span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    buf<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    bufferPool<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>定义 <code>bufferPool</code> 缓存池，<code>New</code> 函数用于返回一个新的 <code>bytes.Buffer</code>；</li><li><code>GetBuffer</code> 返回池中一个 Buffer；</li><li><code>PutBuffer</code> 将 Buffer 重新放入池中。</li></ol><p>这样就达到了对象重复利用的效果，减少了非必要内存的分配。pool 的使用就是这么简单，<br> 当然，对于 http 请求来说，如果请求体的大小是可预测的，完全可以在<code>New</code>的时候预分配<br> 足够的切片容量，即：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">var</span> bufferPool <span class="token operator">=</span> sync<span class="token punctuation">.</span>Pool<span class="token punctuation">{</span>
    New<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> bytes<span class="token punctuation">.</span><span class="token function">NewBuffer</span><span class="token punctuation">(</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 20KB</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这段代码是有问题的，它会产生内存泄漏。产生内存泄漏的原因在于 pool 的具体实现(可以自行 Google)，<br> pool 中的对象通过自定义 GC 函数<code>poolCleanup</code>来实现回收，该函数在一次 GC 时<br> 不会将对象直接 GC 掉，而是移动到 <code>victim</code> 队列中，下次还是可以使用，但两次 GC 之后就被回收了。</p><p>为什么会有内存浪费、内存泄漏(样例见附录 Pool 内存泄漏样例)：</p><ol><li>Get 方法从队列中取元素，本质上是随机的；</li><li>如果缓存了很大的[]byte，比如 256MB，那么 pool 占据了很大的内存容量；</li><li>如果后续 Get 方法取出了 256MB 的[]byte，但实际上只使用了 1KB 的小内存，就会浪费大量的内存；</li><li>由于 pool 的 GC 机制，一次 GC 并不会直接回收，所以就会有大量的大内存切片在队列中，<br> 只有下次 GC 才能回收，就会导致内存泄漏。</li></ol><p>Go fmt 包中，也踩了这个坑，而修复方法也很简单，当判断回收切片内存过大时，直接丢弃，不再<br> 进入池中：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">PutBuffer</span><span class="token punctuation">(</span>buf <span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> buf<span class="token punctuation">.</span><span class="token function">Cap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    buf<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    bufferPool<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,31),r=s("br",null,null,-1),d={href:"https://github.com/vitessio/vitess/blob/main/go/bucketpool/bucketpool.go",target:"_blank",rel:"noopener noreferrer"},k=s("br",null,null,-1),m=a(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// Get returns pointer to []byte which has len size.</span>
<span class="token comment">// If there is no bucket with buffers &gt;= size, slice will be allocated.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Pool<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>size <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">{</span>
	sp <span class="token operator">:=</span> p<span class="token punctuation">.</span><span class="token function">findPool</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span>
	<span class="token keyword">if</span> sp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">makeSlicePointer</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	buf <span class="token operator">:=</span> sp<span class="token punctuation">.</span>pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span>
	<span class="token operator">*</span>buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>size<span class="token punctuation">]</span>
	<span class="token keyword">return</span> buf
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="连接池-connpool" tabindex="-1"><a class="header-anchor" href="#连接池-connpool" aria-hidden="true">#</a> 连接池 connPool</h2><p>对于连接池而言，sync.Pool 自然就不再适用了，连接池的作用就在于能够一直保持连接，<br> 在需要使用的时候无需再次创建、握手、认证，省掉了一系列的步骤，就能直接使用。</p><p>连接池在 Go 的标准库中，也在大量使用。比如 http.Client 就通过 <code>map</code> 缓存了一定<br> 数量的 http 连接，如下：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> Transport <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	idleMu       sync<span class="token punctuation">.</span>Mutex
	closeIdle    <span class="token builtin">bool</span>                                <span class="token comment">// user has requested to close all idle conns</span>
	idleConn     <span class="token keyword">map</span><span class="token punctuation">[</span>connectMethodKey<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>persistConn <span class="token comment">// most recently used at end</span>
	idleConnWait <span class="token keyword">map</span><span class="token punctuation">[</span>connectMethodKey<span class="token punctuation">]</span>wantConnQueue  <span class="token comment">// waiting getConns</span>
	idleLRU      connLRU

	reqMu       sync<span class="token punctuation">.</span>Mutex
	reqCanceler <span class="token keyword">map</span><span class="token punctuation">[</span>cancelKey<span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">error</span><span class="token punctuation">)</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 sql.DB 中，Go 也提供了一个通用的数据库连接池：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> DB <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment">// Atomic access only. At top of struct to prevent mis-alignment</span>
	<span class="token comment">// on 32-bit platforms. Of type time.Duration.</span>
	waitDuration <span class="token builtin">int64</span> <span class="token comment">// Total time waited for new connections.</span>

	connector driver<span class="token punctuation">.</span>Connector
	<span class="token comment">// numClosed is an atomic counter which represents a total number of</span>
	<span class="token comment">// closed connections. Stmt.openStmt checks it before cleaning closed</span>
	<span class="token comment">// connections in Stmt.css.</span>
	numClosed <span class="token builtin">uint64</span>

	mu           sync<span class="token punctuation">.</span>Mutex    <span class="token comment">// protects following fields</span>
	freeConn     <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>driverConn <span class="token comment">// free connections ordered by returnedAt oldest to newest</span>
	connRequests <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">uint64</span><span class="token punctuation">]</span><span class="token keyword">chan</span> connRequest
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>freeConn</code> 字段用来缓存数据库连接，当需要访问数据的时候，拿来即用，另外还提供了<br> API 来设置空闲连接数的大小：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>db <span class="token operator">*</span>DB<span class="token punctuation">)</span> <span class="token function">SetMaxIdleConns</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>db <span class="token operator">*</span>DB<span class="token punctuation">)</span> <span class="token function">SetMaxOpenConns</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...so on</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9),v={href:"https://github.com/fatih/pool",target:"_blank",rel:"noopener noreferrer"},b=s("br",null,null,-1),f=a(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// PoolConn is a wrapper around net.Conn to modify the the behavior of</span>
<span class="token comment">// net.Conn&#39;s Close() method.</span>
<span class="token keyword">type</span> PoolConn <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	net<span class="token punctuation">.</span>Conn
	mu       sync<span class="token punctuation">.</span>RWMutex
	c        <span class="token operator">*</span>channelPool
	unusable <span class="token builtin">bool</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>连接池的使用太频繁，以至于很多人都忘记了它的存在。</p><h2 id="协程池-goroutinepool" tabindex="-1"><a class="header-anchor" href="#协程池-goroutinepool" aria-hidden="true">#</a> 协程池 goroutinePool</h2><p>熟悉其它语言的同学肯定知道，在业务中会大量地使用<code>线程池</code>，但是 Go 将线程完美的封装了起来，<br> 并提供了 go 关键字来直接开辟协程，虽然协程相对轻量，开启几万个乃至十万个都没啥问题，但每次<br> 请求来时开启协程，请求完后协程又得回收，这也是一种协程资源的浪费。</p><p>并且，如此大量的协程的创建也给调度器带来了极大的压力，因此参考线程池的使用方式，我们也可以<br> 来使用协程池。</p>`,5),h={href:"https://github.com/panjf2000/ants",target:"_blank",rel:"noopener noreferrer"},g=s("br",null,null,-1),y=a(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// Set 10000 the size of goroutine pool</span>
p<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> ants<span class="token punctuation">.</span><span class="token function">NewPool</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span><span class="token function">Submit</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>协程池最多只能有 10000 个 goroutine，当提交的任务过多则会新建 goroutine，<br> 当有大量 goroutine 空闲时，pool 会释放掉一批 goroutine 来保证内存。</p>`,2),w={href:"https://strikefreedom.top/high-performance-implementation-of-goroutine-pool",target:"_blank",rel:"noopener noreferrer"},P=s("br",null,null,-1),_=a(`<p>当然 goroutine pool 的实现还有很多，它们特性各异，各有优缺点，可以选择适合自己业务的来使用。</p><p>比如：</p><ul><li>gammazero/workerpool：可以无限制地提交任务，提供了更便利的 Submit 和 SubmitWait 方法提交任务，<br> 还可以提供当前的 worker 数和任务数以及关闭 Pool 的功能。</li><li>ivpusic/grpool：提供 Worker 的数量和等待执行的任务的最大数量，任务的提交是直接往 Channel 放入任务。</li><li>dpaks/goworkers：提供了更便利的 Submit 方法提交任务以及 Worker 数、任务数等查询方法、关闭 Pool 的方法。</li><li>so on...</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>至此，关于在 Go 中，池化的三种方式均以介绍完毕。</p><p>池化几乎可以作为性能、内存优化方案中最常见的一种了，希望下次遇到性能问题时，<br> 我们都能够精准感知系统已有的池化方案，并能在新的地方使用合适的池化方案。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2><ul><li>https://github.com/fatih/pool</li><li>https://www.cnblogs.com/qcrao-2018/p/12736031.html</li><li>https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/</li><li>https://marksuper.xyz/2021/09/02/sync_pool/</li><li>https://github.com/panjf2000/ants</li><li>https://strikefreedom.top/high-performance-implementation-of-goroutine-pool</li></ul><h2 id="附录" tabindex="-1"><a class="header-anchor" href="#附录" aria-hidden="true">#</a> 附录</h2><h3 id="pool-内存泄漏样例" tabindex="-1"><a class="header-anchor" href="#pool-内存泄漏样例" aria-hidden="true">#</a> Pool 内存泄漏样例</h3><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>pool <span class="token operator">:=</span> sync<span class="token punctuation">.</span>Pool<span class="token punctuation">{</span>New<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>

processRequest <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>size <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b <span class="token operator">:=</span> pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span>    <span class="token comment">// Get 从队列里面拿，实际上是随机的</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">500</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> <span class="token comment">// Simulate processing time</span>
    b<span class="token punctuation">.</span><span class="token function">Grow</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span>                       <span class="token comment">// 扩容后再put</span>

    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;buffer size: %d, cap: %d\\n&quot;</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token function">Cap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;address of buffer %p\\n&quot;</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>

    pool<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> <span class="token comment">// Simulate idle time</span>
<span class="token punctuation">}</span>

<span class="token comment">// Simulate a set of initial large writes.</span>
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">processRequest</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">28</span><span class="token punctuation">)</span> <span class="token comment">// 256MiB</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token comment">// Let the initial set finish</span>

<span class="token comment">// Simulate an un-ending series of small writes.</span>
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">{</span>
            <span class="token function">processRequest</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// 1KiB</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Continually run a GC and track the allocated bytes.</span>
<span class="token comment">// 40 Cycles 才被完全 free</span>
<span class="token keyword">var</span> stats runtime<span class="token punctuation">.</span>MemStats
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
    runtime<span class="token punctuation">.</span><span class="token function">ReadMemStats</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stats<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;Cycle %d: %dMB\\n&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> stats<span class="token punctuation">.</span>Alloc<span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
    runtime<span class="token punctuation">.</span><span class="token function">GC</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,11);function C(G,x){const t=p("ExternalLinkIcon");return c(),l("div",null,[u,s("p",null,[n("总而言之，标准库中的 pool 是不够好用的，因此有很多三方库来解决这些问题，"),r,n(" 比如"),s("a",d,[n("bucketpool"),e(t)]),k,n(" 提供了多层级的 pool 实现，按照输入的尺寸大小来返回合适的 pool：")]),m,s("p",null,[n("另外还有一些连接使用的是 TCP 协议，这就需要三方库的支持了，比如"),s("a",v,[n("fatih/pool"),e(t)]),b,n(" 就是一种 TCP 连接池的实现，不过它的实现略有不同，采用 channel 来缓存连接：")]),f,s("p",null,[s("a",h,[n("ants"),e(t)]),n(" 是三方的一个高性能、低损耗的 goroutine 池库，"),g,n(" 提供了简单易用的 API，如下：")]),y,s("p",null,[n("关于 goroutine pool 的实现，ants 的作者有一篇介绍其实现的"),s("a",w,[n("文章"),e(t)]),n("，"),P,n(" 感兴趣的同学可以参考参考。")]),_])}const q=o(i,[["render",C],["__file","pool.html.vue"]]);export{q as default};
