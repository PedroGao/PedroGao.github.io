<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>go-pool | pedrogao | pedrogao个人站</title>

  
  <meta name="author" content="pedrogao">
  

  
  <meta name="description" content="pedrogao个人站">
  

  
  <meta name="keywords" content="pedrogao">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="go-pool"/>

  <meta property="og:site_name" content="pedrogao"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="pedrogao" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">pedrogao</a>
    </h1>
    <p class="site-description">pedrogao个人站</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>go-pool</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/02/28/go-pool/" rel="bookmark">
        <time class="entry-date published" datetime="2022-02-28T16:34:01.000Z">
          2022-02-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Go-pool-池化学习、实践总结"><a href="#Go-pool-池化学习、实践总结" class="headerlink" title="Go pool 池化学习、实践总结"></a>Go pool 池化学习、实践总结</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在业务性能优化过程中，大量使用到了 pool 池化、缓存等技术。在用 pool 的时候一知半解<br>地怼了上去，待上线过后就得抽时间系统学习、总结一下，于是就有了这篇文章。</p>
<p>首先，我们从一个场景出发，在一个简单的 http 接口服务中，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func handleV1(writer http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	var (</span><br><span class="line">		err  error</span><br><span class="line">		data []byte</span><br><span class="line">	)</span><br><span class="line">    // ....</span><br><span class="line">	data, err = ioutil.ReadAll(req.Body)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	// ...... json.Unmarshal 之类的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都避免不了从请求体中读取数据，然后将其解析为 json 处理。每次服务收到请求调用 <code>handleV1</code>函数<br>都避免不了在堆中(如果数据量很小，可能在栈中)开辟新的 <code>data []byte</code> 数据，而 <code>data</code> 数据在<br>请求完毕后就成为了垃圾数据待回收。</p>
<p>在并发量、请求体都很大的情况下，内存就会迅速被占满，从而无法开启新的内存接受新的请求。</p>
<p>一般遇到这种内存大量开辟且迅速消亡的场景，做性能优化的时，可以采用对象池的方式，<br>把不用的对象回收起来，避免被垃圾回收掉，这样使用的时候就不必重新创建。</p>
<p>类似的情况还有：数据库连接、TCP 长连接、HTTP 客户端连接等，这些连接在创建的时候是一个非常耗时的操作。</p>
<p>如果每次都创建一个新的连接对象，耗时较长，很可能整个业务的大部分耗时都花在了创建连接上。<br>如果把这些连接保存下来，避免每次使用的时候都重新创建，不仅可以减少业务的耗时，还能提高应用程序的整体性能。</p>
<h2 id="Go-pool"><a href="#Go-pool" class="headerlink" title="Go pool"></a>Go pool</h2><p>Go 标准库中提供了一个通用的 pool 数据结构，也就是 sync.Pool，来帮助我们来处理这类问题。</p>
<p>但，Go pool 也有不适合的场景，它池化的对象可能会被垃圾回收掉，<br>这对于数据库长连接等场景是不合适的，因此我们可以使用其它的池化方式，<br>后面我们再来谈这个。</p>
<p>sync.Pool 用来保存一组可独立访问的<strong>临时</strong>对象。</p>
<p>注意这里的“临时”这两个字，它说明 pool 中的对象可能会被垃圾回收(GC)给干掉。</p>
<p>pool 可以有效地减少新对象的申请，提升内存的应用效率，所以 Go 标准库也用到了 pool。<br>在 fmt 包中，使用了一个动态大小的 buffer 池做输出缓存，当大量的 goroutine 并发输出的时候，<br>就会创建比较多的 buffer，并且在不需要的时候回收掉。</p>
<p>pool 有两个重要的知识点：</p>
<ul>
<li>pool 本身就是线程安全的，多个 goroutine 可以并发地调用它的方法存取对象；</li>
<li>pool 不可在使用之后再复制使用，内嵌了 <code>noCopy</code> 结构体，<code>go vet</code> 时检查。</li>
</ul>
<p>另外，pool API 非常易用，对外提供了三个方法，分别是 <code>New</code>，<code>Put</code> 和 <code>Get</code>。</p>
<ul>
<li>New：struct Pool 包含了一个 New 字段，这个字段的类型是函数 func() interface{}。<br>当调用 pool 的 Get 方法从池中获取元素，没有更多的空闲元素可返回时，就会调用这个 New 方法来创建新的元素。<br>如果没有设置 New 字段，没有更多的空闲元素可返回时，Get 方法将返回 nil，表明当前没有可用的元素。</li>
<li>Get：调用该方法，就会从 pool 取走一个元素，该元素会从 pool 中移除，返回给调用者。<br>不过，除了返回值是正常实例化的元素，Get 方法的返回值还可能会是一个 nil(Pool.New 字段没有设置，又没有空闲元素可以返回)，<br>所以在使用的时候，可能需要判断。</li>
<li>Put：将一个元素返还给 pool，pool 会把这个元素保存到池中(内部队列)，并且可以复用。<br>但如果 Put 一个 nil 值，Pool 就会忽略这个值。</li>
</ul>
<h2 id="缓存池-bufferPool"><a href="#缓存池-bufferPool" class="headerlink" title="缓存池 bufferPool"></a>缓存池 bufferPool</h2><p>回到刚才的业务场景上，字节切片(byte slice) data 被频繁创建然后销毁，<br>浪费了大量内存。我们使用 pool 来优化这些场景，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var bufferPool = sync.Pool&#123;</span><br><span class="line">    New: func() interface&#123;&#125; &#123;</span><br><span class="line">        return new(bytes.Buffer)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetBuffer() *bytes.Buffer &#123;</span><br><span class="line">    return bufferPool.Get().(*bytes.Buffer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func PutBuffer(buf *bytes.Buffer) &#123;</span><br><span class="line">    buf.Reset()</span><br><span class="line">    bufferPool.Put(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>定义 <code>bufferPool</code> 缓存池，<code>New</code> 函数用于返回一个新的 <code>bytes.Buffer</code>；</li>
<li><code>GetBuffer</code> 返回池中一个 Buffer；</li>
<li><code>PutBuffer</code> 将 Buffer 重新放入池中。</li>
</ol>
<p>这样就达到了对象重复利用的效果，减少了非必要内存的分配。pool 的使用就是这么简单，<br>当然，对于 http 请求来说，如果请求体的大小是可预测的，完全可以在<code>New</code>的时候预分配<br>足够的切片容量，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var bufferPool = sync.Pool&#123;</span><br><span class="line">    New: func() interface&#123;&#125; &#123;</span><br><span class="line">        return bytes.NewBuffer(make([]byte, 0, 20*1024)) // 20KB</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这段代码是有问题的，它会产生内存泄漏。产生内存泄漏的原因在于 pool 的具体实现(可以自行 Google)，<br>pool 中的对象通过自定义 GC 函数<code>poolCleanup</code>来实现回收，该函数在一次 GC 时<br>不会将对象直接 GC 掉，而是移动到 <code>victim</code> 队列中，下次还是可以使用，但两次 GC 之后就被回收了。</p>
<p>为什么会有内存浪费、内存泄漏(样例见附录 Pool 内存泄漏样例)：</p>
<ol>
<li>Get 方法从队列中取元素，本质上是随机的；</li>
<li>如果缓存了很大的[]byte，比如 256MB，那么 pool 占据了很大的内存容量；</li>
<li>如果后续 Get 方法取出了 256MB 的[]byte，但实际上只使用了 1KB 的小内存，就会浪费大量的内存；</li>
<li>由于 pool 的 GC 机制，一次 GC 并不会直接回收，所以就会有大量的大内存切片在队列中，<br>只有下次 GC 才能回收，就会导致内存泄漏。</li>
</ol>
<p>Go fmt 包中，也踩了这个坑，而修复方法也很简单，当判断回收切片内存过大时，直接丢弃，不再<br>进入池中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func PutBuffer(buf *bytes.Buffer) &#123;</span><br><span class="line">    if buf.Cap() &gt; 2*1024*1024 &#123;</span><br><span class="line">       return</span><br><span class="line">    &#125;</span><br><span class="line">    buf.Reset()</span><br><span class="line">    bufferPool.Put(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总而言之，标准库中的 pool 是不够好用的，因此有很多三方库来解决这些问题，<br>比如<a target="_blank" rel="noopener" href="https://github.com/vitessio/vitess/blob/main/go/bucketpool/bucketpool.go">bucketpool</a><br>提供了多层级的 pool 实现，按照输入的尺寸大小来返回合适的 pool：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Get returns pointer to []byte which has len size.</span><br><span class="line">// If there is no bucket with buffers &gt;= size, slice will be allocated.</span><br><span class="line">func (p *Pool) Get(size int) *[]byte &#123;</span><br><span class="line">	sp := p.findPool(size)</span><br><span class="line">	if sp == nil &#123;</span><br><span class="line">		return makeSlicePointer(size)</span><br><span class="line">	&#125;</span><br><span class="line">	buf := sp.pool.Get().(*[]byte)</span><br><span class="line">	*buf = (*buf)[:size]</span><br><span class="line">	return buf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="连接池-connPool"><a href="#连接池-connPool" class="headerlink" title="连接池 connPool"></a>连接池 connPool</h2><p>对于连接池而言，sync.Pool 自然就不再适用了，连接池的作用就在于能够一直保持连接，<br>在需要使用的时候无需再次创建、握手、认证，省掉了一系列的步骤，就能直接使用。</p>
<p>连接池在 Go 的标准库中，也在大量使用。比如 http.Client 就通过 <code>map</code> 缓存了一定<br>数量的 http 连接，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Transport struct &#123;</span><br><span class="line">	idleMu       sync.Mutex</span><br><span class="line">	closeIdle    bool                                // user has requested to close all idle conns</span><br><span class="line">	idleConn     map[connectMethodKey][]*persistConn // most recently used at end</span><br><span class="line">	idleConnWait map[connectMethodKey]wantConnQueue  // waiting getConns</span><br><span class="line">	idleLRU      connLRU</span><br><span class="line"></span><br><span class="line">	reqMu       sync.Mutex</span><br><span class="line">	reqCanceler map[cancelKey]func(error)</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 sql.DB 中，Go 也提供了一个通用的数据库连接池：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type DB struct &#123;</span><br><span class="line">	// Atomic access only. At top of struct to prevent mis-alignment</span><br><span class="line">	// on 32-bit platforms. Of type time.Duration.</span><br><span class="line">	waitDuration int64 // Total time waited for new connections.</span><br><span class="line"></span><br><span class="line">	connector driver.Connector</span><br><span class="line">	// numClosed is an atomic counter which represents a total number of</span><br><span class="line">	// closed connections. Stmt.openStmt checks it before cleaning closed</span><br><span class="line">	// connections in Stmt.css.</span><br><span class="line">	numClosed uint64</span><br><span class="line"></span><br><span class="line">	mu           sync.Mutex    // protects following fields</span><br><span class="line">	freeConn     []*driverConn // free connections ordered by returnedAt oldest to newest</span><br><span class="line">	connRequests map[uint64]chan connRequest</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>freeConn</code> 字段用来缓存数据库连接，当需要访问数据的时候，拿来即用，另外还提供了<br>API 来设置空闲连接数的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (db *DB) SetMaxIdleConns(n int);</span><br><span class="line">func (db *DB) SetMaxOpenConns(n int);</span><br><span class="line">// ...so on</span><br></pre></td></tr></table></figure>

<p>另外还有一些连接使用的是 TCP 协议，这就需要三方库的支持了，比如<a target="_blank" rel="noopener" href="https://github.com/fatih/pool">fatih&#x2F;pool</a><br>就是一种 TCP 连接池的实现，不过它的实现略有不同，采用 channel 来缓存连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// PoolConn is a wrapper around net.Conn to modify the the behavior of</span><br><span class="line">// net.Conn&#x27;s Close() method.</span><br><span class="line">type PoolConn struct &#123;</span><br><span class="line">	net.Conn</span><br><span class="line">	mu       sync.RWMutex</span><br><span class="line">	c        *channelPool</span><br><span class="line">	unusable bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接池的使用太频繁，以至于很多人都忘记了它的存在。</p>
<h2 id="协程池-goroutinePool"><a href="#协程池-goroutinePool" class="headerlink" title="协程池 goroutinePool"></a>协程池 goroutinePool</h2><p>熟悉其它语言的同学肯定知道，在业务中会大量地使用<code>线程池</code>，但是 Go 将线程完美的封装了起来，<br>并提供了 go 关键字来直接开辟协程，虽然协程相对轻量，开启几万个乃至十万个都没啥问题，但每次<br>请求来时开启协程，请求完后协程又得回收，这也是一种协程资源的浪费。</p>
<p>并且，如此大量的协程的创建也给调度器带来了极大的压力，因此参考线程池的使用方式，我们也可以<br>来使用协程池。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/panjf2000/ants">ants</a> 是三方的一个高性能、低损耗的 goroutine 池库，<br>提供了简单易用的 API，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Set 10000 the size of goroutine pool</span><br><span class="line">p, _ := ants.NewPool(10000)</span><br><span class="line">p.Submit(func()&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>协程池最多只能有 10000 个 goroutine，当提交的任务过多则会新建 goroutine，<br>当有大量 goroutine 空闲时，pool 会释放掉一批 goroutine 来保证内存。</p>
<p>关于 goroutine pool 的实现，ants<br>的作者有一篇介绍其实现的<a target="_blank" rel="noopener" href="https://strikefreedom.top/high-performance-implementation-of-goroutine-pool">文章</a>，<br>感兴趣的同学可以参考参考。</p>
<p>当然 goroutine pool 的实现还有很多，它们特性各异，各有优缺点，可以选择适合自己业务的来使用。</p>
<p>比如：</p>
<ul>
<li>gammazero&#x2F;workerpool：可以无限制地提交任务，提供了更便利的 Submit 和 SubmitWait 方法提交任务，<br>还可以提供当前的 worker 数和任务数以及关闭 Pool 的功能。</li>
<li>ivpusic&#x2F;grpool：提供 Worker 的数量和等待执行的任务的最大数量，任务的提交是直接往 Channel 放入任务。</li>
<li>dpaks&#x2F;goworkers：提供了更便利的 Submit 方法提交任务以及 Worker 数、任务数等查询方法、关闭 Pool 的方法。</li>
<li>so on…</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，关于在 Go 中，池化的三种方式均以介绍完毕。</p>
<p>池化几乎可以作为性能、内存优化方案中最常见的一种了，希望下次遇到性能问题时，<br>我们都能够精准感知系统已有的池化方案，并能在新的地方使用合适的池化方案。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/fatih/pool">https://github.com/fatih/pool</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qcrao-2018/p/12736031.html">https://www.cnblogs.com/qcrao-2018/p/12736031.html</a></li>
<li><a target="_blank" rel="noopener" href="https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/">https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/</a></li>
<li><a target="_blank" rel="noopener" href="https://marksuper.xyz/2021/09/02/sync_pool/">https://marksuper.xyz/2021/09/02/sync_pool/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/panjf2000/ants">https://github.com/panjf2000/ants</a></li>
<li><a target="_blank" rel="noopener" href="https://strikefreedom.top/high-performance-implementation-of-goroutine-pool">https://strikefreedom.top/high-performance-implementation-of-goroutine-pool</a></li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Pool-内存泄漏样例"><a href="#Pool-内存泄漏样例" class="headerlink" title="Pool 内存泄漏样例"></a>Pool 内存泄漏样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">pool := sync.Pool&#123;New: func() interface&#123;&#125; &#123; return new(bytes.Buffer) &#125;&#125;</span><br><span class="line"></span><br><span class="line">processRequest := func(size int) &#123;</span><br><span class="line">    b := pool.Get().(*bytes.Buffer)    // Get 从队列里面拿，实际上是随机的</span><br><span class="line">    time.Sleep(500 * time.Millisecond) // Simulate processing time</span><br><span class="line">    b.Grow(size)                       // 扩容后再put</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;buffer size: %d, cap: %d\n&quot;, b.Len(), b.Cap())</span><br><span class="line">    fmt.Printf(&quot;address of buffer %p\n&quot;, b)</span><br><span class="line"></span><br><span class="line">    pool.Put(b)</span><br><span class="line">    time.Sleep(1 * time.Millisecond) // Simulate idle time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Simulate a set of initial large writes.</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">        processRequest(1 &lt;&lt; 28) // 256MiB</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second) // Let the initial set finish</span><br><span class="line"></span><br><span class="line">// Simulate an un-ending series of small writes.</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            processRequest(1 &lt;&lt; 10) // 1KiB</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Continually run a GC and track the allocated bytes.</span><br><span class="line">// 40 Cycles 才被完全 free</span><br><span class="line">var stats runtime.MemStats</span><br><span class="line">for i := 0; ; i++ &#123;</span><br><span class="line">    runtime.ReadMemStats(&amp;stats)</span><br><span class="line">    fmt.Printf(&quot;Cycle %d: %dMB\n&quot;, i, stats.Alloc/(1024*1024))</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    runtime.GC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go-Pool/">Go, Pool</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 pedrogao
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>