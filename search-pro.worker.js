const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":305,\"nextId\":305,\"documentIds\":{\"0\":\"v-79fdd481\",\"1\":\"v-0e503981\",\"2\":\"v-0bc49a02\",\"3\":\"v-0bc49a02#什么是-lsm-tree\",\"4\":\"v-0bc49a02#学习-lsm-tree\",\"5\":\"v-0bc49a02#测试\",\"6\":\"v-0bc49a02#参考资料\",\"7\":\"v-39611c16\",\"8\":\"v-39611c16#前言\",\"9\":\"v-39611c16#简单案例\",\"10\":\"v-39611c16#简介\",\"11\":\"v-39611c16#实践\",\"12\":\"v-39611c16#counter\",\"13\":\"v-39611c16#op-based-counter\",\"14\":\"v-39611c16#state-based-counter\",\"15\":\"v-39611c16#lww-register\",\"16\":\"v-39611c16#operation-based-lww-register\",\"17\":\"v-39611c16#state-based-lww-register\",\"18\":\"v-39611c16#multi-lww-register-map\",\"19\":\"v-39611c16#结语\",\"20\":\"v-39611c16#参考资料\",\"21\":\"v-35f76ad8\",\"22\":\"v-35f76ad8#前言\",\"23\":\"v-35f76ad8#rga\",\"24\":\"v-35f76ad8#案例\",\"25\":\"v-35f76ad8#推演\",\"26\":\"v-35f76ad8#实现\",\"27\":\"v-35f76ad8#tinyautomerge\",\"28\":\"v-35f76ad8#数据结构建模\",\"29\":\"v-35f76ad8#map\",\"30\":\"v-35f76ad8#get\",\"31\":\"v-35f76ad8#put\",\"32\":\"v-35f76ad8#delete\",\"33\":\"v-35f76ad8#list\",\"34\":\"v-35f76ad8#get-1\",\"35\":\"v-35f76ad8#delete-1\",\"36\":\"v-35f76ad8#insert\",\"37\":\"v-35f76ad8#put-1\",\"38\":\"v-35f76ad8#结语\",\"39\":\"v-35f76ad8#参考资料\",\"40\":\"v-328db99a\",\"41\":\"v-328db99a#前言\",\"42\":\"v-328db99a#yata\",\"43\":\"v-328db99a#三条规则\",\"44\":\"v-328db99a#插入算法\",\"45\":\"v-328db99a#案例\",\"46\":\"v-328db99a#实现\",\"47\":\"v-328db99a#yata-版\",\"48\":\"v-328db99a#yjs-优化版\",\"49\":\"v-328db99a#tinyyjs\",\"50\":\"v-328db99a#数据建模\",\"51\":\"v-328db99a#冲突解决\",\"52\":\"v-328db99a#结语\",\"53\":\"v-328db99a#参考资料\",\"54\":\"v-1df29388\",\"55\":\"v-3341bfb0\",\"56\":\"v-3341bfb0#前言\",\"57\":\"v-3341bfb0#总览\",\"58\":\"v-3341bfb0#整体架构\",\"59\":\"v-3341bfb0#代码结构\",\"60\":\"v-3341bfb0#参考资料\",\"61\":\"v-34f6984f\",\"62\":\"v-34f6984f#缓存池\",\"63\":\"v-34f6984f#淘汰策略\",\"64\":\"v-34f6984f#缓存管理器\",\"65\":\"v-34f6984f#参考资料\",\"66\":\"v-36ab70ee\",\"67\":\"v-36ab70ee#并发-b-树\",\"68\":\"v-36ab70ee#b-树定义\",\"69\":\"v-36ab70ee#b-树设计\",\"70\":\"v-36ab70ee#b-树搜索\",\"71\":\"v-36ab70ee#b-树插入\",\"72\":\"v-36ab70ee#b-树删除\",\"73\":\"v-36ab70ee#crabbing-协议\",\"74\":\"v-36ab70ee#小结\",\"75\":\"v-36ab70ee#参考资料\",\"76\":\"v-3860498d\",\"77\":\"v-3860498d#执行器\",\"78\":\"v-3860498d#处理模型\",\"79\":\"v-3860498d#执行计划\",\"80\":\"v-3860498d#参考资料\",\"81\":\"v-3a15222c\",\"82\":\"v-3a15222c#并发控制\",\"83\":\"v-3a15222c#事务\",\"84\":\"v-3a15222c#事务隔离级别\",\"85\":\"v-3a15222c#二阶段事务\",\"86\":\"v-3a15222c#锁管理器\",\"87\":\"v-3a15222c#死锁\",\"88\":\"v-3a15222c#实现\",\"89\":\"v-3a15222c#执行器\",\"90\":\"v-3a15222c#参考资料\",\"91\":\"v-3bc9facb\",\"92\":\"v-3bc9facb#日志和恢复\",\"93\":\"v-3bc9facb#日志\",\"94\":\"v-3bc9facb#恢复\",\"95\":\"v-3bc9facb#参考资料\",\"96\":\"v-ca99df44\",\"97\":\"v-ca99df44#第一版-单文件持久化队列\",\"98\":\"v-ca99df44#第二版-多文件持久化队列\",\"99\":\"v-ca99df44#第三版-多消费者-fanout-持久化队列\",\"100\":\"v-70ba9e64\",\"101\":\"v-70ba9e64#架构设计\",\"102\":\"v-70ba9e64#目标\",\"103\":\"v-70ba9e64#整体架构\",\"104\":\"v-70ba9e64#客户端\",\"105\":\"v-70ba9e64#代理服务\",\"106\":\"v-70ba9e64#缓存服务\",\"107\":\"v-70ba9e64#tikv-pd\",\"108\":\"v-70ba9e64#详细设计\",\"109\":\"v-70ba9e64#客户端-1\",\"110\":\"v-70ba9e64#原生客户端\",\"111\":\"v-70ba9e64#代理客户端\",\"112\":\"v-70ba9e64#代理服务-1\",\"113\":\"v-70ba9e64#缓存服务-1\",\"114\":\"v-70ba9e64#list-类型\",\"115\":\"v-70ba9e64#set-集合\",\"116\":\"v-70ba9e64#hash-集合\",\"117\":\"v-70ba9e64#sorted-set-类型\",\"118\":\"v-70ba9e64#what-s-next\",\"119\":\"v-70ba9e64#参考资料\",\"120\":\"v-16733f83\",\"121\":\"v-16733f83#介绍\",\"122\":\"v-16733f83#领导者选举\",\"123\":\"v-16733f83#节点状态\",\"124\":\"v-16733f83#选举\",\"125\":\"v-16733f83#小结\",\"126\":\"v-16733f83#日志同步\",\"127\":\"v-16733f83#日志\",\"128\":\"v-16733f83#状态机\",\"129\":\"v-16733f83#同步\",\"130\":\"v-16733f83#完善选举\",\"131\":\"v-16733f83#日志应用\",\"132\":\"v-16733f83#小结-1\",\"133\":\"v-16733f83#持久化\",\"134\":\"v-16733f83#优化冲突同步\",\"135\":\"v-16733f83#小结-2\",\"136\":\"v-16733f83#快照\",\"137\":\"v-16733f83#完善日志同步\",\"138\":\"v-16733f83#小结-3\",\"139\":\"v-16733f83#总结\",\"140\":\"v-16733f83#参考资料\",\"141\":\"v-4067e526\",\"142\":\"v-4067e526#整体设计\",\"143\":\"v-4067e526#详细设计\",\"144\":\"v-4067e526#代理层\",\"145\":\"v-4067e526#路由层\",\"146\":\"v-4067e526#协议层\",\"147\":\"v-4067e526#序列化层\",\"148\":\"v-4067e526#注册层\",\"149\":\"v-4067e526#链路层\",\"150\":\"v-4067e526#容错层\",\"151\":\"v-4067e526#下一步计划\",\"152\":\"v-67314688\",\"153\":\"v-67314688#架构设计\",\"154\":\"v-67314688#详细设计\",\"155\":\"v-67314688#元数据\",\"156\":\"v-67314688#broker\",\"157\":\"v-67314688#api\",\"158\":\"v-67314688#消息存储\",\"159\":\"v-67314688#生产者\",\"160\":\"v-67314688#消费者\",\"161\":\"v-67314688#其它待实现特性\",\"162\":\"v-ffb67d9e\",\"163\":\"v-60c1906b\",\"164\":\"v-60c1906b#收获点\",\"165\":\"v-60c1906b#思考点\",\"166\":\"v-023f086b\",\"167\":\"v-023f086b#前言\",\"168\":\"v-023f086b#tdd-流程\",\"169\":\"v-023f086b#需求\",\"170\":\"v-023f086b#测试用例\",\"171\":\"v-023f086b#渐进式开发\",\"172\":\"v-023f086b#读取-xml-配置文件\",\"173\":\"v-023f086b#读取-mapper-xml-文件\",\"174\":\"v-023f086b#支持if语句\",\"175\":\"v-023f086b#参考资料\",\"176\":\"v-3fa780eb\",\"177\":\"v-3fa780eb#背景\",\"178\":\"v-3fa780eb#泛型\",\"179\":\"v-3fa780eb#泛型样例-1\",\"180\":\"v-3fa780eb#泛型原理\",\"181\":\"v-3fa780eb#泛型样例-2\",\"182\":\"v-3fa780eb#stream-设计\",\"183\":\"v-3fa780eb#创建阶段\",\"184\":\"v-3fa780eb#加工阶段\",\"185\":\"v-3fa780eb#汇总阶段\",\"186\":\"v-3fa780eb#stream-实现\",\"187\":\"v-3fa780eb#创建阶段-1\",\"188\":\"v-3fa780eb#加工阶段-1\",\"189\":\"v-3fa780eb#汇总阶段-1\",\"190\":\"v-3fa780eb#总结\",\"191\":\"v-3fa780eb#参考资料\",\"192\":\"v-d78f3932\",\"193\":\"v-d78f3932#操作系统\",\"194\":\"v-d78f3932#进程与线程\",\"195\":\"v-d78f3932#系统调用\",\"196\":\"v-d78f3932#概念\",\"197\":\"v-d78f3932#基本使用\",\"198\":\"v-d78f3932#go-中重要的系统调用\",\"199\":\"v-d78f3932#gmp-模型\",\"200\":\"v-d78f3932#流程剖析\",\"201\":\"v-d78f3932#热点问题\",\"202\":\"v-d78f3932#goexit0-是如何嵌入到非-main-goroutine-中的\",\"203\":\"v-d78f3932#m-是如何与系统线程绑定的\",\"204\":\"v-d78f3932#参考链接\",\"205\":\"v-d2803c04\",\"206\":\"v-d2803c04#魔法-1-调用-runtime-中的私有函数\",\"207\":\"v-d2803c04#memmove\",\"208\":\"v-d2803c04#growslice\",\"209\":\"v-d2803c04#魔法-2-调用-c-汇编函数\",\"210\":\"v-d2803c04#cgo\",\"211\":\"v-d2803c04#汇编\",\"212\":\"v-d2803c04#isspace\",\"213\":\"v-d2803c04#u32toa-small\",\"214\":\"v-d2803c04#总结\",\"215\":\"v-d2803c04#参考资料\",\"216\":\"v-44d91362\",\"217\":\"v-44d91362#魔法-1-最小化运行时-minimal-runtime\",\"218\":\"v-44d91362#魔法-2-即时编译-jit-just-in-time\",\"219\":\"v-44d91362#魔法-3-自举-bootstrap\",\"220\":\"v-44d91362#总结\",\"221\":\"v-44d91362#参考资料\",\"222\":\"v-468dec01\",\"223\":\"v-468dec01#前言\",\"224\":\"v-468dec01#编译源码\",\"225\":\"v-468dec01#ereturn\",\"226\":\"v-468dec01#go-编译器\",\"227\":\"v-468dec01#dowhile\",\"228\":\"v-468dec01#结语\",\"229\":\"v-468dec01#参考资料\",\"230\":\"v-4c9d7954\",\"231\":\"v-4c9d7954#概述\",\"232\":\"v-4c9d7954#内存布局\",\"233\":\"v-4c9d7954#管理方式\",\"234\":\"v-4c9d7954#手动管理\",\"235\":\"v-4c9d7954#自动管理\",\"236\":\"v-4c9d7954#内存管理\",\"237\":\"v-4c9d7954#内存分配原理\",\"238\":\"v-4c9d7954#gc-实践\",\"239\":\"v-4c9d7954#手动内存管理实践\",\"240\":\"v-4c9d7954#first-fit\",\"241\":\"v-4c9d7954#tcmalloc\",\"242\":\"v-4c9d7954#自动内存管理实践\",\"243\":\"v-4c9d7954#mark-sweep-标记清理法\",\"244\":\"v-4c9d7954#tricolor-三色标记法\",\"245\":\"v-4c9d7954#go-内存管理\",\"246\":\"v-4c9d7954#总结\",\"247\":\"v-4c9d7954#参考资料\",\"248\":\"v-24198b5b\",\"249\":\"v-24198b5b#基本介绍\",\"250\":\"v-24198b5b#寄存器\",\"251\":\"v-24198b5b#栈操作\",\"252\":\"v-24198b5b#数据移动\",\"253\":\"v-24198b5b#数据计算\",\"254\":\"v-24198b5b#流程跳转\",\"255\":\"v-24198b5b#变量定义\",\"256\":\"v-24198b5b#函数定义\",\"257\":\"v-24198b5b#小例子\",\"258\":\"v-24198b5b#参考资料\",\"259\":\"v-0f1b156a\",\"260\":\"v-0f1b156a#概述\",\"261\":\"v-0f1b156a#go-pool\",\"262\":\"v-0f1b156a#缓存池-bufferpool\",\"263\":\"v-0f1b156a#连接池-connpool\",\"264\":\"v-0f1b156a#协程池-goroutinepool\",\"265\":\"v-0f1b156a#总结\",\"266\":\"v-0f1b156a#参考资料\",\"267\":\"v-0f1b156a#附录\",\"268\":\"v-0f1b156a#pool-内存泄漏样例\",\"269\":\"v-0826edd7\",\"270\":\"v-0826edd7#tcp-概述\",\"271\":\"v-0826edd7#tcp-简单介绍\",\"272\":\"v-0826edd7#面向连接\",\"273\":\"v-0826edd7#可靠性\",\"274\":\"v-0826edd7#基于字节流\",\"275\":\"v-0826edd7#全双工\",\"276\":\"v-0826edd7#sponge-协议介绍\",\"277\":\"v-0826edd7#socket-api\",\"278\":\"v-0826edd7#用户态协议\",\"279\":\"v-0826edd7#sponge-协议概览\",\"280\":\"v-0826edd7#sponge-协议实现\",\"281\":\"v-0826edd7#bytestream\",\"282\":\"v-0826edd7#streamreassembler\",\"283\":\"v-0826edd7#tcpreceiver\",\"284\":\"v-0826edd7#tcpsender\",\"285\":\"v-0826edd7#tcpconnection\",\"286\":\"v-0826edd7#sponge-使用\",\"287\":\"v-0826edd7#总结\",\"288\":\"v-0826edd7#参考资料\",\"289\":\"v-474157c0\",\"290\":\"v-474157c0#使用\",\"291\":\"v-474157c0#环境搭建\",\"292\":\"v-474157c0#crosstool-ng\",\"293\":\"v-474157c0#buildroot\",\"294\":\"v-474157c0#修改源代码\",\"295\":\"v-474157c0#参考资料\",\"296\":\"v-76d185f2\",\"297\":\"v-e1e3da16\",\"298\":\"v-76d18e2e\",\"299\":\"v-5f688ebf\",\"300\":\"v-46608859\",\"301\":\"v-35495ef1\",\"302\":\"v-76d19d32\",\"303\":\"v-b6b78c94\",\"304\":\"v-76d1bbb6\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,19],\"1\":[1],\"2\":[5,4],\"3\":[3,14],\"4\":[3,463],\"5\":[1,103],\"6\":[1,6],\"7\":[2],\"8\":[1,98],\"9\":[1,46],\"10\":[1,103],\"11\":[1,26],\"12\":[1,9],\"13\":[3,168],\"14\":[3,93],\"15\":[2,31],\"16\":[4,97],\"17\":[4,53],\"18\":[5,104],\"19\":[1,31],\"20\":[1,28],\"21\":[2],\"22\":[1,22],\"23\":[1,75],\"24\":[1,17],\"25\":[1,127],\"26\":[1,187],\"27\":[1,49],\"28\":[1,124],\"29\":[1,3],\"30\":[1,37],\"31\":[1,34],\"32\":[1,34],\"33\":[1,5],\"34\":[1,49],\"35\":[1,29],\"36\":[1,35],\"37\":[1,48],\"38\":[1,16],\"39\":[1,26],\"40\":[2],\"41\":[1,46],\"42\":[1],\"43\":[1,114],\"44\":[1,67],\"45\":[1,18],\"46\":[1,6],\"47\":[2,168],\"48\":[2,132],\"49\":[1,40],\"50\":[1,106],\"51\":[1,164],\"52\":[1,11],\"53\":[1,30],\"54\":[1],\"55\":[3],\"56\":[1,84],\"57\":[1],\"58\":[1,77],\"59\":[1,73],\"60\":[1,7],\"61\":[3],\"62\":[1,22],\"63\":[1,130],\"64\":[1,284],\"65\":[1,11],\"66\":[3],\"67\":[2,11],\"68\":[1,96],\"69\":[1,212],\"70\":[1,85],\"71\":[1,212],\"72\":[1,237],\"73\":[2,208],\"74\":[1,18],\"75\":[1,17],\"76\":[3],\"77\":[1,36],\"78\":[1,85],\"79\":[1,230],\"80\":[1,12],\"81\":[3],\"82\":[1,20],\"83\":[1,26],\"84\":[1,83],\"85\":[1,85],\"86\":[1,45],\"87\":[1,44],\"88\":[1,198],\"89\":[1,125],\"90\":[1,23],\"91\":[3],\"92\":[1,39],\"93\":[1,47],\"94\":[1,47],\"95\":[1,9],\"96\":[1,8],\"97\":[2,16],\"98\":[2,80],\"99\":[4,12],\"100\":[3,1],\"101\":[1],\"102\":[1,26],\"103\":[1,39],\"104\":[1,22],\"105\":[1,36],\"106\":[1,36],\"107\":[2,19],\"108\":[1,2],\"109\":[1],\"110\":[1,15],\"111\":[1,13],\"112\":[1,17],\"113\":[1,56],\"114\":[2,51],\"115\":[2,28],\"116\":[2,19],\"117\":[3,39],\"118\":[3,6],\"119\":[1,68],\"120\":[3],\"121\":[1,37],\"122\":[1,30],\"123\":[1,153],\"124\":[1,245],\"125\":[1,32],\"126\":[1,120],\"127\":[1,56],\"128\":[1,73],\"129\":[1,273],\"130\":[1,93],\"131\":[1,120],\"132\":[1,23],\"133\":[1,152],\"134\":[1,183],\"135\":[1,17],\"136\":[1,402],\"137\":[1,70],\"138\":[1,22],\"139\":[1,60],\"140\":[1,15],\"141\":[2,3],\"142\":[1,19],\"143\":[1,22],\"144\":[1,70],\"145\":[1,43],\"146\":[1,113],\"147\":[1,65],\"148\":[1,43],\"149\":[1,52],\"150\":[1,95],\"151\":[1,38],\"152\":[1,43],\"153\":[1,40],\"154\":[1,3],\"155\":[1,76],\"156\":[1,11],\"157\":[1,134],\"158\":[1,61],\"159\":[1,36],\"160\":[1,36],\"161\":[1,25],\"162\":[2,56],\"163\":[1,1],\"164\":[1,369],\"165\":[1,91],\"166\":[3],\"167\":[1,13],\"168\":[2,45],\"169\":[1,13],\"170\":[1,101],\"171\":[1],\"172\":[3,89],\"173\":[4,33],\"174\":[3,92],\"175\":[1,9],\"176\":[3],\"177\":[1,79],\"178\":[1,10],\"179\":[2,102],\"180\":[1,63],\"181\":[2,139],\"182\":[2,16],\"183\":[1,44],\"184\":[1,39],\"185\":[1,33],\"186\":[2,12],\"187\":[1,46],\"188\":[1,90],\"189\":[1,47],\"190\":[1,69],\"191\":[1,33],\"192\":[6,27],\"193\":[1,7],\"194\":[1,95],\"195\":[1],\"196\":[1,10],\"197\":[1,133],\"198\":[2,133],\"199\":[2,112],\"200\":[1,846],\"201\":[1],\"202\":[6,51],\"203\":[3,60],\"204\":[1,33],\"205\":[2,8],\"206\":[5,44],\"207\":[1,142],\"208\":[1,132],\"209\":[5,5],\"210\":[1,84],\"211\":[1],\"212\":[1,205],\"213\":[2,187],\"214\":[1,29],\"215\":[1,41],\"216\":[2,11],\"217\":[6,220],\"218\":[8,403],\"219\":[5,271],\"220\":[1,8],\"221\":[1,22],\"222\":[2],\"223\":[1,44],\"224\":[1,77],\"225\":[1,257],\"226\":[2,65],\"227\":[1,519],\"228\":[1,56],\"229\":[1,17],\"230\":[2],\"231\":[1,87],\"232\":[1,67],\"233\":[1,21],\"234\":[1,72],\"235\":[1,47],\"236\":[1,76],\"237\":[1,185],\"238\":[2,278],\"239\":[1,37],\"240\":[2,149],\"241\":[1,294],\"242\":[1,51],\"243\":[4,345],\"244\":[3,179],\"245\":[2,49],\"246\":[1,8],\"247\":[1,58],\"248\":[2,28],\"249\":[1],\"250\":[1,64],\"251\":[1,49],\"252\":[1,31],\"253\":[1,16],\"254\":[1,35],\"255\":[1,88],\"256\":[1,62],\"257\":[1,162],\"258\":[1,16],\"259\":[4],\"260\":[1,76],\"261\":[2,95],\"262\":[2,144],\"263\":[2,165],\"264\":[2,85],\"265\":[1,11],\"266\":[1,39],\"267\":[1],\"268\":[2,85],\"269\":[3],\"270\":[2,46],\"271\":[2,4],\"272\":[1,32],\"273\":[1,29],\"274\":[1,22],\"275\":[1,22],\"276\":[2],\"277\":[2,55],\"278\":[1,51],\"279\":[2,114],\"280\":[2,46],\"281\":[1,111],\"282\":[1,237],\"283\":[1,290],\"284\":[1,326],\"285\":[1,418],\"286\":[2,255],\"287\":[1,21],\"288\":[1,14],\"289\":[3],\"290\":[1,23],\"291\":[1,264],\"292\":[2,78],\"293\":[1,123],\"294\":[1,206],\"295\":[1,60],\"296\":[1],\"297\":[1],\"298\":[1],\"299\":[1],\"300\":[1],\"301\":[1],\"302\":[1],\"303\":[1],\"304\":[1]},\"averageFieldLength\":[1.4918032786885247,82.40562855876041],\"storedFields\":{\"0\":{\"h\":\"主页\",\"t\":[\"过去二十年时间，敏捷宣言（Agile Manifesto）和精益创业（Lean startup）对软件社区最大的负面影响就是，一大堆外行或者并没有深刻理解软件工程的从业者，\\n过分追求速度，过度曲解 MVP（Minimum Viable Product），而忽视了从起点出发前，必不可少的架构和设计功夫，导致大部分技术债实际上是架构和设计阶段的债务。\"]},\"1\":{\"h\":\"幻灯片页\"},\"2\":{\"h\":\"跟着 ChatGPT 学 LSM Tree\",\"t\":[\"用一种新的方式来学习 LSM Tree。\"]},\"3\":{\"h\":\"什么是 LSM Tree\",\"t\":[\"一个老生常谈的话题\",\"文心一言的解释是：\",\"ChatGPT 的解释是：\",\"综合来看，ChatGPT 的解释更加的直观，也更加符合工程师视角，而文心一言的解释更加适合做 PPT。\",\"下面就跟随 ChatGPT 来学习 LSM Tree。\"]},\"4\":{\"h\":\"学习 LSM Tree\",\"t\":[\"首先客套一下，提问：\",\"你现在是一个数据库专家，擅长各类存储引擎 \",\"回答：\",\"非常抱歉，我是一个AI语言模型，没有具体的专业领域和技能。 我可以为您提供关于数据库和存储引擎的基本知识和一般性建议。 如果您有关于数据库的问题或需要有关存储引擎的信息，请随时告诉我，我会尽力帮助您。 \",\"不吃这一套，我直接单刀直入：\",\"请设计一款基于LSM树的存储引擎原型，要求给出详细的设计思路和伪代码 \",\"回答：\",\"为了设计基于 LSM 树的存储引擎原型，我们可以按照以下步骤进行：\",\"设计数据结构：\",\"定义存储引擎支持的数据类型，如键-值对。\",\"定义 LSM 树的数据结构，包括 memtable、SSTables（Sorted String Table）和 Bloom Filter。\",\"写入操作：\",\"当有数据写入时，将数据添加到 memtable 中。\",\"当 memtable 的大小达到一定阈值时，将其转换成 SSTable 并写入磁盘。同时，创建一个新的空的 memtable 以接收更多的写入操作。\",\"当写入数据时，还可将数据添加到 Bloom Filter 中以进行快速判断是否存在。\",\"读取操作：\",\"首先，在 memtable 中查找数据项。\",\"如果在 memtable 中找不到，则顺序查找最新的 SSTable 文件，直到找到或者找完所有文件为止。在查找过程中，可以使用 Bloom Filter 来快速判断某个键是否存在于 SSTable 文件中，从而减少磁盘读取次数。\",\"下面是一个简化的伪代码示例：\",\"class LSMTree: def __init__(self): self.memtable = {} self.SSTables = [] self.bloom_filter = BloomFilter() self.max_memtable_size = 1000 def write(self, key, value): self.memtable[key] = value if len(self.memtable) >= self.max_memtable_size: self.flush_memtable() def flush_memtable(self): sstable = SSTable(self.memtable) # 写入磁盘 sstable.write_to_disk() self.SSTables.append(sstable) self.memtable.clear() def read(self, key): if key in self.memtable: return self.memtable[key] for sstable in reversed(self.SSTables): if sstable.contains(key) and key in sstable: return sstable[key] return None def range_read(self, start_key, end_key): results = [] for sstable in reversed(self.SSTables): if sstable.contains_range(start_key, end_key): results.extend(sstable.get_range(start_key, end_key)) return results \",\"这只是一个简单的示例，你可以根据实际需求进行调整和优化。例如，可以添加压缩机制、合并策略和读缓存等，以提高性能和效率。\",\"专业！还是 TMD 的专业！\",\"继续：\",\"删除操作：\",\"删除操作可以被看作是写入一个特殊的标志位来表示该键已被删除。\",\"当执行删除操作时，将相应的键添加到 memtable，标记为删除状态。\",\"在读取操作中，如果发现一个键被标记为删除状态，则可以将其视为不存在。\",\"合并操作：\",\"为了减少磁盘空间的使用和提高查询性能，需要定期合并 SSTable 文件。\",\"可以使用一种合并策略，例如定期合并所有的 SSTables，或根据 SSTable 文件的大小或数量来触发合并。\",\"在合并过程中，可以使用类似归并排序的方式来合并多个 SSTables，并将结果写入新的更大的 SSTable 文件。\",\"压缩操作：\",\"为了进一步减少磁盘空间的使用，可以使用压缩算法对 SSTable 文件进行压缩。\",\"压缩操作可以在合并操作中进行，或者可以单独执行。\",\"压缩算法可以选择一种高效的压缩方法，如 Snappy 或 LZ4。\",\"缓存操作：\",\"为了提高读取性能，可以使用缓存来存储最常访问的数据项。\",\"可以使用 LRU（Least Recently Used）或 LFU（Least Frequently Used）等算法来实现缓存策略。\",\"缓存可以放在内存中，也可以使用专用的缓存服务器，如 Redis。\",\"设计基于 LSM 树的存储引擎需要综合考虑各种因素，如写入性能、读取性能、磁盘使用和内存占用等。通过合理的数据结构设计、写入策略、合并策略和压缩策略，可以实现高效的存储引擎。\",\"直接干翻很多垃圾资料书！继续：\",\"并发控制：\",\"在多线程或多进程环境下，需要实现并发控制来保证数据的一致性和正确性。\",\"可以使用锁机制来保证对数据的原子性访问和操作。\",\"可以使用读写锁（Read-Write Lock）来提高并发读取的性能。\",\"持久性和数据恢复：\",\"写操作需要保证数据的持久性，即将数据持久地写入磁盘。\",\"可以使用日志（Log）记录每次写操作，以便在系统发生故障时可以通过日志进行数据恢复。\",\"数据一致性：\",\"在 LSM 树中，不同的 SSTable 文件可能包含相同的键，并且它们可能具有不同的值。\",\"在查询操作时，需要保证返回的是最新的值，即需要通过 SSTable 文件的合并操作来维护数据的一致性。\",\"容错性：\",\"在系统发生故障时，需要保证数据的完整性和可靠性。\",\"可以使用备份和复制等机制来保证数据的容错性。\",\"可以使用故障检测和恢复机制来自动检测和修复故障。\",\"高可用性：\",\"在系统运行过程中，需要保证数据的高可用性，即系统能够持续地提供服务。\",\"可以使用主备份（Master-Slave）或分布式复制等机制来提高系统的可用性。\",\"LSM 树的设计和实现需要综合考虑以上各种因素，并根据具体应用场景和需求进行优化和调整。通过合理的设计和策略选择，可以实现高效、可靠和可扩展的存储引擎。\",\"光有理论不行，还要实践！请继续给出伪代码实现：\",\"以下是一个简单的伪代码示例，用来说明 LSM 树的基本思想和操作：\",\"class LSMTree: def __init__(self): self.memtable = {} self.sstable = [] # 写操作 def put(self, key, value): self.memtable[key] = value if len(self.memtable) >= THRESHOLD: self.flush() # 将内存表中的数据写入磁盘，形成新的SSTable文件 def flush(self): sorted_keys = sorted(self.memtable.keys()) sstable = SSTable(sorted_keys, self.memtable) self.sstable.append(sstable) self.memtable.clear() # 读操作 def get(self, key): result = None # 从内存表中查询 if key in self.memtable: result = self.memtable[key] # 从SSTable中查询（从后往前遍历，直到找到为止） for sstable in reversed(self.sstable): result = sstable.get(key) if result is not None: break return result class SSTable: def __init__(self, keys, values): self.keys = keys self.values = values # 从SSTable中查询指定键的值 def get(self, key): if key in self.keys: index = self.keys.index(key) return self.values[index] else: return None \",\"以上代码是一个简化版的 LSM 树实现，其中包含了 LSMTree 类和 SSTable 类。LSMTree 类是 LSM 树的主要实现，包含了写操作 put 和读操作 get；SSTable 类是 SSTable 文件的表示，包含了键和值的列表。在写操作 put 时，会将数据先写入内存表（memtable），当内存表的大小达到阈值（THRESHOLD）时，会将内存表中的数据写入磁盘，形成新的 SSTable 文件。 在读操作 get 时，会先从内存表中查询，如果找不到则通过遍历 SSTable 文件列表查询，直到找到对应的值或遍历完为止。\",\"请注意，以上代码仅是一个简化版的示例，并没有考虑并发控制、持久性和数据恢复、数据一致性、容错性和高可用性等方面的实现。\",\"实际实现中需要综合考虑以上因素，并根据具体需求进行优化和扩展。\",\"直接继续，看看能还能扒出什么：\",\"以下是 LSM 树的基本读写伪代码的完整示例：\",\"import bisect class LSMTree: def __init__(self): self.memtable = {} self.sstable = [] # 写操作 def put(self, key, value): self.memtable[key] = value if len(self.memtable) >= THRESHOLD: self.flush() # 将内存表中的数据写入磁盘，形成新的SSTable文件 def flush(self): keys = sorted(self.memtable.keys()) values = [self.memtable[key] for key in keys] sstable = SSTable(keys, values) self.sstable.append(sstable) self.memtable.clear() # 读操作 def get(self, key): # 从内存表中查询 if key in self.memtable: return self.memtable[key] # 从SSTable中查询（从后往前遍历，直到找到为止） for sstable in reversed(self.sstable): result = sstable.get(key) if result is not None: return result return None class SSTable: def __init__(self, keys, values): self.keys = keys self.values = values # 使用二分查找从SSTable中查询指定键的值 def get(self, key): index = bisect.bisect_left(self.keys, key) if index < len(self.keys) and self.keys[index] == key: return self.values[index] return None \",\"在以上示例中，我们引入了 bisect 模块来实现在 SSTable 中使用二分查找查询指定键的值。 在写操作 flush 中，我们使用了列表推导式来生成 SSTable 对象，并将其添加到 sstable 列表中。 在读操作 get 中，我们使用了二分查找算法来在 SSTable 中查询指定键的值，并将查询结果返回。\",\"值得注意的是，以上示例仍然是一个简化的版本，并没有考虑并发控制、持久性和数据恢复、数据一致性、容错性和高可用性等方面的实现。 实际实现中需要综合考虑以上因素，并根据具体需求进行优化和扩展。\",\"ChatGPT 开始梦游了，由于没有明确的prompt，它就不知道该说什么了，所以就开始重复了。这个时候，给一个明确的方向：\",\"请将 merge 操作加入其中。\",\"要在 LSM 树中添加合并（merge）操作，可以在 put 方法中进行检查，并在需要时执行合并操作。以下是更新后的 LSMTree 类的示例代码：\",\"import bisect class LSMTree: def __init__(self): self.memtable = {} self.sstable = [] # 写操作 def put(self, key, value): self.memtable[key] = value if len(self.memtable) >= THRESHOLD: self.flush() if len(self.sstable) > LEVEL_THRESHOLD: self.merge() # 将内存表中的数据写入磁盘，形成新的SSTable文件 def flush(self): keys = sorted(self.memtable.keys()) values = [self.memtable[key] for key in keys] sstable = SSTable(keys, values) self.sstable.append(sstable) self.memtable.clear() # 合并操作：将多个SSTable合并成一个更大的SSTable，并按照键的顺序排序 def merge(self): new_sstable = [] # 将所有SSTable的键值对合并成一个列表 entries = [] for sstable in self.sstable: entries.extend(zip(sstable.keys, sstable.values)) # 对键值对列表按照键排序 entries.sort(key=lambda x: x[0]) # 按照指定大小拆分键值对列表，并生成新的SSTable对象 i = 0 while i < len(entries): keys, values = zip(*entries[i:i+SSTABLE_SIZE]) new_sstable.append(SSTable(list(keys), list(values))) i += SSTABLE_SIZE # 更新SSTable列表 self.sstable = new_sstable # 读操作 def get(self, key): # 从内存表中查询 if key in self.memtable: return self.memtable[key] # 从SSTable中查询（从后往前遍历，直到找到为止） for sstable in reversed(self.sstable): result = sstable.get(key) if result is not None: return result return None class SSTable: def __init__(self, keys, values): self.keys = keys self.values = values # 使用二分查找从SSTable中查询指定键的值 def get(self, key): index = bisect.bisect_left(self.keys, key) if index < len(self.keys) and self.keys[index] == key: return self.values[index] return None \",\"在以上示例代码中，我们在 put 方法中添加了一个检查，当 SSTable 的数量超过阈值 LEVEL_THRESHOLD 时，将执行合并操作。 合并操作会将所有 SSTable 的键值对合并成一个更大的 SSTable，并按照键的顺序进行排序。 然后，我们根据指定的大小拆分键值对列表，并生成新的 SSTable 对象。最后，更新 SSTable 列表为新生成的 SSTable 列表。\",\"需要注意的是，在实际实现中可能需要处理一些并发控制和数据一致性的问题，例如在合并操作期间，可能需要对读写操作进行锁定以防止数据被修改。 此外，还可以根据具体需求对合并操作进行优化和扩展，比如使用更复杂的合并策略来减少 IO 操作和提高查询效率。\",\"再给点提示：现在需要加入事务支持，请问如何改造上面的 LSMTree 类代码\",\"要在上面的 LSMTree 类代码中加入事务支持，可以进行以下改造：\",\"添加一个新的类 Transaction，用于表示事务。Transaction 类可以包含以下属性：\",\"一个标识符用于唯一表示该事务\",\"一个字典用于存储在事务中插入或更新的键值对\",\"一个列表用于存储在事务中删除的键\",\"在 LSMTree 类中添加一个字典属性来存储所有进行中的事务。该字典的键是事务的标识符，值是对应的 Transaction 对象。\",\"在 LSMTree 类中添加以下方法来支持事务操作：\",\"begin_transaction(): 开始一个新的事务。 \",\"生成一个新的事务标识符。\",\"创建一个新的 Transaction 对象，并将其添加到进行中的事务字典中。\",\"commit_transaction(transaction_id): 提交一个事务。 \",\"根据提供的事务标识符获取对应的 Transaction 对象。\",\"将该事务中插入或更新的键值对依次写入 LSM 树中。\",\"将该事务中删除的键依次从 LSM 树中删除。\",\"从进行中的事务字典中移除该事务。\",\"abort_transaction(transaction_id): 中止一个事务。 \",\"根据提供的事务标识符获取对应的 Transaction 对象。\",\"清空该事务中插入或更新的键值对。\",\"从进行中的事务字典中移除该事务。\",\"修改 LSMTree 类的相应方法，以支持事务操作：\",\"put(key, value): 将键值对插入到当前事务的 Transaction 对象中。如果没有事务，则直接将其插入到 LSM 树中。\",\"delete(key): 将键添加到当前事务的 Transaction 对象的删除列表中。如果没有事务，则直接将其从 LSM 树中删除。\",\"get(key): 首先检查进行中的事务字典中是否有对应的事务，如果有，则返回该事务中的键值对。如果没有，则从 LSM 树中检索。\",\"通过以上改造，LSMTree 类就具备了事务支持能力。在进行事务操作时，可以通过 begin_transaction()方法开始一个新的事务，然后在事务中使用 put()和 delete()方法进行插入、更新和删除操作，最后使用 commit_transaction()方法提交事务。或者使用 abort_transaction()方法中止事务。\",\"一个字：强！请将完整代码给出：\",\"下面是根据以上改造说明完成的 LSMTree 类的代码：\",\"import uuid class LSMTree: def __init__(self): self.memtable = {} # 内存表（字典），用于暂时存储插入或更新的键值对 self.disktable = [] # 磁盘表（列表），用于存储已经稳定的键值对 self.transactions = {} # 进行中的事务字典，用于存储所有进行中的事务 def begin_transaction(self): transaction_id = str(uuid.uuid4()) transaction = Transaction(transaction_id) self.transactions[transaction_id] = transaction def commit_transaction(self, transaction_id): transaction = self.transactions.get(transaction_id) if transaction: # 将事务中插入或更新的键值对写入LSM树 for key, value in transaction.data.items(): self.memtable[key] = value # 从LSM树中删除事务中删除的键 for key in transaction.deleted_keys: self.memtable.pop(key, None) # 从进行中的事务字典中移除该事务 del self.transactions[transaction_id] def abort_transaction(self, transaction_id): transaction = self.transactions.get(transaction_id) if transaction: # 清空事务中插入或更新的键值对 transaction.data.clear() # 从进行中的事务字典中移除该事务 del self.transactions[transaction_id] def put(self, key, value): current_transaction = self.transactions.get(self.current_transaction_id) if current_transaction: # 如果当前存在事务，则将键值对插入到事务的数据字典中 current_transaction.data[key] = value else: # 如果没有事务，则直接插入到LSM树中 self.memtable[key] = value def delete(self, key): current_transaction = self.transactions.get(self.current_transaction_id) if current_transaction: # 如果当前存在事务，则将键添加到事务的删除列表中 current_transaction.deleted_keys.append(key) else: # 如果没有事务，则直接从LSM树中删除键 self.memtable.pop(key, None) def get(self, key): current_transaction = self.transactions.get(self.current_transaction_id) if current_transaction: # 如果当前存在事务，则首先在事务中检索键值对 value = current_transaction.data.get(key) if value is not None: return value # 在LSM树中检索键值对 value = self.memtable.get(key) if value is not None: return value for disktable in self.disktable: if key in disktable: return disktable[key] return None class Transaction: def __init__(self, transaction_id): self.transaction_id = transaction_id self.data = {} # 用于存储插入或更新的键值对 self.deleted_keys = [] # 用于存储删除的键 \",\"以上是加入事务支持的 LSMTree 类的完整代码。\",\"通过使用该类，可以创建一个 LSM 树，并使用 begin_transaction()方法开始一个新的事务，在事务中使用 put()和 delete()方法进行插入、更新和删除操作，最后使用 commit_transaction()方法提交事务。或者使用 abort_transaction()方法中止事务。\",\"在进行读取操作时，get()方法会首先在进行中的事务中检索键值对，如果没有找到，则继续在 LSM 树中检索。\"]},\"5\":{\"h\":\"测试\",\"t\":[\"学习从未如此轻松！将 ChatGPT 给出的LSMTree稍加修饰，我们测试看看效果：\",\"# Test code if __name__ == \\\"__main__\\\": lsm_tree = LSMTree() transaction_id = lsm_tree.begin_transaction() lsm_tree.put(\\\"a\\\", \\\"1\\\", transaction_id) lsm_tree.put(\\\"b\\\", \\\"2\\\", transaction_id) lsm_tree.put(\\\"c\\\", \\\"3\\\", transaction_id) assert lsm_tree.get(\\\"a\\\") == None assert lsm_tree.get(\\\"b\\\") == None assert lsm_tree.get(\\\"c\\\") == None print(lsm_tree.get(\\\"a\\\", transaction_id)) print(lsm_tree.get(\\\"b\\\", transaction_id)) print(lsm_tree.get(\\\"c\\\", transaction_id)) lsm_tree.commit_transaction(transaction_id) lsm_tree.put(\\\"d\\\", \\\"4\\\") lsm_tree.put(\\\"e\\\", \\\"5\\\") lsm_tree.put(\\\"f\\\", \\\"6\\\") lsm_tree.put(\\\"g\\\", \\\"7\\\") lsm_tree.put(\\\"h\\\", \\\"8\\\") lsm_tree.put(\\\"i\\\", \\\"9\\\") assert len(lsm_tree.memtable) == 9 lsm_tree.put(\\\"j\\\", \\\"10\\\") lsm_tree.put(\\\"k\\\", \\\"11\\\") assert len(lsm_tree.memtable) == 1 assert len(lsm_tree.sstable) == 1 assert lsm_tree.get(\\\"a\\\") == \\\"1\\\" lsm_tree.put(\\\"l\\\", \\\"12\\\") lsm_tree.put(\\\"m\\\", \\\"13\\\") lsm_tree.put(\\\"n\\\", \\\"14\\\") lsm_tree.put(\\\"o\\\", \\\"15\\\") lsm_tree.put(\\\"p\\\", \\\"16\\\") lsm_tree.put(\\\"q\\\", \\\"17\\\") lsm_tree.put(\\\"r\\\", \\\"18\\\") lsm_tree.put(\\\"s\\\", \\\"19\\\") lsm_tree.put(\\\"t\\\", \\\"20\\\") lsm_tree.put(\\\"u\\\", \\\"21\\\") assert len(lsm_tree.memtable) == 1 lsm_tree.put(\\\"v\\\", \\\"22\\\") lsm_tree.put(\\\"w\\\", \\\"23\\\") lsm_tree.put(\\\"x\\\", \\\"24\\\") lsm_tree.put(\\\"y\\\", \\\"25\\\") lsm_tree.put(\\\"z\\\", \\\"26\\\") lsm_tree.put(\\\"aa\\\", \\\"27\\\") lsm_tree.put(\\\"bb\\\", \\\"28\\\") lsm_tree.put(\\\"cc\\\", \\\"29\\\") lsm_tree.put(\\\"dd\\\", \\\"30\\\") lsm_tree.put(\\\"ee\\\", \\\"31\\\") assert len(lsm_tree.memtable) == 1 assert lsm_tree.get(\\\"a\\\") == \\\"1\\\" assert lsm_tree.get(\\\"aa\\\") == \\\"27\\\" # Output # 1 # 2 # 3 \",\"测试通过，基本覆盖了flush和merge等全部操作，虽然无法直接用于生产，但对于了解原理和get hands dirty来说，已经足够了。\",\"完整代码见：LSMTree.py，基本些许更改就能 work 了。\"]},\"6\":{\"h\":\"参考资料\",\"t\":[\"Learn Prompt\",\"Log-structured merge-tree\"]},\"7\":{\"h\":\"深入理解CRDT-基础篇\"},\"8\":{\"h\":\"前言\",\"t\":[\"CRDT 全称 convergent or commutative replicated data type (CRDT)，是近年来分布式领域的新宠。\",\"与其它分布式系统不同，CRDT 在设计上放弃了共识；这意味着一个 CRDT 副本执行操作时，完全无需与其它副本进行协商，大大提升了副本执行效率。\",\"没有协商并不代表副本数据之间会有差异，CRDT 通过良好的数据结构设计来使所有副本最终达到一致，但前提是任何副本执行的操作都必须通过网络传输并应用到其它副本，即使这些操作到达时是乱序的，但最后的数据仍然保证一致。\",\"目前分布式系统普遍是 3 副本、5 副本，CRDT 可以直接将副本数量提升几个量级，如果允许网络延迟，这个数量还能成倍增加。\",\"CRDT 最早可追溯到 2006 年的一篇论文，论文作者 Gérald 给出了主流协同算法 OT 存在不可解的 dirty case，并且 OT 实现十分复杂，不利于在分布式环境下扩展。\",\"基于此，Gérald 提出了一种名为 Without Operation Transformation (WOOT) 的协同算法，WOOT 算法是 CRDT 文本协同算法的鼻祖。\",\"而在 2011 年，Marc 在其论文Conflict-free Replicated Data Types中正式对 CRDT 给出了明确定义，详细探讨了分布式环境下，为了解决数据冲突从而达到最终一致性是十分困难的，而 CRDT 是一种优秀的可行解，论文还对 CRDT 最终一致性进行了严格证明。\",\"由于 CRDT 出现较晚，本身又比较复杂，为了帮助更多人学习了解 CRDT，Marc 在 2011 同年发布了另外一篇 CRDT 论文:\",\"A comprehensive study of Convergent and Commutative Replicated Data Types\",\"这篇论文详细的阐述了 CRDT 的原理，以及众多案例，并给出了诸多基础 CRDT 类型的伪代码实现，是不可多得的 CRDT 学习资源。\",\"既然珠玉在前，本文对 CRDT 的介绍也会着重参考这几篇论文，当然原理推导、名词介绍不是本身重点，下文会简明其扼要，本文会将重点放在 CRDT 实践上，重点阐述如何实现 CRDT，以及如何运行它。\"]},\"9\":{\"h\":\"简单案例\",\"t\":[\"CRDT（无冲突可复制数据类型）核心功能点，在于无冲突可复制，多个不同的数据副本分布在不同的客户端上，任意客户端都能即时编辑本地副本，无需与其它副本协调，并且保证最后的结果不会存在冲突。\",\"这种特性天然适合多人协作场景，如文档共同编辑、阅读，多人聊天，多人画图等等。说起来挺玄乎的，下面就用一个简单的Counter样例来看看 CRDT 是如何工作且多方协同的：\",\"如上，点击任意一方，增减数值，另外一端在及时收到操作后都能迅速达到双方一致的状态。点击 Network 按钮关闭掉网络，此时增减数值只会在本地生效，另外一段数值不会发生变化。\",\"再次开启网络，则双向又会迅速达成一致。\",\"而双方之所以能够丝滑的达成一致，核心是其核心数据Counter是通过 CRDT 来实现的，不仅如此，还可以发现：\",\"编辑双方需要通过网络传输编辑操作，以便二者数据达到一致；\",\"CRDT 天然支持离线编辑，即时网络断开，本地仍可编辑，而无需与其它节点协商；\",\"CRDT 无需中心化服务器，P2P 即可实现多端协同；\",\"即使编辑从双端扩展到多端，仍能保证多端的最终一致性，这就是 CRDT 的魅力。\"]},\"10\":{\"h\":\"简介\",\"t\":[\"CRDT 的核心思想是最终一致性，即任意副本最终都能达到一致，但不保证实时一致，这意味着 CRDT 副本之间可以存在不一致，但最终都能达到一致。\",\"CRDT 通过数据结构来保证最终一致性，而不是通过协商来保证最终一致性，这是 CRDT 与 OT 的最大区别。\",\"CRDT 分为两大类：\",\"Operation-based CRDT: Commutative Replicated Data Type (CmRDT)\",\"State-based CRDT：Convergent Replicated Data Type (CvRDT)\",\"二者目标一致，都是为了解决分布式环境下数据冲突的问题，从而达到最终一致性，不过达成一致的方式不同。\",\"Operation-based CRDT 强调的是操作，即用户对数据的操作，而 State-based CRDT 强调的是状态，即数据的状态。\",\"这也直接导致二者在设计上十分不同，具体有如下两点：\",\"二者的数据结构不同，Operation-based CRDT 的数据结构核心是操作，而 State-based CRDT 的数据结构核心是状态；\",\"通信数据不同，分布式环境下，多副本达成一致，彼此之间需要进行通信，二者在数据通信上也大不一样，简单说，Operation-based CRDT 交换操作，而 State-based CRDT 交换状态；\",\"CRDT 详细介绍请参考论文 Conflict-free Replicated Data Types，本文的重点在于实践， 对核心原理不做过多阐述，比如 CRDT 如何同时满足 CAP，如何保证强最终一致性等等，这些都是 CRDT 的基础，有兴趣的读者可以参考论文。\",\"既然 CRDT 有两种类型，那么在Counter这个简单案例中，它们是如何实现的呢？会有哪些不同，下面就来看看 Op-based Counter 和 State-based Counter 的伪代码：\",\"首先是 Op-based Counter：\",\"Op-based Counter 在实现上颇为简单，增减只需改变本地状态i即可，而同步时，只需将本地操作op发送给其它节点即可，其它节点收到op后，执行op即可。\",\"所以 Op-based Counter 的核心是操作同步，即图中公式的downstream()函数，具体关于如何实现在下面实践部分会详细介绍。\",\"然后是 State-based Counter：\",\"State-based Counter 在实现上稍微复杂一些，本地状态不再是一个简单的整数i，而是一个整数向量N，每个客户端都是向量 N 中的一项，增减时，客户端只能操作属于自己的项，即N[g]。\",\"而同步时，本地向量N发送给其它节点，其它节点收到N后，需要将本地向量N与收到的向量 N' 进行合并，然后再更新本地向量 N。\",\"摘自 A comprehensive study of Convergent and Commutative Replicated Data Types\"]},\"11\":{\"h\":\"实践\",\"t\":[\"纸上得来终觉浅，绝知此事要躬行，下面就来实践一下一些基础 CRDT 类型，包括：\",\"Counter：计数器；\",\"LWW-Register：单值寄存器；\",\"Multi-LWW-Register：多值存储，即 KV 哈希表存储；\",\"这些基础 CRDT 类型，既能帮助我们理解 CRDT，也是以后工业级 CRDT 库（如 Yjs，Automerge 等）的基础。\"]},\"12\":{\"h\":\"Counter\",\"t\":[\"前面已经介绍了 Op-based Counter 和 State-based Counter 的算法伪代码，下面分别来实现一下。\"]},\"13\":{\"h\":\"Op-based Counter\",\"t\":[\"首先是 Op-based Counter 的实现 OBCounter：\",\"export class OBCounter { value: number; clientId: string; clock: number; ops: Op<number>[]; vector: Map<string, number>; public constructor(init: number = 0, clientId?: string) { this.value = init; this.clientId = clientId ?? randomString(6); this.clock = 0; this.ops = []; this.vector = new Map(); } // ... } \",\"value：本地状态，即计数器的值；\",\"clientId：客户端 ID，用于标识客户端；\",\"clock：本地时钟，用于生成操作 ID；\",\"ops：操作数组，用于存储操作；\",\"vector：向量时钟，用于存储其它客户端的时钟；\",\"value 每次变更都会增加clock的值，vector 时钟的 key 是客户端 ID，value 是客户端的时钟 clock；\",\"OBCounter 的核心是ops数组，每个元素都是一个操作，即Op类型，Op类型定义如下：\",\"export enum OpType { // Counter op types Increment = \\\"increment\\\", Decrement = \\\"decrement\\\", } export type Op<T> = { type: OpType; value: T; id: Id; }; \",\"type：操作类型，即增加或减少；\",\"value：操作值，即增加或减少的值；\",\"id：操作 ID，用于标识操作；\",\"id 是一个元组：\",\"export type Id = [string, number]; \",\"由客户端 ID 和本地时钟组成，即clientId:clock，如client1:1，client1:2，client2:1，client2:2等等，这样既能保证操作 ID 的唯一性，也能保证不同客户端的操作 ID 之间是可比较的，即client1:1 < client1:2 < client2:1 < client2:2。\",\"这种设计思想其实是Lamport timestamp的具体实现，关于 Lamport timestamp 可以参考这里。\",\"Id可以标识每个Op的唯一性，vector用来记录不同客户端的 op 应用状态，避免重复应用 op 导致副本之间状态不一致。\",\"OBCounter 本地状态变更有两个核心方法：\",\"increment：增加计数器；\",\"decrement：减少计数器；\",\" public increment(): void { this.value++; this.ops.push({ type: OpType.Increment, value: 1, id: [this.clientId, this.clock++], } as Op<number>); } public decrement(): void { this.value--; this.ops.push({ type: OpType.Decrement, value: 1, id: [this.clientId, this.clock++], } as Op<number>); } \",\"每次变更都会增加clock的值，同时将变更的操作添加到ops数组中。\",\"需要读取计数器值时，调用get方法：\",\" public get(): number { return this.value; } \",\"需要将本地状态同步到其它节点时，调用flush方法：\",\" public flush() { return this.ops; } \",\"将本地的ops数组返回，其它节点收到ops数组后，调用apply方法依次应用op：\",\" public apply(op: Op<number>): void { const id = op.id; const clock = this.vector.get(id[0]) ?? -1; // Ignore old ops if (clock >= id[1]) { return; } // New op must match clock sequence if (clock + 1 !== id[1]) { throw new Error(`Op id not in order: ${clock} ${id[1]}`); } if (op.type === OpType.Increment) { this.value += op.value; } else if (op.type === OpType.Decrement) { this.value -= op.value; } else { throw new Error(`Unsupport op type: ${op.type}`); } this.vector.set(id[0], id[1]); } \",\"注意，op应用完成后，需立即更新vector时钟，否则会导致重复应用op；在 apply 方法中就针对 vector 做了 op 去重操作，避免 op 污染。\",\"调用flush()得到 ops 后，当前节点需要感知其它节点应用 op 成功的事件，否则下次调用仍会返回相同的 ops，这里可以通过ack来确认 op 应用成功，避免下次重复发送：\",\" public ack(op: Op<number>): void { this.ops = this.ops.filter((o) => !Id.equals(o.id, op.id)); } \",\"至此，一个简单的 OBCounter 就实现了，可以通过上面Counterdemo 来体验一下。\"]},\"14\":{\"h\":\"State-based Counter\",\"t\":[\"State-based Counter 的实现思路和 OBCounter 大不一样，由于 SBCounter 核心在于状态，为了保存所有客户端的数值状态，我们需要一个Map来保存；在通信上，由于传输的数据内容是状态，因此也无需 op，直接传输状态即可。\",\"export class SBCounter { clientId: string; s1: Map<string, number>; s2: Map<string, number>; public constructor(clientId?: string) { this.clientId = clientId ?? randomString(6); this.s1 = new Map(); this.s2 = new Map(); } } \",\"clientId：客户端 ID，用于标识客户端；\",\"s1：保存当前增值状态；\",\"s2：保存当前减值状态；\",\"SBCounter 本地状态变更有两个核心方法：\",\"increment：增加计数器；\",\"decrement：减少计数器；\",\" public increment(): void { this.s1.set(this.clientId, (this.s1.get(this.clientId) ?? 0) + 1); } public decrement(): void { this.s2.set(this.clientId, (this.s2.get(this.clientId) ?? 0) + 1); } \",\"每次变更都会将当前客户端的状态保存到Map中。读取计数时，调用get方法：\",\" public get(): number { return ( Array.from(this.s1.values()).reduce((a, b) => a + b, 0) - Array.from(this.s2.values()).reduce((a, b) => a + b, 0) ); } \",\"对于传输而来的远端状态，调用merge方法合并到本地：\",\"export type CounterState = { s1: Map<string, number>; s2: Map<string, number>; }; public merge(other: CounterState): void { for (const [k, v] of other.s1.entries()) { const old = this.s1.get(k) ?? 0; this.s1.set(k, Math.max(old, v)); } for (const [k, v] of other.s2.entries()) { const old = this.s2.get(k) ?? 0; this.s2.set(k, Math.max(old, v)); } } public toState(): CounterState { return { s1: this.s1, s2: this.s2, }; } \",\"下面就 SBCounter、OBCounter 两种实现进行一下简单对比：\",\"OBCounter\",\"SBCounter\",\"本地状态\",\"1 个整数\",\"2 个 Map\",\"通信内容\",\"1 个整数，一个操作\",\"2 个 Map\",\"通信方式\",\"op\",\"state\",\"实现成本\",\"读写简单，核心在 op，需要防重\",\"读写相对麻烦一点，需要状态合并，无需防重，核心在 state\"]},\"15\":{\"h\":\"LWW-Register\",\"t\":[\"LWW-Register 全称 Last Write Won Register 单值寄存器是 CRDT 另外一个重要的基础类型，它的特点是：\",\"任何时刻只有一个值；\",\"最后写入的值胜出；\",\"寄存器是比较官方的名称，其实一个变量，就像 js 中的： let a = \\\"a\\\"; 是一样的。\",\"与 Counter 类似，LWW-Register 也有两种实现方式：基于 op 的实现和基于 state 的实现。\"]},\"16\":{\"h\":\"Operation-based LWW-Register\",\"t\":[\"Operation-based LWW-Register 伪代码如下：\",\"变量x在初始化时，需要携带一个timestamp标识 x 的声明周期，当 x 被修改时，需要更新timestamp，这样才能保证最后写入的值胜出。\",\"具体的实现：\",\"export class OBLWWRegister<T> { value: T | null; clientId: string; clock: number; ops: Op<T>[]; public constructor(init?: T, clientId?: string) { this.value = init ?? null; this.clientId = clientId ?? randomString(6); this.clock = 0; this.ops = []; } } \",\"value：当前值；\",\"clientId：客户端 ID，用于标识客户端；\",\"clock：时间戳，用于标识当前值的声明周期；\",\"ops：保存所有变更操作；\",\"仍然沿用上文谈到的 Lamport 时钟，每次变更时，都会递增clock作为timestamp，并将变更操作保存到ops中：\",\" public set(value: T): void { this.value = value; this.ops.push({ type: OpType.Set, value: value, id: [this.clientId, ++this.clock], } as Op<T>); } \",\"读取值十分简单：\",\" public get(): T | null { return this.value; } \",\"既然是基于 op 实现，那么 apply，ack 也基本一致：\",\" public apply(op: Op<T>): void { const id = op.id; // Ignore old ops if (this.clock > id[1]) { return; } if (this.clock === id[1] && this.clientId > id[0]) { return; } if (op.type === OpType.Set) { this.value = op.value; this.clock = id[1]; } else { throw new Error(`Unsupport op type: ${op.type}`); } } public ack(op: Op<T>): void { this.ops = this.ops.filter((o) => !Id.equals(o.id, op.id)); } public flush() { return this.ops; } \",\"clock和vector来实现 op 去重。\",\"OBLWWRegister 可通过下面的 demo 来体验：\",\"在左侧输入框输入任何内容，都能被同步到右侧展示区，反之亦然。\"]},\"17\":{\"h\":\"State-based LWW-Register\",\"t\":[\"State-based LWW-Register 伪代码如下：\",\"与 SBCounter 相比，SBLWWRegister 实现更加简单，由于value是时间戳大的一方获胜，因此 merge 时，只需判断双方clock大小即可，如果相等，则判断双方 clientId 大小：\",\"export class SBLWWRegister<T> { clientId: string; value: T | null; clock: number; public constructor(init?: T, clientId?: string) { this.value = init ?? null; this.clientId = clientId ?? randomString(6); this.clock = 0; } public get(): T | null { return this.value; } public set(value: T): void { this.value = value; this.clock++; } public merge(state: RegisterState<T>): void { if (this.clock > state.id[1]) { return; } if (this.clock === state.id[1] && this.clientId > state.id[0]) { return; } this.value = state.value; this.clock = state.id[1]; } } \",\"当然，也别忘记在set变更值时，递增clock。\"]},\"18\":{\"h\":\"Multi-LWW-Register(Map)\",\"t\":[\"LWWRegister 用于表示一个变量，在其基础上，我们可以扩展出多个变量，即MultiLWWRegister，实际上这就是 Map 的 CRDT 实现。\",\"MultiLWWRegister 实现上也必须能支持多个值：\",\"export class MultiLWWRegister<T> { map: Map<string, T | null>; clientId: string; clock: number; ops: Op<string>[]; public constructor(clientId?: string) { this.map = new Map(); this.clientId = clientId ?? randomString(6); this.clock = 0; this.ops = []; } } \",\"map：用于保存多个变量，key 是变量名，value 是变量值；\",\"clientId：客户端 ID，用于标识客户端；\",\"clock：时间戳；\",\"ops：保存所有变更操作；\",\"读取值，调用 get 方法：\",\" public get(key: string): T | null { return this.map.get(key) ?? null; } \",\"通过 set 方法设置值：\",\" public set(key: string, value: T): void { this.map.set(key, value); this.ops.push({ type: OpType.KV, value: JSON.stringify([key, value]), id: [this.clientId, ++this.clock], } as Op<string>); } \",\"并将变更操作保存到ops中。\",\"与其它基于 op 的 CRDT 一样，MultiLWWRegister 也需要 apply，flush 应用、传输 op：\",\" public apply(op: Op<string>): void { const id = op.id; // Ignore old ops if (this.clock > id[1]) { return; } if (this.clock === id[1] && this.clientId > id[0]) { return; } if (op.type === OpType.KV) { const [key, value] = JSON.parse(op.value); this.map.set(key, value); this.clock = id[1]; } else { throw new Error(`Unsupport op type: ${op.type}`); } } public ack(op: Op<string>): void { this.ops = this.ops.filter((o) => !Id.equals(o.id, op.id)); } public flush() { return this.ops; } \",\"核心在apply上，当发现 op 的时间戳小于当前时间戳，或者时间戳相等但 clientId 大于当前 clientId 时，忽略该 op，就样就能保证此时的值是最新的。\",\"MultiLWWRegister 可通过下面的 demo 来体验：\"]},\"19\":{\"h\":\"结语\",\"t\":[\"本文旨在介绍一些基础 CRDT 类型，为以后深入理解文本 CRDT 算法做铺垫。\",\"回顾一下，本篇文章简单介绍了 CRDT 的基本概念，以及常见的几种 CRDT 实现，包括：\",\"Counter;\",\"Register;\",\"Multi-Register(Map);\",\"而 CRDT 的类型还有 Set，Graph 等，感兴趣的可以参考A comprehensive study of Convergent and Commutative Replicated Data Types。\"]},\"20\":{\"h\":\"参考资料\",\"t\":[\"Data consistency for P2P collaborative editing\",\"Conflict-free Replicated Data Types\",\"A comprehensive study of Convergent and Commutative Replicated Data Types\",\"CRDT 简介\",\"如何设计 CRDT 算法\",\"An Interactive Intro to CRDTs\",\"Lamport timestamp\"]},\"21\":{\"h\":\"深入理解CRDT-RGA篇\"},\"22\":{\"h\":\"前言\",\"t\":[\"上一篇文章我们介绍了 CRDT 的基本概念，探讨了一些基础 CRDT 的实现。从本篇文章开始，我们将深入两种 CRDT 算法：\",\"RGA\",\"YATA\",\"这两种算法分别是知名 CRDT 库 Automerge 和 Yjs 所采用的算法，被广泛应用于生产环境，是深入 CRDT 应用的基础。\",\"本篇文章我们将介绍 RGA 算法，下一篇文章我们将介绍 YATA 算法。\"]},\"23\":{\"h\":\"RGA\",\"t\":[\"RGA 全称 Replicate Growable Array 可复制增长数组，由 Hyun 于 2011 年在论文Replicated abstract data types: Building blocks for collaborative applications中提出（2011 年真的是 CRDT 爆发的一年）。\",\"千万别被名字吓到了，其实 RGA 就是列表的 CRDT 实现。论文原话是： growable array is the Vector class of JAVA or STL.\",\"论文中提到 RGA 在有序复制集合上拥有良好的插入、删除性能，优于已有的 OT 算法，适合用于协同文本编辑场景。\",\"当然 RGA 不仅适用于有序文本，同时也能推广到有序列表，哈希表等场景，因此 RGA 也是 Automerge 库的基础。\",\"论文中，给出了 RGA 基于双向链表实现的部分伪代码，如下：\",\"伪代码实现十分简单，无论是插入还是删除，都是在链表中排除已删除项，找到i对应的位置，然后插入或删除即可。\",\"不过，双向链表显然无法满足大文本编辑、查找等场景的性能要求，因此有不少优化版的 RGA 实现，比如：\",\"Automerge 中 RGA 是基于 B+树实现的；\",\"Cola中 RGA 是基于 G-tree 实现的；\",\"RGATreeSplit使用平衡树来优化 RGA；\"]},\"24\":{\"h\":\"案例\",\"t\":[\"下面，以纯文本协同编辑为例，看看 RGA 是如何工作的。\",\"只支持简单的英文、数字文本增、删，不支持中文、复制粘贴等操作。 没办法，input 中文事件笔者不会啊。\",\"在左侧输入框中编辑文本内容，都会同步到对方，最终保证两个输入框的内容一致。\"]},\"25\":{\"h\":\"推演\",\"t\":[\"文本内容本质上是插入操作的集合，因此我们可以通过插入操作来推演 RGA 的工作原理。\",\"下面，以纯文本协同编辑为例，看看 RGA 是保证多方编辑内容最终一致的。\",\"首先，我们看一个最简单的例子：有且只有一个客户端进行编辑\",\"客户端 1 在位置0插入字符1，并将插入操作(op)同步到客户端 2，客户端 2 收到 op 并应用后，将1插入到位置0，此时客户端 1 和客户端 2 的文本内容是一致的。\",\"因为只有客户端 1 有编辑操作，其它客户端处于只读状态，那么就不能产生编辑冲突，因此最后的文本内容肯定是一致的。\",\"可一旦有多个客户端同时进行编辑，就会产生编辑冲突，导致最终文本内容不一致，比如：\",\"客户端 1、2 分别在位置1插入字符2、3，并将插入操作(op)同步到对方应用后，此时客户端 1 和客户端 2 的文本内容不一致。\",\"而产生不一致的原因是，操作同步的数据：\",\"insert(1, \\\"2\\\"); \",\"虽然携带了插入位置1和插入数据2，但没有其它约束条件，导致最终文本内容不一致。\",\"我们可以通过插入意图来解决这个问题：\",\"client1: insert(1, \\\"2\\\", \\\"1\\\"); client2: insert(1, \\\"3\\\", \\\"1\\\"); \",\"这里，\\\"1\\\"就是插入意图，表示在1之后插入2，3，但这样就能保证最终文本内容一致吗？\",\"显然是不能的，因为1虽然是插入意图，但是文本中可能存在多个1，比如：\",\"我们为每个插入字符都添加一个唯一的标识符 Id，比如字符1的 Id：\",\"// [siteId, counter] export type Id = [string, number]; \",\"Id 包括两部分，第一部分是客户端的唯一标识符，第二部分是客户端操作的序号，这样就能保证每个字符都有唯一的 Id。\",\"有了 Id 后，操作同步数据就变成了：\",\"// params: // 1. 插入位置 // 2. 插入数据 // 3. 插入意图，即当前插入位置字符的 Id insert(1, \\\"2\\\", [\\\"site1\\\", 1]); \",\"这样能够保证最终文本内容一致了吗？如下：\",\"客户端 1、2 分别在位置1插入字符2、3，因为两个插入操作的意图是一致的，都插入在字符1右侧，但字符2，3之间位置暂时不知如何排列，从而导致最终文本内容不一致。\",\"我们可以通过字符2，3的 Id 来解决二者之间的插入排序问题，即：\",\"client1: insert(1, { id: [\\\"site1\\\", 2], content: \\\"2\\\" }, [\\\"site1\\\", 1]); client2: insert(1, { id: [\\\"site2\\\", 1], content: \\\"3\\\" }, [\\\"site1\\\", 1]); \",\"约定，如果插入意图一致，那么就按照字符 Id 来排序：\",\"如果counter不同，那么按照counter排序，大者在右边；\",\"如果counter相同，那么按照siteId排序，大者在右边；\",\"有了排序后，最终文本内容就一致了：\",\"最后，来看看删除操作，我们将一次插入抽象为一个Item，即：\",\"export type Item<T> = { content: T | null; // 插入内容 id: Id; // Id parent: Id | null; // 插入意图 }; \",\"至于删除，最容易想到的是将Item直接删除掉，但这显然不行，因此不同客户端可能在同一个插入意图上工作，如果将字符删除掉了，那么意图也就丢失了，文本最终内容也就不一致了。\",\"因此，我们不能直接删除Item，而是引入墓碑机制，即：\",\"export type Item<T> = { content: T | null; // 插入内容 id: Id; // Id isDeleted: boolean; parent: Id | null; // 插入意图 }; \",\"删除Item时，将isDeleted设置为 true，这样就能保留插入意图，从而保证最终文本内容一致。\"]},\"26\":{\"h\":\"实现\",\"t\":[\"充分推演后，我们就能给出一个简单 RGA 的实现了。\",\"首先是数据建模，每个插入字符操作被抽象为一个Item：\",\"export type Item<T> = { content: T | null; // root item has no content id: Id; isDeleted: boolean; children: Id[]; // children of this item parent: Id | null; // parent of this item }; \",\"parent：插入意图；\",\"children：子节点，每个字符都可能成为多个字符的意图，因此子节点可能有多个；\",\"很明显，这样的数据结构导致文本内容是一个树：\",\"ROOT 节点是虚拟节点，标识文档的开始，没有实际意义。\",\"因此我们可以使用Map来存储Item，其中key是Item.id，value是Item。\",\"export class Doc<T> { root: Id; length: number; vector: Vector; clientId: string; store: Map<string, Item<T>>; public constructor(clientId?: string) { const cid = clientId ?? randomString(6); const root = { content: null, id: [cid, 0], isDeleted: false, children: [], parent: null, } as Item<T>; // Root item should insert at the beginning, and could not be deleted or updated this.root = root.id; this.length = 0; // Exclude root item this.vector = { [cid]: 0, }; this.clientId = cid; this.store = new Map([[Id.hash(root.id), root]]); } } \",\"root：文档的根节点，虚拟节点；\",\"length：文档长度，不包括根节点；\",\"vector：客户端向量；\",\"clientId：客户端唯一标识符；\",\"store：存储Item的Map；\",\"新建Doc时，向store中插入根节点，同时设置length、vector。\",\"由于整个文档是一颗树，每个字符是其中一个节点，获取文档内容时，我们需要遍历整个树，将所有字符拼接起来：\",\" public getContent(): T[] { const doc = this; const content: T[] = []; const queue: Id[] = []; queue.push(doc.root); while (queue.length > 0) { const id = queue.shift()!; const item = doc.store.get(Id.hash(id))!; if (!item.isDeleted && item.content !== null) { content.push(item.content); } queue.push(...item.children); } return content; } \",\"由于字符3被软删除掉了，因此最终文本内容是[1, 2, 4]。\",\"接下来是插入操作，插入操作的核心是生成Item，然后将集成(intergrate，下文再详谈)到文档树中。\",\" public insert(pos: number, content: T) { const item = this.findItemByIndex(pos - 1); if (!item) { throw new Error(\\\"Item not found\\\"); } const newItem = { content, id: [this.clientId, this.vector[this.clientId] + 1], isDeleted: false, children: [], parent: item.id, } as Item<T>; this.integrate(newItem); } \",\"insert将字符插入到pos位置，因此需要找到pos-1位置的Item作为其插入意图 parent，然后生成新的Item，最后将其集成到文档树中。\",\"findItemByIndex使用 DFS 遍历文档树，排除掉删除字符，找到pos位置的Item：\",\" private findItemByIndex(pos: number): Item<T> | null { if (pos === -1) { return this.store.get(Id.hash(this.root))!; } const queue: Id[] = []; let i = pos; // DFS queue.push(this.root); while (queue.length > 0) { const id = queue.shift()!; const item = this.store.get(Id.hash(id))!; if (item.content === null) { queue.push(...item.children); continue; } if (i === 0 && !item.isDeleted) { return item; } if (!item.isDeleted) { i--; } queue.push(...item.children); } return null; } \",\"有了findItemByIndex有，删除就十分简单了：\",\" public delete(pos: number) { const item = this.findItemByIndex(pos); if (!item) { throw new Error(\\\"Item not found\\\"); } item.isDeleted = true; this.length -= 1; } \",\"最后，解释一下最复杂的integrate：\",\"private integrate(item: Item<T>) { const lastClock = this.vector[item.id[0]] ?? 0; const clock = item.id[1]; if (lastClock >= clock) { // This item has been integrated return; } if (lastClock + 1 !== clock) { throw new Error(\\\"Clock not match\\\"); } this.vector[item.id[0]] = clock; // 1. Find the parent item // 2. Insert the new item to parent.children, compare the id of new item and the next item // 3. Update the version and length of doc const parent = item.parent![1] === 0 ? this.store.get(Id.hash(this.root))! : this.store.get(Id.hash(item.parent!))!; if (!parent) { // Root item can not integrate throw new Error(\\\"Parent not found\\\"); } let destIndex = 0; for (; destIndex < parent.children.length; destIndex++) { const child = parent.children[destIndex]; // Smaller id should at left if (item.id[0] <= child[0]) { break; } } parent.children.splice(destIndex, 0, item.id); this.store.set(Id.hash(item.id), item); if (!item.isDeleted && item.content !== null) { this.length += 1; } } \",\"integrate 有三个核心步骤：\",\"clock去重逻辑，如果item已经被集成到文档树中，那么就不需要再次集成了；\",\"找到item的parent，然后将item插入到parent.children中，这里需要注意的是，item的id需要和parent.children中的id进行比较，保证id小的在左边，大的在右边；\",\"更新doc的length和vector；\"]},\"27\":{\"h\":\"TinyAutomerge\",\"t\":[\"Automerge 是为数不多将 RGA 用在生产环境上的 CRDT 库，RGA 是 Automerge 中的核心算法部分，设计方式和实现思路都很有借鉴性。\",\"笔者实现了一个 toy 版本：TinyAutomerge。\",\"TinyAutomerge 是 Automerge 的一个极简版本，它是按照笔者个人理解以及 Automerge 文档来实现的，可以帮助我们更好的理解 Automerge 和 RGA。\",\"Automerge 中 RGA 的实现文档其实已经被官方文档删除掉了，笔者在 github 上找到了以前的 commit，然后将其复制到了飞书文档，希望能帮助到对 Automerge 感兴趣的人\",\"TinyAutomerge 支持两种 CRDT 数据类型以及其基本操作：\",\"List(Text): \",\"insert(pos, content)\",\"delete(pos)\",\"put(pos, content)\",\"get(pos)\",\"range(start, end)\",\"Map: \",\"put(key, value)\",\"get(key)\",\"delete(key)\",\"range(start, end)\",\"Text 纯文本本质上和 List 是一样的，因此这里没有额外实现。\",\"下面就 Automerge 核心数据结构建模以及基本操作伪代码做一个简单的介绍。\"]},\"28\":{\"h\":\"数据结构建模\",\"t\":[\"TinyAutomerge仍然以Operation(操作)作为核心建模方式，任何一个基本操作，包括insert、delete、put、get都可以被抽象为一个Operation：\",\"export type Operation<T> = { id: OpId; prop: string; // map property name or array insert|update origin intention insert: boolean; value: T | null | \\\"make(map)\\\" | \\\"make(list)\\\"; // null means delete pred: OpId[]; succ: OpId[]; }; \",\"这里的OpId其实也是 Lamport 时钟，也即是[actorId, clock]，actorId是一个字符串，clock是一个数字。\",\"在Automerge中 actorId 其实就是siteId。\",\"每个Operation都有唯一的id，insert字段表示是否为插入操作；\",\"prop字段略微有点特殊，对于Map来说，prop就是map中的某个key，对于List来说，prop 操作意图，即插入位置前一项。\",\"另外 pred 和 succ 字段分别标识操作的前驱、后继操作，以Map为例，如果多个put操作的key相同，那么这些put操作的pred和succ就会形成一个双链表，最后的操作在链表最后端。\",\"如果Operation的 succ 不为空，证明这个Operation已经过期了，因为有新的Operation插入到了这个Operation之后。\",\"而delete略有不同，因为 delete 没有实际的删除数据，只是将上一个Operation的succ指向自己，这样就可以将Operation从链表中软移除了。\",\"同样地，文档是操作的集合：\",\"type OpTree<T> = { parent: ObjId | null; // null means root objType: ObjType; // map or list store: Array<Operation<T>>; // sorted by OpId or Prop }; type OpSet<T> = { // Op trees trees: Map<ObjId, OpTree<T>>; // The length of op array length: number; }; export type Doc<T> = { ops: OpSet<T>; // The current actor. id: Actor; // The maximum operation counter this document has seen. maxOpCount: number; }; \",\"Doc核心数据实际就是op的集合，即OpSet。OpSet 下可以有多个 OpTree，每个 OpTree 对应一个Map或者List，OpTree 中的store是一个操作有序数组，parent指向父节点，objType标识是Map还是List。\",\"从这里就可以得出，对于Map和List的操作一般需要两步：\",\"在OpSet中找到对应的OpTree，如果没有就创建一个；\",\"在OpTree中查找、变更、对应的Operation；\"]},\"29\":{\"h\":\"Map\",\"t\":[\"了解了基本数据结构后，我们就可以来看看Map的基本操作实现了。\"]},\"30\":{\"h\":\"get\",\"t\":[\"伪代码：\",\"def get(store, prop): operations, _ := search(store, prop); last := operations[opertaions.len - 1]; return last.value; def search(store, prop): result := []; start_idx := index of the first row that matches prop end_idx := store.length for i in range(start_idx, end_idx): if store[i].prop != prop: return result, i; result.append(store[i]); return result, end_idx + 1; \",\"get(prop)：\",\"查找store，找到与prop相关的所有Operation；\",\"返回最后一个Operation的value；\"]},\"31\":{\"h\":\"put\",\"t\":[\"伪代码：\",\"def put(store, prop, value): operations, last_idx := search(store, prop) last := operations[opertaions.len - 1]; pred := [last.id] local_op := { op: lamport_clock_inc(), obj: table.objId, prop, value: \\\"{value}\\\", pred, succ: [] } last.succ.append(local_op.id); insert_op(store, local_op, last_idx); \",\"put(prop, value)：\",\"查找store，找到与prop相关的所有Operation；\",\"生成一个新的Operation，pred指向最后一个Operation；\",\"将最后一个Operation的succ指向新的Operation；\",\"将新的Operation插入到store中；\"]},\"32\":{\"h\":\"delete\",\"t\":[\"伪代码：\",\"def delete(store, prop): operations, _ := search(store, prop) last := operations[opertaions.len - 1]; pred := [last.id] new_clock := lamport_clock_inc() last.succ.append(new_clock); \",\"delete(prop)：\",\"查找store，找到与prop之相关的所有Operation；\",\"生成新的 lamport_clock，加入到最后一个Operation的succ中；\",\"delete 不会生成新的Operation，而是将最后一个Operation的succ指向新的lamport_clock，这样就可以将Operation从链表中软移除了。如下：\",\"empty表示空的Operation，只有一个lamport lock并指向age最后一个Operation 100，从而达到删除age的效果。\"]},\"33\":{\"h\":\"List\",\"t\":[\"List的实现稍微复杂一点，因为List没有明确的key，而index也是动态变化的，所以找到会更加麻烦一点。\"]},\"34\":{\"h\":\"get\",\"t\":[\"伪代码：\",\"def get(store, index): operations, _ := nth(store, index); last := operations[operations.len - 1]; return last.action.value; def nth(store, index): seen = 0; // current position pos := 0; // result operations res = []; for operation in store: if operation is insert: if seen > index: return res, pos; if operation.insert && operation.succ.length == 0: seen += 1; if seen == index && operation.succ.length == 0: res.append(operation); pos++; return res, pos; \",\"get(index)：\",\"核心点在nth即找到第index个Item上，注意不是Operation。 一个列表Item会包括一个或者多个Operation。\",\"遍历store，找到第index个Item；\",\"返回最后一个Operation的value；\",\"如上图所示，第0项 Item 只有 1 个Operation，第1项 Item 有 3 个Operation。\"]},\"35\":{\"h\":\"delete\",\"t\":[\"伪代码：\",\"def delete(store, index): operations, _ := nth(store, index); first := operations[0]; new_clock := lamport_clock_inc() first.succ.append(new_clock); \",\"delete(index)：\",\"遍历store，找到第index个Item，即operations；\",\"生成新的 lamport_clock，加入到第一个Operation的succ中；\",\"这里与 Map 不同，Map 的delete是在最后一个Operation上加入新的lamport_clock，而 List 是在第一个Operation上加入新的lamport_clock。\"]},\"36\":{\"h\":\"insert\",\"t\":[\"伪代码：\",\"def insert(store, index, value): operations, idx := nth(store, index); firstOp = operations[0]; prop = firstOp ? (firstOp.insert ? firstOp.id : firstOp.prop) : obj; pred = firstOp ? [firstOp.id] : []; local_op := { op: lamport_clock_inc(), obj: store.id, prop, action: \\\"{value}\\\", succ: null, pred, }; if firstOp: firstOp.pred.append(local_op.id); insert_op(store, local_op, idx); \",\"insert(index, value)：\",\"遍历store，找到第index个Item；\",\"生成一个新的Operation，pred指向firstOp，firstOp 可能为空，即插入一个新的Item；\",\"将firstOp的pred指向新的Operation；\",\"将新的Operation插入到store中；\"]},\"37\":{\"h\":\"put\",\"t\":[\"伪代码：\",\"def put(store, index, value): operations, idx := nth(store, index); if operations.len == 0: return; # not found firstOp = operations[0]; prop = firstOp.id; pred = firstOp ? [firstOp.id] : []; local_op := { op: lamport_clock_inc(), obj: store.id, prop, action: \\\"{value}\\\", succ: null, pred, }; firstOp.pred.append(local_op.id); insert_op(store, local_op, idx); \",\"put(index, value)基本与insert类似，但 put 不能插入新的Item，只能修改已有的Item。\",\"因此未找到Item时，直接返回；而prop实际就是firstOp.id，第一个插入Operation的 id。\",\"对于Text，其实本质与List大差不差，只是value是一个字符而已，当然如果需要支持富文本，那就没那么简单了。\",\"RGA 富文本实现可参考peritext。\"]},\"38\":{\"h\":\"结语\",\"t\":[\"本文以 RGA 为切入点，介绍了其基本原理和实现，并参考 RGA 在 Automerge 中的设计，给出了 TinyAutomerge 的实现。\",\"希望能够帮助读者对 CRDT 与 RGA 有一个更加深入的理解。\"]},\"39\":{\"h\":\"参考资料\",\"t\":[\"Automerge RGA Runtime\",\"awesome-crdt\",\"Near Real-Time Peer-to-Peer Shared Editing on Extensible Data Types\",\"Replicated abstract data types: Building blocks for collaborative applications\",\"peritext\"]},\"40\":{\"h\":\"深入理解CRDT-YATA篇\"},\"41\":{\"h\":\"前言\",\"t\":[\"上一篇文章探讨了 RGA 算法的原理与实现，本文我们将介绍另一种 CRDT 算法——YATA。\",\"YATA 全称为 Yet Another Transformation Approach，于 2016 年由 Kevin 在论文 Near Real-Time Peer-to-Peer Shared Editing on Extensible Data Types 中提出。\",\"该论文不仅贡献了 YATA 算法，还给出了 YATA 算法的开源 CRDT 协同库——Yjs。\",\"Yjs 有着良好的架构设计，运行性能、内存消耗方面都十分优异，而且有着良好的生态，是目前生产环境使用最广泛的 CRDT 算法。\",\"因此 YATA 是学习 CRDT，入门协同的必经之路。\",\"Near Real-Time Peer-to-Peer Shared Editing on Extensible Data Types论文详细阐述了协同算法的发展历史，尤其是介绍部分基本囊括了所有主流的协同算法，是学习协同算法的必读论文。\"]},\"42\":{\"h\":\"YATA\"},\"43\":{\"h\":\"三条规则\",\"t\":[\"YATA 认为文档是插入操作的集合，保证文档有序的关键是保证插入操作有序，因此 YATA 的核心是插入操作——o：\",\"ok​(idk​,origink​,leftk​,rightk​,isDeletedk​,contentk​),\",\"idk​：操作的唯一标识，由 lamport 时钟实现，即[siteId, clock]；\",\"origink​：操作意图，操作创建时，左边相邻的操作项oi​，不会改变；\",\"leftk​：ok​左边操作项；\",\"rightk​：ok​右边操作项；\",\"isDeletedk​：操作是否被删除；\",\"contentk​：插入的内容。\",\"插入操作抽象为o，删除时，将o的isDeleted置为true；left与right是操作之间的左、右链接，构建出完整的插入有序链表。\",\"遍历整个有序链表，筛掉被删除的操作，即可得到有序的文档内容。\",\"origin的存在是为了解决并发插入问题，如下图所示：\",\"客户端 1、2 同时在文本111中的同一位置插入新的字符2，3，此时客户端 1、2 的操作都是并发的，因此无法确定谁先谁后，对于这类并发冲突 YATA 定义了 3 条规则：\",\"禁止origin连线交叉；\",\"插入操作必须严格按照顺序排列，如果o1​与o2​相邻，且o1​在左边，即满足o1​<c​o2​，那么不可能找到另外一个oi​比o1​大，同时比o2​小，即不可能存在o1​<c​oi​<c​o2​；\",\"如果两个插入操作的origin一致，那么 id 大的字符在右边；\",\"规则 2 很好理解，插入操作必须严格按照顺序排列，否则无法保证文档的有序性。\",\"规则 3 借鉴了 OT 算法，当两个操作的origin一致时，由于无法通过origin来比较顺序，因此按照id来比较，由于id是唯一且确定的，这样可以保证文档在任何客户端都能最终收敛到一致。\",\"这里，笔者尝试用自己的理解来解释规则 1，首先，origin连线是这样的：\",\"字符插入后，左右连线指向当前相邻的字符，而origin连线只会一直指向操作创建时的左边字符，并且不会改变。\",\"origin连接不会交叉，即不会出现这样的情况：\",\"而下面的两种情况是允许的：\",\"通过规则 1，操作意图origin与操作o这样就能得到如下的性质：\",\"o1​<rule1​o2​⇔o1​<origin2​∨origin2​≤origin1​\",\"操作o1​如果在操作o2​的左边，通过规则 1，就能推导得出下面两种 case：\",\"case1，o1​在origin2​的左边，即o1​<origin2​；\",\"case2，origin2​在origin1​的左边，或者 origin2​与origin1​是同一个操作，即origin2​≤origin1​。\",\"有了 rule1，2，3，YATA 就能保证只要操作意图origin不变，那么插入操作在任意副本都能收敛到全局有序，即文档内容是一致的。\",\"规则 1 不好理解，论文其实并没有给出为什么要引入规则 1，而是给出规则 1,2,3 后，通过严格的数学公式证明所有插入操作最终有序；当然这也足够了，明确前提条件，能够推理正确就算理解 YATA 了；对推理过程感兴趣的可以直接看论文。\"]},\"44\":{\"h\":\"插入算法\",\"t\":[\"每次插入操作都需要满足上面的 3 条规则，如果不满足，就需要调整操作的位置，使其满足规则。这样就能得出插入算法：\",\"insert函数有两个参数：\",\"i：插入操作，即ok​(idk​,origink​,leftk​,rightk​,isDeletedk​,contentk​)；\",\"ops：与i有冲突的插入操作列表；\",\"函数作用是将i插入到ops中，使其满足规则 1，2，3。\",\"函数虽然只有 10 行左右的代码，但理解起来不容易，下面笔者尝试用自己的理解来解释这个函数。\",\"将插入操作i插入到ops中，实际是在寻找i.left——o，然后将i插入到o后面，即 o<i。\",\"o<i需要满足上面的 3 条规则（or​：o的origin；ir​：i的origin）：\",\"如果 or​<ir​<o<i，那么origin存在交叉，无法满足，直接 break，对应算法中的breaking condition；\",\"如果 ir​<or​<o<i，或者 or​<o<ir​<i，满足规则 1；\",\"如果 or​=ir​<o<i，需比较 creator，满足规则 3；\",\"满足规则 1,3，那么 i.position+1，直至找到满足规则 2 的o为止，对应图中的for range。\",\"YATA 算法虽然推理起来很麻烦，但实际上最后的算法代码很少，对应到 Yjs 实现上也就是几十行代码而已。\"]},\"45\":{\"h\":\"案例\",\"t\":[\"介绍完 YATA 原理后，可以体验一下 YATA 的实际案例，如下是一个纯文本编辑器：\",\"只支持简单的英文、数字文本增、删，不支持中文、复制粘贴等操作。 没办法，input 中文事件笔者不会啊。\",\"在左侧输入框中编辑文本内容，都会同步到对方，最终保证两个输入框的内容一致。\"]},\"46\":{\"h\":\"实现\",\"t\":[\"在理解 YATA 算法的基础上，我们再来看看 YATA 的实现。\"]},\"47\":{\"h\":\"YATA 版\",\"t\":[\"首先，抽象出 YATA 的插入操作：\",\"export type Item<T> = { content: T; id: Id; isDeleted: boolean; origin: Id | null; // null if insert at doc's begin }; \",\"Item包含了content、id、isDeleted、origin四个属性，分别对应 YATA 插入操作的contentk​、idk​、isDeletedk​、origink​。\",\"再看看文档的数据结构：\",\"export class Doc<T> { content: Item<T>[]; length: number; vector: Vector; clientId: string; public constructor(clientId?: string) { const cid = clientId ?? randomString(6); this.content = []; this.length = 0; this.vector = {}; this.clientId = cid; } } \",\"Item中之所有没有leftk​、rightk​，是因为这里的实现没有选择双向链表，而是统一存储在Doc中的content列表。\",\"content：文档内容，即Item列表；\",\"length：文档长度，筛掉删除的Item后的列表长度；\",\"vector：clock 向量；\",\"clientId：客户端 ID；\",\"首先看看insert函数：\",\" public insert(pos: number, content: T) { const clock = this.vector[this.clientId] ?? -1; // origin is previous item of pos const i = this.findPositionByIndex(pos); // create current item of pos const item: Item<T> = { content, id: [this.clientId, clock + 1], isDeleted: false, origin: this.content[i - 1]?.id ?? null, }; this.integrate(item); } \",\"因为墓碑机制的存在，所以pos并不是content的下标，而是content中未删除的Item的下标，所以需要先通过findPositionByIndex函数找到pos对应的Item的下标i。\",\"然后，创建Item，并调用integrate函数将其插入到content中，注意：origin是创建时的左侧Item节点。\",\"整个insert的核心是integrate，对应 YATA 中插入解决冲突部分：\",\" private integrate(item: Item<T>) { const lastClock = this.vector[item.id[0]] ?? -1; const clock = item.id[1]; if (lastClock + 1 !== clock) { throw new Error(\\\"Clock not match\\\"); } this.vector[item.id[0]] = clock; // origin always front of the item // the origin.right may be conflict with the item // find the right place for the item start with origin.right let origin = this.findItemById(item.origin); let destIndex = origin + 1; let scanning = false; // search o, which i is successor of o // ir < or < o < i // or < o < ir < i // or = ir < minClient(o, i) < maxClient(o, i) // The logic below can be summarized in these two lines: // if (oleft < left || (oleft === left && newItem.id[0] <= o.id[0])) break // if (oleft === left) scanning = newItem.id[0] <= o.id[0] for (let i = destIndex; ; i++) { if (!scanning) { destIndex = i; } if (i === this.content.length) { break; } const o = this.content[i]; const oorigin = this.findItemById(item.origin); // Insert i before o // case1: or < ir < i < o => break // case2: or = ir < min(i, o) < max(i, o) => break if (oorigin < origin || (oorigin === origin && item.id[0] <= o.id[0])) { break; } if (oorigin === origin) { scanning = item.id[0] <= o.id[0]; } } if (!item.isDeleted) { this.length += 1; } this.content.splice(destIndex, 0, item); } \",\"首先，检查clock是否连续，如果不连续则抛出异常；\",\"然后，根据origin找到初始目标下标destIndex，即item的插入位置，因为并发冲突都是在origin后发生的，因此destIndex的初始值为origin的下标加 1；\",\"判断出o与item之间是否满足 3 条规则，满足则后移，直至找到item的插入位置，不满足则跳出循环，即已找到插入位置；\",\"最后，将item插入到content中。\",\"delete函数十分简单，找到pos对应item然后标记isDeleted即可：\",\" public delete(pos: number) { const i = this.findPositionByIndex(pos); const item = this.content[i]; if (!item) { throw new Error(\\\"Item not found\\\"); } item.isDeleted = true; this.length -= 1; } \"]},\"48\":{\"h\":\"Yjs 优化版\",\"t\":[\"YATA 版实现了论文原有的插入算法，但这版插入算法其实有一个严重的 base case：\",\"客户端 1，2 有同一段文本12，1是2的origin，现在客户端 2 向1插入了一个3，按照算法规则，文本会变成132；\",\"可一旦操作同步到客户端 1，因为字符3的origin是1，且3的id大，因此会跑到2的后面，导致文本变成123，这就导致了双方最终内容不一致。\",\"为了解决这个问题，yjs 引入了另外一个属性originRight，同时规定插入的操作排序后必须在originRight之前，这样客户端 2 插入3时，由于originRight是2，因此3会插入到2的前面，最终文本变成132，双方达成一致，这样就解决了这个问题。\",\"有了originRight后，插入操作o就变成了这样：\",\"ok​(idk​,origink​,originRightk​,leftk​,rightk​,isDeletedk​,contentk​),\",\"而这一版的实现，抽象出了新的Item类：\",\"export type Item<T> = { content: T; id: Id; isDeleted: boolean; originLeft: Id | null; // null if insert at doc's begin originRight: Id | null; // null if insert at doc's end }; \",\"originLeft：对应上面的origin；\",\"originRight：即 yjs 新增的originRight；\",\"Doc定义不变，而insert函数有了些许变化：\",\" public insert(pos: number, content: T) { const clock = this.vector[this.clientId] ?? -1; // origin is previous item of pos const i = this.findPositionByIndex(pos); // create current item of pos const item: Item<T> = { content, id: [this.clientId, clock + 1], isDeleted: false, originLeft: this.content[i - 1]?.id ?? null, originRight: this.content[i]?.id ?? null, }; this.integrate(item); } \",\"item在新建时，需要同时指定originLeft和originRight，且后面不会再变化。另外 integrate 也增加了originRight的判断条件：\",\"private integrate(item: Item<T>) { const lastClock = this.vector[item.id[0]] ?? -1; const clock = item.id[1]; if (lastClock + 1 !== clock) { throw new Error(\\\"Clock not match\\\"); } this.vector[item.id[0]] = clock; let left = this.findItemById(item.originLeft); let right = this.findItemById(item.originRight); let destIndex = left + 1; let scanning = false; for (let i = destIndex; ; i++) { if (!scanning) { destIndex = i; } if (i === this.content.length) { break; } // 1. Must insert between originLeft and originRight if (i === right) { break; } const o = this.content[i]; const oleft = this.findItemById(item.originLeft); const oright = this.findItemById(item.originRight); // 2. if ( oleft < left || (oleft === left && oright == right && item.id[0] <= o.id[0]) // 3. ) { break; } if (oleft === left) { scanning = item.id[0] <= o.id[0]; } } if (!item.isDeleted) { this.length += 1; } this.content.splice(destIndex, 0, item); } \",\"上面的注释 1、2、3 处增加了originRight的判断，即必须在originLeft和originRight之间，这样就保证了插入的顺序。\"]},\"49\":{\"h\":\"TinyYjs\",\"t\":[\"yjs 是目前生产环境使用最为广泛 CRDT 库，其设计思想和实现优化都非常值得学习。\",\"TinyYjs 是笔者实现的一个精简版 yjs，支持YMap，YArray，YText（纯文本，不支持富文本）三种数据类型，实现了基本的 CRDT 功能，但没有实现 yjs 的优化，因此可以作为一个学习 yjs 的入门项目。\",\"YArray： \",\"insert(index, content)\",\"get(index): any\",\"delete(index)\",\"toArray(): any[]\",\"YText： \",\"insert(index, content)\",\"get(index): any\",\"delete(index)\",\"toString(): string\",\"YMap： \",\"set(key, value)\",\"get(key): any\",\"delete(key)\",\"has(key): boolean\",\"toJSON(): any\",\"下面分别就这 3 个基础类型来介绍 TinyYjs 的实现。\"]},\"50\":{\"h\":\"数据建模\",\"t\":[\"在 tinyyjs 中，每个插入操作被抽象为Item：\",\"export class Item { content: ContentAny; id: Id; isDeleted: boolean; originLeft: Id | null; // null if insert at doc's begin originRight: Id | null; // null if insert at doc's end left: Item | null; right: Item | null; parent: AbstractType | null; parentSub: string | null; public constructor( content: ContentAny, id: Id, isDeleted: boolean, originLeft: Id | null, originRight: Id | null, left: Item | null, right: Item | null, parent: AbstractType | null, parentSub: string | null ) { this.content = content; this.id = id; this.isDeleted = isDeleted; this.originLeft = originLeft; this.originRight = originRight; this.left = left; this.right = right; this.parent = parent; this.parentSub = parentSub; } } export class Doc { share: Map<string, AbstractType>; vector: Vector; clientId: string; store: Map<string, Item[]>; // client id => item list public constructor(clientId?: string) { const cid = clientId ?? randomString(6); this.share = new Map(); this.vector = {}; this.clientId = cid; this.store = new Map(); } } \",\"content，id，isDeleted，originLeft，originRight 与上面保持一致；\",\"left，right是链表的左右指针，分别指向前后两个操作；\",\"Doc.share是一个Map，key 是AbstractType的名字，value 是AbstractType的实例。\",\"Item.parent 指向父节点AbstractType；AbstractType是 YArray，YMap，YText 等数据类型的基类，一个Item属于一个AbstractType，这样Doc就能支持多数据类型。如下：\",\" public getText(name: string = \\\"\\\"): YText { if (!this.share.has(name)) { const at = new YText(this); this.share.set(name, at); } return this.share.get(name) as YText; } public getArray(name: string = \\\"\\\"): YArray { if (!this.share.has(name)) { const at = new YArray(this); this.share.set(name, at); } return this.share.get(name) as YArray; } \",\"如果Item的 parent 为空，代表该Item是游离节点，会被垃圾回收掉。\",\"对于 YArray，YText 这类线性数据结构而言，Item之间通过连续的双向链表连接在一起，如下图：\",\"对于 YMap 而言，Item之间是分离的，如下图：\",\"Item.parentSub用来表示YMap的 key，Item是YMap的 value，一个key上的value可能会被多个客户端操作，因此value是一个小双向链表。\",\"遵循LWW(Last Write Won)规则，最后写入的Item会覆盖之前写入的Item，上图中key1下有两个Item，而生效的是a。\",\"Doc.share中所有的AbstractType实例，其Item都会被存储在Doc.store中，key 是clientId，value 是Item数组。\"]},\"51\":{\"h\":\"冲突解决\",\"t\":[\"数据建模是 tinyyjs 参考 yjs 简化而来，并以此支持多数据类型，由于是多种数据类型，因此冲突解决需要稍加改变一下：\",\" public integrate(doc: Doc) { const parent: AbstractType = this.parent!; const parentSub = this.parentSub; const getItem = (id: Id | null) => doc.getItem(id); if ( (!this.left && (!this.right || this.right.left !== null)) || (this.left && this.left.right !== this.right) ) { let left = this.left; // 插入时的左边节点，即插入origin let o; // 是否具有冲突的节点 // set o to the first conflicting item if (left !== null) { // list, text set left to the first conflicting item o = left.right; } else if (parentSub !== null) { // map sets left to the first item with the same key o = parent._map.get(parentSub) || null; while (o !== null && o.left !== null) { // map, set o to the first item of key o = o.left; } } else { o = parent._start; // default set o to the first item } const conflictingItems = new Set(); const itemsBeforeOrigin = new Set(); // Let c in conflictingItems, b in itemsBeforeOrigin // ***{origin}bbbb{this}{c,b}{c,b}{o}*** // Note that conflictingItems is a subset of itemsBeforeOrigin while (o !== null && o !== this.right) { itemsBeforeOrigin.add(o); conflictingItems.add(o); if (Id.compare(this.originLeft, o.originLeft)) { // case 1 if (o.id[0] < this.id[0]) { // 如果o的clientID小于this的clientID，那么o在this的左边，大的在右边 left = o; conflictingItems.clear(); } else if (Id.compare(this.originRight, o.originRight)) { // 右插入意图相同，则直接break // this and o are conflicting and point to the same integration points. The id decides which item comes first. // Since this is to the left of o, we can break here break; } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations } else if ( o.originLeft !== null && itemsBeforeOrigin.has(getItem(o.originLeft)) ) { // use getItem instead of getItemCleanEnd because we don't want / need to split items. // case 2 if (!conflictingItems.has(getItem(o.originLeft))) { left = o; conflictingItems.clear(); } } else { break; // 直接break，会发生意图交叉 } o = o.right; } this.left = left; } // reconnect left/right + update parent map/start if necessary if (this.left !== null) { const right = this.left.right; this.right = right; this.left.right = this; } else { let r; if (parentSub !== null) { r = parent._map.get(parentSub) || null; while (r !== null && r.left !== null) { r = r.left; } } else { r = parent._start; parent._start = this; } this.right = r; } // for map if (this.right !== null) { this.right.left = this; } else if (parentSub !== null) { // set as current parent value if right === null and this is parentSub parent._map.set(parentSub, this); if (this.left !== null) { // this is the current attribute value of parent. delete right this.left.delete(); } } doc.addItem(this); } \",\"这段冲突解决代码几乎与 yjs 一致，这里简单解释一下。\",\"Item插入时，Item.left会被初始化为Item.originLeft，因此与其有冲突的节点从Item.left开始，直到Item.right，这些节点都有可能是冲突节点。\",\"如果是 YArray，YText，第一个冲突节点是left.right，如果是 YMap，第一个冲突节点是parent._map.get(parentSub)对应的最左边节点；\",\"插入位置需要遵循 3 条规则，虽然改成了双向链表，但是判断逻辑基本一致；\",\"最后，将Item插入到链表中。\",\"对于 tinyyjs 的介绍就到这里，感兴趣的可以查看源码。\"]},\"52\":{\"h\":\"结语\",\"t\":[\"关于 YATA 算法，就介绍到这里。\",\"后续文章会对 yjs 实现做一次解密，看看明星 CRDT 库是如何实现的。\"]},\"53\":{\"h\":\"参考资料\",\"t\":[\"YATA 线性数据插入算法 - 掘金\",\"(PDF) Near Real-Time Peer-to-Peer Shared Editing on Extensible Data Types\",\"CRDTs go brrr\",\"Operation-based CRDTs: arrays (part 1)\",\"Deep dive into Yrs architecture\",\"yjs INTERNALS\"]},\"54\":{\"h\":\"谈谈在线表格协同方案\"},\"55\":{\"h\":\"谈谈关系数据库的设计与实现(1)——总览\"},\"56\":{\"h\":\"前言\",\"t\":[\"数据库是一个老生常谈的话题，类别众多，如内存数据库(Redis)，文档数据库(MongoDB)，时序数据库(InfluxDB)，图数据库(Neo4j)等，还有目前使用最广泛、最重要的关系数据库(MySQL、PostgreSQL 等)，这也有今天的主角——关系数据库。\",\"对于关系数据库，与它有关的论文、书籍、博文都数不胜数，但是大部分书籍和博文都在教开发者如何去使用一款数据库，鲜有去教开发者如何去弄懂数据库系统架构设计、原理和实现的。\",\"《Database System Concepts》正是这样一本书(中文名：《数据库系统概念》)，而恰好也有这么一门课程 CMU15445，来教我们如何去弄懂数据库原理，掌握数据库系统设计，甚至去实现一个小巧的数据库—— bustub 。\",\"而这恰好也是本文主题——关系数据库的设计与实现。本文不会去介绍如何写 SQL，如何用索引，如何数据备份，而是希望通过剖许 bustub 这个精巧的关系数据库来告诉你：数据库系统架构是什么样的？为什么要这么设计？它又是如何实现的？\",\"在正式介绍数据库设计和实现之前，请你先尝试回答如下几个问题：\",\"数据库会预读数据到缓冲池中，缓冲池是如何实现的，它有何作用？\",\"B+树似乎是数据库组织数据的最常用数据结构，它又是如何实现的？B+树一个节点究竟能存储多少项？B+树又是如何支持并发访问的？\",\"数据库是如何执行 SQL 的，执行器究竟是如何实现的？\",\"数据库事务隔离级别有哪几个？不同级别又是如何实现？数据库是如何处理并发访问控制的？ 如果你能迅速回答出这几个问题，那么本文可能不适合你，可是如果你还有疑惑，想要尝试从源码级别上来搞懂这几个问题，那么希望你能耐心阅读完本文，相信你能从中自己发掘出答案。\",\"注意：bustub 是 CMU 数据库组开源的一款关系数据库，用于 CMU15445 课程实验。目前 bustub 开源于 Github，代码虽然开源，但是由于涉及到课程实验作业，因此开源的只有一部分，为了保护课程，避免抄袭，本文只会贴出部分实现代码进行剖析，其它部分只会用画图的方式来说明。\"]},\"57\":{\"h\":\"总览\"},\"58\":{\"h\":\"整体架构\",\"t\":[\"bustub 究竟有哪些模块，这些模块负责哪些功能，模块之间如何协调？下面，我们一起来看看。\",\"bustub 整体架构图如下：\",\"图 1 bustub 架构图\",\"bustub 暂时没有 SQL 解析器、优化器等，其着重点在于数据库后端部分，即上图 1 中的查询处理、存储管理和磁盘存储三大部分，这三部分又包含了数据库很多模块：\",\"执行器(executor)：负责执行查询、插入等计划(plan)，bustub 暂时并未实现 SQL 解析器，无法将 SQL 语句转化为执行计划，因此需直接写代码构建执行计划来执行；\",\"缓存管理器(buffer_pool_manager)：从磁盘中读取页数据并缓存在内存中，避免每次查询、更改都读写磁盘，是数据库性能提升的核心组件；\",\"磁盘管理器(disk_manager)：负责向磁盘写数据页、日志，或者从磁盘读数据页、日志；\",\"事务管理器(transaction_manager)：bustub 支持数据库事务，保证数据操作的原子性、一致性等；\",\"日志管理器(log_manager)：为避免物理机突然崩溃，bustub 实现了日志记录功能，用于故障后数据恢复；\",\"快照管理器(checkpoint_manager)：实现数据库数据快照功能；\",\"磁盘存储：由磁盘管理器和宿主机操作系统共同完成。 在这个架构下，bustub 每执行一次查询(或更新、插入)的流程就如图 1 中的箭头所示：\",\"应用程序构建执行计划，并将执行计划交给执行器；\",\"执行器根据执行计划，请求事务管理器获取事务，然后以事务的方式请求缓存管理器获取数据页；\",\"缓存管理器判断数据页是否已在缓存中，如已在，则直接返回页数据，不存在则调用文件管理器读取对应页然后再返回；\",\"执行器根据执行计划中过滤条件筛选数据返回给应用程序。 当然这个过程中还伴随着索引、锁、日志、缓存淘汰等操作，这些将在后面详细介绍。\"]},\"59\":{\"h\":\"代码结构\",\"t\":[\"了解了 bustub 整体架构后，我们一起来看一下其代码结构，对项目整体有一个基本认识。如下：\",\"./src ├── buffer // 缓存模块，如缓存管理器，淘汰算法LRU ├── catalog // 数据库目录，如数据列、数据表定义 ├── common // 公共模块 ├── concurrency // 并发控制，如事务管理器、锁管理器 ├── execution // 执行模块，如查询执行器、插入执行器等 ├── include // 头文件 ├── recovery // 故障恢复模块，如快照管理器，日志管理器 ├── storage // 存储模块 │ ├── disk // 磁盘存储，磁盘管理器 │ ├── index // 索引，B+树 │ ├── page // 数据页，如B+树索引页，数据表页，元数据页 │ └── table // 数据表，数据记录，数据表迭代器 └── type // 字段类型，如整型、bool类型等 \",\"每个目录后面用注释说明了当前模块的作用和功能，这些模块将按照如下顺序依次介绍：\",\"缓存池：buffer 目录，缓存池、LRU 算法实现；\",\"并发 B+树：storage 目录，B+树实现及并发；\",\"执行器：execution 目录，执行期实现；\",\"并发控制：concurrency 目录，事务管理器、锁管理器实现；\",\"故障恢复：recovery 目录，日志记录、快照实现。 下面，我们来依次详细介绍这些模块的作用和实现。\"]},\"60\":{\"h\":\"参考资料\",\"t\":[\"CMU15445-fall2020\",\"Database System Concepts, 6th Edition\"]},\"61\":{\"h\":\"谈谈关系数据库的设计与实现(2)——缓存池\"},\"62\":{\"h\":\"缓存池\",\"t\":[\"减少磁盘和内存之间的数据 IO 次数是数据库提升查询效率的主要途径之一，也是数据设计的主要目标。\",\"为了达到这个目标，数据库需要在内存中保留尽可能多的数据页，最大限度地提高在内存中处理数据查询的机会，减少磁盘访问次数。\",\"但不可能将所有页都保存在内存中，我们需要一个管理内存与磁盘数据的中介组件——缓存池。\",\"磁盘上保存的数据实则是缓存池数据的副本。缓存池中的基本单位是页(对应操作系统 IO 的基本单位也是页)，每一页在磁盘上都有一个副本，磁盘上的副本可能是老数据(脏页)，负责分配缓存池的组件被称为缓存管理器(buffer_manager)。\"]},\"63\":{\"h\":\"淘汰策略\",\"t\":[\"相较于磁盘而言，内存是非常有限的，数据库不可能将所有数据页装在内存中，只能尽可能的将热点数据存储在缓冲池中，因此一旦缓存池满了，那么就需要淘汰一部分数据页将其刷到磁盘中，再从磁盘读取新的页。\",\"常见的淘汰算法有 FIFO、 LRU 和 LFU 等。数据库可以实现多种淘汰算法，在不同场景中选择合适的淘汰策略，这里我们来详细介绍 LRU 算法。\",\"LRU(Least recently used)，全称最近最少使用算法，是目前最常见的页面置换算法。LRU 算法会选择最近最少使用的页淘汰，缓存管理器会将其从缓存池中淘汰，并刷到磁盘中，然后从磁盘上读取新的数据页。\",\"LRU 的核心点在于最近、最少两个字，选择合适的数据结构就能解决这个问题。这里，笔者选择了最常见的双向链表+哈希表法，原理也很简单：\",\"新增(新访问)页将其保存在链表头部，并写入哈希表供快速查询；\",\"待页慢需要淘汰时，从链表尾部得到淘汰页，并从哈希表中删除。 由于每次访问或者新增页时，都会将页保存在链表头部，那么链表尾部自然就成为了最近最少使用的页，当缓存池满了需要淘汰时，直接将链表尾部页淘汰即可。\",\"bustub 中的 LRUReplacer 定义如下：\",\"class LRUReplacer : public Replacer { public: // ... // 淘汰一个页，并将淘汰页的 frame_id 返回 bool Victim(frame_id_t *frame_id) override; // 从 LRU 淘汰策略中删除一个页，不受淘汰约束 void Pin(frame_id_t frame_id) override; // 将一个页加入 LRU 淘汰策略 void Unpin(frame_id_t frame_id) override; // 当前 LRU 中有多少页 size_t Size() override; private: size_t num_pages; // 最大页数量 std::list<frame_id_t> list_; // 双向链表 std::unordered_map<frame_id_t, std::list<frame_id_t>::iterator> _map; // 哈希表 std::mutex mu; // 锁 }; \",\"LRUReplacer 实现并不困难，也不复杂，不过需要注意以下两点：\",\"LRUReplacer 需要保证并发安全，故每个函数操作都需加锁；\",\"缓存管理器会调用 Unpin 方法向 LRUReplacer 中加入需要被淘汰的页，也会调用 Pin 方法删除页，一经删除后，该页不再受 LRU 约束。 LRUReplacer 中的三个核心方法伪代码如下：\",\"void LRUReplacer::Unpin(frame_id_t frame_id) { lock(); // 加锁 // 如果超过了最大数量，或者已经包含了 frame_id，则直接返回 if (size >= num_pages || _map.contains(frame_id)) { return; } // 将 frame_id 加入到 LRU 中 front = list_.push_front(frame_id); _map[frame_id] = front; } void LRUReplacer::Pin(frame_id_t frame_id) { lock(); // 加锁 if (!_map.contains(frame_id)) { return; // 没有则直接返回 } it = _map[frame_id]; // 删除这个节点 _list.erase(it); _map.erase(frame_id); } bool LRUReplacer::Victim(frame_id_t *frame_id) { lock(); // 加锁 if (_map.empty()) { return false; } // 删除尾部 *frame_id = _list.pop_back(); _map.erase(*frame_id); return true; } \"]},\"64\":{\"h\":\"缓存管理器\",\"t\":[\"缓存管理器负责协同内存、磁盘之间的数据交换，且数据基本单位是页。缓存管理器负责将新数据页刷新到磁盘中，也会从磁盘中读取数据页到内存。如下图 2 所示：\",\"图 2 缓存管理器内存、磁盘\",\"缓存管理器是内存、磁盘之间的数据通道，元数据、表数据、索引数据都会通过缓存管理器来管理，对应 bustub 中的 BufferPoolManager 类。定义如下：\",\"class BufferPoolManager { public: // ... // 获取所有数据页 Page *GetPages() { return pages_; } // 缓存池大小 size_t GetPoolSize() { return pool_size_; } protected: // 通过 page_id 获取对应页 Page *FetchPageImpl(page_id_t page_id); // Unpin 一个页，is_dirty 表示是否脏页 bool UnpinPageImpl(page_id_t page_id, bool is_dirty); // 将页刷到磁盘 bool FlushPageImpl(page_id_t page_id); // 新建一个页 Page *NewPageImpl(page_id_t *page_id); // 从缓存中删除一个页 bool DeletePageImpl(page_id_t page_id); // 将缓存中所有页到刷到磁盘 void FlushAllPagesImpl(); // 缓存池大小 size_t pool_size_; // 缓存池中的页 Page *pages_; // 磁盘管理器 DiskManager *disk_manager_ __attribute__((__unused__)); // 日志管理器，暂不关注 LogManager *log_manager_ __attribute__((__unused__)); // 页表，page_id => frame_id std::unordered_map<page_id_t, frame_id_t> page_table_; // 置换器，如 LRUReplacer Replacer *replacer_; // 空闲页列表 std::list<frame_id_t> free_list_; // 锁 std::mutex latch_; }; \",\"BufferPoolManager 中由 pages_ 负责缓存数据页，其本质为一个 Page 数组，数组中的每一项被称为帧(frame)，每一项对应的数组序号称为 frame_id；\",\"page_table_ 负责维护 frame_id 与 page_id 之间的关系，pages_ 数组是有限的，frame_id 是数据页在内存中的标识，而 page_id 是数据页在磁盘上的标识；\",\"free_list_ 是空闲页列表，表示当前缓存池还有多少帧是空闲的，可以用于缓存页数据；\",\"BufferPoolManager 上的操作也需要保证并发安全，因此锁(latch_) 也是必须的。 这里需要额外说明的是，数据存储在磁盘上被称为页，但是被加载到内存 pages_ 后，又给它取了一个新名字，叫做帧，由 frame_id 来表示，当然其数据本身还是由 Page 来表示，因此后面还是会统一称作页。frame_id 是页在内存中暂时的 id 而已，当页被淘汰，就会有新页来继续使用这个 frame_id。\",\"BufferPoolManager 的意义在于，任何内存与磁盘之间的交互都需要通过它来进行，无论是获取数据页(FetchPage)，删除数据页(DeletePage)，新建数据页(NewPage)，刷数据页(FlushPage)都被它垄断，这样就能最大程度的利用缓存，提高访问性能。\",\"BufferPoolManager 的主要作用点在于操作数据页，有如下几个核心方法：\",\"获取数据页(FetchPage)；\",\"删除数据页(DeletePage)；\",\"新建数据页(NewPage)；\",\"将数据页刷至磁盘(FlushPage)。 以 FetchPage 方法为例，以 page_id 为参数调用 FetchPage 来获取对应的数据页，如果缓存中已有该页，则 Pin 该页(避免被 LRU 淘汰)并增加 pin_count 直接返回；如缓存中没有，则判断空闲列表是否有空闲页，如有直接获取空闲页，若无则淘汰一个页并且拿到该页；如果该页是脏页，则刷至磁盘，最后重置页数据，并从磁盘中读取新页。流程图如下图 3：\",\"图 3 FetchPage 流程图\",\"FetchPage 伪代码实现如下：\",\"Page *BufferPoolManager::FetchPageImpl(page_id_t page_id) { lock(); // 加锁，保证线程安全 page = page_table_.find(page_id); if (page) { // 缓存中已有 page replacer.Pin(page.frame_id); // Pin frame，frame 不会再淘汰 page.pin_count_++; // pin_count += 1 return page; // 返回 page } // 缓存中没有 page，未找到 Page frame_id_t free_frame_id; if (!free_list_.empty()) { // 从空闲列表中获取 free_frame_id = free_list_.pop_front(); } else { // 如果 free_list 中没有则淘汰一个页 replacer_.Victim(&free_frame_id); } // 得到空闲页 page = pages_[free_frame_id]; // 如果 free_frame_id 的页是脏的，则刷至磁盘 if (page.IsDirty()) { disk_manager.WritePage(page); page.is_dirty_ = false; } // 更新 page_table_ page_table_[page_id] = free_frame_id; // 更新 P 的元数据 page.reset(); // 从磁盘中读取 page_id 对应的页数据到 page disk_manager_.ReadPage(page_id, page); return page; } \",\"其它方法，这里就不再赘述了，感兴趣的可以点击 这里 查看其说明。这里贴出笔者实现的伪代码：\",\"bool BufferPoolManager::UnpinPageImpl(page_id_t page_id, bool is_dirty) { lock(); // 加锁 page = page_table_.find(page_id); // 寻找 page if (not page) { return false; // 未找到，返回 false } if (page.pin_count_ < 0) { // 如果 pin_count < 0，返回 false return false; } if (page.pin_count_ > 0) { // 如果 > 0，则 -1 page->pin_count_--; } if (page.pin_count_ == 0) { // 如果 == 0，则证明无人使用该页，加入到 replacer 中 replacer_.Unpin(frame_id); // Unpin 后，该页可能会被替换 } if (is_dirty) { page.is_dirty_ = is_dirty; // 是否脏页，即是否更改了该页数据 } return true; } bool BufferPoolManager::FlushPageImpl(page_id_t page_id) { lock(); // 加锁 page = page_table_.find(page_id); // 寻找数据页 if (not page) { return false; } if (page.IsDirty()) { // 是否脏页 disk_manager_.WritePage(page); // 脏页记得写回磁盘 page.is_dirty_ = false; } return true; } Page *BufferPoolManager::NewPageImpl(page_id_t *page_id) { lock(); *page_id = disk_manager_.AllocatePage(); // 分配新的 page_id // 寻找新的 frame_id frame_id_t free_frame_id; if (!free_list_.empty()) { free_frame_id = free_list_.pop_front(); // 从空闲列表中拿到 } else { // 如果 free_list 中没有则淘汰一个页 replacer_.Victim(&free_frame_id); } page = pages_[free_frame_id]; // 如果 free_frame_id 的页是脏的，则刷至磁盘 if (page.IsDirty()) { // 写到 page disk_manager_.WritePage(page); page.is_dirty_ = false; } page_table_[*page_id] = free_frame_id; // 更新 page_table // 重置 P 的元数据 page.reset() return pages_[free_frame_id]; } bool BufferPoolManager::DeletePageImpl(page_id_t page_id) { lock(); page = page_table_.find(page_id); if (not page) { return true; // 不存在，直接返回 } if (page.pin_count_ > 0) { return false; // 注意：pin_count > 0 证明有人正在使用，不能删除 } if (page.IsDirty()) { disk_manager_.WritePage(page); page.is_dirty_ = false; } // 元数据重置 page->reset(); // 删除 page_table_.erase(page_id); // 从 page_table 中删除 free_list_.push_back(frame_id); // 加入到空闲列表 disk_manager_->DeallocatePage(page_id); // 释放该页，并刷回磁盘 return true; } void BufferPoolManager::FlushAllPagesImpl() { lock(); for page in pages_ { // 刷每一页 FlushPage(page); } } \",\"额外说明：\",\"UnpinPage 需要注意 pin_count，pin_count 不可能为负，当有人拿到数据页，就会 pin_count += 1，一旦 pin_count 为 0，就证明无人使用该页，那么该页就应该被加入到 replacer 中，可以被淘汰；\",\"FlushPage 和 FlushAllPages 需要注意脏页，若是脏页，则必须刷回磁盘；\",\"NewPage 与 FetchPage 类似，都需要检查空闲列表，如果没有空闲页，那么则需要淘汰一个页；\",\"DeletePage 时也需要注意脏页，另外如果 pin_count > 0，那么证明有人正在使用该页，不能删除。 从伪代码中，我们可以发现 FetchPage 和 UnpinPage 实则为一对反操作，FetchPage 会增加页的 pin_count，而 UnpinPage 会减少 pin_count，并且页最后能否被删除取决于 pin_count 是否为 0，所以请切记：一旦你调用了 FetchPage 获取了数据页，操作完成后，不再使用，一定记得 UnpinPage，否则页永远不能删除，缓存的淘汰策略就名存实亡了。\"]},\"65\":{\"h\":\"参考资料\",\"t\":[\"Buffer Pools\",\"Database System Concepts 10.8\",\"PROJECT #1 - BUFFER POOL\"]},\"66\":{\"h\":\"谈谈关系数据库的设计与实现(3)——并发B+树\"},\"67\":{\"h\":\"并发 B+树\",\"t\":[\"主流关系数据库(如 MySQL、PostgreSQL 等)在数据组织和索引组织上几乎都选择了 B+树或其变种。B+树在关系数据库上的重要性不言而喻，这里我们先简单的来介绍一下 B+树 。\"]},\"68\":{\"h\":\"B+树定义\",\"t\":[\"B+树是一种多路自平衡树，不同于二叉树，B+树可以拥有多个子节点，并且能够一直保持完美的自平衡。一颗 B+树包括根节点、内部节点、叶子节点三种节点，根节点既可以是内部节点，也可以作为叶子节点。如下图 4 所示：\",\"图 4 根节点\",\"图 4 左边，树有且只有一个节点，即根节点，此时根节点在树的底部，因此根节点也是叶子结点，图 4 右边，树有三个节点，树的底部是叶子结点，树的内部是内部节点，此时根节点是内部节点。\",\"一颗 m 阶 B+树，必须满足如下几个条件：\",\"每个节点最多只有 m 个子节点；\",\"每个非叶子节点(除了根)具有至少 m/2 子节点；\",\"如果根不是叶节点，则根至少有两个子节点；\",\"具有 k 个子节点的内部叶节点包含 k - 1 个键；\",\"所有叶子节点高(深)度一致。 首先，我们需要明确 m 的含义，前面谈到 B+ 树可以拥有多个子节点，如图 5 所示是一棵 6 阶 B+树：\",\"图 5 六阶 B+树\",\"这棵 6 阶 B+树，其 m 就是 6，表示树中的每个节点最多只能有 6 个子节点，最少得有 3(6/2 取整) 个子节点，这条规则被称为半满。\",\"当然也有例外，如果是根节点不必满足半满这个条件，它最少只需有 2 个子节点。\",\"对于条件 4，一个内部节点有 k 个孩子节点(对应图中的箭头，每一个箭头指向一个孩子节点)，那么该内部节点只有 k-1 个键(对应图中节点里面的数字)，内部节点的第一个键可以理解为是空的，如图中内部节点的第一个空键，指向孩子节点的指针则是值。\",\"但是对于叶子结点，情况就不一样了，叶子节点没有子节点，有 k 个键，也有 k 个值，键即是图中的数字，值则是插入到 B+ 树中的数据。\",\"因此，可以得出 B+的一条性质，B+树中只有叶子结点才会存储真正的数据，内部节点只会存储键和子节点指针，如需对 B+树查询数据，那么最后必然会搜索到叶子结点上。\"]},\"69\":{\"h\":\"B+树设计\",\"t\":[\"简单介绍 B+树后，我们来看看 B+树的实现。bustub 中，B+树实现花了大量篇幅，涉及到好几个类和几千行代码，对 B+树的抽象非常优美，在具体的 B+树实现之前，我们先来看看其精美的代码设计，领略大师风采。\",\"首先，B+树在代码中被抽象定义为 BPlusTree 类：\",\"INDEX_TEMPLATE_ARGUMENTS class BPlusTree { using InternalPage = BPlusTreeInternalPage<KeyType, page_id_t, KeyComparator>; // 内部节点 using LeafPage = BPlusTreeLeafPage<KeyType, ValueType, KeyComparator>; // 叶子节点 public: explicit BPlusTree(std::string name, BufferPoolManager *buffer_pool_manager, const KeyComparator &comparator, int leaf_max_size = LEAF_PAGE_SIZE, int internal_max_size = INTERNAL_PAGE_SIZE); // ... } \",\"BPlusTree 支持 Key，Value，KeyComparator 三种范型参数，如下：\",\"// k-v，k-comparator 类型，如何比较 k #define INDEX_TEMPLATE_ARGUMENTS template <typename KeyType, typename ValueType, typename KeyComparator> \",\"KeyType：树中键的类型，如 int；\",\"ValueType：树中值的类型，如 string；\",\"KeyComparator：键比较器类型，用于 key 之间的排序。 B+树节点可分为内部节点、叶子节点两种，分别是 InternalPage 和 LeafPage，其中 InternalPage 类的值类型为 page_id_t，表示内部节点中值上存储页 id，而叶子结点的值类型与 BPlusTree 的值类型为 ValueType。一个具体的 BPlusTree 例子可以为：\",\"template class BPlusTree<GenericKey<8>, RID, GenericComparator<8>>; \",\"KeyType 为 GenericKey<8>，ValueType 为 RID，KeyComparator 为 GenericComparator<8>；这样，BPlusTree 树就可以用于存储 RID。 构造 BPlusTree 时，name 参数用于指定树名称，也可以看作索引的名称，参数 leaf_max_size 和 internal_max_size 分别表示叶子节点和内部节点能够拥有的最大子节点个数，最大子节点个数是根据页大小，Key、Value 大小计算而来的：\",\"// k-v 类型 #define MappingType std::pair<KeyType, ValueType> // 叶子节点能容纳的 k-v 数量 #define LEAF_PAGE_SIZE ((PAGE_SIZE - LEAF_PAGE_HEADER_SIZE) / sizeof(MappingType)) \",\"这样就能保证一个叶子节点数据刚好能够存储在一个页中，由于操作系统 IO 的基本单位是页，所以每次 IO 恰好能获取一个节点的数据。 B+树结构类图如图 6 所示：\",\"图 6 B+树类图\",\"说明：\",\"BPlusTree 作为主类，向外提供 B+树的搜索、插入、删除 API；\",\"BPlusTreeLeafPage 和 BPlusTreeInternalPage 是对叶子节点和内部节点的抽象；\",\"BufferPoolManager 是 BPlusTree 读取、存储页数据的唯一途径。 BPlusTree 在内部通过调用 BufferPoolManager 的函数获取 Page 数据，那么这些 Page 数据是如何转化为叶子结点 BPlusTreeLeafPage 和 内部节点 BPlusTreeInternalPage 了？\",\"很简单，通过 reinterpret_cast：\",\"Page page = FindXXX(...); // 叶子结点 LeafPage *leaf_node = reinterpret_cast<LeafPage *>(page->GetData()); // 内部节点 InternalPage *leaf_node = reinterpret_cast<InternalPage *>(page->GetData()); \",\"Page 类是对数据页的代码抽象，其内部的 data 字段才是真正的物理页数据，因此可将该字段通过 reinterpret_cast 转化为 LeafPage 或者 InternalPage。 LeafPage 和 InternalPage 虽然是物理页数据，但不可能只保存键值对，还会保存页的元数据，被称为 header，这些元数据被抽象为了 LeafPage 和 InternalPage 的父类 BPlusTreePage：\",\"class BPlusTreePage { / // ... private: // member variable, attributes that both internal and leaf page share IndexPageType page_type_ __attribute__((__unused__)); // 页类型，是内部节点，还是叶子节点 lsn_t lsn_ __attribute__((__unused__)); // log sequence number int size_ __attribute__((__unused__)); // 页中 k-v 对的数量 int max_size_ __attribute__((__unused__)); // k-v 对的最大数量 page_id_t parent_page_id_ __attribute__((__unused__)); // 父节点 id page_id_t page_id_ __attribute__((__unused__)); // 节点 id }; \",\"有了这些元数据，Page 被读取转换后才能知道其 id，节点类型、最大子节点个数和父节点 id。 LeafPage 和 InternalPage 中用于保存键值对的字段是 array 数组字段，如下：\",\"class BPlusTreeInternalPage : public BPlusTreePage { // kv 数据数组 MappingType array[0]; }; \",\"这里利用了 C 语言特性，长度为 0 的数组实则可以任意扩容，而 array 的真正长度由 size_ 字段来维护。\"]},\"70\":{\"h\":\"B+树搜索\",\"t\":[\"在对 B+树一番介绍后，我们来一起看看 B+树搜索是如何实现的。搜索是 B+树中最简单的部分，合理利用好二分查找就足够了。B+树中搜索函数 GetValue 伪代码如下：\",\"Value GetValue(key) { // 树为空，直接返回 if (IsEmpty()) { return null; } // 寻找包含 key 的 Page page = FindLeafPage(key); if (not page) { return null; } // 将 data 转化为叶子结点 leaf_node = reinterpret_cast<LeafPage>(page->GetData()); val = leaf_node.Lookup(key); // 只要一个页使用完毕后，那么一定要 Unpin 一下，进入 LRU buffer_pool_manager_.UnpinPage(page); return val; } \",\"GetValue 会尝试从树中搜索 key 对应的值，由于 B+树将所有值存储在了叶子结点中，因此需先调用 FindLeafPage 获得 key 所在的叶子结点，然后调用 Lookup 从叶子结点上寻找值。如下：\",\"Page FindLeafPage(key) { page = buffer_pool_manager_.FetchPage(root_page_id); while (!page.IsLeafPage()) { page = page.Lookup(key); } return page; } ValueType Lookup(key) { // 二分查找 sz = GetSize(); st = 1; ed = sz - 1; while (st <= ed) { int mid = (ed - st) / 2 + st; if (array[mid].key <= key) { st = mid + 1; } else { ed = mid - 1; } } return array[st - 1].value; } \",\"B+树在搜索时，二分查找主要运用在如下两点：\",\"节点之间是有序的，左孩子节点小于当前 key，右孩子节点大于等于当前 key，通过 key 就能快速锁定是左边节点还是右边节点；\",\"节点中的键值对也是有序的，可直接通过二分查找找到对应的值。\"]},\"71\":{\"h\":\"B+树插入\",\"t\":[\"相较于查询，B+树插入会复杂一些，难点在于节点分裂。在 前面 也谈到了，B+树节点最多只能拥有 m 个子节点，最少要拥有 m/2 个子节点(根节点除外)，B+树在插入数据时，会不断的扩容节点，势必会导致节点的子节点个数超过 m。为了仍然保证 B+树性质，节点需要分裂。\",\"节点分裂可分为如下两种情况：\",\"基本情况，节点 A 子节点个数 >= m(叶子节点是值的个数 >= m)，节点 A 平分为两个节点 A 和 A1，若节点 A 有父节点，那么向父节点中加入指向 A1 节点的指针，父节点的子节点个数+1；\",\"递归情况，在基本情况的基础上，节点 A 的父节点子节点个数 +1 后，个数也 >= m，因此父节点也需要继续分裂，分裂过程与基本情况一致；同样地，如果再次分裂后，祖先节点可能仍需分离，因此递归情况需分裂到不可分裂为止； 如图 7 所示，是一棵 6 阶 B+树，节点 A 为叶子节点，已有 5 个值，节点 B 为内部节点，己有 5 个子节点。此时，向树中插入一个新数据 15。\",\"图 7\",\"通过搜索，发现 15 的插入点正好在节点 A 的末尾(按照排序来)，如图 8：\",\"图 8\",\"向(叶子)节点 A 插入 15 后，发现节点 A 已经拥有 6 个值了，按照分裂情况 1，需要对节点 A 进行分裂，如图 9：\",\"图 9\",\"节点 A 被分裂成 A 和 A1 后，父节点 B 中新增了指向 A1 的指针，此时节点 B 拥有了 6 个子节点，按照分裂情况 2，节点 B 也必须分裂。如图 10 所示：\",\"图 10\",\"节点 B 被分裂为 B、B1，并且 B1 节点上的第一个键上移到节点 C 中，节点 C 的子节点个数+1，此时节点 C(根节点)只有 3 个子节点，无需再次分裂，分裂完毕。\",\"在 B+树中插入数据 15 后，引起了两次节点分裂，第一次是叶子节点 A 分裂，第二次是内部节点 B 分裂；节点分裂后会使父节点的孩子节点个数增加，从而可能引发父节点再次分裂。\",\"B+树插入伪代码如下：\",\"bool Insert(key, value) { // 空树，那么新建 if (IsEmpty()) { StartNewTree(key, value); return true; } // 非空，插入至叶子节点 return InsertIntoLeaf(key, value, transaction); } \",\"B+树插入对外暴露 Insert API，如果当前仍是空树，那么将新建一棵 B+树，如下：\",\"void StartNewTree(key, value) { // 新建 root_page root_page = buffer_pool_manager_.NewPage(); // 将根节点数据视为叶子节点 root_node = reinterpret_cast<LeafPage>(root_page.GetData()); // 初始化根节点 root_node.Init(); // 向根节点中插入数据 root_node.Insert(key, value); } \",\"StartNewTree 会从缓冲池中获取一个新页作为根节点页，然后将页数据视为叶子(根)节点，对其初始化，并插入 kv。 如果当前树不为空，那么将 kv 插入到叶子节点中，如下：\",\"bool InsertIntoLeaf(key, value) { // 寻找 key 所在的叶子节点页 leaf_page = FindLeafPage(key); // 得到叶子结点 leaf_node = reinterpret_cast<LeafPage>(leaf_page.GetData()); // 向叶子节点中插入 kv ok = leaf_node.Insert(key, value); // 插入失败 if (!ok) { return false; } // 判断节点大小是否小于叶子节点最大个数 if (leaf_node.size < leaf_max_size) { // 小于，不用分裂，直接返回 return true; } // 分裂，new_node 是右半部分 new_node = Split(leaf_node); InsertIntoParent(leaf_node, new_node.FirstKey, new_node); return true; } void InsertIntoParent(old_node, first_key, new_node) { if (old_node.IsRootPage()) { // 那么重新申请一个页作为新的根节点，也作为 old_node 和 new_node 的父节点 new_page = buffer_pool_manager_.NewPage(); new_root_node = reinterpret_cast<InternalPage>(new_page.GetData()); // 初始化新的根节点，并且设置指向子节点的指针 new_root_node.Init(); // 更新 new_node 和 old_node 的父节点 old_node.SetParentPageId(new_page.GetPageId()); new_node.SetParentPageId(new_page.GetPageId()); return; } // 不是根节点，得到 old_node 的父节点 parent_page = old_node->GetParentPage(); // 拿到父节点，父节点一定是内部节点 parent_node = reinterpret_cast<InternalPage>(parent_page.GetData()); new_node.SetParentPageId(parent_id); // new_node 设置父节点 // 将 new_node 的 page_id 插入父节点 size = parent_node.InsertNewKey(new_node.FirstKey); if (size < internal_max_size_) { // 父节点无需分裂，直接返回 return; } // 分裂 parent 节点 parent_sibling = Split(parent_node); // 递归 InsertIntoParent(parent_node, parent_sibling.FirstKey, parent_sibling); } \",\"数据若要插入到叶子节点，需先找到该叶子结点，插入后判断是否需要分裂，若需要，还需要判断父节点是否需要分裂，依次向上递归，直至无需分裂后返回。插图流程图如图 11 所示： \",\"图 11\"]},\"72\":{\"h\":\"B+树删除\",\"t\":[\"B+树删除是 B+操作中最复杂的一部分。在删除的过程中，节点大小会变小，可能会出现 < size/2 的情况(半满)，那么对于这样的节点，有如下的处理方式：\",\"如果节点 A(删除后)与其兄弟节点 B，二者的子节点(值)个数加起来 > max_size，则将 A、B 与 A 的节点 C 进行重组(Redistribute)；\",\"如果节点 A(删除后)与其兄弟节点 B，二者的子节点(值)个数加起来 <= max_size，则将 A、B 节点合并(Coalesce)；\",\"如果在重组或者合并后，发现父节点未满足半满的性质，那么对父节点仍然递归的执行 1、2 操作；\",\"如果节点 A(删除后)是根节点： \",\"如果 A 是内部节点，且只有一个子节点，那么该子节点成为新的根节点；\",\"如果 A 是叶子结点，且无任何子节点，那么 B+树已被清空。 如图 12 所示，是一棵 6 阶 B+树，节点 A 大小为 3，刚好处于半满状态，节点 B 大小为 5，节点 C 是 A、B 的父节点，且也处于半满状态。\",\"图 12\",\"现在从树中删除 10，10 位于节点 A 中，删除后，A 节点大小为 2，不满足半满性质，因此需要重组或合并。B 节点是 A 的兄弟节点，其大小为 5，A、B 节点加起来的大小为 7，大于 6，因此需要重组而不是合并(合并后大小仍然大于 6，故不能合并)。如图 13 所示：\",\"图 13\",\"重组过程比较简单，B 节点将自己的末尾项 9，借给兄弟节点 A，A 将 9 加入到节点头部，并且更新父节点 C 节点中指向 A 节点的键(以前为 10，重组后为 9)。\",\"现在再从树中删除 15，如图 14 所示：\",\"图 14\",\"15 在节点 D 中，被删除后，节点 D 大小只有 2，不满足半满性质，且其兄弟节点 A 大小为 3，二者大小加起来也只有 5，小于 6，因此节点 D、A 需要合并，如下图 15 所示：\",\"图 15\",\"A、D 节点合并后成为节点 A，删除节点 C 中指向 D 的指针，并且更新 A 节点指向兄弟节点的指针。节点 C 删除一个子节点后，也无法满足半满性质，其兄弟节点 E 大小只有 3，因此 C、E 节点也需要合并，如图 16 所示。\",\"图 16\",\"节点 C、E 合并成为节点 C 后，其父节点 F(根节点)删除指向 E 的指针，虽然节点 F 也不满足半满的性质，但是 F 是根节点，最少只需要两个节点，因此合并完毕。\",\"在这个例子中，10 删除引发了节点重组，15 删除引发了两次节点合并，删除的复杂性大大高于插入。删除对应的 API 如下：\",\"void Remove(key) { // 如果是一棵空树，直接返回 if (IsEmpty()) { return; } page = FindLeafPage(key); leaf_node = reinterpret_cast<LeafPage>(page.GetData()); // 删除 entry ok = leaf_node->RemoveAndDeleteRecord(key); if (!ok) { // 删除失败 return; } // coalesce(合并) 或者 redistribute(重组) CoalesceOrRedistribute(leaf_node); } \",\"删除时，如果为空树则直接返回，否则找到含 key 的叶子结点，并从中删除 key，随后根据删除后的节点大小来决定重组、合并。如下：\",\"void CoalesceOrRedistribute(node) { if (node.IsRootPage()) { return AdjustRoot(node); } // 判断一下 if (node.GetSize() >= node.GetMinSize()) { return; } // 得到父节点、兄弟节点 parent = FindParentNode(node); sibling_node = FindSiblingNode(node); // 重组 if (node.GetSize() + sibling_node.GetSize() > node.GetMaxSize()) { Redistribute(sibling_node, node, parent); return; // no deletion happens } // 合并 Coalesce(sibling_node, node, parent); } void Coalesce(neighbor_node, node, parent) { // 合并以后可能还需要合并或者重组 // node 所有项移动到 neighbor_node node.MoveAllTo(neighbor_node); // 从 parent 中删除 node parent.Remove(node); // 判断 parent 是否需要合并或者重组 return CoalesceOrRedistribute(parent); } void Redistribute(neighbor_node, node, parent) { // 将 neighbor_internal_node \\b末尾移到 node 的最前面 // 或者将 node 的开始项移到 neighbor_internal_node 末尾 neighbor_internal_node.MoveLastToFrontOf(node); // 更新父节点指针 parent.SetKeyAt(index, neighbor_node); } void AdjustRoot(old_root_node) { // 根节点还不是最后一个节点，仍然是内部节点，且有一个孩子节点 if (old_root_node->GetSize() == 1 && !old_root_node->IsLeafPage()) { // 孩子节点成为新的根节点，然后删除旧的根节点 new_root_node = NewRootNode(); DeleteOldRootPage(); UpdateRootPageId(new_root_node); return; } // 只剩下根节点了，且已经没有子节点了 if (old_root_node.IsLeafPage() && old_root_node.GetSize() == 0) { // 删除根节点 root_page_id_ = INVALID_PAGE_ID; } } \",\"如果是根节点，则进入 AdjustRoot，判断是否需要删除根节点；\",\"如果节点与兄弟节点加起来大于 max_size，则重组否则合并；\",\"重组、合并都是可以递归向上执行的，直到满足半满为止。 删除流程图如图 17 所示：\",\"图 17\",\"提示：实际的代码实现其实比较复杂，伪代码只为说明过程和原理。\"]},\"73\":{\"h\":\"Crabbing 协议\",\"t\":[\"前面实现的 B+树可以满足单线程下任意读写，但如果是多线程，B+树该如何支持并发访问了？\",\"在实际的数据库场景中，并发访问索引是极其常见的，思考一下，如果我们在 BPlusTree 类中定义一把锁，该锁确实可以保证树在多线程是数据安全的，但也导致了单位时间内只有一个线程能够访问该索引，如果是真实环境，那么性能将是十分的低下。\",\"因此我们需要一种算法(或者协议)来让 B+树支持多线程并发访问、更新、删除，并且尽可能的提高并发性能。\",\"而 Crabbing 正是这样的一个协议。协议也十分好理解(实现起来有难度)，如下：\",\"当寻找一个 key 时，以共享锁锁住根节点，沿着树向下遍历，获取子节点，并对子节点加上共享锁后，释放父节点上的锁，重复这个过程，直至寻找到包含 key 的叶子结点，并释放锁；\",\"当更新、删除、插入一个 kv 时，以独占锁锁住根节点，向下遍历，获取子节点，对子节点加独占锁后，如果子节点是「安全」的，那么释放父节点锁，否则一直持有，重复这个过程，操作成功后，释放所有节点上的锁；\",\"如果在删除的过程中，发生重组、合并，那么也必须对兄弟节点加独占锁。 节点「安全」的定义如下：\",\"如果是插入操作，那么节点大小必须 < max_size -1(插入后不会超过 max_size，因此不回分裂，所以是安全的)；\",\"如果是删除操作，那么节点大小必须 > min_size(删除后，仍然满足半满性质，不会发生重组、合并，所以是安全的)；\",\"如果是删除操作，且为根节点，那么节点大小必须 > 2(删除后，根节点不用更新，所以是安全的)。 Crabbing 协议的向下查找方式像极了螃蟹走路，先移动一条腿，然后移动另外一条，因此也被称为「蟹行协议」。\",\"Crabbing 协议的核心点在于，如果是查询，那么只需要共享锁，且所有节点无需变更，都是安全的，因此每得到一个锁，就可以释放上一个锁，锁的「粒度」从树级别下降到了页级别，且共享锁是共享的，别人也可以同时访问。\",\"而如果是删除、插入操作，Crabbing 协议则复杂一些，每访问一个节点都必须先加独占锁，然后在判断子节点安全后，才能释放祖先节点的锁，如果不安全，那么将一直持有整条路线上的锁，对于重组、合并，还必须得兄弟节点加独占锁，待操作完毕后，才能释放所有持有的锁。\",\"注意：Crabbing 协议也有很多优化点，比如更新时，可以先加共享锁，然后升级为独占锁，这些本文不做讨论，感兴趣的可以自行查阅资料。 如图 18 所示，在 B+树中查询 18，从根节点 A 开始加共享锁，然后获取节点 B，对 B 加共享锁，释放 A 的锁，然后获取节点 C，对 C 加锁，释放 B 的锁，最后找到 18，释放 C 的锁。\",\"图 18\",\"查询过程中，无论是加锁、还是解锁都十分简单，那么如果是删除则复杂一些，如图 19 所示，\",\"图 19\",\"如图 19 所示，我们需要删除 46 号元素，从根节点 A 开始，加独占锁，然后获取节点 B，加独占锁，但是 B 不安全，大小为 3，所以无法释放 A 的锁，然后获取节点 C，读 C 加独占锁，而 C 也不安全，因此无法释放 A、B 上的锁，此时 A、B、C 全部加锁；但是删除元素 46 后，发现节点 C、D 需要合并，因此也需要对 D 加独占锁，此时 A、B、C、D 全被锁住了，当所以合并操作完成后，这次删除操作才能释放所有节点上的锁。\",\"因此，可以看到删除操作加锁比查询加锁要复杂的多，而且锁的粒度可能很大。\",\"对于 Crabbing 协议的实现，重点在于搜索时根据操作类型来选择锁的方式，并通过判断节点是否安全来决定是否释放祖先节点上的锁，其核心伪代码如下：\",\"Page FindLeafPageByOperation(key, op_type) { page = GetRootPage(); // 根节点页 if (op_type == OperationType::SEARCH) { page.RLatch(); // 搜索，加读锁 } else { page.WLatch(); // 其他操作，加独占锁 } // 如果不是叶子节点，那么继续向下搜索 while (!node.IsLeafPage()) { child_page = page.Lookup(key); if (op_type == OperationType::SEARCH) { child_page.RLatch(); // 子节点加锁 page->RUnlatch(); // 父节点解锁 } else { child_page->WLatch(); // 子节点枷锁 if (IsSafety(child_node, op_type)) { ReleaseAllAncestorLocks(); // 如果节点安全，则释放祖先节点的锁 } } page = child_page; node = child_node; } return page; } \",\"而在重组、合并时，需记得对兄弟节点加独占锁，这里就不展示相关的伪代码了。\"]},\"74\":{\"h\":\"小结\",\"t\":[\"B+树，尤其是支持并发的 B+树，在实现上其实是非常复杂的，有很多小细节都需要考虑和完善，笔者在实现的过程中，被虐的死去活来；尤其是加上 Crabbing 协议后，并发的 BUG 往往十分诡异，肉眼很难捕捉，往往花了好久才能定位问题，但是付出是值得的，实现过如此复杂的数据结构后，就很难再对数据结构产生畏惧。\"]},\"75\":{\"h\":\"参考资料\",\"t\":[\"Database System Concepts 11.3~11.4\",\"Database System Concepts 15.10\",\"PROJECT #2 - B+TREE\",\"Trees Indexes I\",\"Trees Indexes II\",\"B+ tree\"]},\"76\":{\"h\":\"谈谈关系数据库的设计与实现(4)——执行器\"},\"77\":{\"h\":\"执行器\",\"t\":[\"前面的两个小节中，分别介绍了缓存池组件以及支持存储引擎的 B+树，本节的主角是执行器。\",\"数据库系统从客户端接收到 SQL 语句后，对语句解析、优化并得到该语句的「查询计划」，而执行器的作用就是按照查询计划来执行查询操作。\",\"这里的查询操作，并不单单指数据查询，它包括如下几类操作：\",\"访问、查询，如表遍历，记录查询等；\",\"更改，如数据更新、插入、删除等；\",\"其它，如 Limit、Offset、聚合函数，Join 等；\",\"注意：bustub 中不会实现 SQL 解析器、优化器，这里也不做介绍。\"]},\"78\":{\"h\":\"处理模型\",\"t\":[\"「处理模型」规定了执行器如何去执行查询计划。常见的处理模型有：\",\"Iterator Model(迭代器模型)\",\"Materialization Model\",\"Vectorized / Batch Model(批处理模型) bustub 实现了迭代器模型，其核心思想是：每一个执行器都实现 Next 方法。\",\"每次调用 Next 方法，执行器都会返回一条数据记录(Tuple)，如果没有则返回空；\",\"执行器可以拥有子执行器，父执行器在 Next 被调用时可以调用子执行器的 Next 方法，获取子执行器数据记录后，进一步处理返回。 bustub 通过 ExecutionEngine 类实例来执行查询计划，并获取查询结果，其定义如下：\",\"class ExecutionEngine { public: // ... bool Execute(const AbstractPlanNode *plan, std::vector<Tuple> *result_set, Transaction *txn, ExecutorContext *exec_ctx) { // construct executor auto executor = ExecutorFactory::CreateExecutor(exec_ctx, plan); // prepare executor->Init(); // execute try { Tuple tuple; RID rid; while (executor->Next(&tuple, &rid)) { if (result_set != nullptr) { result_set->push_back(tuple); } } } catch (Exception &e) { } return true; } // ... } \",\"ExecutionEngine 对外只暴露一个 Execute 方法，该方法接收四个参数：\",\"plan：查询计划；\",\"result：数据记录容器；\",\"txn：当前查询事务；\",\"exec_ctx：执行上下文。 AbstractPlanNode 是所有执行计划的父类，可用来表示所有类型的执行计划，通过调用 ExecutorFactory::CreateExecutor 方法可根据 plan 类型来生成对应的执行器，然后初始化该执行器，并不断调用 Next 方法来获取所有符合条件的数据记录(Tuple)。\"]},\"79\":{\"h\":\"执行计划\",\"t\":[\"为了支持各类查询计划(比如 select 查询计划)，bustub 定义了 AbstractPlanNode 作为所有查询计划的父类，其定义如下：\",\"class AbstractPlanNode { public: // ... AbstractPlanNode(const Schema *output_schema, std::vector<const AbstractPlanNode *> &&children) : output_schema_(output_schema), children_(std::move(children)) {} virtual ~AbstractPlanNode() = default; // ... / private: // 数据表范式 const Schema *output_schema_; // 子查询计划 std::vector<const AbstractPlanNode *> children_; }; \",\"AbstractPlanNode 类有两个重要字段：\",\"output_schema_：数据表范式(定义)，查询数据组织方式，如：a int, b bool；\",\"children_：子查询计划列表； 每一类查询(如全表扫描)计划都有一个对应的查询计划类，以全表扫描的 SeqScanPlanNode 为例：\",\"class SeqScanPlanNode : public AbstractPlanNode { public: SeqScanPlanNode(const Schema *output, const AbstractExpression *predicate, table_oid_t table_oid) : AbstractPlanNode(output, {}), predicate_{predicate}, table_oid_(table_oid) {} PlanType GetType() const override { return PlanType::SeqScan; } const AbstractExpression *GetPredicate() const { return predicate_; } table_oid_t GetTableOid() const { return table_oid_; } private: // 谓词 const AbstractExpression *predicate_; // 数据表 id table_oid_t table_oid_; }; \",\"SeqScanPlanNode 表示全表扫描查询计划，即 SQL 中的 select 语句，其核心字段有两个：\",\"predicate_：断言，也可理解为查询条件，如 where id > 1；\",\"table_oid_：数据表 id，用来唯一标识一张表，即对哪张表进行全表扫描。 全表扫描查询计划保存了当前查询的表 id、查询条件等，那么该查询计划又是如何被执行器执行的呢？\",\"无独有偶，与查询计划一样，所有执行器也有一个公共父类 AbstractExecutor：\",\"class AbstractExecutor { public: explicit AbstractExecutor(ExecutorContext *exec_ctx) : exec_ctx_{exec_ctx} {} virtual ~AbstractExecutor() = default; virtual void Init() = 0; virtual bool Next(Tuple *tuple, RID *rid) = 0; virtual const Schema *GetOutputSchema() = 0; ExecutorContext *GetExecutorContext() { return exec_ctx_; } protected: ExecutorContext *exec_ctx_; }; \",\"AbstractExecutor 有且只有一个核心字段 exec_ctx_，即执行器上下文。执行器上下文上保存了执行器所需的环境、数据等信息，如：\",\"缓冲池管理器(BufferPoolManager)：执行器需访问数据页；\",\"目录(Catalog)：存储表、索引元数据；\",\"等等。 AbstractExecutor 还定义了执行器的基本方法 Init、Next 等，ExecutionEngine 就是通过 Next 方法来获取数据记录的。\",\"因此任何一个执行器，其核心其实都是 Next 方法，仍以全表扫描为例，其核心实现如下：\",\"SeqScanExecutor::SeqScanExecutor(ExecutorContext *exec_ctx, const SeqScanPlanNode *plan) : AbstractExecutor(exec_ctx), plan_(plan) { table_metadata_ = exec_ctx->GetCatalog()->GetTable(plan->GetTableOid()); } void SeqScanExecutor::Init() { table_iterator_ = std::make_unique<TableIterator>(table_metadata_->table_->Begin(exec_ctx_->GetTransaction())); } bool SeqScanExecutor::Next(Tuple *tuple, RID *rid) { Tuple tup; do { // 到末尾了，直接返回 if (*table_iterator_ == table_metadata_->table_->End()) { return false; } tup = *(*table_iterator_); // 得到当前 tuple ++(*table_iterator_); // 下一个 } while (plan_->GetPredicate() != nullptr && // 执行 !plan_->GetPredicate()->Evaluate(&tup, &(table_metadata_->schema_)).GetAs<bool>()); // 一个 Tuple 是一条记录，values 是字段值，schema 是字段名称 std::vector<Value> values; std::transform(plan_->OutputSchema()->GetColumns().begin(), plan_->OutputSchema()->GetColumns().end(), std::back_inserter(values), [&tup, &table_metadata_ = table_metadata_](const Column &col) { // Column 是数据列，即字段的定义，调用 Evaluate 获取列数据 return col.GetExpr()->Evaluate(&tup, &(table_metadata_->schema_)); }); // 赋值 *tuple = Tuple{values, plan_->OutputSchema()}; *rid = tup.GetRid(); return true; } \",\"SeqScanExecutor 构造函数、Init 方法分别用来初始化表元数据、表迭代器。其核心 Next 方法主要流程如下：\",\"判断迭代器是否结束，若结束，返回 false；\",\"迭代器++，若查询谓词为空，或者当前表记录(Tuple)满足查询条件(Predicate)，那么结束 while 循环，否则迭代器继续 ++；\",\"将表字段数据(Value)按照执行计划上的表范式(output_schema)包装为表记录(Tuple)返回。 不同的查询计划对应不同的执行器，bustub 通过 ExecutionEngine、AbstractExecutor 和 AbstractPlanNode 巧妙将其解耦；执行器执行时从上下文中获取查询所需的环境、数据等信息，然后通过谓词判断记录是否符合查询条件，若符合则取出值，并包装为表记录返回给执行引擎。\",\"执行器运行流程图如图 20 所示：\",\"图 20\",\"当然，bustub 有多种查询计划、执行器，如下：\",\"./src/execution ├── aggregation_executor.cpp ├── delete_executor.cpp ├── executor_factory.cpp ├── index_scan_executor.cpp ├── insert_executor.cpp ├── limit_executor.cpp ├── nested_index_join_executor.cpp ├── nested_loop_join_executor.cpp ├── seq_scan_executor.cpp └── update_executor.cpp \",\"全表扫描仅仅只是其中最简单的一种，得益于 bustub 精妙的抽象，我们只需实现一个简单的执行器就能领略到数据库执行器的风采，篇幅有限，其它执行器的实现这里就不再赘述了，感兴趣的可以点开参考资料查阅。\"]},\"80\":{\"h\":\"参考资料\",\"t\":[\"Database System Concepts 12\",\"PROJECT #3 - QUERY EXECUTION\",\"Query Execution I\",\"Query Execution II\"]},\"81\":{\"h\":\"谈关系数据库的设计与实现(5)——并发控制\"},\"82\":{\"h\":\"并发控制\",\"t\":[\"在并发 B+树这一节中，我们实现了支持并发访问的 B+树，B+树可用于存储索引，但是数据库还有更加重要的数据部分——数据表记录(Tuple)。\",\"在 bustub 中，是通过 TransactionManager(事务管理器) 和 LockManager(锁管理器) 来实现 Tuple 并发访问控制和数据库事务的。\"]},\"83\":{\"h\":\"事务\",\"t\":[\"事务是数据库访问、更新数据的一个基本执行单元，它可由多个数据库操作组成，且多个操作不可分割，要么全部成功，要么全部失败。\",\"事务具有如下四个特性(摘自维基百科)，习惯上被称之为 ACID特性 。\",\"原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\",\"一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。\",\"隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\",\"持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。\"]},\"84\":{\"h\":\"事务隔离级别\",\"t\":[\"多事务并发执行的情况下，可能会出现如下几个问题：\",\"脏读（dirty read）：A 事务读取 B 事务尚未提交的数据，此时如果 B 事务发生错误并执行回滚操作，那么 A 事务读取到的数据就是脏数据；\",\"不可重复读（non-repeatable read）：A 事务第一次读取数据 1，然后 B 事务更改了数据 1 为 2，然后 A 事务再次读取，发现数据变成了 2；\",\"幻读（phantom read）：幻读发生在其他事务 insert 数据，A 事务第一次查询有 100 条，第二次查询却发现有 200 条，原因在于其它事务插入了数据。 为了解决这些问题，就有了「事务隔离级别」这个概念。隔离级别用于控制多个事务并发访问时，彼此的隔离状态，级别越高，隔离度也越好，但是整体运行效率也越低。\",\"读未提交：一个事务还没提交，其变更就能被其它事务看到。\",\"读提交：一个事务提交之后，其变更才能被其它事务看到。\",\"可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。\",\"串行化：后访问的事务必须等前一个事务执行完成，才能继续执行。 隔离级别越高，所能解决的问题就越多，但同样的，效率也就越低。如下表 1 所示，读未提交无法解决脏读、不可重复读、幻读中的任何一个，而串行化能够解决它们。\",\"脏读\",\"不可重复读\",\"幻读\",\"读未提交\",\"✖️\",\"✖️\",\"✖️\",\"读提交\",\"☑️\",\"✖️\",\"✖️\",\"可重复读\",\"☑️\",\"☑️\",\"✖️\",\"串行化\",\"☑️\",\"☑️\",\"☑️\",\"表 1\",\"那么是不是隔离级别越高越好了？显然不是的，如 MySQL 默认的隔离级别是 RR(可重复读)，而 PostgreSQL 默认隔离级别是 RC(读提交)，性能是数据库一个重要的考量指标，而不可重读等问题实际上出现的并不多，很少有人在一个事务过程中，多次读取同一条记录。\"]},\"85\":{\"h\":\"二阶段事务\",\"t\":[\"介绍事务基本概念后，又该如何实现事务了？\",\"一个事务访问数据库时，可能会对多个数据页加锁并读取数据，那么又该如何保证事务之间不发生数据冲突了？\",\"在 bustub 中，是通过「二阶段事务」来解决这两个问题的。事务一般有三个操作：\",\"开始(Begin)：启动一个事务；\",\"提交(Commit)：提交一个事务；\",\"回滚(Rollback)：回滚一个事务。 二阶段事务沿用了这三个操作，在 bustub 中也可以通过 Begin 开始一个事务，Commit 提交一个事务，如果发生问题，也可以通过 Rollback 回滚事务。\",\"但二阶段事务却有 4 个状态：\",\"Growing：获取锁阶段，事务向锁管理器请求锁；\",\"Shrinking：释放锁阶段，事务不能再获取锁，只能释放锁；\",\"Commited：提交阶段，事务已提交；\",\"Aborted：终止阶段，事务已终止。 事务是数据访问的基本单位，任何一个连接建立后，数据库系统都会为其分配一个事务(由事务 id 唯一标识)，此后该连接对数据的访问都会以此事务作为基本单位。\",\"因此对于并发连接的数据访问控制，实则就是对事务的控制。、\",\"两阶段锁定协议（2PL）是一种并发控制协议，决定事务是否可以动态地访问数据库中的对象。\",\"2PL 两个阶段：\",\"Growing： \",\"每个事务当需要时向锁管理器请求锁；\",\"锁管理器负责向事务授予锁、或者阻塞事物。\",\"Shrinking： \",\"事务无法再获取新的锁(也不能升级)，只能释放原来获取的锁。 \",\"2PL 仍然会存在：\",\"脏读问题，解决方案是 Strong Strict 2PL；\",\"死锁问题，解决方案是检测、预防。 为什么会存在脏读？因为再 shrinking 阶段，若事务释放了一个数据的锁，那么该锁可以被其它事务获取，而当前事务还未提交，因此其它事务可能读到脏数据。\",\"强二阶段锁定协议示意图如下：\",\"强二阶段锁规定，shrinkong 阶段不能释放某一个锁，只能在结束时释放所有的锁。\"]},\"86\":{\"h\":\"锁管理器\",\"t\":[\"锁是为了解决不同事务并发操作的隔离性问题，如下：\",\"事务 T1 最后访问 A 的同时，T2 更新了 A 并提交了，因此 T1 会读到脏数据。\",\"我们需要一种机制来保证所有事务执行是正确的（即事务本身觉得是序列化执行的），事务不用关系其它事务之间的数据依赖。\",\"解决办法：使用锁来保护数据对象。如下：\",\"事务 T1 来访问 A 时，必须对 A 加锁，加锁后，T2 不能访问 A，必须等待 T1 释放锁后，才能对 A 加锁，然后再更改。\",\"锁可分为如下两种类型：\",\"S：共享锁，其它事务可读；\",\"X：独占锁，其它事物不可读、不可写。 锁管理器的执行机制如下：\",\"事务请求(或者升级)锁；\",\"锁管理器授予事务锁、或者阻塞事务执行；\",\"事务释放锁；\",\"锁管理器在内部维护了事务锁表：跟踪哪些事务持有哪些锁以及哪些事务正在等待获取其它锁。\"]},\"87\":{\"h\":\"死锁\",\"t\":[\"当事务之间存在数据依赖，并且发生了环等待，就会产生死锁。解决死锁的方法有两种：\",\"死锁检测\",\"死锁预防 锁管理器在内部维护一个名为 wait-for 的图，用来记录事务正在等待获取的锁：\",\"图中的节点是事务；\",\"如果 T1 正在等待 T2 释放锁，那么 T1 有一条边指向 T2。 数据库系统会周期性地检查 wait-for 图，找到死锁，并决定如何打破它。\",\"如图所示：\",\"T1 等待 T2 释放锁，T2 等待 T3 释放锁，而 T3 又在等待 T1 释放锁，因此会出现环形等待，即死锁。\",\"当系统检测到死锁时，它会选择一个事务回滚以打破循环等待。回滚事务将重新启动或中止，这取决于具体情况。\",\"事务淘汰策略有多种，比如：\",\"By age，长事务先淘汰；\",\"By number of locks，锁多的先淘汰；\",\"等等\"]},\"88\":{\"h\":\"实现\",\"t\":[\"锁管理器(LockManager)负责对维护事务与数据表记录之间的锁联系，任何事务在访问数据记录之前，必须先尝试获取该记录的锁，这个过程被称为「请求锁」，请求成功后，锁管理器会赋予事务锁，否则返回失败。\",\"比如，事务获取某条记录的共享锁：\",\"bool LockManager::LockShared(Transaction *txn, const RID &rid) { // 事务共享锁加入 rid // Transaction txn tries to take a shared lock on record id rid. // This should be blocked on waiting and should return true when granted. // Return false if transaction is rolled back (aborts). // 如果是读未提交，那么直接 abort if (txn->GetIsolationLevel() == IsolationLevel::READ_UNCOMMITTED) { AbortImplicitly(txn, AbortReason::LOCKSHARED_ON_READ_UNCOMMITTED); return false; } // 如果是可重复读，且事务处于 shrinking 状态，那么直接 abort // 因为 shrinking 状态下，事务不能再加锁 if (txn->GetIsolationLevel() == IsolationLevel::REPEATABLE_READ && txn->GetState() == TransactionState::SHRINKING) { AbortImplicitly(txn, AbortReason::LOCK_ON_SHRINKING); return false; } // 如果 rid 已经被锁了，那么直接返回 true if (txn->IsSharedLocked(rid) || txn->IsExclusiveLocked(rid)) { return true; } // latch_ 用来保护 lock_table // lock_table 中保存了 rid 对应的锁队列 std::unique_lock<std::mutex> latch(latch_); auto &lock_request_queue = lock_table_[rid]; latch.unlock(); // 解锁 // 操作 rid 对应的队列，对队列加锁 std::unique_lock<std::mutex> queue_latch(lock_request_queue.latch_); // 将事务 id 和加锁模式加入到队列 auto &lock_request = lock_request_queue.request_queue_.emplace_back(txn->GetTransactionId(), LockManager::LockMode::SHARED); // 加入后等待 lock_request_queue.cv_.wait(queue_latch, [&lock_request_queue, &lock_request, &txn] { // 如果事务 abort，或者当前锁请求与队列中的其它锁兼容，比如都是共享锁，那么直接停止等待，继续执行 return LockManager::IsLockCompatible(lock_request_queue, lock_request) || txn->GetState() == TransactionState::ABORTED; }); // abort，直接返回 if (txn->GetState() == TransactionState::ABORTED) { AbortImplicitly(txn, AbortReason::DEADLOCK); } // 授予锁 lock_request.granted_ = true; txn->GetSharedLockSet()->emplace(rid); return true; } \",\"LockShared 方法接受两个参数：\",\"RID：每一条数据记录都由 RID 唯一标识；\",\"Transaction：事务，即当前请求共享锁的事务实例。 当调用 LockShared 方法时，txn 向锁管理器请求 rid 记录的共享锁。方法会根据事务隔离级别、以及事务阶段来判断是否授予锁。同理锁管理器还提供了 LockExclusive，LockUpgrade，Unlock 等方法分别用于互斥锁、锁升级和解锁等操作。\",\"而对于死锁检测，锁管理器维护了一个 waits_for_ 等待列表，并启动一个后台线程专门用于检查事务之间的依赖关系，如下：\",\"void LockManager::RunCycleDetection() { // 检查是否存在死锁 // You should not be maintaining a graph, it should be built and destroyed every time the thread wakes up. while (enable_cycle_detection_) { std::this_thread::sleep_for(cycle_detection_interval); { std::unique_lock<std::mutex> latch(latch_); if (!enable_cycle_detection_) { break; } waits_for_.clear(); BuildWaitsForGraph(); txn_id_t txn_id; while (HasCycle(&txn_id)) { // 得到死锁的 txn_id auto txn = TransactionManager::GetTransaction(txn_id); txn->SetState(TransactionState::ABORTED); // abort // 清除 txn_id 上的锁 // 得到 txn_id 上所有的边 for (const auto &wait_on_txn_id : waits_for_[txn_id]) { auto wait_on_txn = TransactionManager::GetTransaction(wait_on_txn_id); // 得到事务上的所有 share、exclusive 的 RID std::unordered_set<RID> lock_set; lock_set.insert(wait_on_txn->GetSharedLockSet()->begin(), wait_on_txn->GetSharedLockSet()->end()); lock_set.insert(wait_on_txn->GetExclusiveLockSet()->begin(), wait_on_txn->GetExclusiveLockSet()->end()); for (auto locked_rid : lock_set) { // 通知 lock_table_[locked_rid].cv_.notify_all(); } } // 重新建立图 waits_for_.clear(); BuildWaitsForGraph(); } } } } \",\"后台线程每隔一段时间就会构建出事务之间的依赖图，然后判断事务之间是否存在循环依赖(Cycle)，如果存在则将事务的状态设置为 Abort。\"]},\"89\":{\"h\":\"执行器\",\"t\":[\"在上一讲中，我们介绍了 bustub 如何通过执行器来执行 SQL 查询计划，但很显然，前面的执行器是无法支持事务隔离的，因此我们需要通过锁管理器来完善执行器的事务支持。\",\"仍然以全表扫描为例，SeqScanExecutor 是如何来支持事务的呢？在 Next 函数中，加上事务隔离级别的判断，如下：\",\"bool SeqScanExecutor::Next(Tuple *tuple, RID *rid) { Tuple tup; // 谓词不为空，而且执行 ok // tuples are returned if predicate(tuple) = true or predicate = nullptr do { // 到末尾了，直接返回 if (*table_iterator_ == table_metadata_->table_->End()) { return false; } tup = *(*table_iterator_); // 得到当前 tuple ++(*table_iterator_); // 下一个 } while (plan_->GetPredicate() != nullptr && // 执行 !plan_->GetPredicate()->Evaluate(&tup, &(table_metadata_->schema_)).GetAs<bool>()); // 判断事务隔离级别 + switch (exec_ctx_->GetTransaction()->GetIsolationLevel()) { + case IsolationLevel::READ_UNCOMMITTED: + break; // 读未提交，未加任何锁，直接 break + case IsolationLevel::READ_COMMITTED: + // 读已提交 + // 1.没有加读锁; + // 2.也没有加写锁; + // 3.不能加读锁后，立即解锁成功 + if (!exec_ctx_->GetTransaction()->IsSharedLocked(tup.GetRid()) && + !exec_ctx_->GetTransaction()->IsExclusiveLocked(tup.GetRid()) && + !(exec_ctx_->GetLockManager()->LockShared(exec_ctx_->GetTransaction(), tup.GetRid()) && + exec_ctx_->GetLockManager()->Unlock(exec_ctx_->GetTransaction(), tup.GetRid()))) { + return false; + } + break; + case IsolationLevel::REPEATABLE_READ: + // 可重读读 + // 1. 没有加读锁 + // 2. 没有加写锁 + // 3. 且不能加读锁 + if (!exec_ctx_->GetTransaction()->IsSharedLocked(tup.GetRid()) && + !exec_ctx_->GetTransaction()->IsExclusiveLocked(tup.GetRid()) && + !exec_ctx_->GetLockManager()->LockShared(exec_ctx_->GetTransaction(), tup.GetRid())) { + return false; + } + break; + default: + break; } // 一个 Tuple 是一条记录，values 是字段值，schema 是字段名称 std::vector<Value> values; std::transform(plan_->OutputSchema()->GetColumns().begin(), plan_->OutputSchema()->GetColumns().end(), std::back_inserter(values), [&tup, &table_metadata_ = table_metadata_](const Column &col) { // Column 是数据列，即字段的定义，调用 Evaluate 获取列数据 return col.GetExpr()->Evaluate(&tup, &(table_metadata_->schema_)); }); // 赋值 *tuple = Tuple{values, plan_->OutputSchema()}; *rid = tup.GetRid(); return true; } \",\"对于三个事务隔离级别的处理方式如下：\",\"读未提交，未加任何锁，直接 break；\",\"读已提交，没有加读、写锁，且无法加读锁，并能解锁；\",\"可重复读：没有加读、写锁，切无法加读锁 TODO 还未完全理清楚\"]},\"90\":{\"h\":\"参考资料\",\"t\":[\"Database System Concepts 15\",\"PROJECT #4 - CONCURRENCY CONTROL\",\"Concurrency Control Theory\",\"Two-Phase Locking Concurrency Control\",\"https://www.bdwms.com/?p=741\",\"https://zhuanlan.zhihu.com/p/362061406\"]},\"91\":{\"h\":\"谈谈关系数据库的设计与实现(6)——日志和恢复\"},\"92\":{\"h\":\"日志和恢复\",\"t\":[\"计算机容易发生各种故障，如磁盘故障、宕机、软件错误等。一旦计算机故障就容易引起运行其内的数据库丢失数据，因此数据库必须预先采取措施以保证即使发生故障，数据仍然找回。\",\"恢复机制是数据库必不可少的一部分，它能保证数据库即使在故障发生的情况下，仍然恢复到发生前的状态，保证前后数据的一致性，保证数据库的高可用性。\",\"恢复算法是确保数据库一致性、原子性和持久性的关键技术。\",\"恢复算法主要工作包括如下两部分：\",\"记录事务处理期间的操作，以确保 DBMS 可以从故障中恢复；\",\"将数据库恢复到某个失败后的状态，确保操作的原子性、一致性和持久性。 恢复算法主要思路：\",\"预写日志(WAL)：\",\"任何数据更改在应用到数据库之前，必须先由日志写入磁盘。\",\"必须使用 STEAL + NO-FORCE 缓冲池策略。\",\"在重做期间恢复历史数据：在重新启动时，重做操作并将数据库恢复到崩溃前的状态。\",\"撤消期间记录更改：将撤消操作记录到日志中以确保操作不会在重复失败的情况下重复执行。\"]},\"93\":{\"h\":\"日志\",\"t\":[\"在 bustub 中通过 LogManager 来实现WAL日志记录。类定义如下：\",\"class LogManager { public: explicit LogManager(DiskManager *disk_manager) : next_lsn_(0), persistent_lsn_(INVALID_LSN), disk_manager_(disk_manager) { log_buffer_ = new char[LOG_BUFFER_SIZE]; flush_buffer_ = new char[LOG_BUFFER_SIZE]; } ~LogManager() { delete[] log_buffer_; delete[] flush_buffer_; log_buffer_ = nullptr; flush_buffer_ = nullptr; } void RunFlushThread(); void StopFlushThread(); void Flush(bool force); lsn_t AppendLogRecord(LogRecord *log_record); inline lsn_t GetNextLSN() { return next_lsn_; } inline lsn_t GetPersistentLSN() { return persistent_lsn_; } inline void SetPersistentLSN(lsn_t lsn) { persistent_lsn_ = lsn; } inline char *GetLogBuffer() { return log_buffer_; } // ... } \"]},\"94\":{\"h\":\"恢复\",\"t\":[\"那么 bustub 碰到数据库崩溃、电源断开等情况又该如何恢复呢？bustub 的处理其实是比较粗糙的，定义如下：\",\"class LogRecovery { public: LogRecovery(DiskManager *disk_manager, BufferPoolManager *buffer_pool_manager) : disk_manager_(disk_manager), buffer_pool_manager_(buffer_pool_manager), offset_(0) { log_buffer_ = new char[LOG_BUFFER_SIZE]; } ~LogRecovery() { delete[] log_buffer_; log_buffer_ = nullptr; } void Redo(); void Undo(); bool DeserializeLogRecord(const char *data, LogRecord *log_record); // ... } \",\"bustub 的崩溃恢复必须先 Redo 再 Undo，首先 Redo 会扫描全部的日志文件，并通过 LSN 大小来重做未完成的事务，在重做期间记录正在活跃的事务，然后调用 Undo 来撤销这些操作。\"]},\"95\":{\"h\":\"参考资料\",\"t\":[\"PROJECT #4 - LOGGING & RECOVERY\",\"Database System Concepts 16\",\"Database Recovery\"]},\"96\":{\"h\":\"diskqueue持久化队列设计演进\",\"t\":[\"一步一步推导演进持久化磁盘队列的设计与实现。 在方向不明确，不够熟练的情况下，从 demo 做起，一步步学习先进的设计理念并付诸行动。\"]},\"97\":{\"h\":\"第一版，单文件持久化队列\",\"t\":[\"元数据、堆数据存储在一个文件中；\",\"元数据：记录读、写消费指针，队列大小；\",\"堆数据：item 长度、数据；\",\"元数据 + 堆数据单文件存储；\",\"UML 类图：\",\"读：\",\"写：\",\"实现参考dqv1\"]},\"98\":{\"h\":\"第二版，多文件持久化队列\",\"t\":[\"元数据、堆数据存储在不同文件中；\",\"元数据：记录读、写消费指针，队列大小；\",\"堆数据：item 长度、数据；\",\"元数据 + 堆数据单文件存储；\",\"实现参考dqv2\",\"diskqueue：\",\"fields： \",\"size：队列大小；\",\"readPos：读偏移；\",\"writePos：写偏移；\",\"readFileNum：读文件序号；\",\"writeFileNum：写文件序号；\",\"nextReadPos：下一次读文件偏移；\",\"nextReadFileNum：下一次读文件序号；\",\"name：队列名称；\",\"path：数据存储路径；\",\"maxBytesPerFile：文件最大字节数；\",\"maxBytesFileRead：文件最大可读字节数；\",\"syncThreshold：刷盘次数阈值；\",\"syncTimeout：刷盘间隔；\",\"methods： \",\"open：（重新）打开队列；\",\"readMetadata：读元数据；\",\"writeMetadata：写元数据；\",\"writeOne：写一条消息；\",\"readOne：读一条消息；\",\"sync：刷盘，元数据文件、写文件；\",\"diskqueue open：\",\"diskqueue readMetadata：\",\"diskqueue writeMetadata：\",\"diskqueue readOne：\",\"readOne 需要同时支持 peek 和 poll，peek 不会更新 readPos、readFileNum、size，因此 readOne 也不会更新，但 poll 会更新。\",\"diskqueue writeOne：\",\"实现参考dqv3\",\"优化点：\",\"刷盘策略：\",\"刷盘线程，频率可配置\",\"时间戳：\",\"按时间清除数据\",\"Page 读取：\",\"HeapFile、MetaFile 按照页组织\",\"Cache 策略：\",\"增加读、写命中率\"]},\"99\":{\"h\":\"第三版，多消费者（Fanout）持久化队列\",\"t\":[\"元数据、堆数据存储在不同文件中；\",\"元数据：记录多个消费者读、写消费指针，队列大小；\",\"堆数据：item 长度、数据；\",\"元数据 + 堆数据单文件存储；\",\"实现参考diskqueue\"]},\"100\":{\"h\":\"distributed-kv 设计与实现\",\"t\":[\"旨在探索分布式缓存的设计与实现\"]},\"101\":{\"h\":\"架构设计\"},\"102\":{\"h\":\"目标\",\"t\":[\"支持大容量缓存、持久化，PB 级别；\",\"支持哈希槽分片，动态收缩；\",\"支持 List，Set，String，Hash，Sorted set 等数据结构；\",\"集成 Deno，支持脚本事务；\",\"使用简单，redis-cli 客户端可直接使用，直连代理节点；\",\"二次封装 redis 客户端，支持代理模式自动切换；\"]},\"103\":{\"h\":\"整体架构\",\"t\":[\"distributed-kv 基于 Tikv 实现，并提供兼容 redis 数据结构的 API，支持基本 5 种基本类型数据结构，不支持 Pub/Sub，Pipeline 等高级特性，旨在探索超大容量缓存的架构实践。\",\"整体如下：\",\"Client：客户端；\",\"Discover：服务发现；\",\"Proxy Cluster：服务代理集群；\",\"Server Cluster：缓存服务集群，按照哈希槽分片；\",\"Tikv Cluster：Tikv 集群，提供 KV 服务；\",\"PD Cluster：Tikv 调度器、元数据管理集群，与 Tikv 并存；\"]},\"104\":{\"h\":\"客户端\",\"t\":[\"distributed-kv 提供两种客户端访问模式：\",\"原生 redis 客户端通过 proxy 地址访问；\",\"二次封装 redis 客户端通过 discover 服务发现访问；\",\"原生客户端兼容已有 redis 客户端访问模式，但 proxy 服务宕机需要手动切换地址；二次封装客户端基于服务发现 proxy 集群，proxy 单点故障后，由服务发现通知更换，避免二次编码、配置更改发布。\"]},\"105\":{\"h\":\"代理服务\",\"t\":[\"由于 distributed-kv 有多个缓存服务节点，这些节点可能分布在不同集群、区域中。客户端直接访问缓存服务有诸多不便：\",\"节点变更，客户端需感知变更；\",\"多集群访问需要多个不同连接池；\",\"缓存分片信息重度冗余在客户端等；\",\"基于此，distributed-kv 加了一层代理服务，客户端无需过多关注缓存服务集群信息，只需直连代理服务就能访问到不同集群的数据，连接管理更加简单方便，降低客户端使用难度。\",\"代理服务是多个 proxy 节点组成的集群，proxy 节点注册到 ETCD，客户端通过拉取和监听 proxy 列表，然后再向访问单节点 redis 一样访问每个 proxy 即可。\",\"由于 proxy 集群部署，因此其中有节点宕机也并无关系，客户端会选择其它节点继续使用。\",\"这样访问 distributed-kv 就跟访问普通 redis 一样了，其架构图如下：\"]},\"106\":{\"h\":\"缓存服务\",\"t\":[\"缓存服务是 distributed-kv 的心脏，缓存集群负责处理 redis 协议请求，并将其转化为 Tikv 所支持的 KV API，操作 Tikv 集群后返回结果。\",\"每个服务节点中 Transform 模块来负责完成 redis 5 种数据结构与基础 KV 的转换。\",\"缓存服务通过哈希槽方式来实现分片，共有 1024 个哈希槽（slot），按照 crc32 哈希算法来分区，每个节点都有其特有的哈希槽，proxy 接到请求后，根据 key 的哈希计算得到 slot，然后转发到对应的缓存节点中。\"]},\"107\":{\"h\":\"Tikv & PD\",\"t\":[\"Tikv 是 Tidb 开源的一款分布式 KV 存储数据库，支持海量数据扩容，支持事务等多种特性，是 distributed-kv 的存储底座。\",\"Tikv 本身架构就比较复杂，如下：\",\"Tikv 具有优越的性能，良好的工程设计以及丰富的特性，十分适合作为分布式存储底座，这里就不赘述，可参考这里。\"]},\"108\":{\"h\":\"详细设计\",\"t\":[\"下面就每个模块详细阐述其设计。\"]},\"109\":{\"h\":\"客户端\"},\"110\":{\"h\":\"原生客户端\",\"t\":[\"指定 proxy 地址，直接使用 redis-cli 就可以直连，兼容 redis 生态，但：\",\"不支持除5 种基本类型的数据结构；\",\"不支持代理集群自动切换等高级功能，代理节点宕机需手动更改地址；\"]},\"111\":{\"h\":\"代理客户端\",\"t\":[\"兼容 redis 协议的新客户端，只需指定 Discover 服务发现组件的地址就能自动连接到 proxy 集群，支持：\",\"proxy 宕机自动切换；\",\"proxy 集群动态收缩；\",\"读写分离；\"]},\"112\":{\"h\":\"代理服务\",\"t\":[\"代理服务最大的特点是 IO 密集，主要有如下功能：\",\"网络连接管理；\",\"协议解析；\",\"协议转发；\",\"命令监控；\",\"另外代理节点启动时，需要向 Discover 中注册自身地址，供客户端使用；节点宕机后，注册信息自动失效，代理节点开启后台线程定点检查注册信息是否存在和正确。\"]},\"113\":{\"h\":\"缓存服务\",\"t\":[\"缓存服务主要有如下功能：\",\"协议解析、数据处理；\",\"redis 命令转化为 Tikv API；\",\"缓存服务也需要将自己地址、哈希槽位等信息注册到 Discover 中，proxy 转发时会根据信息转发到正确的缓存节点上。\",\"Tikv 只提供了单值的键值对类型，而 redis 键值对中的值还可以是集合类型，Transform 模块就需要处理这二者之间的转换。\",\"对于 redis 的 String 类型来说，它本身就是单值的键值对，我们直接用 Tikv 保存就行。但是，对于集合类型来说，就无法直接把集合保存为单值的键值对，而是需要进行转换操作。\",\"为了保持和 Redis 的兼容性，Transform 模块就负责把 redis 的集合类型转换成单值的键值对。简单来说，可以把 Redis 的集合类型分成两类：\",\"一类是 List 和 Set 类型，它们的集合中也只有单值；\",\"另一类是 Hash 和 Sorted Set 类型，它们的集合中的元素是成对的，其中，Hash 集合元素是 field-value 类型，而 Sorted Set 集合元素是 member-score 类型。\",\"具体怎么转换呢？下面分别看下每种类型的转换。\"]},\"114\":{\"h\":\"List 类型\",\"t\":[\"List 集合的 key 被嵌入到了单值键值对的键当中，用 key 字段表示；而 List 集合的元素值，则被嵌入到单值键值对的值当中，用 value 字段表示。\",\"因为 List 集合中的元素是有序的，所以，Transform 模块还在单值键值对的 key 后面增加了 sequence 字段，表示当前元素在 List 中的顺序，同时，还在 value 的前面增加了 previous sequence 和 next sequence 这两个字段，分别表示当前元素的前一个元素和后一个元素。\",\"此外，在单值键值对的 key 前面，Transform 模块还增加了一个值“l”，表示当前数据是 List 类型，以及增加了一个 1 字节的 size 字段，表示 List 集合 key 的大小。\",\"在单值键值对的 value 后面，Transform 模块还增加了 version 和 ttl 字段，分别表示当前数据的版本号和剩余存活时间（用来支持过期 key 功能），如下图所示：\"]},\"115\":{\"h\":\"Set 集合\",\"t\":[\"Set 集合的 key 和元素 member 值，都被嵌入到了 Pika 单值键值对的键当中，分别用 key 和 member 字段表示。同时，和 List 集合类似，单值键值对的 key 前面有值“s”，用来表示数据是 Set 类型，同时还有 size 字段，用来表示 key 的大小。Pika 单值键值对的值只保存了数据的版本信息和剩余存活时间，如下图所示：\"]},\"116\":{\"h\":\"Hash 集合\",\"t\":[\"对于 Hash 类型来说，Hash 集合的 key 被嵌入到单值键值对的键当中，用 key 字段表示，而 Hash 集合元素的 field 也被嵌入到单值键值对的键当中，紧接着 key 字段，用 field 字段表示。Hash 集合元素的 value 则是嵌入到单值键值对的值当中，并且也带有版本信息和剩余存活时间，如下图所示：\"]},\"117\":{\"h\":\"Sorted Set 类型\",\"t\":[\"Sorted Set 类型需要能够按照集合元素的 score 值排序的，而 RocksDB 只支持按照单值键值对的键来排序。所以，Nemo 模块在转换数据时，就把 Sorted Set 集合 key、元素的 score 和 member 值都嵌入到了单值键值对的键当中，此时，单值键值对中的值只保存了数据的版本信息和剩余存活时间，如下图所示：\",\"采用了上面的转换方式之后，Transform 不仅能兼容支持 Redis 的数据类型，而且还保留了这些数据类型的特征，例如 List 的元素保序、Sorted Set 的元素按 score 排序。\",\"Transform 转换方案并不是自己独有的，而是参考了 Pika，包括 rockskv 也使用了类似方案。\"]},\"118\":{\"h\":\"What's Next\",\"t\":[\"实现 distributed-kv 😂，然后再完善文档。\"]},\"119\":{\"h\":\"参考资料\",\"t\":[\"https://github.com/pedrogao/rust-kv\",\"用 Golang 实现 Redis - 随笔分类 - -Finley- - 博客园\",\"https://github.com/seppo0010/rsedis\",\"https://github.com/erikgrinaker/toydb\",\"6.5840 Lab 4: Sharded Key/Value Service\",\"https://github.com/lotusdblabs/lotusdb\",\"https://github.com/tidb-incubator/tidis\",\"https://github.com/yongman/tidis\",\"https://github.com/ledisdb/xcodis\",\"https://github.com/dgraph-io/badger\",\"https://github.com/talent-plan/tinykv\",\"https://github.com/etcd-io/raft\",\"https://github.com/HDT3213/godis\",\"实践篇（08）Pika: 如何基于 SSD 实现大容量 Redis？\",\"https://mp.weixin.qq.com/s/jsJ3_E_5IOs4_rPDM5axzQ\",\"TiKV 源码解析系列 - multi-raft 设计与实现\",\"开源|如何开发一个高性能的 redis cluster proxy? - 掘金\",\"Redis Cluster 的数据分片机制 - 掘金\"]},\"120\":{\"h\":\"谈谈 Raft 分布式共识性算法的实现\"},\"121\":{\"h\":\"介绍\",\"t\":[\"Raft 目前是最著名的分布式共识性算法，被广泛的应用在 etcd、k8s 中。\",\"本文聚焦在 Raft 算法的实现上，不对 Raft 本身做过多介绍，想要了解的可以阅读 extended Raft paper 论文。\",\"根据 Raft 论文，可将 Raft 拆分为如下 4 个功能模块：\",\"领导者选举；\",\"日志同步、心跳；\",\"持久化；\",\"日志压缩，快照。\",\"这 4 个模块彼此并不完全独立，如日志的同步情况左右着领导者选举，快照也影响着日志同步等等；为了前后的递进性，对于一些功能的实现，可能会出现改动和优化，比如日志同步实现后，在数据持久化部分又会对同步做一些优化，提高主、从节点日志冲突解决的性能。\"]},\"122\":{\"h\":\"领导者选举\",\"t\":[\"Raft 算法是目前使用最为广泛的分布式共识性算法，在数据共识性的问题上，Raft 使用「强领导者」模型，即：\",\"一个集群中有且只有一个领导者；\",\"所有数据写请求，都必须由领导者处理，领导者接受后再同步给其它节点；\",\"领导者是绝对的「土皇帝」，不断地向追随者发送号令(同步日志)。 因此，在一个使用 Raft 算法的集群中，「领导者选举」是集群的第一步。\",\"一个集群的节点个数往往是「奇数」，如 3、5 等，这样就避免了选举时会发生脑裂(出现了多个领导者)的情况。\"]},\"123\":{\"h\":\"节点状态\",\"t\":[\"在 Raft 集群中，一个节点会存在如下 3 种状态：\",\"追随者(Follower)，追随领导者，接收领导者日志，并实时同步；\",\"协调者(Candidate)，选举时会触发的状态，如追随者一定时间内未收到来自领导者的心跳包，追随者会自动切换为协调者，并开始选举操作，向集群中的其它节点发送投票请求，待收到半数以上的选票时(如 3 节点集群，需收到 2 票，含自己的 1 票)，协调者升级成为领导者；\",\"领导者(Leader)，集群土皇帝，不断地向集群其它节点发号施令(心跳、日志同步)，其它节点接到领导者日志请求后成为其追随者。 因此在具体谈到 Raft 算法实现之前，我们需要先来解决这三个状态。首先我们需要对节点这个概念进行抽象，如下：\",\"// raft.go type Raft struct { mu sync.Mutex // 锁 peers []*labrpc.ClientEnd // 集群信息 persister *Persister // 持久化 me int // 当前节点 id dead int32 // 是否死亡，1 表示死亡，0 还活着 state PeerState // 节点状态 currentTerm int // 当前任期 votedFor int // 给谁投过票 leaderId int // 集群 leader id applyCh chan ApplyMsg // apply message channel } \",\"在这段代码中，Raft 结构体是对 Raft 节点的一个抽象，每一个 Raft 实例可表示一个 Raft 节点，每一个节点会有集群元数据(peers)，节点元数据(me、state、currentTerm 等)等信息。在领导者选举部分，有 3 个重要的字段需要说明：\",\"state：节点状态，当前节点处于领导者、还是追随者；\",\"votedFor：投票记录，当前节点在当前任期内给「那个」节点投过票；\",\"currentTerm：节点当前所在的任期。 「任期」是 Raft 算法中一个非常重要的概念，你可以将其理解为「逻辑时钟」，每一个节点在初始化时，状态为追随者，任期为 0，当一定时间内未收到领导者日志后，会自动成为协调者，并给自己投票，且任期+1，如下面的 becomeCandidate 函数：\",\"// state.go type PeerState string const ( Follower PeerState = \\\"follower\\\" Candidate PeerState = \\\"candidate\\\" Leader PeerState = \\\"leader\\\" ) func (rf *Raft) becomeLeader() { rf.state = Leader rf.leaderId = rf.me } func (rf *Raft) becomeCandidate() { rf.state = Candidate rf.votedFor = rf.me // vote for me rf.currentTerm += 1 } func (rf *Raft) becomeFollower(term int) { rf.state = Follower rf.votedFor = -1 rf.currentTerm = term } \",\"在这里，我们定义了 Follower、Candidate 和 Leader 三种状态，一个节点可以在这三种状态中切换，如 becomeLeader 函数，会将当前节点切换为领导者状态，并且设置 leaderId 为自己。 becomeCandidate 函数上面也谈到了，节点成为协调者后会增加任期，并给自己投票；调用 becomeFollower 函数时，节点会切换为追随者状态，且重置 votedFor 字段，追随者更新任期后，重新拥有「选票权」，可以进行投票。\",\"这里抛出 2 个问题：选举过程是如何产生的？任期在选举过程中发挥了什么作用了？下面我们来一一解答。\"]},\"124\":{\"h\":\"选举\",\"t\":[\"Raft 集群节点初始化时，会在节点内部存储集群元数据(如 peers)，节点需要通过集群元数据信息与其它节点进行沟通，而沟通的方式是 RPC 请求。\",\"选举指的是，集群中的某一个节点，在成为协调者后，不满足于自己现在状态，迫切的想要成为领导者(土皇帝)，虽然它给自己投了 1 票，但很显然 1 票是不够，它需要其它节点的选票才能成为领导者。\",\"因此协调者会与其它节点进行沟通协商(RPC 请求)，当然它暂时不会沟通别的，只会向其它节点发送投票 RPC 请求(RequestVote RPC 请求)；因此选举的过程实则就是：追随者未收到日志同步(也可理解为心跳)转变成为协调者，给自己投票后迫切地想成为领导者，并通过 RPC 请求其它节点给自己投票。\",\"翻译成代码，大致如下：\",\"// raft.go func Make(peers []*labrpc.ClientEnd, me int, persister *Persister, applyCh chan ApplyMsg) *Raft { rf := &Raft{} rf.peers = peers rf.persister = persister rf.me = me rf.votedFor = -1 rf.state = Follower rf.currentTerm = 0 rf.leaderId = -1 rf.applyCh = applyCh rf.readPersist(persister.ReadRaftState()) // start ticker goroutine to start elections go rf.ticker() return rf } \",\"Make 函数负责新建一个 Raft 节点，抛开 applyCh，readPersist 这些东西先不管，我们关注的是 state，votedFor，currentTerm 这些字段。和上面说的一致，节点初始化时为追随者状态，且拥有选票(votedFor 为-1)，并且任期为 0。 那么这个追随者是如何超时成为协调者的呢？答案在 ticker 这个函数中：\",\"// raft.go func (rf *Raft) ticker() { for rf.killed() == false { time.Sleep(getRandElectTimeout()) rf.mu.Lock() // 如果已经是 leader 了，则跳过下面逻辑 if rf.state == Leader { rf.mu.Unlock() continue } rf.becomeCandidate() var votes int32 = 1 // 自己的一票 for peerId, _ := range rf.peers { if peerId == rf.me { // 跳过自己，向其它节点发送请求 continue } go rf.sendRequestVoteToPeer(peerId, &votes) } rf.mu.Unlock() } } \",\"ticker 是由 go 关键字开启的一个死循环(loop)，即节点被创建后会一直运行，除非节点被杀死，永远不会停止。 进入循环后，节点会通过 Sleep 函数休眠一段时间，这段时间就是节点的心跳超时时间，在这段时间内，如果当前节点还未收到来自领导者的心跳请求，那么节点就会自动从追随者切换到协调者，当然由于日志暂时还未实现，因此目前 ticker 会休眠一段后，自动成为协调者，这部分将在后面一一完成。\",\"节点成为协调者后，会向集群中的其它节点发送投票 RPC 请求，即 sendRequestVoteToPeer 函数。\",\"该函数会向其它节点发送 RequestVote RPC 请求，在论文中，RequestVote 是这样定义的：\",\"图中划红线的字段暂时不需要。转化为代码如下：\",\"type RequestVoteArgs struct { Term int // 请求者任期 CandidateId int // 请求者 id } type RequestVoteReply struct { Term int // 回复者任期 VoteGranted bool // 是否投票，true 则投票 } \",\"RequestVoteArgs 是 RequestVote RPC 请求参数，RequestVoteReply 是响应结果。 请求者通过 sendRequestVote 函数向某个节点发送 RequestVote RPC 请求：\",\"func (rf *Raft) sendRequestVote(server int, args *RequestVoteArgs, reply *RequestVoteReply) bool { ok := rf.peers[server].Call(\\\"Raft.RequestVote\\\", args, reply) return ok } \",\"其它节点受到请求后，会自动调用 RequestVote 函数进行处理：\",\"func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) { rf.mu.Lock() defer rf.mu.Unlock() reply.Term = rf.currentTerm reply.VoteGranted = false if args.Term < rf.currentTerm { return } // 发现任期大的，成为 follower if args.Term > rf.currentTerm { rf.becomeFollower(args.Term) } if rf.votedFor == -1 || rf.votedFor == args.CandidateId { reply.VoteGranted = true rf.votedFor = args.CandidateId // 投票后，记得更新 votedFor } } \",\"这里，我们无需纠结这个 RPC 是如何产生的，只需要知道 sendRequestVote 发出的 RPC 请求会被 RequestVote 函数处理然后返回。 这个地方，我们再来回答刚才提出的问题：任期在选举过程中究竟有何作用了？\",\"「任期」表示节点的逻辑时钟，任期高的节点拥有更高的话语权。在 RequestVote 这个函数中，如果请求者的任期小于当前节点任期，则拒绝投票；如果请求者任期大于当前节点人气，那么当前节点立马成为追随者。\",\"「投票」建立在双方任期一致的情况下，如果当前节点未投过票(即 votedFor 为 -1)，或者已经给请求者投过票，那么仍然可以为请求者投票(VoteGranted=true)，投票后需设置 votedFor 字段为请求者 id。\",\"我们再回到 sendRequestVoteToPeer 这个函数上来，协调者通过该函数向其它节点发送投票请求，并在函数中对请求结果进行处理，如下：\",\"func (rf *Raft) sendRequestVoteToPeer(peerId int, votes *int32) { rf.mu.Lock() args := RequestVoteArgs{ Term: rf.currentTerm, CandidateId: rf.me, } reply := RequestVoteReply{} rf.mu.Unlock() ok := rf.sendRequestVote(peerId, &args, &reply) if !ok { return } rf.mu.Lock() defer rf.mu.Unlock() // 如果当前的状态不为 candidate，那么将不能接受选票，所以直接返回 if rf.state != Candidate || args.Term != rf.currentTerm { return } if reply.Term > rf.currentTerm { rf.becomeFollower(reply.Term) return } if reply.VoteGranted { atomic.AddInt32(votes, 1) curVotes := int(atomic.LoadInt32(votes)) if curVotes >= (len(rf.peers)+1)/2 { rf.becomeLeader() return } } } \",\"代码 3 ～ 7 行，请求者将自己的任期、id 信息包装为请求结构体，并通过 sendRequestVote 函数发送 RPC 请求。 代码 16 ～ 30 行，请求者拿到响应结果后，处理响应数据。首先判断节点是否为协调者，如不是则直接返回，如果在发送 RPC 过程中，节点任期发生了变化(不同任期的选票不能使用)，也直接返回；如果发现回复者任期大，那么立马成为追随者并返回；增加选票数，如果超过了半数，协调者立即成为领导者。\",\"在这里，我们也发现了一条黄金铁律：任期大的节点对任期小的拥有绝对的话语权，一旦发现任期大的节点，立马成为其追随者。\"]},\"125\":{\"h\":\"小结\",\"t\":[\"领导者选举主要工作可总结如下：\",\"三个状态，节点状态之间的转换函数；\",\"1 个 loop——ticker；\",\"1 个 RPC 请求和处理，用于投票。 另外，ticker 会一直运行，直到节点被 kill，因此集群领导者并非唯一，一旦领导者出现了宕机、网络故障等问题，其它节点都能第一时间感知，并迅速做出重新选举的反应，从而维持集群的正常运行，毕竟国不可一日无主，Raft 集群一旦失去了领导者，就无法工作。\",\"对于领导者而言，一旦当选，就必须不停的向其它节点宣示自己的地位，只要朕还在一日，尔等仍是太子。\",\"那么领导者如何向其它节点宣示自己的地位了？这就是日志同步这个模块要解决的问题。\"]},\"126\":{\"h\":\"日志同步\",\"t\":[\"日志同步是领导者独有的权利，领导者向追随者发送日志，追随者同步日志。\",\"日志同步要解决如下两个问题：\",\"领导者宣示自己的主权，追随者不可造反(再次选举)；\",\"领导者将自己的日志数据同步到追随者，达到数据备份的效果。 同样地，日志同步也需要与其它节点进行沟通，对应论文中的 AppendEntriesArgs RPC 请求，如下图所示：\",\"将其翻译为代码：\",\"// log.go type AppendEntriesArgs struct { Term int // leader 任期 LeaderId int // leader id PrevLogIndex int // leader 中上一次同步的日志索引 PrevLogTerm int // leader 中上一次同步的日志任期 Entries []LogEntry // 同步日志 LeaderCommit int // 领导者的已知已提交的最高的日志条目的索引 } type AppendEntriesReply struct { Term int // 当前任期号，以便于候选人去更新自己的任期号 Success bool // 是否同步成功，true 为成功 } \",\"在 RPC 参数有几个重要字段：\",\"PreLogIndex：领导者与节点上一次同步的日志序号；\",\"PreLogTerm：领导者与节点上一次同步的日志任期；\",\"Entries：待同步日志数据；\",\"LeaderCommit：领导者日志提交序号。 领导者与追随者之间的日志同步有一种特殊情况：Entries 为空，即无日志同步，既然没有日志需要发送，那么为什么要发送 AppendEntries 请求了？\",\"因为领导者需要宣示自己的权利，如果领导者不发送请求，那么追随者会认为领导者「死亡」了，会自发的进行下一轮选举，霸道的领导者肯定不愿意这种情况发生，因此即使日志是空的，也要发送 AppendEntries 请求，这种特殊的场景被称为「心跳」。\",\"追随者在一定时间内收到日志同步请求或者心跳，都会重置自己「选举超时时间」，因此就不会发出下一轮选举，领导者一直是安全的。\",\"既然领导者需要不断地与追随者同步日志，那么领导者如何知道追随者日志的同步情况了？\",\"Raft 节点使用 nextIndex，matchIndex 等字段来维护这些信息，如下：\",\"type Raft struct { // ....省略 state PeerState currentTerm int // 当前任期 votedFor int // 给谁投过票 leaderId int // 集群 leader id applyCh chan ApplyMsg // apply message channel // 2B + log rLog // 日志 + lastReceivedFromLeader time.Time // 上一次收到 leader 请求的时间 + nextIndex []int // 下一个待发送日志序号，leader 特有 + matchIndex []int // 已同步日志序号，leader 特有 + commitIndex int // 已提交日志序号 + lastApplied int // 已应用日志序号 } \",\"log：节点日志数据；\",\"lastReceivedFromLeader：上一次收到 leader 请求的时间；\",\"nextIndex：节点下一个待同步的日志序号；\",\"matchIndex：节点已同步的日志序号；\",\"commitIndex：已提交的日志序号；\",\"lastApplied：已应用的日志序号。\"]},\"127\":{\"h\":\"日志\",\"t\":[\"Raft 集群中的节点通过日志来保存数据，且日志是只可追加的(Append-only)，如下图所示：\",\"以 KV 为例，日志可以看作是一个不断增加的数组，从 0 开始，序号为 0 的日志内容为 x=1，即将 x 的值设为 1；由于旧日志不可修改，因此如果需要修改 x，那么就只能通过追加覆盖的方式，即序号为 2 的日志 x=5。\",\"那么日志「已提交」与「已应用」有什么区别了？\",\"仍以上图为例，假设日志的提交序号为 2，即 x=5 已提交，但是日志的应用序号为 1，即 x=5 未应用，但已提交，因此实际可见的数据其实是这样的：\",\"x 值为 1，而 y 为 3，而一旦日志 2 被应用后，x 值就会被更改(日志数据不变，x 可见数据会变)，如下：\",\"虽然日志数据没有发生改变，但是 x 可见值却发生了改变，可以将日志序号理解为版本，新版本会覆盖旧版本的值。\"]},\"128\":{\"h\":\"状态机\",\"t\":[\"已提交的日志被应用后才会生效，那么数据的可见性由何种机制来保证了？Raft 使用了状态机来保证相同日志被应用不同节点后，数据是一致的。如下图所示：\",\"状态机保证了不同节点在被应用了相同日志后，数据的可见性是一致的，这样就能保证集群数据的一致性，这也是 Raft 算法的根本目的所在。\",\"继续来看 log 这个字段，Raft 节点将所有日志以追加的方式保存到了 log 中，log 本质上是一个数组(切片)，如下：\",\"// rLog.go type LogEntry struct { Term int // 任期 Command interface{} // 命令 } type rLog struct { Entries []LogEntry } func defaultRLog() rLog { return rLog{ Entries: []LogEntry{ { Term: 0, Command: nil, }, }, } } func (l *rLog) entryAt(index int) LogEntry { return l.Entries[index-l.first()] } func (l *rLog) append(entry ...LogEntry) { l.Entries = append(l.Entries, entry...) } func (l *rLog) last() int { if len(l.Entries) == 0 { return 0 } return len(l.Entries) - 1 } func (l *rLog) lastTerm() int { return l.Entries[l.last()].Term } func (l *rLog) first() int { return 0 } func (l *rLog) firstTerm() int { return l.Entries[l.first()].Term } func (l *rLog) size() int { return len(l.Entries) } \",\"每一条日志都可被抽象为 LogEntry，其有两个字段：\",\"Term：日志任期；\",\"Command：日志内容，任意类型，根据具体业务来实现。 rLog 结构体用来保存节点日志，其核心字段 Entries 就是用来存储日志内容的切片。我们顺便也给 rLog 定义了一系列函数方便访问日志数据(避免每次在业务中对切片进行操作)。\",\"注意：defaultRLog 函数返回一个默认的 rLog，根据 Raft 论文中的阐述，日志切片的第一个作为占位使用，因此在初始化时，我们推入了一个 Command 为 nil 的日志。\"]},\"129\":{\"h\":\"同步\",\"t\":[\"日志同步是领导者独有的功能，因此在成为领导者后，第一时间就是初始化 nextIndex、matchIndex 并且开始日志同步，如下：\",\"func (rf *Raft) becomeLeader() { rf.state = Leader rf.leaderId = rf.me + l := len(rf.peers) + rf.nextIndex = make([]int, l) + rf.matchIndex = make([]int, l) + for i := 0; i < l; i++ { + // nextIndex[0] 表示 0 号 peer + rf.nextIndex[i] = rf.log.last() + 1 // 初始值为领导者最后的日志序号+1 + rf.matchIndex[i] = 0 // 初始值为 0，单调递增 + } + go rf.ping() } \",\"这里，我们就能发现 nextIndex、matchIndex 的含义了，成为领导者后，领导者并不知道其它节点的日志情况，因此与其它节点需要同步那么日志，领导者并不知道，因此他选择了「试」。 nextIndex、macthIndex 的长度都是节点个数，如 3，其中 nextIndex[0]、matchIndex[0] 分别用来保存节点 0 的下一个待同步日志序号、已同步日志序号。\",\"nextIndex 初始化值为 log.last + 1，即领导者最后一个日志序号+1，因此其实这个日志序号是不存在的，显然领导者也不指望一次能够同步成功，而是拿出一个值来试探。\",\"matchIndex 初始化值为 0，这个很好理解，因为他还未与任何节点同步成功过，所以直接为 0。\",\"最后领导者通过 ping 函数来周期性地向其它节点同步日志(或心跳)，如下：\",\"func (rf *Raft) ping() { for rf.killed() == false { rf.mu.Lock() if rf.state != Leader { rf.mu.Unlock() // 如果不是 leader，直接退出 loop return } for peerId, _ := range rf.peers { if peerId == rf.me { // 更新自己的 nextIndex 和 matchIndex rf.nextIndex[peerId] = rf.log.size() rf.matchIndex[peerId] = rf.nextIndex[peerId] - 1 continue } go rf.sendAppendEntriesToPeer(peerId) } rf.mu.Unlock() time.Sleep(heartbeatInterval) } } \",\"和 ticker 一样，ping 同样是一个死循环，但是领导者独有的。一旦发现当前状态不为 leader，立马退出循环(代码第 4 行)，领导者通过 sendAppendEntriesToPeer 函数向其它所有节点(自己除外)发送 AppendEntries RPC 请求。 与 RequestVote 类似，调用 sendAppendEntries 函数发送请求：\",\"func (rf *Raft) sendAppendEntries(server int, args *AppendEntriesArgs, reply *AppendEntriesReply) bool { ok := rf.peers[server].Call(\\\"Raft.AppendEntries\\\", args, reply) return ok } \",\"请求达到节点后，会自动调用 AppendEntries 函数处理请求：\",\"func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) { rf.mu.Lock() defer rf.mu.Unlock() reply.Term = rf.currentTerm reply.Success = false if args.Term < rf.currentTerm { return } // 如果你大，那就成为 follower if args.Term > rf.currentTerm { rf.becomeFollower(args.Term) rf.leaderId = args.LeaderId } if rf.state != Follower { rf.becomeFollower(args.Term) } rf.leaderId = args.LeaderId rf.lastReceivedFromLeader = time.Now() logSize := rf.log.size() // 日志、任期冲突直接返回 if args.PrevLogIndex >= logSize || rf.log.entryAt(args.PrevLogIndex).Term != args.PrevLogTerm { return } entriesSize := len(args.Entries) insertIndex := args.PrevLogIndex + 1 entriesIndex := 0 // 遍历日志，找到冲突日志 for { // 超过了长度 break if insertIndex >= logSize || entriesIndex >= entriesSize { break } // 日志冲突，break if rf.log.entryAt(insertIndex).Term != args.Entries[entriesIndex].Term { break } insertIndex++ entriesIndex++ } // 追加日志中尚未存在的任何新条目 if entriesIndex < entriesSize { // [0,insertIndex) 是之前已经同步好的日志 rf.log.subTo(insertIndex - rf.log.first()) rf.log.append(args.Entries[entriesIndex:]...) } // 取两者的最小值 if args.LeaderCommit > rf.commitIndex { rf.commitIndex = minInt(args.LeaderCommit, rf.log.last()) } reply.Success = true } \",\"AppendEntries 处理请求是比较复杂的，首先代码 7 ～ 14 行，二者几乎一致，如果任期小则拒绝，任期大，则称为其追随者。 代码 15 ～ 19 行，如果收到 AppendEntries 请求，当前节点必须立马成为追随者(土皇帝来了！)，并且更新 leaderId 和 lastReceivedFromLeader，即更新超时心跳时间。\",\"代码 22 行，如果日志完全冲突，上一个同步日志序号超过了当前节点的日志大小，或者任期不一致，那么直接返回 false。\",\"代码 25~46 行，解决日志部分冲突的问题，如果集群发生了领导者更换，新领导者的日志与现有节点日志有很多冲突，那么需要依次遍历日志，找到不冲突的起始序号，删除冲突日志，然后继续同步(由于 Raft 的特性，如果后面的日志是匹配的，那么前面的日志一定是匹配的)。\",\"代码 48~49 行，根据领导者日志提交序号来更新日志提交序号，日志提交序号 = min(leaderCommit, last)。\",\"最后返回 true 给领导者，同步成功。\",\"领导者收到这个响应后，如何处理了：\",\"func (rf *Raft) sendAppendEntriesToPeer(peerId int) { rf.mu.Lock() nextIndex := rf.nextIndex[peerId] prevLogTerm := 0 prevLogIndex := 0 entries := make([]LogEntry, 0) // 可能会存在 nextIndex 超过 rf.log 的情况 if nextIndex <= rf.log.size() { prevLogIndex = nextIndex - 1 } prevLogTerm = rf.log.entryAt(prevLogIndex).Term entries = rf.log.getEntries(nextIndex-rf.log.first(), rf.log.size()) args := AppendEntriesArgs{ Term: rf.currentTerm, LeaderId: rf.me, PrevLogIndex: prevLogIndex, PrevLogTerm: prevLogTerm, Entries: entries, LeaderCommit: rf.commitIndex, } reply := AppendEntriesReply{} rf.mu.Unlock() // 发送 RPC 的时候不要加锁 ok := rf.sendAppendEntries(peerId, &args, &reply) if !ok { return } rf.mu.Lock() defer rf.mu.Unlock() if rf.state != Leader || args.Term != rf.currentTerm { return } if reply.Term > rf.currentTerm { rf.becomeFollower(reply.Term) rf.leaderId = peerId return } if reply.Success { // 1. 更新 matchIndex 和 nextIndex rf.matchIndex[peerId] = prevLogIndex + len(args.Entries) rf.nextIndex[peerId] = rf.matchIndex[peerId] + 1 // 2. 计算更新 commitIndex newCommitIndex := getMajorIndex(rf.matchIndex) if newCommitIndex > rf.commitIndex { rf.commitIndex = newCommitIndex } } else { // 同步失败，回退一步 rf.nextIndex[peerId] -= 1 if rf.nextIndex[peerId] < 1 { rf.nextIndex[peerId] = 1 } } } \",\"回到 sendAppendEntriesToPeer 函数中来，领导者通过该函数向其它节点发送同步日志，首先领导者通过 nextIndex 获取发送节点下一个要同步的日志序号，将其-1 就是上一个已同步的日志序号。 然后将这些信息包装为参数发送给节点，收到节点响应后，根据结果来处理。\",\"代码 31 行，如果不再是领导者、前后任期不一致，直接返回。\",\"代码 34 行，黄金铁律，发现任期大的，立马成为追随者。\",\"代码 41 ～ 47 行，如果同步成功则更新该节点的 matchIndex 和 nextIndex，并且根据 matchIndex 来推进 commitIndex；这里原理很简单，领导者的 commitIndex 必须建立在集群的大部分节点均已匹配的基础上，因此 getMajorIndex 实则取的是 matchIndex 的中位数，这个地方的序号已经被大部分节点同步到了，因此就可以用来更新领导者的 commitIndex。\",\"代码 50 ～ 53 行，如果同步失败了，更新 nextIndex，这个地方比较粗暴，直接回退-1，不断的试探，直至试出匹配值(待优化)。\",\"在 ping 函数中，领导者正是通过不间断的日志同步，冲突则重新同步的方式来与其它节点同步数据，若所有节点日志均已同步完成，那么 AppendEntries 被视为心跳，控制追随者勿发起新的选举。\"]},\"130\":{\"h\":\"完善选举\",\"t\":[\"在领导者选举中，我们提到是否投出选票还与日志有关，那么有何关联了？\",\"实则也简单，为了保证日志「更加完善」的节点能够当选领导者，因此选票会向日志完善的节点倾斜，这被称为 upToDate 条件。\",\"如下：\",\"type RequestVoteArgs struct { // ... // 2B + LastLogTerm int + LastLogIndex int } func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) { // Your code here (2A, 2B). // 1. 如果 term < currentTerm 返回 false （5.2 节） // 2. 如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他（5.2 节，5.4 节） rf.mu.Lock() defer rf.mu.Unlock() // 省略.... + upToDate := false + // 如果两份日志最后的条目的任期号不同，那么任期号大的日志新 + if args.LastLogTerm > rf.log.lastTerm() { + upToDate = true + } + // 如果两份日志最后的条目任期号相同，那么日志比较长的那个就新 + if rf.log.lastTerm() == args.LastLogTerm && args.LastLogIndex >= rf.log.last() { + upToDate = true + } + if (rf.votedFor == -1 || rf.votedFor == args.CandidateId) && upToDate { + reply.VoteGranted = true + rf.votedFor = args.CandidateId // 投票后，记得更新 votedFor + } } func (rf *Raft) sendRequestVoteToPeer(peerId int, votes *int32) { rf.mu.Lock() args := RequestVoteArgs{ Term: rf.currentTerm, CandidateId: rf.me, + LastLogIndex: rf.log.last(), + LastLogTerm: rf.log.lastTerm(), } // 省略.... } \",\"请求者在发送 RequestVote 请求时，会附带上自己日志的最后序号和任期；回复者接收到这两条信息后，会将其与自己的任期和日志进行比较，来看看双方谁的日志比较完整。 首先比较任期，任期大的更新话语权，如果请求者的最后任期大，那么 upToDate 为 true，如果任期相同，但请求者的日志序号大或者相等，那么 upToDate 为 true，只有当 upToDate 为 true 时，当前节点才能投出选票。\"]},\"131\":{\"h\":\"日志应用\",\"t\":[\"在 Raft 节点中还有 lastApplied 这个重要的字段，维护着当前节点的日志应用序号。在日志同步的过程中，commitIndex 会不断的更新，但 lastApplied 似乎一直没有变过，因为我们把它遗忘了，按照 Raft 论文的说话，一旦发现 commitIndex 大于 lastApplied，应该立马将可应用的日志应用到状态机中。\",\"那么如何应用了？答案就是 applyCh 这个字段。\",\"Raft 节点本身是没有状态机实现的，状态机应该由 Raft 的上层应用来实现，因此我们不会谈论如何实现状态机，只需将日志发送给 applyCh 这个通道即可。如下：\",\"func (rf *Raft) applyLog() { for rf.killed() == false { time.Sleep(applyInterval) rf.mu.Lock() msgs := make([]ApplyMsg, 0) for rf.commitIndex > rf.lastApplied { rf.lastApplied++ // 上一个应用的++ // 超过了则回退，并 break if rf.lastApplied >= rf.log.size() { rf.lastApplied-- break } msg := ApplyMsg{ CommandValid: true, Command: rf.log.entryAt(rf.lastApplied).Command, CommandIndex: rf.lastApplied, } msgs = append(msgs, msg) } rf.mu.Unlock() for _, msg := range msgs { rf.applyCh <- msg } } } \",\"applyLog 是 Raft 实现中的第三个死循环，且每个节点都有。主要工作就是周期性的检查 commitIndex 与 lastApplied，一旦发现 commitIndex 大于 lastApplied，立马将 lastApplied 值推到与 commitIndex 一致。 ApplyMsg 是应用日志的结构体定义，如下：\",\"type ApplyMsg struct { CommandValid bool // 是否有效，无效则不应用 Command interface{} // 日志命令 CommandIndex int // 日志序号 } \",\"ApplyMsg 会被发送到 applyCh 通道中，上层服务接收到后，将其应用到状态机中。 applyLog 同样是通过 go 关键字开启的一个协程，如下：\",\"func Make(peers []*labrpc.ClientEnd, me int, persister *Persister, applyCh chan ApplyMsg) *Raft { rf := &Raft{} // 省略... rf.applyCh = applyCh // 2B + rf.log = defaultRLog() + rf.lastReceivedFromLeader = time.Now() + rf.commitIndex = 0 + rf.lastApplied = 0 // initialize from state persisted before a crash rf.readPersist(persister.ReadRaftState()) // start ticker goroutine to start elections go rf.ticker() + go rf.applyLog() return rf } \"]},\"132\":{\"h\":\"小结\",\"t\":[\"日志同步主要工作可总结如下：\",\"2 个 loop，ping 领导者独有，applyLog 所有节点均有，推进日志应用；\",\"1 个 RPC 请求和处理，用于日志同步；\",\"完善选举，加入日志完整度判断。 到此，选举、日志同步均已完成，那么如果集群中的节点发生了宕机，已经同步好的日志都丢了怎么办？如何解决这个问题，这就是持久化模块的功能了。\"]},\"133\":{\"h\":\"持久化\",\"t\":[\"数据持久化是 Raft 四大模块中最简单的一部分。在 Raft 论文中指出，需要持久化的字段只有三个：\",\"分别是 currentTerm(当前任期)，votedFor(给谁投过票)，log(日志数据)。数据落盘的编码方式有很多种，这里我们选择比较简单的 gob 编码，代码实现如下：\",\"// 将数据持久化到磁盘 func (rf *Raft) persist() { w := new(bytes.Buffer) e := labgob.NewEncoder(w) e.Encode(rf.currentTerm) e.Encode(rf.votedFor) e.Encode(rf.log) data := w.Bytes() rf.persister.SaveRaftState(data) } // 从磁盘中读取数据并解码 func (rf *Raft) readPersist(data []byte) { if data == nil || len(data) < 1 { return } r := bytes.NewBuffer(data) d := labgob.NewDecoder(r) var ( currentTerm int votedFor int log rLog ) if d.Decode(&currentTerm) != nil || d.Decode(&votedFor) != nil || d.Decode(&log) != nil { DPrintf(\\\"decode persisted state err.\\\") } else { rf.currentTerm = currentTerm rf.votedFor = votedFor rf.log = log } } \",\"persist 函数负责将当前 Raft 节点中需要持久化的字段保存至磁盘中，而 readPersist 函数负责从磁盘中读取数据并反序列化为 currentTerm、votedFor 和 log 三个字段。 对于 readPersist 函数，在 Raft 节点创建的时候调用它一次，如下：\",\"func Make(peers []*labrpc.ClientEnd, me int, persister *Persister, applyCh chan ApplyMsg) *Raft { rf := &Raft{} // 省略 // initialize from state persisted before a crash rf.readPersist(persister.ReadRaftState()) // 省略 return rf } \",\"而 persist 函数则稍微复杂一些，不过只需记住一条黄金铁律即可：currentTerm、votedFor 和 log 任何一个字段只要发生了更改，立马调用 persist 函数。 在投票模块中，节点状态改变、投出选票等操作均会引起这三个字段的改变，在改变后加上 persist 函数即可：\",\"func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) { // 省略 // 发现任期大的，成为 follower if args.Term > rf.currentTerm { rf.becomeFollower(args.Term) + rf.persist() } // 省略 if (rf.votedFor == -1 || rf.votedFor == args.CandidateId) && upToDate { reply.VoteGranted = true rf.votedFor = args.CandidateId // 投票后，记得更新 votedFor + rf.persist() } } func (rf *Raft) sendRequestVoteToPeer(peerId int, votes *int32) { // 省略 if reply.Term > rf.currentTerm { rf.becomeFollower(reply.Term) + rf.persist() return } // 省略 } \",\"在 ticker 函数中，如果心跳超时节点会自发成为协调者，任期和选票均会发生改变，因此：\",\"func (rf *Raft) ticker() { for rf.killed() == false { // 省略 rf.becomeCandidate() + rf.persist() // 省略 } } \",\"同样地，在日志同步模块也会引发日志、状态的改变：\",\"func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) { // 省略 // 如果你大，那就成为 follower if args.Term > rf.currentTerm { rf.becomeFollower(args.Term) rf.leaderId = args.LeaderId + rf.persist() } if rf.state != Follower { rf.becomeFollower(args.Term) + rf.persist() } // 省略 // 追加日志中尚未存在的任何新条目 if entriesIndex < entriesSize { // [0,insertIndex) 是之前已经同步好的日志 rf.log.subTo(insertIndex - rf.log.first()) rf.log.append(args.Entries[entriesIndex:]...) + rf.persist() } reply.Success = true } func (rf *Raft) sendAppendEntriesToPeer(peerId int) { // 省略 if reply.Term > rf.currentTerm { rf.becomeFollower(reply.Term) rf.leaderId = peerId + rf.persist() return } // 省略 } \",\"对于 persist 的调用时机其实是很容易把握的，只需记住任何引起该三个字段发生改变的操作都必须紧接着一次 persist 函数即可。\"]},\"134\":{\"h\":\"优化冲突同步\",\"t\":[\"在日志同步模块中，我们提到：如果同步失败了，更新 nextIndex，这个地方比较粗暴，直接回退 1，不断的试探，直至试出匹配值(待优化)。\",\"每次 -1 的试探是非常低效了，试想一下，如果二者日志相差几百，那么就得几百次试探，集群可能需要很久才都达到一致。因此提高同步效率，我们需要优化同步冲突问题。\",\"思路也很简单，在同步发生冲突后，不再靠领导者一点点试探，而是追随者主动告诉领导者冲突的日志序号和任期，下次领导者直接通过冲突序号、任期再次同步即可。\",\"为此，我们需要给 Reply 增加两个字段分别表示冲突任期和序号：\",\"type AppendEntriesReply struct { + ConflictTerm int // 日志冲突任期 + ConflictIndex int // 日志冲突序号 Term int // 当前任期号，以便于候选人去更新自己的任期号 Success bool } \",\"在 AppendEntries 处理中，如果日志发生了完全冲突，需要遍历日志找到冲突任期、序号：\",\"func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) { // 省略 // 日志、任期冲突直接返回 + if args.PrevLogIndex >= logSize { + reply.ConflictIndex = rf.log.size() + reply.ConflictTerm = -1 + return + } + if rf.log.entryAt(args.PrevLogIndex).Term != args.PrevLogTerm { + reply.ConflictTerm = rf.log.entryAt(args.PrevLogIndex).Term + for i := rf.log.first(); i < rf.log.size(); i++ { + if rf.log.entryAt(i).Term == reply.ConflictTerm { + reply.ConflictIndex = i + break + } + } + return + } // 省略 } \",\"代码第 4 ～ 6 行，如果领导者上一次同步日志序号大于当前节点的日志大小，那么冲突序号就是日志大小，冲突任期为 -1。 代码 9 ～ 16 行，如果上一次同步序号仍在日志内，但是当前节点在该序号的日志任期与领导者任期不同，那么设置冲突任期为当前节点序号的任期，并遍历日志找到第一个有任期冲突的日志序号，并设置为 ConflictIndex。\",\"有了日志冲突任期和序号后，领导者收到同步失败后，就能立马对下一次同步做出调整：\",\"func (rf *Raft) sendAppendEntriesToPeer(peerId int) { // 省略 if reply.Success { // 1. 更新 matchIndex 和 nextIndex rf.matchIndex[peerId] = prevLogIndex + len(args.Entries) rf.nextIndex[peerId] = rf.matchIndex[peerId] + 1 // 2. 计算更新 commitIndex newCommitIndex := getMajorIndex(rf.matchIndex) - if newCommitIndex > rf.commitIndex { + if newCommitIndex > rf.commitIndex && rf.log.entryAt(newCommitIndex).Term == rf.currentTerm { rf.commitIndex = newCommitIndex } } else { + if reply.ConflictTerm == -1 { + rf.nextIndex[peerId] = reply.ConflictIndex + } else { + // Upon receiving a conflict response, the leader should first search its log for conflictTerm. + // If it finds an entry in its log with that term, + // it should set nextIndex to be the one beyond the index of the last entry in that term in its log. + lastIndexOfTerm := -1 + for i := rf.log.last(); i >= rf.log.first(); i-- { + if rf.log.entryAt(i).Term == reply.ConflictTerm { + lastIndexOfTerm = i + break + } + } + // If it does not find an entry with that term, it should set nextIndex = conflictIndex. + if lastIndexOfTerm < 0 { + rf.nextIndex[peerId] = reply.ConflictIndex + } else { + // 如果找到了冲突的任期，那么 +1 就是下一个需要同步的 + rf.nextIndex[peerId] = lastIndexOfTerm + 1 + } + } } } \",\"代码 14 ～ 15 行，如果冲突任期为 -1，证明日志任期无问题，因此我们只需更新冲突序号。 代码 20 ～ 32 行，如果冲突任期不为-1，那么从日志尾部向头部遍历，找到冲突任期所在的最后一个日志序号 A，然后判断该序号是否小于 0，若小于 0，则表示找不到该冲突任期的序号，因此下一次同步序号仍然为冲突序号，否则下一次同步序号为 A+1。\",\"另外，你是否发现了代码 9 ～ 10 行也发生了改变，对于 commitIndex 的更新，我们新增了一个判断条件：新的提交日志序号的任期必须与节点当前任期一致。\",\"为什么要加上这个条件了？在论文 Figure 8 中有其说明，主要是为了保证领导者只能提交自己任期的日志，不能提交其它任期日志，从而保证原来任期的日志不会被覆盖。具体可 参考 。\"]},\"135\":{\"h\":\"小结\",\"t\":[\"数据持久化是 Raft 中最简单的一个模块，只需掌握持久化时机，细心一点就能完成。\",\"解决了数据持久化和日志冲突问题后，我们再来引入一个新的问题，日志只能以追加方式进行操作，那么如果某一条数据被修改了很多次，那么日志中存在了该数据的多个版本，如果数据量庞大，那么就会造成很大的空间浪费，相应地，对于日志持久化也会带来很大的性能影响，那么如何解决这个问题呢？答案就是快照。\"]},\"136\":{\"h\":\"快照\",\"t\":[\"节点是无法容忍日志数据无限增加的。为了解决这个问题，Raft 引入了快照机制，例如，一个 Raft 节点当前日志序号范围是 [0,100)，对范围为 [0,50] 日志进行快照后，日志范围就变成为[51,100)。如下图：\",\"x，y 值有多条日志，但实际上大部分日志都是可被删除的，因此快照机制直接将 1 ～ 5 号日志融合，合并成一个快照块。\",\"快照块的存储方式与日志不同，主要分为三个部分：\",\"lastIncludeIndex，快照块所包含的最后一个日志序号，即图中的 5；\",\"lastIncludeTerm，快照块所包含的最后一个日志任期，即图中的 3；\",\"state，状态机数据，由上层应用来处理，Raft 节点不做处理。 为什么我们无需保存快照块的第一个日志序号呢？快照只会从头开始，不会从日志切片中间截断，因此只需保存最后一个日志序号。\",\"注意，在快照后，日志切片会发生截断，日志切片序号与日志序号会有不兼容问题，如下：\",\"日志经过快照后，切片序号仍然是 1、2、3(0 号作为占位，无实际意义)，但是日志序号却是 11、12、13，因此如果再使用日志序号来从日志切片中获取日志，需有一个转换操作，这个操作也很简单：\",\"切片序号 = 日志序号 - lastIncludeIndex。 因此，我们需要重构 rLog 这个结构体和其方法：\",\"type rLog struct { Entries []LogEntry + LastIncludedIndex int + LastIncludedTerm int } func defaultRLog() rLog { return rLog{ Entries: []LogEntry{ { Term: 0, Command: nil, }, }, + LastIncludedIndex: 0, + LastIncludedTerm: 0, } } func (l *rLog) entryAt(index int) LogEntry { + if index < l.LastIncludedIndex || index > l.LastIncludedIndex+len(l.Entries) { + panic(fmt.Sprintf(\\\"lastIncludeIndex: %d, but index: %d is invalid\\\", l.LastIncludedIndex, index)) + } + return l.Entries[index-l.LastIncludedIndex] } // 最后序号 func (l *rLog) last() int { if len(l.Entries) == 0 { return 0 } + return len(l.Entries) + l.LastIncludedIndex - 1 } // 最后任期 func (l *rLog) lastTerm() int { + return l.Entries[l.last()-l.LastIncludedIndex].Term } // 第一个序号 func (l *rLog) first() int { + return l.LastIncludedIndex } // 日志长度 func (l *rLog) size() int { + return len(l.Entries) + l.LastIncludedIndex } \",\"rLog 新增了 LastIncludedIndex 和 LastIncludedTerm 两个字段，分别用于表示当前节点最后一个快照块的 lastIncludedIndex、lastIncludedTerm 值。 另外，在 entryAt 函数中，读日志需要将日志序号减去 LastIncludedIndex 值，第一个日志序号应该是 LastIncludedIndex 值，即 first 函数，size 函数也需要加上 LastIncludedIndex 后才能得到当前所有日志的总大小。\",\"同时，Raft 节点需要新增一个 snapshopt 字段用来保存快照数据，如下：\",\"type Raft struct { // 省略 + snapshot []byte } func Make(peers []*labrpc.ClientEnd, me int, persister *Persister, applyCh chan ApplyMsg) *Raft { rf := &Raft{} // 省略 rf.readPersist(persister.ReadRaftState()) + rf.snapshot = persister.ReadSnapshot() + rf.commitIndex = rf.log.LastIncludedIndex + rf.lastApplied = rf.log.LastIncludedIndex // 省略 return rf } \",\"Raft 在新建时，还需从磁盘中读取持久化的快照数据，且 commitIndex、lastApplied 的初始值不再是 0，而是 LastIncludedIndex。 现在，我们来解决最后两个问题：何时快照？快照如何执行？\",\"首先第 1 个问题：何时快照？\",\"上层应用发送快照数据给 Raft 实例；\",\"领导者发送快照 RPC 请求给追随者。 对于第 1 点，前面我们谈到，状态机在上层应用中，因此上层应用知道状态机数据以及日志应用情况，当上层应用觉得日志序号过大(或者其它触发情况)，就会将状态机数据、日志应用号通过 Snapshot 函数发送给 Raft 实例，如下：\",\"func (rf *Raft) Snapshot(index int, snapshot []byte) { rf.mu.Lock() defer rf.mu.Unlock() // 拒绝快照过的，也拒绝还未提交的 if index <= rf.log.LastIncludedIndex || index > rf.commitIndex { return } rf.log.Entries = append([]LogEntry{{Term: 0, Command: nil}}, rf.log.Entries[index-rf.log.LastIncludedIndex+1:]...) rf.log.LastIncludedIndex = index rf.log.LastIncludedTerm = rf.log.entryAt(index).Term rf.snapshot = snapshot rf.persistStateAndSnapshot(snapshot) } \",\"Snapshot 函数接受 index，snapshot 两个参数，snapshot 为快照数据，index 是快照数据中最后一个日志序号。 代码第 5 行，判断 index 与 commitIndex、lastIncludeIndex 之间的关系，如果 index 大于 commitIndex，证明快照数据中的日志，当前节点还未提交，因此无法快照；如果 index 小于等于 lastIncludeIndex 证明上一次快照已经包含了本次快照数据，所以拒绝。\",\"代码 8~12 行，接受快照数据，并持久化快照，然后更新 LastIncludedIndex，LastIncludedTerm，并切截断日志切片，将已快照部分日志从切片中删除。\",\"任何一个节点都可由上层应用通过 Snapshot 函数调用来执行快照。\",\"如果一个新加入集群的追随者，其日志大幅度落后领导者，如果仅靠日志同步请求来，那么是不够快的(还得一个一个日志的应用)，这个时候领导者可以选择将快照发给追随者，追随者直接使用快照就能迅速与其它节点保持数据一致。\",\"因此对于领导者，还有另外一个 InstallSnapshot RPC 请求，参数与响应定义如下：\",\"type InstallSnapshotArgs struct { Term int LeaderId int LastIncludedIndex int LastIncludedTerm int Data []byte } type InstallSnapshotReply struct { Term int } \",\"领导者发送 RPC 时，需携带本次快照请求的快照数据、LastIncludedIndex、LastIncludedTerm 以及任期，而追随者只需回复自己的任期即可，因此对于追随者而言即使快照请求失败也不会有其它影响，而任期代表着话语权，这与其它 RPC 请求一样。 与 AppendEntries 类似，领导者通过 sendInstallSnapshot 函数发送快照请求，RPC 达到时会调用 InstallSnapshot 函数进行处理：\",\"// peer 接受 leader InstallSnapshot 请求 func (rf *Raft) InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) { rf.mu.Lock() defer rf.mu.Unlock() reply.Term = rf.currentTerm if args.Term < rf.currentTerm { return } // Send the entire snapshot in a single InstallSnapshot RPC. // Don't implement Figure 13's offset mechanism for splitting up the snapshot. if args.Term > rf.currentTerm { rf.becomeFollower(args.Term) rf.persist() } if rf.state != Follower { rf.becomeFollower(args.Term) rf.persist() } rf.leaderId = args.LeaderId rf.lastReceivedFromLeader = time.Now() // 拒绝，如果你的小，证明我已经快照过了，无需再次快照 if args.LastIncludedIndex <= rf.log.LastIncludedIndex { return } msg := ApplyMsg{ SnapshotValid: true, Snapshot: args.Data, SnapshotTerm: args.LastIncludedTerm, SnapshotIndex: args.LastIncludedIndex, } go func() { // 应用快照 msg rf.applyCh <- msg }() } // 发送 InstallSnapshot func (rf *Raft) sendInstallSnapshot(server int, args *InstallSnapshotArgs, reply *InstallSnapshotReply) bool { ok := rf.peers[server].Call(\\\"Raft.InstallSnapshot\\\", args, reply) return ok } \",\"代码 3 ～ 20 行，与 AppendEntries 几乎一致，判断任期是否需要成为追随者，刷新 leaderId 和接收时间。 代码第 22 行，判断当前快照的 LastIncludedIndex 与当前节点的 LastIncludedIndex 之间的大小，如果小于等于，证明快照数据已经存在，直接拒绝即可。\",\"代码 25 ～ 34 行，将快照数据封装到 ApplyMsg 中，并通过 applyCh 发送给上层应用。\",\"和日志应用一样，快照应用也是通过发送 ApplyMsg，ApplyMsg 结构体中增加了快照相关的字段：\",\"type ApplyMsg struct { CommandValid bool Command interface{} CommandIndex int // 2D + SnapshotValid bool + Snapshot []byte + SnapshotTerm int + SnapshotIndex int } \",\"当 CommandValid 为 true 时，应用的是日志，SnapshotValid 为 true 时，应用的是快照。 领导者得到快照响应后做如下处理：\",\"// sendInstallSnapshotToPeer 向其它 peer 发送快照请求 func (rf *Raft) sendInstallSnapshotToPeer(peerId int) { rf.mu.Lock() args := InstallSnapshotArgs{ Term: rf.currentTerm, LeaderId: rf.me, LastIncludedIndex: rf.log.LastIncludedIndex, LastIncludedTerm: rf.log.LastIncludedTerm, Data: rf.snapshot, } reply := InstallSnapshotReply{} rf.mu.Unlock() ok := rf.sendInstallSnapshot(peerId, &args, &reply) if !ok { return } rf.mu.Lock() defer rf.mu.Unlock() // 如果当前的状态不为 leader，那么将不能接受 if rf.state != Leader || args.Term != rf.currentTerm { return } if reply.Term > rf.currentTerm { rf.becomeFollower(reply.Term) // 你的任期大，我成为你的追随者 rf.leaderId = peerId rf.persist() return } // 注意，快照和日志同步一样，需要更新 matchIndex 和 nextIndex // 发送完快照后，更新了 matchIndex 和 nextIndex，因此在快照期间的日志同步将需要重新来 rf.matchIndex[peerId] = args.LastIncludedIndex rf.nextIndex[peerId] = args.LastIncludedIndex + 1 } \",\"代码 20~29 行，与 AppendEntries 一致，判断任期与状态。 代码 32 ～ 33 行，快照后更新 matchIndex、nextIndex。\",\"领导者在发现某个节点同步日志序号落后 LastIncludedIndex 的情况下就会决定发送快照，如下：\",\"func (rf *Raft) ping() { for rf.killed() == false { // 省略 for peerId, _ := range rf.peers { // 省略 // 当 leader 发现一个 follower 的 nextIndex[follower] - 1, 即 prevLogIndex // 小于 leader 节点的快照时刻时，就会通过 RPC 调用发快照过去 + prevLogIndex := rf.nextIndex[peerId] - 1 + if prevLogIndex < rf.log.LastIncludedIndex { + go rf.sendInstallSnapshotToPeer(peerId) + } else { + go rf.sendAppendEntriesToPeer(peerId) + } } // 省略 } } \",\"第 2 个问题，快照如何执行？\",\"上层应用通过 Snapshot 函数来执行快照；\",\"上层应用通过 CondInstallSnapshot 函数来执行快照。 你应该也发现了，追随者收到快照请求后，并没有立即更新 snapshot、log 等数据，而是将其包装为了 ApplyMsg 发送给了上层应用。\",\"那是因为如果 Raft 实例单独应用了快照，而上层应用不知道，那么就会造成二者的数据不统一。收到 ApplyMsg 后，上层应用会调用 CondInstallSnapshot 函数来真正的应用快照，如下：\",\"func (rf *Raft) CondInstallSnapshot(lastIncludedTerm int, lastIncludedIndex int, snapshot []byte) bool { rf.mu.Lock() defer rf.mu.Unlock() // 已快照过了，拒绝 if lastIncludedIndex <= rf.commitIndex { return false } // 快照后的处理工作 defer func() { rf.log.LastIncludedIndex = lastIncludedIndex rf.log.LastIncludedTerm = lastIncludedTerm rf.snapshot = snapshot rf.commitIndex = lastIncludedIndex rf.lastApplied = lastIncludedIndex rf.persistStateAndSnapshot(snapshot) // 持久化快照 }() // 删除掉 lastIncludedIndex 之前的日志记录 if lastIncludedIndex <= rf.log.last() && rf.log.entryAt(lastIncludedIndex).Term == lastIncludedTerm { // [rf.log.LastIncludedIndex, lastIncludedIndex) 是当前 snapshot 中的日志数据，所以应该删除 // 前面需要一个占位 rf.log.Entries = append([]LogEntry{{Term: 0, Command: nil}}, rf.log.Entries[lastIncludedIndex-rf.log.LastIncludedIndex+1:]...) return true } // 快照，删除所有 log entries rf.log.Entries = []LogEntry{{Term: 0, Command: nil}} return true } \",\"和 Snapshot 类似，CondInstallSnapshot 会判断 lastIncludedIndex，然后截断日志切片，并且更新 log，snapshot，commitIndex，lastApplied 等字段，然后持久化快照数据。 注意，CondInstallSnapshot 还需要判断快照任期是否一致，否则删除所有日志。另外，为什么 CondInstallSnapshot 中更新了 commitIndex，lastApplied，而 Snapshot 却没有？\",\"因为 Snapshot 是由上层应用直接触发的，建立在当前 Raft 实例的基础上，而 CondInstallSnapshot 虽然也是上层应用来调用，但却是领导者触发的，因此追随者的 commitIndex，lastApplied 字段需要与快照保持一致。\"]},\"137\":{\"h\":\"完善日志同步\",\"t\":[\"在引入了 lastIncludeIndex 以后，日志同步可能与快照之间相互冲突，例如快照更新了 lastIncludeIndex 的同时 AppendEntries 在发送日志，却不知道日志发生了截断，因此在取日志数据的时候会发生冲突，我们可以在日志发送前对其判断一次：\",\"func (rf *Raft) sendAppendEntriesToPeer(peerId int) { // 省略 nextIndex := rf.nextIndex[peerId] prevLogTerm := 0 prevLogIndex := 0 entries := make([]LogEntry, 0) // 可能会存在 nextIndex 超过 rf.log 的情况 if nextIndex <= rf.log.size() { prevLogIndex = nextIndex - 1 } // double check，检查 prevLogIndex 与 lastIncludeIndex + if rf.log.LastIncludedIndex != 0 && prevLogIndex < rf.log.LastIncludedIndex { + rf.mu.Unlock() + return + } // 省略 } \",\"在 LastIncludedIndex 非 0，即已经发生了快照的情况下，如果待同步日志序号小，那么直接返回，本次日志无需同步，快照中已经存在了。 另外追随者在受到日志同步请求时，发现同步日志的序号小于自己的 LastIncludedIndex 时，会直接将 LastIncludedIndex 作为 ConflictIndex 返回给领导者。\",\"func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) { // 省略 rf.leaderId = args.LeaderId rf.lastReceivedFromLeader = time.Now() + if args.PrevLogIndex < rf.log.LastIncludedIndex { + reply.ConflictIndex = rf.log.LastIncludedIndex + reply.ConflictTerm = -1 + return } // 省略 } \"]},\"138\":{\"h\":\"小结\",\"t\":[\"快照主要工作可总结如下：\",\"1 个 RPC 请求和处理，用于快照；\",\"两个快照应用函数 CondInstallSnapshot 和 Snapshot；\",\"完善日志同步，加入 LastIncludedIndex 判断。 快照机制并不复杂，关键是日志切片序号与日志序号发生了脱离，需要 LastIncludedIndex 来转换； 快照请求与日志同步请求大同小异，不过快照最终都是由上层应用来触发，从而保证二者的数据一致性。\"]},\"139\":{\"h\":\"总结\",\"t\":[\"Raft 算法实现是颇具挑战力的，从理解到实现需要走很长的一段路，也正因如此才能收获颇丰。下面让我们来总结一下 Raft 算法实现的几个重要脉络：\",\"3 个状态，follwer，candidate 和 leader，状态切换的核心在于任期与心跳；\",\"3 个 loop，ticker，ping，applyLog，其中 ping 是 leader 独有的死循环，用于日志同步和快照，ticker 用于超时后发起选举，applyLog 是最简单的一个死循环，负责将通道中发送日志数据；\",\"3 个 RPC 请求，RequestVote，AppendEntries，InstallSnapshot，分别用于请求投票、日志同步和快照，其中 AppendEntries 和 InstallSnapshot 都有 leader 独有的，二者处理也十分类似；\",\"2 条黄金铁律：发现任期大的立即成为其追随者；任何引起 currentTerm，votedFor，log 改变的操作后，立即持久化数据。 当然 Raft 算法想要应用在工业上，还需更多的打磨与优化，不推荐造轮子，而是直接使用成品，比如： hashicorp/raft 。而从头撸一遍 Raft 会给你带来新的体验与收获，让你从根上理解 Raft，理解它被提出的背景，在此背景下又是如何解决实际问题的，这才是从头实现一个 Raft 所带来的真正收益。\"]},\"140\":{\"h\":\"参考资料\",\"t\":[\"Raft 论文\",\"https://pdos.csail.mit.edu/6.824/labs/lab-raft.html\",\"guide\",\"Raft 代码实现\"]},\"141\":{\"h\":\"tinyrpc 设计与实现\",\"t\":[\"探索一个简单、易用RPC框架——tinyrpc的设计与实现\"]},\"142\":{\"h\":\"整体设计\",\"t\":[\"RPC（Remote Procedure Call），全称为远程调用。一个完整的RPC架构分为了以下几个核心组件：\",\"Server：服务器；\",\"Client：客户端；\",\"Server Stub：服务端接收到Client发送的数据之后进行消息解包，调用本地方法；\",\"Client Stub：将客户端请求的参数、服务名称、服务地址进行打包，统一发送给server方；\",\"调用流程如下图所示：\"]},\"143\":{\"h\":\"详细设计\",\"t\":[\"tinyrpc 框架的整体结构基本分层为：\",\"代理层：负责对底层调用细节的封装；\",\"链路层：负责执行一些自定义的过滤链路，可以供后期二次扩展；\",\"路由层：负责在集群目标服务中的调用筛选策略；\",\"协议层：负责请求数据的转码封装等作用；\",\"序列化层：负责将不同的序列化技术嵌套在框架中；\",\"注册层：关注服务的上下线，以及一些权重，配置动态调整等功能；\",\"容错层：当服务调用出现失败之后需要有容错层的兜底辅助；\",\"接入层：考虑如何与常用框架Spring的接入。\"]},\"144\":{\"h\":\"代理层\",\"t\":[\"代理层旨在帮助开发者包装RPC接口调用参数，屏蔽通信、序列化等调用细节。\",\"开发者在服务端只需定义、实现接口：\",\"public interface DataService { String sendData(String data); List<String> getList(); } public class DataServiceImpl implements DataService { @Override public String sendData(String data) { return \\\"success\\\"; } @Override public List<String> getList() { return Arrays.asList(\\\"a\\\", \\\"b\\\", \\\"c\\\"); } } \",\"在客户端通过代理拿到接口并直接调用，即可完成整个RPC调用链路，极大地拉低了框架使用门槛。如下：\",\"final DataService dataService=ProxyFactory.get(DataService.class); // proxy service bean for(int i=0;i< 100;i++){ String response=dataService.sendData(\\\"Hello RPC\\\"); log.info(\\\"Client.main: response: {}\\\",response); } \",\"Java中实现接口代理的方式有两种：\",\"方案\",\"优点\",\"缺点\",\"JDK代理\",\"JDK原生，上手简单，门槛低；\",\"不能对类进行代理，只能对接口进行代理，如果我们的类没有实现任何接口，那么就不能使用这种方式进行动态代理；调用性能较差；\",\"Javassist\",\"动态字节码生成，接口、类都能代理，还能生成业务代码；\",\"字节码生成，调用性能高；字节码生成，开发门槛高；\"]},\"145\":{\"h\":\"路由层\",\"t\":[\"如果一个服务有多个提供者，客户端需要从其中选择一个最合适的服务提供者并发起请求；服务选择是路由层的核心功能，为了更好的支持业务发展，也需要支持如下功能：\",\"服务负载均衡；\",\"服务权重选择；\",\"服务轮训选择；\",\"服务灰度策略等；\",\"每个服务提供者都有一个唯一且确定的连接，路由层通过不同的策略来选择合适的连接，并发起请求：\",\"基于此，我们抽象一个 Router 接口，用于客户端发起请求时选择提供者连接：\",\"public interface Router { ConnectionWrapper select(List<ConnectionWrapper> connectionWrappers); ConnectionWrapper select(List<ConnectionWrapper> connectionWrappers, String serviceName); } \",\"以哈希路由为例，具体实现如下：\",\"public class HashRouter implements Router { @Override public ConnectionWrapper select(List<ConnectionWrapper> connectionWrappers) { return select(connectionWrappers, \\\"\\\"); } @Override public ConnectionWrapper select(List<ConnectionWrapper> connectionWrappers, String serviceName) { int hashCode = serviceName.hashCode(); int i = hashCode % connectionWrappers.size(); return connectionWrappers.get(i); } } \",\"虽然一个服务会存在多个提供者，但是只要提供的参数保持不变，哈希后选择的提供者也不会变。其它的路由实现就不赘述了。\"]},\"146\":{\"h\":\"协议层\",\"t\":[\"协议是RPC的灵魂，需要考虑如下因素：\",\"性能，协议传输效率，降低延迟；\",\"兼容，协议版本升、降级，向前、后兼容；\",\"存储，协议包尽可能小，提升带宽利用率；\",\"可读，协议可读性好，方便调试、观测；\",\"良好的协议需要充分的调研和长时间的打磨，但我们显然没有这种条件，这里我们提出了一种名为 TinyProtocol 的简单协议：\",\"TinyProtocol 小巧可用，仅有5个字段，性能高：\",\"Magic：魔数，判断消息是否有效；\",\"Version：协议版本；\",\"Serialization：content 序列化方法；\",\"Length：content 长度；\",\"Content：请求内容；\",\"在Netty的加持下，协议编解码实现就非常简单了，首先是编码：\",\"public class TinyEncoder extends MessageToByteEncoder<TinyProtocol> { @Override protected void encode(ChannelHandlerContext channelHandlerContext, TinyProtocol tinyProtocol, ByteBuf out) throws Exception { out.writeShort(tinyProtocol.getMagicNumber()); out.writeShort(tinyProtocol.getVersion()); out.writeShort(tinyProtocol.getSerialization()); out.writeInt(tinyProtocol.getContentLength()); out.writeBytes(tinyProtocol.getContent()); } } \",\"编码部分十分简单，直接向ByteBuf中写入5个字段即可，性能十分可观；另外解码部分也十分简单：\",\"public class TinyDecoder extends ByteToMessageDecoder { public final int BASE_LENGTH = 2 + 2 + 2 + 4; @Override protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> out) throws Exception { // magicNumber + contentLength if (byteBuf.readableBytes() < BASE_LENGTH) { return; } short magicNumber = byteBuf.readShort(); if (magicNumber != MAGIC_NUMBER) { byteBuf.resetReaderIndex(); // magic number invalid, reset reader index return; } short version = byteBuf.readShort(); // protocol version short serialization = byteBuf.readShort(); // serialization type int length = byteBuf.readInt(); if (byteBuf.readableBytes() < length) { byteBuf.resetReaderIndex(); // content length invalid, reset reader index return; } byte[] content = new byte[length]; byteBuf.readBytes(content); TinyProtocol tinyProtocol = new TinyProtocol(version, serialization, content); out.add(tinyProtocol); } } \",\"由于继承了 ByteToMessageDecoder，消息拆包、粘包已被默认处理。\"]},\"147\":{\"h\":\"序列化层\",\"t\":[\"序列化层核心功能是将业务数据序列化为二进制数据，然后交给网络层进行传输，在整个调研链路中，序列化十分频繁，是提升整体性能的一个关键点。\",\"目前序列化成熟方案有很多，大致可分为两类：\",\"二进制协议，比如知名的 protobuf，thrift等；\",\"文本协议，比如 json，xml 等；\",\"方案\",\"优点\",\"缺点\",\"二进制协议\",\"无冗余字段，传输高效，方便解析\",\"观测性差，调试困难\",\"文本协议\",\"直观、描述性强，容易理解，便于调试\",\"冗余数据较多，占用空间大\",\"tinyrpc 抽象了 Serializer 接口用于调用参数序列化抽象：\",\" public interface Serializer { <T> byte[] serialize(T obj); <T> T deserialize(byte[] data, Class<T> clz); } \",\"通信时，按照 TinyProtocol 中的 serialization 字段来选择序列化框架，默认我们使用 json 序列化，框架选择 fastjson（实在是国内用的太普遍了）：\",\" public class JsonSerializer implements Serializer { @Override public <T> byte[] serialize(T obj) { return JSON.toJSONBytes(obj); } @Override public <T> T deserialize(byte[] data, Class<T> clz) { return JSON.parseObject(data, clz); } } \"]},\"148\":{\"h\":\"注册层\",\"t\":[\"服务消费者通过注册中心感知服务提供者的地址信息，从而发起RPC请求；如下：\",\"服务提供者向注册中心注册服务；\",\"服务消费者从注册中心订阅服务；\",\"消费者拿到服务URL后，向提供者发起请求；\",\"当注册数据发生变更时，向提供者、消费者发送变更通知；\",\"以Zookeeper为例，服务注册遵循目录规范，一个简单的服务注册结构图如下：\",\"服务提供者：向ZK注册（register）地址信息，启动RPC服务，等待请求； 服务消费者：向ZK订阅（subscribe）地址信息，发起RPC请求，等待响应；\",\"考虑到服务提供者会发生下线、宕机、发布，因此注册的地址信息存在变更、失效等场景；因此消费者订阅后，需要通过其它手段来及时同步地址信息：\",\"重新订阅：RPC请求失败后，重新请求ZK获取地址信息；\",\"ZK通知：订阅时，附带订阅地址信息变更通知（ZK通知只有一次，每次通知后需重新订阅通知）；\",\"定时刷新：启动定时任务，固定时段去重新获取地址信息；\"]},\"149\":{\"h\":\"链路层\",\"t\":[\"扩展性是一个RPC框架另一个重要的特性，RPC框架在设计时就应该考虑到将框架部分模块功能暴露出去；责任链模式非常适合帮助框架提高扩展性。\",\"代理层封装方法、参数后，将请求交给路由层之前必须经过整个链路层（责任链）后才能到达路由层，而在整个责任链路中，都支持插入用户自定义的中间件对请求处理，比如：\",\"打印RPC调用日志；\",\"修改RPC调用参数；\",\"等等；\",\"链路层不仅仅可以在代理层、路由层之间，还可以在其它地方也引入责任链，这里就不赘述了。\",\"tinyrpc 支持客户端、服务端（未实现）双端过滤器责任链：\",\" public interface ClientFilter extends Filter { boolean handle(Invocation invocation); } \",\"有了过滤器后，打印调用日志就十分简单了：\",\" public class LogFilter implements ClientFilter { private final Logger log = LoggerFactory.getLogger(LogFilter.class); @Override public boolean handle(Invocation invocation) { log.info(\\\"call {} {}\\\", invocation.getTargetServiceName(), invocation.getTargetMethod()); return true; } } \"]},\"150\":{\"h\":\"容错层\",\"t\":[\"容错层主要处理如下一些异常情况：\",\"网络层，RPC 请求时，网络通信失败处理；\",\"路由层，获取提供者信息失败；\",\"序列化层，数据序列化失败；\",\"链路层，自定义业务处理失败；\",\"服务过载保护机制，限流、降级、熔断；\",\"整个框架的每个模块都有调用错误、失败的可能，提升整个框架稳定性是容错层必须解决的问题。\",\"提升容错，我们主要考虑下面两个核心思想：\",\"快速报错，将错误信息上升到业务逻辑；\",\"延时重试，屏蔽底层通信、序列化可能带来的异常；\",\"服务提供者新增限流、降级、熔断机制；\",\"以重试为例，如果服务提供者正在发布，或者突然宕机，那么客户端此时的请求很可能会失败，tinyrpc 需要 cover 这种情况， 因此会尝试不断重试，直到重试次数超过了阈值，才会将错误信息上报到调用方：\",\"private final Retryer<Object> retryer=RetryerBuilder.newBuilder() .retryIfResult(Objects::isNull) .retryIfRuntimeException() .withWaitStrategy(WaitStrategies.fixedWait(1L,TimeUnit.SECONDS)) .withStopStrategy(StopStrategies.stopAfterAttempt(5)) .build(); Callable<Object> callable = () -> { SEND_QUEUE.add(invocation); Object result=RESP_MAP.get(invocation.getUuid()); if(result instanceof Invocation){ return((Invocation)result).getResponse(); } return null; }; try { return retryer.call(callable); } catch (RetryException|ExecutionException e) { log.error(\\\"JDKClientInvocationHandler.invoke error \\\",e); throw new RuntimeException(e); } \",\"容错是一个系统稳定的根本，需要大量实践和打磨，也是工程师素养的重中之重。\"]},\"151\":{\"h\":\"下一步计划\",\"t\":[\"tinyrpc 是一个可用的RCP玩具，旨在学习和实践，距离生产可用还有很长的距离。\",\"tinyrpc 可优化的 3 个方向：\",\"提升性能，优化序列化、代理、worker线程池（Netty处理器中不阻塞流程）、锁优化等；\",\"新增SPI插件，提升扩展性；\",\"新增注册、订阅事件、回调，提升业务开发效率；\",\"接入spring，tinyrpc 实现后，我们可以通过接入spring来进一步拉低使用门槛，并融入spring的庞大生态；\",\"以SPI插件为例，我们可以参考 mysql-connector-driver 的实现，将驱动实现交给其它方；tinyrpc 也可以将序列化、路由负载均衡交给其它方，然后在框架启动时，\\n扫描 meta-info 目录获取实现类并加载应用即可。\"]},\"152\":{\"h\":\"tinymq设计与实现\",\"t\":[\"旨在探索 MQ 的设计与实现，掌握基本原型即可，不上升高级功能。\",\"中间件三驾马车：数据库、缓存，MQ，是每个后端工程师都应深入理解的必备技能，同时也是工作、面试的常客。\",\"自工作以来，笔者基本每天都在与消息队列（MQ）打交道，无论是模块解耦，流量削峰，还是事件通知，MQ 都太好用了。\",\"彻底搞懂 MQ，这个目标一直都在，但苦于下面的原因所以一直没有实施：\",\"工作内容又繁又杂，没有一个整块时间去思考与沉淀；\",\"MQ 选型众多，Kafka，RocketMQ，Pulsar 等都非常好用，但各有各的特点与不同；\",\"MQ 经过这么多年的发展，本来也越来越复杂，一头扎进去难免一叶障目；\",\"市面上的 MQ 产品，比如 Pulsar，Kafka，RocketMQ，经过多年的迭代，已经变得十分复杂和臃肿，不再适合作为一个原型产品进行学习与实践。本着实现了才算理解的初衷，笔者尝试去设计与实现一个极简 MQ，称为 tinymq。\"]},\"153\":{\"h\":\"架构设计\",\"t\":[\"tinymq 架构着重参考了 Kafka（没办法，Pulsar、RocketMQ 都参考了它）， 在一些方面做了精简：\",\"整体上，仍然沿用 Producer、Broker、Consumer 的数据流设计；\",\"注册中心选用 Zookeeper，实现上可以抽象为注册接口，方便后续迁移；\",\"通信上，直接集成了 grpc 作为通信框架，无需自定义协议、序列化；\",\"消息分区在 Producer 端实现，Broker 地址从注册中心获取；\",\"不支持消费者组，一个 Topic 可以有多个消费者（Channel），每个消费者独有自己的消费序号；\",\"消费进度没有存储至 ZK 中，而是直接在 DiskQueue 中存储；\"]},\"154\":{\"h\":\"详细设计\",\"t\":[\"下面就每个模块，详细阐述其设计与实现。\"]},\"155\":{\"h\":\"元数据\",\"t\":[\"tinymq 主要有如下几类元数据：\",\"broker 注册信息，那些 broker 在线，broker 地址、端口等，broker 下线则自动删除；\",\"topic 注册信息，创建了那些 topic，topic 下有那些分区（Queue），分区下消费者等；\",\"元数据必须保证强一致性，高可靠，主流的注册中心有 Zookeeper、ETCD，Consul 等，这里和 Kafka 保持一致选择 ZK，ZK 的树结构十分适合 tinymq 注册数据。\",\"实现上，为了方便后续扩展，tinymq 定义了 RegistryService：\",\"public interface RegistryService extends Closeable { void registerBroker(String brokerId, BrokerInfo brokerInfo); void unRegisterBroker(String brokerId); BrokerInfo getBroker(String brokerId); List<BrokerInfo> getAllBrokers(); void registerTopic(String topicId, TopicInfo topicInfo); void unRegisterTopic(String topicId); TopicInfo getTopic(String topicId); List<TopicInfo> getAllTopics(); void registerQueue(String topicId, String queueId, QueueInfo queueInfo); void unRegisterQueue(String topicId, String queueId); QueueInfo getQueue(String topicId, String queueId); void setQueueConsumer(String topicId, String queueId, String consumerId); String getQueueConsumer(String topicId, String queueId); void unsetQueueConsumer(String topicId, String queueId); List<QueueInfo> getQueuesByTopic(String topicId); List<QueueInfo> getAllQueues(); } \",\"默认实现了 ZookeeperRegistryService，如果以后弃用 ZK，可以更换 RegistryService 实现。\",\"在架构上，RegistryService 是多端访问元数据的桥梁，因此整个 ZK 集群的稳定性至关重要。\"]},\"156\":{\"h\":\"Broker\",\"t\":[\"broker 是 MQ 的心脏，承担着消息存储、转发、处理等核心功能，对外暴露主题操作、消息生产消费等核心 API。\"]},\"157\":{\"h\":\"API\",\"t\":[\"broker 对外暴露的 API 分为两大类：\",\"主题、队列类：操作 Topic，查询 Queue 信息；\",\"消息：生产、消费消息；\",\"tinymq 网络层直接由 protobuf 实现，API 定义如下：\",\"service QueueService { rpc produceMessage (ProduceMessageRequest) returns (ProduceMessageResponse) {} rpc asyncProduceMessage (ProduceMessageRequest) returns(Empty) {} rpc consumeMessage (ConsumeMessageRequest) returns (ConsumeMessageResponse) {} rpc fetchMessage (FetchMessageRequest) returns (FetchMessageResponse) {} rpc createQueue(CreateQueueRequest) returns (CreateQueueResponse) {} rpc deleteQueue(DeleteQueueRequest) returns (DeleteQueueResponse) {} rpc getQueueSize(GetQueueSizeRequest) returns (GetQueueSizeResponse) {} } \",\"为什么选择 grpc？ 主流的 MQ 框架都会自定义通信层、序列化层，这样就能保证消息链路全可控，方便迭代和优化，但同时也带来了麻烦，作为一个 MQ 原型，实在是不应该把精力花在通信层上面，因此已有成熟稳定的实现，拿来用是最好的选择。 暴露的消息 API 可以由生产者、消费者访问，主题操作 API 由 admin 平台访问。\",\"有了 grpc 支持后，tinymq 只需实现 QueueService 服务即可，而这个接口由 QueueManager 来实现：\",\"public class QueueManager extends QueueServiceGrpc.QueueServiceImplBase implements Closeable { //... @Override public void produceMessage(ProduceMessageRequest request, StreamObserver<ProduceMessageResponse> responseObserver) { String queueName = request.getQueueName(); ByteString payload = request.getPayload(); try { BackendQueue queue = queueMap.get(queueName); if (queue == null) { log.error(\\\"queue {} not found\\\", queueName); Result result = genQueueNotFoundResult(queueName); ProduceMessageResponse response = ProduceMessageResponse.newBuilder().setResult(result).build(); responseObserver.onNext(response); return; } long index = queue.push(payload.toByteArray()); ProduceMessageResponse response = ProduceMessageResponse.newBuilder().setResult(genSuccessResult()).setIndex(index).build(); responseObserver.onNext(response); } catch (Exception e) { log.error(\\\"produce message error\\\", e); responseObserver.onError(e); } finally { responseObserver.onCompleted(); } } // ... } \",\"QueueManager 负责管理当前 broker 下的所有 Queue 实例，主要功能包括：\",\"消息入队、出队；\",\"消息定时持久化；\",\"旧消息清理等；\"]},\"158\":{\"h\":\"消息存储\",\"t\":[\"Topic 是 tinymq 的逻辑消息组织单位，为了支持分区，一个 Topic 下可以有多个 Queue：\",\"每个 Queue 分配在不同的 broker 实例中。\",\"Topic 分区分配、管理比较复杂，不同的 MQ 产品的实现都有所不同，tinymq 实现颇为简单粗暴，即每个 broker 一个 queue 实例。\",\"队列消息存储又是一个大麻烦，可参考 diskqueue 持久化队列设计演进，这里不再赘述。为了支持多存储引擎，方便后续扩展和迭代，tinymq 定义了 BackendQueue 接口：\",\"public interface BackendQueue extends Closeable { String getName(); long push(byte[] data) throws IOException; byte[] poll(String channel) throws IOException; byte[] peek(String channel) throws IOException; byte[] get(long index) throws IOException; boolean isEmpty(String channel) throws IOException; long size(String channel) throws IOException; void flush() throws IOException; void close() throws IOException; void delete() throws IOException; void removeBefore(long timestamp) throws IOException; // 删除旧数据 } \",\"默认由 diskqueue 实现。\"]},\"159\":{\"h\":\"生产者\",\"t\":[\"生产消息，并调用 API 将消息存储到 Broker；常见的消息生产方式有两种：\",\"同步生产，适合低频率消息生产，保证消息投递可靠性；\",\"异步生产，适合高频率消息生产，为了性能牺牲可靠性；\",\"以同步生产为例，其流程图：\",\"Producer 从 RegistryService 获取 broker、queue 注册信息；\",\"新建 SenderPool 实例，每个 broker 都对应一个 Sender，Producer 可以向多个 broker 发送消息，因此是 SenderPool；\",\"Sender 将消息发送到 broker，并返回成功；\",\"关于异步生产暂未实现，其核心是引入生产线程，并在成功后回调。\"]},\"160\":{\"h\":\"消费者\",\"t\":[\"调用 API 消费消息，消费者实现方式一般有两种：\",\"拉模式，消费者主动从 broker 拉取消息；\",\"推模式，broker 主动向消费者推消息；\",\"二者各有优劣，tinymq 选择实现拉模式，其流程图如下：\",\"Consumer 从 RegistryService 中获取 broker、queue 信息；\",\"新建 MessageStream 用于返回 topic 下的消息流，Consumer 可以从多个 broker 中请求消息，每个 broker 一个 fetcher；\",\"消费消息，选择 fecther 获取其对应 broker 中的消息，并返回消息列表；\"]},\"161\":{\"h\":\"其它待实现特性\",\"t\":[\"作为一个 MQ 原型，tinymq 实现了核心功能和 API，但距离真正可用还有很远的距离，比如缺少如下特性：\",\"监控、告警；\",\"副本；\",\"延时队列；\",\"死信队列；\",\"消费者组；\",\"so on...；\",\"参考资料\",\"GitHub - pedrogao/tinymq: tiny distribute message queue implement & practice\"]},\"162\":{\"h\":\"工程师思考、做事闭环\",\"t\":[\"关注核心竞争力，用思考找到技术价值再动手做事，而非关注代码/项目本身\",\"项目背景\",\"为什么做这个项目？\",\"目标和路径是什么？\",\"其中技术亮点在哪里？\",\"取得了那些收益？\",\"目标与评估\",\"可量化的目标是什么？\",\"实现这个系统的技术约束是什么？\",\"技术方案\",\"设计理念/思路是什么？\",\"技术架构是什么？\",\"核心流程是什么？\",\"如何处理异常情况？\",\"任务拆解\",\"你是如何拆解任务的？\",\"团队内以及跨团队协作你如何完成？\",\"如何推进整体项目的落地？优先级？风险把控？\",\"测试方案\",\"自测/反测，如何设计测试用例\",\"怎么做集成测试\",\"如何保证上线变更的兼容性\",\"上线方案\",\"如何保证每一步上线都是可回滚、可灰度的？\",\"上线后如何评估变更已生效？如何确认无异常？\",\"最坏情况是什么？影响面是什么？如何止损？\",\"效果评估\",\"上线后获得了那些收益？\",\"个人与团队的成长是什么？\",\"收益是符合预期/不符合预期/超出预期？为什么？\",\"未来演进\",\"长期看还有那些问题需要解决？为什么？\",\"解决问题的途径是什么？那些最值得尝试？\",\"做事如何实施这个闭环\",\"需求评审时思考\",\"技术调研、写技术方案时思考\",\"写完代码后自测思考\",\"面对别人质疑时思考\",\"上线后思考\"]},\"163\":{\"h\":\"TDD学习心得\",\"t\":[\"原文\"]},\"164\":{\"h\":\"收获点\",\"t\":[\"TDD 不是一种写代码方法，而是一种功能迭代模式。\",\"理解需求，找到需求输入、输出；\",\"拆解需求，如何将一个需求拆解为子任务，并以测试来驱动子任务实现；\",\"克服恐惧，不再指望一次性完成需求，而是慢慢测试迭代，保证鲁棒性；\",\"按照 红-> 绿 -> 重构循环来不断推进代码；\",\"单测不通过-> 红灯，改生产代码；\",\"单测通过 -> 绿灯，重构生产代码；\",\"尽量使用可读的方法名替代注释；\",\"由于初期良好的绿灯重构，代码结构规整，责任分配良好，因此后续代码越写越快，效率越来越高；\",\"TDD 的 3 个特点： a. 将功能拆分为一系列任务，再将任务转化为测试，以测试体现研发进度，将开发过程变成有序的流程，减少无效劳动； b. 修改代码时，可以及时通过测试来回归，发现错误后可快速定位，降低 bug 带来的成本； c. 时刻感知认知提升，克服恐惧。\",\"TDD 是帮助我们从可用代码进化到优质代码的一种优秀的工程实践方法，在没有上帝视角的情况下，唯有通过实践才能得知在当前条件下哪个路径是最佳的，TDD 可以帮助减小改进的成本，固化测试知识，每进行一次回归测试收益就增加一次。\",\"测试步骤：setup -> exercise -> verify -> teardown \",\"验证方式：状态验证，行为验证 a. 对于状态验证，在引入三方中间件的情况下，会引入不断增长的数据，因此可以使用增量验证的方式来完成测试，比如测试插入一条数据，先查询已有数据数量，然后再插入一条数据，然后再查询现有数据数量，比较先后数量的差值为 1 即可； b. 行为验证没有状态验证直观和方便，但是对于一些需要 mock 的场景，比如数据库 mock，如果是状态验证，那么必须得拿到数据才能验证，因此我们必须得引入数据 mock，但如果是行为验证，对数据结果不关心的情况下，我们只需关心函数是否被调用，功能是否 work，如下：\",\"@Test public void should_parse_value_if_flag_present() { // 并不会真正的去解析，而是需要验证返回值，具体的说是验证 parse函数是否被调用 // 因此此处，状态验证就会先得很别扭，我们将其改造为行为验证 Object parsed = new Object(); Function<String, Object> parse = (it) -> parsed; Object whatever = new Object(); assertSame(parsed, OptionParsers.unary(whatever, parse).parse(Arrays.asList(\\\"-p\\\", \\\"8080\\\"), option(\\\"p\\\"))); } @Test public void should_parse_value_if_flag_present2() { Function parse = Mockito.mock(Function.class); OptionParsers.unary(Mockito.any(), parse).parse(Arrays.asList(\\\"-p\\\", \\\"8080\\\"), option(\\\"p\\\")); Mockito.verify(parse).apply(\\\"8080\\\"); // 验证 parse方法被调用，并且传入参数为 8080 } \",\"举一个业务例子： StudentRepository 是一个 JPA 代理的仓储服务：\",\"@Repository public interface StudentRepository extends JpaRepository<Student, Long> { Optional<Student> findByEmail(String email); }StudentServiceImpl 将其引入，并作为查询数据库数据的代理： public class StudentServiceImpl implements StudentService { private final StudentRepository studentRepository; public StudentServiceImpl(StudentRepository studentRepository) { this.studentRepository = studentRepository; } @Override public Optional<Student> queryOneById(Long id) { return studentRepository.findById(id); } } \",\"如果是状态测试，那么我们必须引入数据库 Mock，比如 H2 等；实际上，studentRepository.findById 是由 JPA 保证正确性的，我们对状态结果并不关系，即使测试环境下 H2 的用例全部通过了，等到了生成环境数据库采用了 MySQL，也不一定能保证测试通过，因此我们的核心诉求是验证 findById 这个函数是否被调用，即行为验证，而不是这个函数返回的结果，即状态验证，那么行为测试我们可以这样写:\",\"class StudentServiceImplTest { StudentRepository repository; @BeforeEach public void before() { repository = Mockito.mock(StudentRepository.class); } @Test void queryOneById() { var service = new StudentServiceImpl(repository); service.queryOneById(1L); Mockito.verify(repository).findById(1L); } } \",\"这样，对于 queryOneById 这个方法，我们每天验证其返回的数据，而是通过 Mockito 来验证内部的 findById 函数是否被成功调用，且传入的参数是否正确，这样就减少了依赖的复杂度。\",\"行为验证的适用场景（状态数据难以得到，就采用行为测试）： a. 微服务调用 b. 三方支付场景 c. MQ d. 数据库 e. so on...\",\"行为测试对 TDD 的用处不大，核心在于行为测试必须先写一篇测试实现代码，然后在生产代码再写一遍，另外 TDD 本质上就是拆分为多个小任务，每个小任务都有明确的结果验证再继续推进；行为验证本身并不能验证功能是否正确，而只能验证功能是否按照某种方式实现，这与 TDD 的核心逻辑就冲突了。在 TDD 的红 / 绿 / 重构中，重构要求在功能不变的前提下，改变实现方式。而对于行为验证而言，实现方式改变就是功能改变（代码变更）。因而重构就无法进行！需要重写！也就是说，行为验证会阻碍 TDD 的进行；虽然行为验证的主要目的是降低测试成本，但如果丧失了测试的有效性，那么成本再低也是无意义的；将行为验证放在接口而非实现上；\",\"在 TDD 的语境下，“单元测试”指的是能提供快速反馈的低成本的研发测试（Developer Test），Martin 将其称为极限单元测试（Xunit Test）： a. TDD 中的测试是由不同粒度的功能测试构成的； b. 每一个测试都兼具功能验证和错误定位的功效； c. 要从发现问题和定位问题的角度，去思考测试的效用与成本； d. 单元粒度要以独立的功能上下文或变化点为粒度。\",\"将所有直接耦合都视为坏味道的设计取向，会将功能需求的上下文打散到一组细碎的对象群落中，增加理解的难度。最终滑向过度设计（Over Design）的深渊；\",\"测试驱动开发的主要关注点在于功能在单元（模块）间的分配，而对于模块内怎么实现，需要你有自己的想法，因此测试驱动开发在“单元（模块）内的实现方式”失去驱动力；\",\"TDD“驱动”的是架构，因而实际是一种架构技术；\",\"从功能测试出发，逐步完成软件开发，这或许没问题。但架构怎么办？实际上，红 / 绿 / 重构循环中的重构就是解决架构问题的。只不过架构并不是预先设计的（Upfront Design），而是在完成功能的前提下演进而来的，因而也称演进式设计（Evlutionary Design）；\",\"“最晚尽责时刻”让我们不必花费时间进行空对空的讨论，可以尽早开始实现功能，再通过重构从可工作的软件（Working Software）中提取架构。这种方式也被称作 TDD 的经典学派（Classic School）或芝加哥学派（Chicago School）。除了经典学派之外，还有一种 TDD 风格，被称作 TDD 的伦敦学派（London School）。如果架构愿景已经比较清晰了，那么我们就可以使用伦敦学派进行 TDD；\",\"伦敦学派是在组件结构、接口定义的情况下开始 TDD，而经典学派是没有架构设计，只有输入、输出的情况下，通过 TDD 一步步推出架构；\",\"伦敦学派可以先对其他组件（功能函数）进行打桩（Stub），返回固定值，对某个模块用 TDD 驱动开发，最后完成全部开发：\",\"@Test void should_query_one_by_id() { Mockito.when(repository.findById(1L)).thenReturn(Optional.of(new Student(\\\"pedro\\\", \\\"1312342604@qq.com\\\"))); var service = new StudentServiceImpl(repository); Optional<Student> student = service.queryOneById(1L); assertTrue(student.isPresent()); assertEquals(\\\"pedro\\\", student.get().getName()); } \",\"在这个测试例子中，已知 StudentServiceImpl 一定会依赖 StudentRepository，这是墨守成规的 MVC 模式，因此我们不需要 TDD 来推出这个架构，而是可以直接给出分层代码，在 StudentServiceImpl 单元模块推进下，完全可以对 StudentRepository 进行打桩，然后驱动其开发。 无论是伦敦学派，还是经典学派，都是 TDD 的一种模式，都需要掌握。\",\"TDD 流程： • 首先将需求分解为功能点，也就是将需求转化为一系列可验证的里程碑点； • 如果已经存在架构或架构愿景，则依据架构中定义的组件与交互，将功能点分解为不同的功能上下文； • 如果尚不存在架构愿景，则可以将功能点作为功能上下文； • 将功能点按照功能上下文，分解为任务项。也就是进一步将可验证的里程碑点，分解为功能上下文中可验证的任务项； • 将任务项转化为自动化测试，进入红 / 绿 / 重构循环，驱动功能上下文内的功能实现； • 如果重构涉及功能上下文的重新划分，即提取 / 合并组件，即视作对于架构的重构与梳理。需调整后续功能点中对于功能上下文以及任务项的划分。 • 如此往复，直到所有功能完成。\"]},\"165\":{\"h\":\"思考点\",\"t\":[\"TDD 重构是否过度？至少在课程中，我觉得有些重构是过度的，尤其是类架构的更改导致了大量的测试也更改，这是否会导致大量时间都用在了产出不大的重构上？\",\"如果测试书写良好？那么在生产时可以适当重构后即可交付，优先保证质量和速度，因为测试覆盖率高，交付后仍然可以后续再来绿灯重构，持续提升代码质量。\",\"在整个参数解析案例完成后，可以发现生产代码非常少，也就 200 ～ 300 行，但是却经历了好几次的重构而来，代码由少变多，再由多变少，整个过程都是在测试驱动下完成的；因此沉淀了大量的测试用例和测试代码，保证了代码质量和可测试性。\",\"试想，如果是需求多变的业务代码，能不能采用测试先行的方式了？我想是很难的，没有知道产品和老板会怎么样？那么如何保证代码质量呢？就我个人而言，代码分层是一种很好的模式，将核心层代码通过 TDD 来迭代保证质量，业务层代码随时应变，或者激进一点，使用 BDD 来验证？但以我之前在腾讯的工作经历来看，这几乎不可能，当然不同的公司有不同的模式，及时跟 leader 和 boss 沟通再来推进。\",\"如果是核心类库，那么测试上下文（setup）相对简单，不会涉及到任何中间件、数据库等，但是如果是业务代码就肯定会存在大量的中间件、通信依赖，这样测试的上下文就会复杂很多，直接影响测试编写难度和测试维护成本。\",\"过去的代码开发过程中，我似乎一直很注重实现和功能完成，对于代码测试和工程质量的重视程度不够，很多时候因为测试的复杂性而选择放弃测试，从而导致代码越来越难以维护，越来越难以测试，严重拉低了工程质量；完成功能不代表做完了需求，而是需要严格的测试和验证来保证自己的正确性。\",\"工程师三驾马车：\\na. 基础知识（操作系统、数据库、编译原理 and so on...）\\nb. 工程能力（沟通能力，理解需求，拆解需求，落地场景 tradeoff，基本工程方法论）\\nc. 编码能力（拆解任务，实现需求，代码质量，测试）\"]},\"166\":{\"h\":\"TDD实践——从零写一个简单的Mybatis——TinyBatis\"},\"167\":{\"h\":\"前言\",\"t\":[\"之前有幸学习过徐昊的 TDD 课程，收获颇大，但是一直没有好的 idea 去实践，这次就用 TDD 的模式来实现一个简单的 Mybatis，取名为 TinyBatis。\"]},\"168\":{\"h\":\"TDD 流程\",\"t\":[\"以下仅为个人理解，一千个读者就有一千个哈姆雷特，欢迎大家探讨。\",\"TDD(Test-Driven Development)核心是一套指导思想。\",\"之前笔者编程的模式一直是：先写代码，后写测试。\",\"这样编程会带来几个很麻烦的问题：\",\"代码写完后，测试用例写起来很麻烦，因为代码的设计并没有考虑到测试用例，所以测试用例写起来很费劲。\",\"严重依赖模块、代码结构设计，写起来很容易卡壳。\",\"误导排期和进度，代码写完了不代表功能完成了。\",\"而 TDD 的核心思想是：先写测试，后写代码：\",\"编写测试用例，测试用例是对功能的需求的描述，有助于理解需求（需求都没理解，怎么可能写好代码）；\",\"测试用例反推代码结构，有利于写出测试良好的代码；\",\"重构方便，完备的测试用例保证了重构后代码的正确性；\",\"有了 TDD 思想指导后，笔者的流程是这样的：\",\"理解需求，先写入口测试用例；\",\"从入口测试用例反推代码结构，写出测试良好的代码；\",\"通过测试用例；\",\"发现不合理代码，重构再通过测试用例；\"]},\"169\":{\"h\":\"需求\",\"t\":[\"TinyBatis 的需求是这样的：\",\"支持从XML配置构建SqlSessionFactory，SqlSessionFactory可以创建SqlSession，SqlSession可以执行Mapper中的select语句。\",\"TDD 真的不好用文字描述，本文写的稀烂，勉强能看，权当做个人 TDD 笔记吧。 代码直接参考这里。\"]},\"170\":{\"h\":\"测试用例\",\"t\":[\"这样的一句话需求肯定是让人难受的（PM 经常这样干）。\",\"拆解一下需求，将其转化为测试用例：\",\" @Test public void testWithXml1() throws Exception { String resource = \\\"mybatis-config.xml\\\"; InputStream inputStream = ResourceUtil.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } \",\"读取mybatis-config.xml配置文件；\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"https://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <configuration> <environments default=\\\"development\\\"> <environment id=\\\"development\\\"> <transactionManager type=\\\"JDBC\\\"/> <dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"org.h2.Driver\\\"/> <property name=\\\"url\\\" value=\\\"jdbc:h2:mem:demo;INIT=runscript from 'classpath:create.sql'\\\"/> <property name=\\\"username\\\" value=\\\"sa\\\"/> <property name=\\\"password\\\" value=\\\"\\\"/> </dataSource> </environment> </environments> <mappers> <mapper resource=\\\"BlogMapper.xml\\\"/> </mappers> </configuration> \",\"新建SqlSessionFactoryBuilder解析配置文件，构建SqlSessionFactory；\",\"下面让这个测试用例通过：\",\"新建SqlSessionFactoryBuilder类，新建build方法：\",\"public class SqlSessionFactoryBuilder { public SqlSessionFactory build(InputStream inputStream) { return new SqlSessionFactory(configurationConfig); } } \",\"新建SqlSessionFactory类：\",\"public class SqlSessionFactory { public SqlSessionFactory() { } public SqlSession openSession() { return new SqlSession(); } } \",\"最后新建SqlSession类：\",\"public class SqlSession implements AutoCloseable { public SqlSession() { } } \",\"运行测试，测试通过。\"]},\"171\":{\"h\":\"渐进式开发\"},\"172\":{\"h\":\"读取 XML 配置文件\",\"t\":[\"第一个测试用例通过了，接下来就是实现第一个小需求：读取mybatis-config.xml配置文件。\",\"public class SqlSessionFactoryBuilder { public SqlSessionFactory build(InputStream inputStream) { ConfigParser configParser = new ConfigParser(); try { ConfigurationConfig configurationConfig = configParser.parse(inputStream); return new SqlSessionFactory(configurationConfig); } catch (DocumentException e) { throw new RuntimeException(\\\"parse mybatis-config.xml error\\\", e); } catch (ClassNotFoundException e) { throw new RuntimeException(\\\"load driver error\\\", e); } } } \",\"新建ConfigParser类，实现parse方法：\",\"public class ConfigParser { public ConfigurationConfig parse(InputStream is) throws DocumentException { SAXReader saxReader = new SAXReader(); Document document = saxReader.read(is); Element configurationElement = document.getRootElement(); if (!configurationElement.getName().equals(\\\"configuration\\\")) { throw new RuntimeException(\\\"root should be <configuration>\\\"); } Element environmentsElement = configurationElement.element(\\\"environments\\\"); String defaultEnvironment = environmentsElement.attribute(\\\"default\\\").getValue(); List<EnvironmentConfig> environmentConfigs = parseEnvironments(environmentsElement); Element mappersElement = configurationElement.element(\\\"mappers\\\"); List<MapperConfig> mapperConfigs = parseMappers(mappersElement); List<MapperNode> mapperNodes = new ArrayList<>(mapperConfigs.size()); // Parse Mapper XML files MapperParser mapperParser = new MapperParser(); for (MapperConfig mapperConfig : mapperConfigs) { InputStream mapperConfigInputStream = ResourceUtil.getResourceAsStream(mapperConfig.getResource()); MapperNode mapperNode = mapperParser.parse(mapperConfigInputStream); mapperNodes.add(mapperNode); } return new ConfigurationConfig(defaultEnvironment, environmentConfigs, mapperConfigs, mapperNodes); } // ... } \"]},\"173\":{\"h\":\"读取 Mapper XML 文件\",\"t\":[\"public class MapperParser { public MapperNode parse(InputStream is) throws DocumentException { SAXReader saxReader = new SAXReader(); Document document = saxReader.read(is); Element mapperElement = document.getRootElement(); if (!mapperElement.getName().equals(\\\"mapper\\\")) { throw new RuntimeException(\\\"root should be <mapper>\\\"); } // ... return new MapperNode(namespace, selectNodes); } } \"]},\"174\":{\"h\":\"支持 if 语句\",\"t\":[\" <select id=\\\"selectOne\\\" resultType=\\\"github.io.pedrogao.tinybatis.Blog\\\"> select * from blog where id = ? <if test=\\\"title != null\\\"> and title = ? </if> </select> \",\"IfNode类中解析test语句，并得到 tokens：\",\"public class IfNode { private String test; private String subSql; private List<Token> tokens; public IfNode(String test, String subSql) { this.test = test; this.subSql = subSql; this.tokens = new Lexer(test, Rule.DEFAULT_RULES).tokenize(); } // ... } \",\"解析完成后在SqlSession中解释执行：\",\" public Object selectOne(String id, Map<String, Object> variables, Object... params) { try { SelectNode selectNode = selectNodeMap.get(id); if (selectNode == null) { throw new RuntimeException(\\\"selectNode not found\\\"); } StringBuilder sql = new StringBuilder(selectNode.getSql()); for (var ifNode : selectNode.getIfNodes()) { String subSql = ifNode.getSubSql(); Parser parser = new Parser(ifNode.getTokens()); Expr expr = parser.parseExpr(); // 1. 解析得到表达式 Object res = interpreter.interpret(expr, variables); // 2. 执行表达式 if (res != null && (Boolean) res) { // 3. 如果结果为 true，拼接 subSql sql.append(\\\" \\\").append(subSql); } } PreparedStatement statement = connection.prepareStatement(sql.toString()); } } \"]},\"175\":{\"h\":\"参考资料\",\"t\":[\"Generating java code from xml schema\",\"Test-driven development\"]},\"176\":{\"h\":\"go 泛型尝鲜，实现一个流式处理库\"},\"177\":{\"h\":\"背景\",\"t\":[\"熟悉 Java、Rust 的同学，肯定都非常喜欢其 Stream API，以 Java 为例，筛选一个简单的数字列表，可以有如下实现：\",\"boolean ok = Stream.of(1, 2, 3, 4, 5). map(item -> item + 100). filter(item -> item > 102). allMatch(item -> item > 102); \",\"Stream API 能让我们以链式调用和 函数式编程的方式来处理数据，数据在函数之间流转、映射，最后汇总得到结果。\",\"Stream 是流式处理的一种实现，Stream 是数据的通道，简称数据流，数据流进入(无状态)函数后，返回一个新的数据流。\",\"而在 Go 中，目前标准库是没有提供相关的实现，既眼馋于 Stream API 的易用与炫酷，又恰逢 Go 泛型的即将发布(go1.18 发布)， 想着将二者结合，体验一把 Go 泛型，于是就有了这篇文章。\",\"我们的目标很明确，使用 Go 泛型实现一个流式处理库，实现后的效果如下：\",\"ok := stream.Just(1, 2, 3, 4, 5). Concat(stream.Just(6, 9, 10)). Map(func (item int) int { return item + 100 }). Filter(func (item int) bool { return item > 105 }). Sort(func (a, b int) bool { return a > b }). AllMatch(func (item int) bool { return item > 105 }) \",\"下面，就来实现它吧。\"]},\"178\":{\"h\":\"泛型\",\"t\":[\"泛型是 Go 近几年最大的一次变动，考虑到很多同学对其不熟悉，这里会先介绍一下 Go 泛型，如果你对 Go 泛型非常了解，可以跳过。\"]},\"179\":{\"h\":\"泛型样例 1\",\"t\":[\"在 Go 中，对于一个加法函数：\",\"func add(a, b int) int { return a + b } \",\"由于 Go 是强类型语言，因此在编译器就必须确定 a，b 的类型，一旦确定 a，b 是int类型后，就无法改变其类型。\",\"因此，函数 add 就只能用于 int 类型数据的加法，如果此时还需要一个用于浮点数的加法函数， 那么就只能新写一个函数了：\",\"// Bad func add(a, b float64) float64 { return a + b } \",\"而 Go 本身是不支持函数重载的，因此两个 add 函数重名，是不能编译通过的，所以我们需要更改函数名：\",\"func addi(a, b int) int { return a + b } func addf(a, b float64) float64 { return a + b } \",\"如果再新增一个用于 complex64 加法函数，就需要再写一个相同功能的函数，而这些函数除了数据类型不同，其它的逻辑却一样。\",\"在 Go1.18 之前，对于这些重复的逻辑，我们可以通过 interface{} 和反射来将其提取为一个函数，如下：\",\"// Bad, need to be improved func add(a, b interface{}) interface{} { typ := reflect.TypeOf(a) if typ.Kind() == reflect.Int { return a.(int) + b.(int) } else { // TODO } return nil } \",\"虽然这样可以传入任意类型的参数，但是却给程序的安全性和可维护性带来了问题，并且每次都需要类型断言，给函数使用带来的麻烦。\",\"而在 Go1.18 引入了泛型后，我们可以实现泛型来解决这个问题：\",\"func add[T int | float64](a, b T) T { return a + b } \",\"函数 add 的参数 a，b 类型为T，而T并不是一个固定的类型，它既可以为int类型， 也可以为float64类型，因此将其称为泛型。\",\"有了泛型T后，函数 add 只需定义一次，就可以接受两种类型的参数，并且完成加法， 而如果需要再支持一个新类型，也只需给T添加一个新的类型约束即可：\",\"func add[T int | float64 | complex64](a, b T) T { return a + b } \",\"考虑到，如果T的类型约束过多，那么写在函数上面也不太好看，因此 Go 支持我们将泛型定义为接口再使用，如下：\",\"// main.go type Addable interface { int | int64 | int32 | float64 | float32 | string } func add[T Addable](a, b T) T { return a + b } \",\"这样，泛型T就能支持 6 种类型的加法，而无需为每种类型都写一个 add 函数。\"]},\"180\":{\"h\":\"泛型原理\",\"t\":[\"那么泛型T是如何实现支持多种数据类型的呢？\",\"使用反汇编工具来查看一下生成的汇编代码：\",\"$ go tool compile -N -l -S ./main.go $ go tool objdump ./main.o \",\"对应的汇编代码如下(截取部分)：\",\"TEXT \\\"\\\".add[go.shape.int_0](SB) gofile../add/main.go main.go:11 SUBQ $0x10, SP main.go:11 MOVQ BP, 0x8(SP) main.go:11 LEAQ 0x8(SP), BP main.go:11 MOVQ AX, 0x18(SP) main.go:11 MOVQ BX, 0x20(SP) main.go:11 MOVQ CX, 0x28(SP) main.go:11 MOVQ $0x0, 0(SP) main.go:12 MOVQ 0x20(SP), AX main.go:12 ADDQ 0x28(SP), AX main.go:12 MOVQ AX, 0(SP) main.go:12 MOVQ 0x8(SP), BP main.go:12 ADDQ $0x10, SP main.go:12 RET TEXT \\\"\\\".add[go.shape.float64_0](SB) gofile../add/main.go main.go:11 SUBQ $0x10, SP main.go:11 MOVQ BP, 0x8(SP) main.go:11 LEAQ 0x8(SP), BP main.go:11 MOVQ AX, 0x18(SP) main.go:11 MOVSD_XMM X0, 0x20(SP) main.go:11 MOVSD_XMM X1, 0x28(SP) main.go:11 XORPS X1, X1 main.go:11 MOVSD_XMM X1, 0(SP) main.go:12 MOVSD_XMM 0x20(SP), X0 main.go:12 ADDSD 0x28(SP), X0 main.go:12 MOVSD_XMM X0, 0(SP) main.go:12 MOVQ 0x8(SP), BP main.go:12 ADDQ $0x10, SP main.go:12 RET \",\"从汇编代码上可以看到，Go add 函数被编译成了多个 add[go.shape.xxx] 函数，不同类型 对应的着不同的指令实现，如 int_0 是 int 的函数实现，通过 ADDQ 指令来实现加法, 而 float64_0 通过 ADDSD 指令来实现加法。\",\"Go 泛型可以理解为：编译器帮忙写不同类型的实现代码，编译器通过泛型定义来生成不同的指令实现。\"]},\"181\":{\"h\":\"泛型样例 2\",\"t\":[\"下面，来看一个稍微复杂一点的泛型样例。在正式的流式处理实现之前，我们先来看看 Map、Filter 函数的泛型是如何实现的？\",\"首先，给出类型定义：\",\"type ( Item interface { comparable } // FilterFunc 筛选函数 FilterFunc[T Item] func(T) bool // MapFunc 数据映射函数 MapFunc[T Item, R Item] func(item T) R ) \",\"此处定义了三个类型，Item接口，作为泛型约束，内部实际是一个 comparable 类型。\",\"comparable 是 Go1.18 后新加入至标准库的内置类型：\",\"comparable is an interface that is implemented by all comparable types, (booleans, numbers, strings, pointers, channels, interfaces, arrays of comparable types, structs whose fields are all comparable types).\",\"FilterFunc函数类型用于过滤数据，该函数有一个泛型参数，即 T，泛型约束则是 Item，代表着 FilterFunc 可以接受一切实现了 comparable 的参数。\",\"MapFunc函数类型用于数据映射，该函数拥有两个泛型参数，即T和R，泛型约束均为Item，所以 MapFunc 可以接受一个类型的参数， 但返回另一个类型的结果，但这两个类型均需实现 comparable 接口。\",\"有了 FilterFunc 和 MapFunc 函数类型后，我们还需实现对应的函数来使用它们，如下：\",\"func Map[T Item, R Item](a []T, m MapFunc[T, R]) []R { var n []R for _, e := range a { v := m(e) n = append(n, v) } return n } func Filter[T Item](a []T, f FilterFunc[T]) []T { var n []T for _, e := range a { if f(e) { n = append(n, e) } } return n } \",\"有了泛型后，Map和Filter函数的实现可以说是既简洁又明确。对于 Map 函数，接受两个参数，分别是数据切片a和 MapFunc m， 函数内部使用 range 得到每个元素后调用 m 函数得到新的元素，最后将其 append 到新的切片返回即可。\",\"Filter 函数实现类似，就不做过多介绍了。\",\"有了 Map 和 Filter 两个函数就，我们可以实现简单的数据过滤和映射。如下：\",\"vi是一个简单的整数切片；\",\"vi通过 Filter 函数会过滤掉>=4 的数字;\",\"然后vi会通过 Map 函数得到最后的 float 切片;\",\"输出最后的结果。\",\"// main.go func main() { vi := []int{1, 2, 3, 4, 5, 6} vi = Filter(vi, func(v int) bool { return v < 4 }) bi := Map(vi, func(v int) float32 { return float32(v) + 100.01 }) fmt.Println(bi) } // output: [101.01 102.01 103.01] \",\"在这个例子中，可以清晰的看到泛型的作用。因为泛型的存在，使 Map 和 Filter 函数足够简单，每当需要新的类型支持时， 不用去兼容老的代码逻辑，而是直接在调用时指定泛型参数的类型即可。\"]},\"182\":{\"h\":\"Stream 设计\",\"t\":[\"在对 Go 泛型和函数式编程有了一定了解后，我们再来看看如何设计和实现 Stream。流式处理与工厂中的流水线作业非常类似，可以 将其拆解为如下三个阶段：\",\"创建阶段：获取原始数据；\",\"加工阶段：数据处理、映射；\",\"汇总阶段：得到数据处理后的结果。\"]},\"183\":{\"h\":\"创建阶段\",\"t\":[\"按照这三个阶段来设计 Stream 的 API。首先是创建阶段，即 Stream 的构造函数：\",\"// Stream computing Stream[T Item] struct { source <-chan T // 只读 channel，不能写 } func Range[T Item](source <-chan T) Stream[T] func Just[T Item](items ...T) Stream[T] func From[T Item](generate GenerateFunc[T]) Stream[T] func (s Stream[T]) Concat(steams ...Stream[T]) Stream[T] \",\"为了支持链式调用，将 Stream 定义为一个结构体，Stream 有一个泛型参数，用于编译时指定 数据流的类型；Stream 内部通过 source 字段来存储数据流。\",\"提供了 Range、Just、From、Concat 四个函数来初始化、合并数据流：\",\"Range：通过 channel 来初始化 Stream；\",\"Just：通过切片来初始化；\",\"From：通过生成函数来初始化；\",\"Concat：通过 Stream 拼接得到新的 Stream。\"]},\"184\":{\"h\":\"加工阶段\",\"t\":[\"数据处理映射阶段可以定义出非常复杂和丰富的 API，这里只给出部分的定义：\",\"func (s Stream[T]) Distinct(keyFunc KeyFunc[T, T]) Stream[T] func (s Stream[T]) Filter(filterFunc FilterFunc[T], opts ...Option) Stream[T] func (s Stream[T]) Walk(fn WalkFunc[T, T], opts ...Option) Stream[T] func (s Stream[T]) Head(n int64) Stream[T] func (s Stream[T]) Tail(n int64) Stream[T] func (s Stream[T]) Map(fn MapFunc[T, T], opts ...Option) Stream[T] func (s Stream[T]) Sort(fn LessFunc[T]) Stream[T] \",\"数据处理不会停止流，而是彼此组合，越丰富的 API 越拥有强大的数据处理能力。\",\"其对应的功能分别如下：\",\"Distinct：数据去重；\",\"Filter：数据过滤；\",\"Walk：数据遍历；\",\"Head：截取流头部数据；\",\"Tail：截取流尾部数据：\",\"Map：数据映射；\",\"Sort：数据排序。\"]},\"185\":{\"h\":\"汇总阶段\",\"t\":[\"数据流经处理后，可由汇总函数得到最后的处理结果，汇总函数调用后，流处理就会终止。\",\"其部分 API 定义如下：\",\"func (s Stream[T]) AllMatch(fn PredicateFunc[T]) bool func (s Stream[T]) AnyMatch(fn PredicateFunc[T]) bool func (s Stream[T]) NoneMatch(fn func(item T) bool) bool func (s Stream[T]) Count() int func (s Stream[T]) ForAll(fn ForAllFunc[T]) func (s Stream[T]) ForEach(fn ForEachFunc[T]) \",\"汇总函数不会再返回新的数据流，而是一个处理结果：\",\"AllMatch：每个数据项均需满足条件后返回结果；\",\"AnyMatch：任何一个数据项需满足条件后返回结果；\",\"NoneMatch：无任何数据项需满足条件后返回结果；\",\"Count：得到数据项总数；\",\"ForAll：对整个数据流执行操作；\",\"ForEach：对数据流中的每一项都执行操作。\"]},\"186\":{\"h\":\"Stream 实现\",\"t\":[\"在设计完备的基础上，借助 Go channel 和泛型的强大能力，我们能够非常方便的实现 Stream。\",\"这里只给出部分 API 的实现，其它基本类似。\"]},\"187\":{\"h\":\"创建阶段\",\"t\":[\"以 Range 函数为例：\",\"func Range[T Item](source <-chan T) Stream[T] { return Stream[T]{ source: source, } } \",\"Range 函数实则是一个简单的构造函数，从参数读取 source 后赋值给 Stream 返回即可。\",\"对于稍微复杂一点的 Concat 函数：\",\"func (s Stream[T]) Concat(steams ...Stream[T]) Stream[T] { // 创建新的无缓冲channel source := make(chan T) go func() { // 创建一个waiGroup对象 group := task.NewRoutineGroup() // 异步从原channel读取数据 group.Run(func() { for item := range s.source { source <- item } }) // 异步读取待拼接Stream的channel数据 for _, stream := range steams { // 每个Stream开启一个协程 group.Run(func() { for item := range stream.channel() { source <- item } }) } // 阻塞等待读取完成 group.Wait() close(source) }() // 返回新的Stream return Range[T](source) } \",\"Concat 函数会拼接多个流的数据，然后汇总到 source 通道中，最后返回。\"]},\"188\":{\"h\":\"加工阶段\",\"t\":[\"数据处理函数是实现的一个难点，以 Distinct 为例：\",\"// Distinct 去重，使用 map 来实现去重 func (s Stream[T]) Distinct(keyFunc KeyFunc[T, T]) Stream[T] { source := make(chan T) common.GoSafe(func() { // 新建协程写数据 // channel记得关闭是个好习惯 defer close(source) keys := make(map[T]common.PlaceholderType) for item := range s.source { // 自定义去重逻辑 key := keyFunc(item) // 这里的key类型是R // 如果key不存在,则将数据写入新的channel if _, ok := keys[key]; !ok { source <- item keys[key] = common.Placeholder } } }) return Range[T](source) } \",\"Distinct 函数的核心在于去重，这里我们借助 map 来混存数据映射关系，以数据项作为 key， 去掉重复的 key 从而达到去重的效果。\",\"对于 Tail 函数，由于 channel 的特性，我们必须遍历完 channel 才能得到最后的几项，因此 我们可以借助环形切片来实现：\",\"func (s Stream[T]) Tail(n int64) Stream[T] { if n < 1 { panic(\\\"n must be greater than 1\\\") } source := make(chan T) go func() { ring := collection.NewRing[T](int(n)) // 读取全部元素，如果数量>n环形切片能实现新数据覆盖旧数据 // 保证获取到的一定最后n个元素 for item := range s.source { ring.Add(item) } for _, item := range ring.Take() { source <- item } close(source) }() return Range[T](source) } \",\"Ring是一个带有固定缓存池的环形切片，它只能保存固定n个数据项，我们依次遍历 source 并向 Ring 中添加，待遍历完毕后，就能得到最后的 n 个数据。\",\"而 Head 函数就比较简单了，只需遍历 n 次停止即可，这里就不做过多介绍了。\"]},\"189\":{\"h\":\"汇总阶段\",\"t\":[\"在数据汇总阶段，实则是对数据流的一个检查与判断，以AnyMatch为例：\",\"func (s Stream[T]) AnyMatch(fn PredicateFunc[T]) bool { for item := range s.source { if fn(item) { // 需要排空 s.source，否则前面的goroutine可能阻塞 go drain(s.source) return true } } return false } \",\"AnyMatch接受一个断言函数fn，在遍历 source 的时候，只需一个满足条件的项出现，就能立马返回 true。\",\"AllMatch与NoneMatch与之类似，内部处理逻辑稍有不同。\",\"而对于ForEach、Count就必须全部遍历，并对每一个数据项进行处理：\",\"func (s Stream[T]) ForEach(fn ForEachFunc[T]) { for item := range s.source { fn(item) } } func (s Stream[T]) Count() int { var count int for range s.source { count++ } return count } \",\"ForEach 接受一个 fn 参数，用于对每一个数据项处理，而 Count 函数只需增加数据项的总数返回即可。\"]},\"190\":{\"h\":\"总结\",\"t\":[\"完成 Stream 后，就能方便的使用 Stream API 对数据进行处理与检查，如下：\",\"// main.go func main() { ok := stream.Just(1, 2, 3, 4, 5). Concat(stream.Just(6, 9, 10)). Map(func(item int) int { return item + 100 }). Filter(func(item int) bool { return item > 105 }). Sort(func(a, b int) bool { return a > b }). AllMatch(func(item int) bool { return item > 105 }) fmt.Println(ok) } // output: true \",\"Stream 处理数据优雅又易读，在有了泛型后，就无需过多关系数据类型的问题，相较于使用 for range 的 语法来处理数据流，Stream 无疑更加合适。\",\"而在整个设计、实现的过程中，借助 channel 和泛型是颇为简单的，当然前提是你得对数据结构有一定的理解， 上面我们就借助哈希表和环形切片来快速实现了数据去重、数据尾项等功能。\",\"至此，一个基于泛型的流式处理库已实现完毕，当然这个库只能称为 tiny Stream，因为 Stream API 实则非常丰富， 比如我们未涉及到的 Reduce 等，这就待我们后续去实践和完善了。\"]},\"191\":{\"h\":\"参考资料\",\"t\":[\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html\",\"https://mp.weixin.qq.com/s/ocI6TWGI9f5c11uAKBumew\",\"https://mp.weixin.qq.com/s/t3INtSfFSmv-nsJqLmdPew\",\"https://github.com/zeromicro/go-zero\",\"https://github.com/akutz/go-generics-the-hard-way\",\"https://github.com/mattn/go-generics-example\",\"https://github.com/zyedidia/generic\",\"https://github.com/golang/go\"]},\"192\":{\"h\":\"从 Hello World 来看看 go 的运行流程\",\"t\":[\"一直以来我们都在享受 Go 语言带来的便利，却不知道它一直在为我们负重前行。本文我们将从底层出发，从 Hello World 这个最基本例子来看看 Go 是如何运行的。重新审视 Hello World，保持对 Hello World 的敬畏。\",\"本文涉及知识点有：\",\"plan9 汇编\",\"GMP 模型\",\"系统调用\",\"进程与线程\",\"。。。\",\"为了帮助大家能够更好的理解 Go 运行流程，这里会先介绍一些前置知识，如果你已经熟稔于心可以直接选择跳过，如果你还一知半解，那么请随我一起来回顾回顾。\"]},\"193\":{\"h\":\"操作系统\",\"t\":[\"Go 程序的运行依托于操作系统(本文基于 linux)，想要读懂其运行流程，必须先准备一些前置知识。\"]},\"194\":{\"h\":\"进程与线程\",\"t\":[\"在 linux 中，线程与进程均有同一个结构体 task_struct 来表示，二者均由内核调度器来调度，该结构体的定义如下：\",\"struct task_struct { volatile long state; // 进程状态 void *stack; // 进程内核栈地址 struct list_head tasks;// 所有进程的链表 struct mm_struct *mm; // 指向进程内存结构 pid_t pid; // 进程 id struct task_struct __rcu *parent;// 指向其父进程 struct fs_struct *fs; // 进程相关的文件系统信息 struct files_struct *files;// 进程打开的所有文件 struct vm_struct *stack_vm_area;// 内核栈的内存区 }; \",\"task_struct 是一个非常庞大的结构体，这里只摘出了有用的部分，下面分别说明一下：\",\"state：进程状态，表示进程正在运行、睡眠等等。\",\"stack：内核栈，在内核运行时使用的调用栈。\",\"mm：进程用户地址空间，包括栈、堆等等。\",\"files：资源文件\",\"mm 实则就是我们平时所理解的地址空间，如下：\",\"我们暂时不关注代码段、数据段，将注意力放在栈和堆中，这里的栈实则就是进程在用户态的调用栈，当进程在用户态运行时，会使用这个栈，而当进程陷入内核时，则使用内核栈，即 stack 字段。\",\"线程与进程是同一种数据结构 task_struct，二者的区别在于进程拥有独立的地址空间和资源，即独立的 mm 和 files，而线程必须得与进程共享地址空间和资源。因此在 linux 下，进程本身也是可执行单元，可以将其理解为主线程，主线程拥有地址空间和资源，而非主线程则共享主线程的地址空间和资源。\",\"在主线程中新建非主线程后，非主线程也会被分配调用栈（linux 下为 8 M），那么这个栈在什么地方了，它肯定在地址空间里面，而且在堆里面，没错，其它线程调用栈是在堆里面分配的，因为堆是一段很大的地址空间，而栈相对较小，因此选择在堆里面开辟。如下图：\",\"总结一下：\",\"无论进程和线程都有一个内核栈，陷入内核态后再使用。\",\"进程和线程是同一种数据结构，二者并无本质区别，由内核调度器统一调度，进程拥有独立地址空间与资源，而线程则共享其地址空间与资源。\",\"非主线程也有用户态调用栈，且在进程中的堆上开辟。\"]},\"195\":{\"h\":\"系统调用\"},\"196\":{\"h\":\"概念\",\"t\":[\"系统调用(system call)指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。\",\"现代操作系统都有明确的权限隔离，一般分为内核态和用户态两个运行态。内核态拥有最高权限，而用户态权限受限，无法直接使用高权操作和访问内核数据。\"]},\"197\":{\"h\":\"基本使用\",\"t\":[\"举个例子，常见的 print 函数会在终端输出一段文本，可在用户态是没有 IO 权限的，用户态程序需要通过系统调用这个桥梁向内核发起申请，陷入内核态后再进行 IO 操作。\",\"下面我们以 C 语言为例，来看看 IO 系统调用是如何产生的：\",\"#include <stdio.h> int main() { char *str = \\\"Hello, World\\\\n\\\"; printf(\\\"%s\\\", str); return 0; } \",\"上面是一段最基本的 Hello World 代码，编译并运行：\",\"$ gcc -o helloworld helloworld.c $ ./helloworld Hello, World \",\"在终端成功输出了 Hello World 文本，通过 strace 工具查看一下该程序的系统调用：\",\"$ strace ./helloworld execve(\\\"./helloworld\\\", [\\\"./helloworld\\\"], 0x7ffe88f6ce40 /* 46 vars */) = 0 .... .... .... write(1, \\\"Hello, World\\\\n\\\", 13Hello, World ) = 13 exit_group(0) = ? +++ exited with 0 +++ \",\"write 对应系统调用 sys_write，write 函数是 glibc 库包装好的系统调用函数，直面上感受不到系统调用的发生。 Linux 在 x86 上的系统调用通过 int 80h 实现，用系统调用号来区分入口函数。操作系统实现系统调用的基本过程是：\",\"应用程序调用库函数（API）；\",\"API 将系统调用号存入 eax，然后通过中断调用使系统进入内核态；\",\"内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；\",\"系统调用完成相应功能，将返回值存入 eax，返回到中断处理函数；\",\"中断处理函数返回到 API 中；\",\"API 将 eax 返回给应用程序。 下面我们以汇编的形式来看看如何在 linux 下发起一次系统调用。\",\".section .data # 数据段 msg: .ascii \\\"Hello, World\\\\n\\\" .section .text # 代码段 .global _start # 全局开始函数，必须是 _start _start: movl $13, %edx # 系统调用 write 的第 3 个参数为 13 movl $msg, %ecx # 第 2 个参数是 Hello World\\\\n movl $1, %ebx # 第 1 个参数是 1，标准输出的编号 movl $4, %eax # sys_write 系统调用的编号是 4 int $0x80 movl $0, %ebx # exit 系统调用的第一个参数，即 exit(0) movl $1, %eax # sys_exit 编号为 1 int $0x80 # 调用 exit，退出程序 \",\"在命令行中输入并运行：\",\"$ as helloworld.s -o helloworld.o $ ld helloworld.o -o helloworld $ ./helloworld Hello, World \",\"可以看到通过汇编系统调用同样实现了与 C 程序一样的结果。关于上面代码的说明已经写在了注释中了，linux 系统调用严格遵循了刚才介绍的系统调用流程，当然这里并不是鼓励大家去写汇编，而是在汇编层面上去理解系统调用。\"]},\"198\":{\"h\":\"Go 中重要的系统调用\",\"t\":[\"在 Go 程序运行时，每秒都在发生系统调用，系统调用可以说是无处不在，下面将介绍 Go 程序启动过程中比较重要的两个系统调用，它们分别是：\",\"clone：新建线程；\",\"arch_prctl：设置或者获取线程局部变量地址。 arch_prctl 系统调用，用来设置架构特定的线程状态。定义如下：\",\"arch_prctl - set architecture-specific thread state int arch_prctl(int code, unsigned long addr); int arch_prctl(int code, unsigned long *addr); ARCH_SET_FS Set the 64-bit base for the FS register to addr. \",\"之所以需要介绍 arch_prctl，是因为 Go 在 runtime 中大量的使用了 arch_prctl 系统调用。 arch_prctl 一般用于设置线程局部变量(TLS)地址到 FS 寄存器 ，FS 寄存器指向当前 CPU 正在运行的线程，其中偏移 02C 指向线程的局部存储变量地址，因此调有 arch_prctl 时会将线程局部变量地址设置到 02C 处。\",\"在 Go 中，会将工作线程(m)上正在运行 g 的地址存储到工作线程的线程局部变量中，这样就能轻松获取 m 上正在运行的 g，如下：\",\"_g_ := getg() \",\"Go runtime 中频繁的使用了这行代码，它由编译器实现，核心原理就是通过 archprctl 获取线程局部变量地址，然后拿到 _g 的地址。 clone 系统调用，用于新建子进程或者线程。在 runtime 中，Go 通过 clone 系统调用来新建线程，然后再将其与 m 绑定，Go 中 clone 调用的样例如下：\",\"cloneFlags = _CLONE_VM | /* share memory */ _CLONE_FS | /* share cwd, etc */ _CLONE_FILES | /* share fd table */ _CLONE_SIGHAND | /* share sig handler table */ _CLONE_SYSVSEM | /* share SysV semaphore undo lists (see issue #20763) */ _CLONE_THREAD /* revisit - okay for now */ // 通过 clone 系统调用新建线程，注意 cloneFlags 中共享内存与字段，故是线程 // 传入 mp 即 m，g0 和 mstart 作为线程的启动函数，因此线程创建后会运行 mstart 函数，然后开启调度循环 // 注意：m 可以有 mstartfn，所以 mstart 可能不是立马执行 ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart))) \",\"正是通过 clone 这个系统调用，Go 程序才能创建多个线程，并同时运行多个 g，充分的发挥多核的能力。\"]},\"199\":{\"h\":\"GMP 模型\",\"t\":[\"GMP 模型是 Go runtime 的调度运行模型，是 Go 高效运行的根本。GMP 实际上是 G、M、P 三个部分的组合，三个部分说明如下：\",\"G：goroutine，Go 中最基本的运行单元，也就是我们通常意义上理解的协程，goroutine 是一个抽象的概念；在 runtime 中用数据结构 g 表示，g 存储了协程栈、状态和任务函数等信息。\",\"M：machine，runtime 对系统线程的一个包装，可以将 M 简单的理解为工作线程，是操作系统的基本执行单位；在 runtime 中用数据结构 m 表示。\",\"P：processor，处理器，P 是 G 与 M 之间的桥梁；在 runtime 中用数据结构 p 表示， 在 p 中维护了 M 执行的上下文，G 的运行队列，P 通过绑定 G 与 M 来执行 G，G 被绑定到 M 后才能运行，否则只能在队列中等待。 \",\"注意：很多地方将 machine 介绍为内核线程，但在源码中 machine 绑定的线程实则是通过 clone 系统调用来创建的，该线程的调用栈分明是在用户地址空间分配的，不仅仅只在内核态运行，所以这种说法是不严谨的！ Go 的 GMP 模型示意图如下：\",\"在 Linux 平台下，一个 Go 程序（即一个进程，也可以理解为主线程）通过 execve 系统调用运行后，可以通过 clone 系统调用来新建多个线程，每个线程都与 runtime 中的一个 m 进行绑定，m 可以看作是系统线程的包装。\",\"Go 程序在运行的时候会创建多个 g，这些 g 分布在 runnext 和各种队列中，p 负责协调多个 m 和多个 g，也就是常说的 M：N 模型，g 在绑定 m 后（即获得了执行资源后）才能开始执行。\",\"这里的 M:N 是指 M 个 goroutine 运行在 N 个操作系统线程之上，内核负责对这 N 个操作系统线程进行调度，而这 N 个系统线程又负责对这 M 个 goroutine 进行调度和运行。\",\"另外提一点，m 从其它 p (非自身当前绑定的 p)的本地运行队列中盗取 goroutine 时的状态称为自旋状态。\",\"说明：\",\"在 Linux 平台下，进程和线程都是抽象出来的概念，进行和线程都由同一个 task_struct 数据结构表示，不同的是进程独有自己的资源和地址空间，而线程则与其它线程共享进程的资源和地址空间，因此可将进程当作主线程对待。\",\"G、M、P 是概念，在 runtime 的实现中分别对应 g、m、p 三个结构体，因此后面统一小写来表示。\"]},\"200\":{\"h\":\"流程剖析\",\"t\":[\"在介绍了一系列的前置知识后，我们正式进入 Hello World 的流程剖析。\",\"虽然只是一个简单的 Hello World 的流程剖析，但是会涉及大量知识点：\",\"Go runtime 实现；\",\"操作系统；\",\"plan9 汇编；\",\"。。。\",\"我们将使用 dlv 调试工具来一步步的解析 Hello World 运行流程，里面会涉及到大量 runtime 设计策略和实现细节，如果感到吃力，这很正常，请不要拘泥于细节，跳脱全局，整体把握。\",\"我们剖析的 Hello World 程序代码很简单，如下：\",\"package main import \\\"fmt\\\" func main() { fmt.Println(\\\"Hello World\\\") } \",\"编译该代码并使用 dlv 来调试：\",\"go build -o helloworld main.go dlv exec ./helloworld \",\"进入 dlv 交互界面后，使用 l(list) 命令查看程序当前运行点：\",\"(dlv) l > _rt0_amd64_linux() 5: #include \\\"textflag.h\\\" 6: 7: TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8 => 8: JMP _rt0_amd64(SB) // 入口 9: 10: TEXT _rt0_amd64_linux_lib(SB),NOSPLIT,$0 11: JMP _rt0_amd64_lib(SB) \",\"上面 => 箭头所指向的地方是程序的起始点，Go 程序的入口不是 main 函数，而在 runtime 中的 rt0_linux_amd64.s 汇编文件中，如下：\",\"TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8 JMP _rt0_amd64(SB) // 入口 \",\"_rt0_amd64_linux 函数有且只有一行代码，那就是跳转到 _rt0_amd64 函数。执行 si 命令，跟踪到这次代码跳转：\",\"(dlv) si > _rt0_amd64() 14: TEXT _rt0_amd64(SB),NOSPLIT,$-8 => 15: MOVQ 0(SP), DI // argc 16: LEAQ 8(SP), SI // argv 17: JMP runtime·rt0_go(SB) 18: \",\"_rt0_amd64 函数有如下两个工作：\",\"将程序运行时候的参数地址 argc，argv 拷贝到寄存器 DI，SI 上；\",\"跳转到核心启动函数 rt0_go 上。 继续使用多次 si 指令(后面将不会再说明 dlv 这些调试指令，而是直接看代码)，进入 rt0_go 函数，rt0_go 函数将会完成 Go 程序启动的绝大部分工作，是 Go 程序启动中最重要的函数，我们需要详细来分析它，首先是该函数的前面部分：\",\"TEXT runtime·rt0_go<ABIInternal>(SB),NOSPLIT,$0 MOVQ DI, AX // argc，将 argc 参数从 DI 拷贝到 AX MOVQ SI, BX // argv，将 argv 参数从 SI 拷贝到 BX SUBQ $(4*8+7), SP // 2args 2auto SP 移动，留出足够的栈空间 ANDQ $~15, SP // SP 栈顶寄存器，16 字节对齐，SSE 指令要求 MOVQ AX, 16(SP) // 将 argc 拷贝到 SP + 16 字节处 MOVQ BX, 24(SP) // 将 argv 拷贝到 SP + 24 字节处 // ... // ... \",\"_rt0_amd64 函数将 argc 和 argv 两个参数从栈中拷贝到 DI，SI 寄存器后，rt0_go 函数继续来处理这两个参数，将 DI、SI 中的参数拷贝到 AX，BX 中，调整 SP 的位置，并 16 字节对齐，然后再将 argc，argv 从寄存器拷贝回栈中。 在 Go runtime 中，g0 是一个特殊的 g，主要负责 goroutine 调度，每一个 m 都有一个 g0。m0 是 Go 程序的第一个工作线程，也就是进程(主线程)本身，g0 是 m0 的第一个 g，二者都是 runtime 包中的全局变量。\",\"rt0_go 函数处理好参数后，开始设置 g0 栈：\",\"TEXT runtime·rt0_go<ABIInternal>(SB),NOSPLIT,$0 // .... MOVQ $runtime·g0(SB), DI // g0 是全局变量，第一个 g；将 g0 的地址存储到 DI 中 LEAQ (-64*1024+104)(SP), BX // BX = SP - 64 * 1024 + 104 MOVQ BX, g_stackguard0(DI) // g0.g_stackguard0 = SP - 64 * 1024 + 104 MOVQ BX, g_stackguard1(DI) // g0.g_stackguard1 = SP - 64 * 1024 + 104 MOVQ BX, (g_stack+stack_lo)(DI) // g0.stack_lo = SP - 64 * 1024 + 104 MOVQ SP, (g_stack+stack_hi)(DI) // g0.stack_hi = SP // .... \",\"在调用 rt0_go 时，当前程序正在主线程上执行，因此 SP 寄存器指向的是主线程的调用栈，上面这段代码则是在主线程栈中分配一段内存当作 g0 栈，因此 g0 的调用栈实际就是线程调用栈，在 Go 中统称为系统栈。 接着是一大堆代码，我们挑重要的代码段说明：\",\"TEXT runtime·rt0_go<ABIInternal>(SB),NOSPLIT,$0 // .... LEAQ runtime·m0+m_tls(SB), DI // DI = &m0.tls，取 m0 的 tls 字段地址存储到 DI 寄存器 CALL runtime·settls(SB) // 调用 settls 设置线程局部存储，settls 的参数在 DI 寄存器中，简单的说，将 m0.tls 存储到线程局部变量 // ... // set the per-goroutine and per-mach \\\"registers\\\" get_tls(BX) // 获取 fs 段基址到 BX 寄存器 LEAQ runtime·g0(SB), CX // CX = g0 MOVQ CX, g(BX) // 将 g0 地址存储到 tls 中，即 m0.tls[0] = &g0 LEAQ runtime·m0(SB), AX // AX = m0 // save m->g0 = g0 MOVQ CX, m_g0(AX) // 将 g0 和 m0 相互绑定 // save m0 to g0->m MOVQ AX, g_m(CX) // .... \",\"tls 全称 Thread Local Storage 线程局部变量，是 Go 调度中十分重要的一个机制，这种变量仅当前线程可见。m 中有一个 tls 字段，如下：\",\"type m struct { tls [6]uintptr // thread-local storage (for x86 extern register) } \",\"代码说明如下： 代码第 3 行将 m0 的 tls 字段地址拷贝到 DI 寄存器中，然后调用 settls 函数将 tls 字段与线程局部变量绑定。\",\"代码第 7 行，调用 get_tls 获取线程局部变量地址并拷贝到 BX 寄存器中，然后将 g0 的地址拷贝到 CX 中。\",\"代码第 9 行，通过 MOVQ 指令将 g0 的地址拷贝到 m0 的 tls 字段中，这样在 m0 中就可以通过线程局部变量来获取 g0 地址。\",\"代码 13 ～ 15 行，将 m0 与 g0 相互绑定。\",\"继续看 rt0_go 函数的代码：\",\"TEXT runtime·rt0_go<ABIInternal>(SB),NOSPLIT,$0 // .... MOVL 16(SP), AX // copy argc AX = argc MOVL AX, 0(SP) // 将 AX 值拷贝到 SP 处，即栈顶 MOVQ 24(SP), AX // copy argv AX = argv MOVQ AX, 8(SP) // 将 AX 值拷贝到 SP + 8 处 CALL runtime·args(SB) // 初始化程序参数，处理参数和环境变量 CALL runtime·osinit(SB) // 初始化 os，获取硬件 CPU 核数 CALL runtime·schedinit(SB) // 重点：初始化调度器 // create a new goroutine to start program MOVQ $runtime·mainPC(SB), AX // entry 设置程序入口 AX = runtime.main PUSHQ AX // 入栈，传递参数 PUSHQ $0 // arg size，参数内存大小为 0，第一个参数最后入栈 CALL runtime·newproc(SB) // 新建 G，来启动 runtime.main，AX 寄存器上存储的是 runtime.main 函数的地址 POPQ AX // 两次出栈 POPQ AX // start this M CALL runtime·mstart(SB) // 启动 m0，开始等待空闲 G，进入调度循环，m0 是主线程(进程本身) \",\"这段代码中，rt0_go 主要做了以下三件事：\",\"runtime·schedinit：初始化调度器，如初始化栈，内存分配器，p 等；\",\"runtime·newproc 函数新建一个 g 来启动 runtime.main 方法；\",\"runtime·mstart 函数启动 m0 进入调度循环。 首先看 runtime·schedinit 函数：\",\"func schedinit() { // ... _g_ := getg() // 由编译器实现，见：cmd/compile/internal/amd64/ssa.go#712 sched.maxmcount = 10000 // M 的最大数量 moduledataverify() stackinit() // 初始化栈池 mallocinit() // 初始化 malloc，内存分配器 fastrandinit() // must run before mcommoninit mcommoninit(_g_.m, -1) // machine，初始化当前 m，即 m0，将主线程与 m0 绑定 cpuinit() // 初始化 cpu，must run before alginit alginit() // maps must not be used before this call modulesinit() // 模块初始化，provides activeModules typelinksinit() // 类型链接初始化，uses maps, activeModules itabsinit() // itabs 初始化，uses activeModules sigsave(&_g_.m.sigmask) // 存储 m0 的信号掩码 initSigmask = _g_.m.sigmask goargs() // 参数 goenvs() // 环境变量 parsedebugvars() // debug 参数 gcinit() // gc 初始化 lock(&sched.lock) sched.lastpoll = uint64(nanotime()) procs := ncpu // p 的数量默认 cpu 核数 // 获取 GOMAXPROCS 来设置 p 的个数 if n, ok := atoi32(gogetenv(\\\"GOMAXPROCS\\\")); ok && n > 0 { procs = n } // 调整 p 的个数 if procresize(procs) != nil { // 创建和初始化 allp throw(\\\"unknown runnable goroutine during bootstrap\\\") } unlock(&sched.lock) // World is effectively started now, as P's can run. 世界开始 worldStarted() // ... } \",\"schedinit 函数中给出了详细的注释，非主干的代码都已删除，说明如下： 代码第 3 行，通过 getg 函数获取当前 g，此时 g 其实就是 g0，getg 函数是由编译器来实现的，原理则是利用 tls 找到当前运行 m 中的 tls 字段，从而获取 g0 的地址。\",\"代码第 4 行，设置 p 的最大个数为 10000。\",\"代码第 10 行，初始化 m，此时的 m 其实就是 m0，因此 mcommoninit 函数的作用就是将 m0 与主线程绑定，此后可将 m 看作是工作线程。\",\"代码第 33 行，调用 procresize 函数，该函数功能很复杂，此时会创建和初始化所有的 p，即 allp，也可以调整 p 的个数。\",\"代码 39 行，m 开始工作，世界开始！\",\"然后看 runtime·newproc 函数，该函数会新建一个 g：\",\"func newproc(siz int32, fn *funcval) { argp := add(unsafe.Pointer(&fn), sys.PtrSize) // goroutine 函数的入口地址 gp := getg() // 获取当前 g pc := getcallerpc() // 获取 pc，即 eip 寄存器的值 // systemstack 属于编译器行为，调用当前函数不在当前 g 栈中进行，而是转移到 // 当前运行的线程栈(g0 栈)中运行，这个线程栈在用户空间分配 systemstack(func() { // 切换到系统栈 newg := newproc1(fn, argp, siz, gp, pc) // 在系统栈中新建 g _p_ := getg().m.p.ptr() runqput(_p_, newg, true) // 将 newg 加入到运行队列中 if mainStarted { wakep() // 唤醒 p } }) } \",\"newproc 函数接受两个参数，分别是 siz 和 fn，并新建 newg：\",\"siz：siz 是当前 g 传递给 newg 的参数大小；\",\"fn：newg 的入口函数。 代码第 2~4 行，获取入口函数地址、当前 g 和 pc 值。\",\"代码第 7 行，切换到系统栈，即 g0 栈。\",\"代码第 8 行，新建 g，即 newg。\",\"代码第 9 ～ 10 行，获取 newg 绑定的 p，并将 newg 加入到 p 的本地运行队列。\",\"代码第 12 行，唤醒 p，继续运行。\",\"newproc 函数中真正创建 g 的函数实际是 newproc1，该函数如下：\",\"func newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g { _g_ := getg() // g0 acquirem() // disable preemption because it can be holding p in a local var siz := narg siz = (siz + 7) &^ 7 _p_ := _g_.m.p.ptr() // 拿到 g0 对应的 p newg := gfget(_p_) // 从 p 的缓冲里面拿到一个空闲的 g，如果为 nil，则初始化 if newg == nil { newg = malg(_StackMin) // 新建一个 g，从进程堆内存上给其分配栈 casgstatus(newg, _Gidle, _Gdead) // 设置状态 allgadd(newg) // 将 g 加入 allg, publishes with a g->status of Gdead so GC scanner doesn't look at uninitialized stack. } // 调整 g 的栈顶指针 totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame totalSize += -totalSize & (sys.SpAlign - 1) // align to spAlign sp := newg.stack.hi - totalSize spArg := sp if narg > 0 { memmove(unsafe.Pointer(spArg), argp, uintptr(narg)) // 将参数从 caller g 栈拷贝到新 g 的栈中 } // 将新 g 的 sched 置 0 newg.sched.sp = sp newg.stktopsp = sp // 设置 newg 的最后执行函数是 goexit newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function newg.sched.g = guintptr(unsafe.Pointer(newg)) gostartcallfn(&newg.sched, fn) // 设置 g 的入口函数，设置 sched newg.gopc = callerpc newg.ancestors = saveAncestors(callergp) newg.startpc = fn.fn casgstatus(newg, _Gdead, _Grunnable) // 设置为可运行的状态 newg.goid = int64(_p_.goidcache) // 设置 gid _p_.goidcache++ releasem(_g_.m) // 解锁 m return newg } \",\"代码第 1 行，获取 g，其实就是 g0。 代码第 2 行，锁住 m 禁止抢占。\",\"代码第 7 ～ 12 行，从 p 的空闲池中取 g，如果没有则新建 g。\",\"代码第 14 ～ 17 行，设置 newg 的栈。\",\"代码第 20 行，拷贝 g 参数，即上面谈到的 siz 参数。\",\"代码第 23 ～ 33 行，设置 newg 数据，如 id，状态等。\",\"代码第 35 行，释放 m。\",\"最后我们看看 runtime·mstart 函数：\",\"func mstart() { _g_ := getg() // 当前 g osStack := _g_.stack.lo == 0 // 判断是否为系统栈 // 省略了一堆判断代码 mstart1() // 开始 m mexit(osStack) } \",\"可以发现 mstart 的核心在于 mstart1 函数，它才是 m 开始工作的真正入口点：\",\"func mstart1() { _g_ := getg() // 获取 g0 save(getcallerpc(), getcallersp()) // 保存 g0 的 pc，sp asminit() // asm 初始化，其实是个空函数 minit() // 信号相关的初始化 if _g_.m == &m0 { mstartm0() // 如果是 m0，则处理一些信号操作 } if fn := _g_.m.mstartfn; fn != nil { fn() // 调用 m 的 startfn } if _g_.m != &m0 { // 如果不是 m0，则获取下一个 p acquirep(_g_.m.nextp.ptr()) // 获取下一个 p，然后调度 _g_.m.nextp = 0 } schedule() // 开启调度，所以线程用户都是在调度循环 } \",\"代码第 1 行，获取 g，即 g0。 代码第 2 行，存储 g0 的 pc 和 sp 值。\",\"代码第 6 行，判断是否为 m0，如果是额外进行一些信号处理工作。\",\"代码第 9 行，判断是否有 mstartfn 函数(可以不予理会，不影响对流程的学习)，如果有则调用。\",\"代码第 16 行，m 开启调度循环。\",\"mstart1 的核心点在 schedule 函数，该函数永远不会返回，因此工作线程 m 实则一直在调度循环：\",\"func schedule() { _g_ := getg() // 获取 g0 top: // 注意，循环调度的关键 pp := _g_.m.p.ptr() // 获取 p pp.preempt = false // 标记为不可抢占 checkTimers(pp, 0) // 每次调度的时候，检查定时器 var gp *g var inheritTime bool if gp == nil { // 每调度 61 次，就去全局队列中获取 g，避免饥饿 if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 { lock(&sched.lock) gp = globrunqget(_g_.m.p.ptr(), 1) unlock(&sched.lock) } } if gp == nil { gp, inheritTime = runqget(_g_.m.p.ptr()) // 本地队列中获取 g } if gp == nil { // 从其它本地队列中偷 g gp, inheritTime = findrunnable() // blocks until work is available } if tryWakeP { wakep() } // 执行 g execute(gp, inheritTime) } \",\"schedule 函数实际上比较复杂，这里只贴出了主干部分，实际上为了调度循环，schedule 函数会不断的判断当前是否有 g 可运行，如果没有则 goto top 进行下一轮调度。 代码第 6 行，检查定时器，每次调度都会检查定时器，判断是否存在定时任务触发。\",\"代码第 10 ～ 17 行，每调度 61 次就会从全局队列中获取 g，避免全局队列中的 g 饿死。\",\"代码第 19 行，从 runnext 和本地队列中获取 g，如果有则执行。\",\"代码第 22 行，从其它 p 的本地队列中偷 g，其实在 findrunnable 中不会直接偷 g，而是再次判断本地队列和全局队列，实在是没有才去偷。\",\"代码第 28 行，执行 g。\",\"终于到执行 g 了，execute 会执行调度时找到的 g，代码如下：\",\"func execute(gp *g, inheritTime bool) { _g_ := getg() // 获取 g0，调度只在 g0 上执行 _g_.m.curg = gp // 设置 gp 为 curg gp.m = _g_.m // 设置 m casgstatus(gp, _Grunnable, _Grunning) // 设置 gp 状态 gp.waitsince = 0 gp.preempt = false // 不可抢占 gp.stackguard0 = gp.stack.lo + _StackGuard // 开始 g，见：TEXT runtime·gogo(SB) // g0 将 cpu 使用权交给 gp，实则就是切换寄存器上的值 // 重点：如果在程序开始阶段，g0 将 cpu 使用权交给了 runtime.main go gogo(&gp.sched) } \",\"代码第 3~8 行，设置 gp 的数据字段，如状态、不可抢占等。 代码第 12 行，切换上下文(寄存器值)， 当前运行的 g 将 CPU 使用权转交给 gp。\",\"上下文切换的 gogo 由汇编实现，代码如下：\",\"TEXT runtime·gogo(SB), NOSPLIT, $16-8 MOVQ buf+0(FP), BX // gobuf BX = gobuf MOVQ gobuf_g(BX), DX // DX = gbuf.sched.g MOVQ 0(DX), CX // make sure g != nil get_tls(CX) // CX = tls 获取当前 g MOVQ DX, g(CX) // tls = DX MOVQ gobuf_sp(BX), SP // restore SP MOVQ gobuf_ret(BX), AX MOVQ gobuf_ctxt(BX), DX MOVQ gobuf_bp(BX), BP MOVQ $0, gobuf_sp(BX) // clear to help garbage collector MOVQ $0, gobuf_ret(BX) MOVQ $0, gobuf_ctxt(BX) MOVQ $0, gobuf_bp(BX) MOVQ gobuf_pc(BX), BX // BX = pc JMP BX // 跳转到 pc \",\"gogo 函数通过 get_tls 获取到当前运行 g 然后通过 MOVQ 指令来交换上下文数据。 切换上下文后，程序将进入到 gp 的执行流程，在程序启动时，这个 gp 实际就是 runtime.main 函数，在 rt0_go 中有如下代码：\",\"MOVQ $runtime·mainPC(SB), AX // entry 设置程序入口 AX = runtime.main PUSHQ AX // 入栈，传递参 \",\"runtime.main 函数地址被当作参数，传递给了 newproc 函数，因此 gp 的开始函数就是 runtime.main。该函数代码如下：\",\"func main() { g := getg() if sys.PtrSize == 8 { maxstacksize = 1000000000 } else { maxstacksize = 250000000 } mainStarted = true if GOARCH != \\\"wasm\\\" { // no threads on wasm yet, so no sysmon atomic.Store(&sched.sysmonStarting, 1) systemstack(func() { // 在系统栈中新建一个 m，用于 sysmon，系统监控 newm(sysmon, nil, -1) }) } lockOSThread() // 锁住 m if g.m != &m0 { // runtime.main 必须由 m0 开始 throw(\\\"runtime.main not on m0\\\") } m0.doesPark = true doInit(&runtime_inittask) // Must be before defer. needUnlock := true defer func() { if needUnlock { unlockOSThread() // 释放锁 } }() gcenable() // 开启 gc main_init_done = make(chan bool) doInit(&main_inittask) close(main_init_done) needUnlock = false unlockOSThread() // 开始执行 main.main，main 包下的 main 函数 // main_main 会链接到程序的 main 函数 fn := main_main // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime fn() // 此处执行程序的 main 函数 exit(0) // 执行完毕后退出 for { // 如果退出失败，反复访问非法地址，造成程序 crash var x *int32 *x = 0 } } \",\"同样的，runtime.main 函数代码比较长，这里摘取了其中的主干部分： 代码第 9 ～ 14 行，开启监控线程，注意在系统栈调用。\",\"代码第 37~38 行，获取 main 包下的 main 函数地址，然后调用该函数。\",\"终于，程序进入到了 main.main 函数，也就是：\",\"package main import \\\"fmt\\\" func main() { fmt.Println(\\\"Hello World\\\") } \",\"然后，我们可以看到熟悉的 Hello World 了。Hello World 的运行流程到此结束了！ 流程图如下：\",\"这里需要说明几个点：\",\"main 包下的 main 函数并没有新建 g，而是被 runtime.main 的 g 来执行。\",\"如果 m 没有找到可运行 g 那么就会进入休眠，等待被唤醒。\",\"每个工作线程一直都在执行 schedule 函数，即调度循环。\"]},\"201\":{\"h\":\"热点问题\"},\"202\":{\"h\":\"goexit0 是如何嵌入到非 main goroutine 中的？\",\"t\":[\"在 runtime/proc.go:4066 的函数 newproc1 中，新建的 g 的 sched.pc 字段被设置为 goexit：\",\"// 将新 g 的 sched 置 0 memclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched)) newg.sched.sp = sp newg.stktopsp = sp // 设置 newg 的最后执行函数是 goexit newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function newg.sched.g = guintptr(unsafe.Pointer(newg)) gostartcallfn(&newg.sched, fn) // 设置 g 的入口函数，设置 sched \",\"这样在 goroutine 完成使命时，会调用 goexit 函数。\"]},\"203\":{\"h\":\"m 是如何与系统线程绑定的？\",\"t\":[\"答案在 newosproc 函数中，该函数有多种实现，如果是 linux，那么在 runtime/os_linux.go 下面，如下（省略了部分代码）：\",\"func newosproc(mp *m) { stk := unsafe.Pointer(mp.g0.stack.hi) var oset sigset sigprocmask(_SIG_SETMASK, &sigset_all, &oset) // 通过 clone 系统调用新建线程，注意 cloneFlags 中共享内存与字段，故是线程 // 传入 mp 即 m，g0 和 mstart 作为线程的启动函数，因此线程创建后会运行 mstart 函数，然后开启调度循环 // 注意：m 可以有 mstartfn，所以 mstart 可能不是立马执行 ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart))) sigprocmask(_SIG_SETMASK, &oset, nil) } \",\"在 linux 下，m 被初始化后，通过系统调用 clone 传入到新建线程中，此后系统线程就与 m 进行了绑定。\"]},\"204\":{\"h\":\"参考链接\",\"t\":[\"Go 几个重要的汇编\",\"详尽干货！从源码角度看 Golang 的调度（上）\",\"详尽干货！从源码角度看 Golang 的调度（下）\",\"深入 golang runtime 的调度\",\"我可能并不会使用 golang goroutine\",\"goroutine 调度器\",\"汇编函数 mcall systemstack asmcgocall syscall gogo()\",\"System call\",\"TLS variable in Linux\",\"Scalable Go Scheduler Design Doc\",\"很有用的 FS 寄存器\"]},\"205\":{\"h\":\"go 的两个黑魔法技巧\",\"t\":[\"最近，在写 Go 代码的时候，发现了其特别有意思的两个奇技淫巧，于是写下这篇 文章和大家分享一下。\"]},\"206\":{\"h\":\"魔法 1：调用 runtime 中的私有函数\",\"t\":[\"按照 Go 的编译约定，代码包内以小写字母开头的函数、变量是私有的：\",\"package test // 私有 func abs() {} // 公共 func Abs() {} \",\"对于 test 包中 abs 函数只能在包内调用，而 Abs 函数却可以在其它包中 导入后使用。\",\"私有变量、方法的意义在于封装：控制内部数据、保证外部交互的一致性。\",\"这样既能促进系统运行的可靠性，也能减少使用者的信息负载。\",\"这样的规定对设计、封装良好的包是友好的，但并不是每个人都有这样的能力，另外 对于一些特殊的函数，如：runtime 中的 memmove 函数，在有些场景下，确实是需要的。\",\"因此 Go 在程序链接阶段给开发者打开了一扇窗，即可以通过 go:linkname 指令来 链接包内的私有函数。\"]},\"207\":{\"h\":\"memmove\",\"t\":[\"以 memmove 为例， 如下：\",\"func memmove(to, from unsafe.Pointer, n uintptr) \",\"memmove 作为 runtime 中的私有函数，用于任意数据之间的内存拷贝，无视类型信息，直接操作 内存，这样的操作在 Go 中虽然是不提倡的，但是用好了，却也是一把利刃。\",\"新建一个 go 文件，如 runtime.go，并加上如下内容：\",\"//go:noescape //go:linkname memmove runtime.memmove //goland:noinspection GoUnusedParameter func memmove(to unsafe.Pointer, from unsafe.Pointer, n uintptr) \",\"把视角放到 go:linkname 指令上，该指令接受两个参数：\",\"memmove：当前函数名称；\",\"runtime.memmove：对应链接的函数的路径，报名+函数名。\",\"这样，编译器在做链接时就会将当前的 memmove 函数链接到 runtime 中的 memmove 函数， 我们就能使用该函数了。\",\"在平常写代码的时候，我们经常性地需要拷贝字节切片、字符串之间的数据。比如将数据从切片 1 拷贝到切片 2，使用 memmove 代码如下：\",\"// runtime.go type GoSlice struct { Ptr unsafe.Pointer Len int Cap int } // runtime_test.go func Test_memmove(t *testing.T) { src := []byte{1, 2, 3, 4, 5, 6} dest := make([]byte, 10, 10) spew.Dump(src) spew.Dump(dest) srcp := (*GoSlice)(unsafe.Pointer(&src)) destp := (*GoSlice)(unsafe.Pointer(&dest)) memmove(destp.Ptr, srcp.Ptr, unsafe.Sizeof(byte(0))*6) spew.Dump(src) spew.Dump(dest) } \",\"字节切片([]byte)在内存中的形态如 GoSlice 结构体来所示，Len、Cap 分别表示切片长度、容量，字段 Ptr 指向真实的字节数据。\",\"将两个切片的数据指针以及拷贝长度作为参数传入 memmove，数据就能从 src 拷贝到 dest。运行结果如下：\",\"=== RUN Test_memmove # 拷贝之前 ([]uint8) (len=6 cap=6) { 00000000 01 02 03 04 05 06 |......| } ([]uint8) (len=10 cap=10) { 00000000 00 00 00 00 00 00 00 00 00 00 |..........| } # 拷贝之后 ([]uint8) (len=6 cap=6) { 00000000 01 02 03 04 05 06 |......| } ([]uint8) (len=10 cap=10) { 00000000 01 02 03 04 05 06 00 00 00 00 |..........| \",\"显然，对于切片之间的数据拷贝，标准库提供的 copy 函数要更加方便一些：\",\"func Test_copy(t *testing.T) { src := []byte{1, 2, 3, 4, 5, 6} dest := make([]byte, 10, 10) spew.Dump(src) spew.Dump(dest) copy(dest, src) spew.Dump(src) spew.Dump(dest) } \",\"这样也能达到一样的效果，memmove 更加适合字符串(string)和数组切片之间的数据拷贝场景，如下：\",\"// runtime.go type GoString struct { Ptr unsafe.Pointer Len int } // runtime_test.go func Test_memmove(t *testing.T) { str := \\\"pedro\\\" // 注意：这里的len不能为0，否则数据没有分配，就无法复制 data := make([]byte, 10, 10) spew.Dump(str) spew.Dump(data) memmove((*GoSlice)(unsafe.Pointer(&data)).Ptr, (*GoString)(unsafe.Pointer(&str)).Ptr, unsafe.Sizeof(byte(0))*5) spew.Dump(str) spew.Dump(data) } \",\"类似地，GoString 是字符串在内存中的表达形态，通过 memmove 函数就能快速的将字符数据从 字符串拷贝到切片，反之亦然，运行结果如下：\",\"# 拷贝之前 (string) (len=5) \\\"pedro\\\" ([]uint8) (len=10 cap=10) { 00000000 00 00 00 00 00 00 00 00 00 00 |..........| } # 拷贝之后 (string) (len=5) \\\"pedro\\\" ([]uint8) (len=10 cap=10) { 00000000 70 65 64 72 6f 00 00 00 00 00 |pedro.....| } \"]},\"208\":{\"h\":\"growslice\",\"t\":[\"切片是 Go 中最常用的数据结构之一，对于切片扩容，Go 只提供了 append 函数来隐式的扩容，但内部是通过调用 runtime 中的 growslice 函数来实现的：\",\"func growslice(et *_type, old slice, cap int) slice \",\"growslice 函数接受 3 个参数：\",\"et：切片容器中的数据类型，如 int，_type 可以表示 Go 中的任意类型；\",\"old：旧切片；\",\"cap：扩容后的切片容量。\",\"扩容成功后，返回新的切片。\",\"同样地，使用go:linkname来链接 runtime 中的 growslice 函数，如下：\",\"// runtime.go type GoType struct { Size uintptr PtrData uintptr Hash uint32 Flags uint8 Align uint8 FieldAlign uint8 KindFlags uint8 Traits unsafe.Pointer GCData *byte Str int32 PtrToSelf int32 } // GoEface 本质是 interface type GoEface struct { Type *GoType Value unsafe.Pointer } //go:linkname growslice runtime.growslice //goland:noinspection GoUnusedParameter func growslice(et *GoType, old GoSlice, cap int) GoSlice \",\"growslice 函数的第一个参数 et 实际是 Go 对所有类型的一个抽象数据结构——GoType。\",\"这里引入了 Go 语言实现机制中的两个重要数据结构：\",\"GoEface：empty interface，即 interface{}，空接口；\",\"GoType：Go 类型定义数据结构，可用于表示任意类型。\",\"关于 GoEface、GoIface、GoType、GoItab 都是 Go 语言实现的核心数据结构，这里的内容很多， 感兴趣的可以参考这里 。\",\"这样，我们就能通过调用 growslice 函数来对切片进行手动扩容了，如下：\",\"// runtime.go func UnpackType(t reflect.Type) *GoType { return (*GoType)((*GoEface)(unsafe.Pointer(&t)).Value) } // runtime_test.go func Test_growslice(t *testing.T) { assert := assert.New(t) var typeByte = UnpackType(reflect.TypeOf(byte(0))) spew.Dump(typeByte) dest := make([]byte, 0, 10) assert.Equal(len(dest), 0) assert.Equal(cap(dest), 10) ds := (*GoSlice)(unsafe.Pointer(&dest)) *ds = growslice(typeByte, *ds, 100) assert.Equal(len(dest), 0) assert.Equal(cap(dest), 112) } \",\"由于 growslice 的参数et类型在 runtime 中不可见，我们重新定义了 GoType 来表示， 并且通过反射的机制来拿到字节切片中的 GoType，然后调用 growslice 完成扩容工作。\",\"运行程序：\",\"--- PASS: Test_growslice (0.00s) PASS \",\"注意一个点，growslice 传入的 cap 参数是 100，但是最后的扩容结果却是 112， 这个是因为 growslice 会做一个 roundupsize 处理，感兴趣的同学可以参考这里 。\"]},\"209\":{\"h\":\"魔法 2：调用 C/汇编函数\",\"t\":[\"下面，我们再来看 Go 的另外一个更加有趣的黑魔法。\"]},\"210\":{\"h\":\"cgo\",\"t\":[\"通过 cgo，我们可以很方便地在 Go 中调用 C 代码，如下：\",\"/* #include <stdio.h> #include <unistd.h> static void* Sbrk(int size) { void *r = sbrk(size); if(r == (void *)-1){ return NULL; } return r; } */ import \\\"C\\\" import ( \\\"fmt\\\" ) func main() { mem := C.Sbrk(C.int(100)) defer C.free(mem) fmt.Println(mem) } \",\"运行程序，会得到如下输出：\",\"0xba00000 \",\"cgo 是 Go 与 C 之间的桥梁，让 Go 可以享受 C 语言强大的系统编程能力，比如这里的 sbrk 会直接向 进程申请一段内存，而这段内存是不受 Go GC 的影响的，因此我们必须手动地释放(free)掉它。\",\"在一些特殊场景，比如全局缓存，为了避免数据被 GC 掉而导致缓存失效，那么可以尝试这样使用。\",\"当然，这还不够 tricky，别忘了，C 语言是可以直接内联汇编的，同样地，我们也可以在 Go 中内联汇编 试试，如下：\",\"/* #include <stdio.h> static int Add(int i, int j) { int res = 0; __asm__ (\\\"add %1, %2\\\" : \\\"=r\\\" (res) : \\\"r\\\" (i), \\\"0\\\" (j) ); return res; } */ import \\\"C\\\" import ( \\\"fmt\\\" ) func main() { r := C.Add(C.int(2022), C.int(18)) fmt.Println(r) } \",\"运行程序，可以得到如下输出：\",\"2040 \",\"cgo 虽然给了我们一座桥梁，但付出的代价也不小，具体的缺点可以参考这里。\",\"对 cgo 感兴趣的同学可以参考这里 。\"]},\"211\":{\"h\":\"汇编\"},\"212\":{\"h\":\"isspace\",\"t\":[\"那么有没有一种方式可以回避掉 cgo 的缺点，答案自然是可以的。\",\"这个方式其实很容易想到：不使用 cgo，而是使用 plan9，也就是 Go 支持的汇编语言。\",\"当然我们不是直接去写汇编，而是将 C 编译成汇编，然后再转化成 plan9 与 .go 代码一起编译。\",\"编译的过程如下图所示：\",\"而且 C 本身就是汇编的高级抽象，作为目前最强劲性能的存在，这种方式不仅回避了 cgo 的性能问题， 反而将程序性能提高了。过程如下：\",\"首先，我们定义一个简单的 C 语言函数 isspace(判断字符为空)：\",\"// ./inner/op.h #ifndef OP_H #define OP_H char isspace(char ch); // ./inner/op.c #include \\\"op.h\\\" char isspace(char ch) { return ch == ' ' || ch == '\\\\r' || ch == '\\\\n' | ch == '\\\\t'; } \",\"然后，使用 clang 将其编译为汇编(注意：是 clang)：\",\"$ clang -mno-red-zone -fno-asynchronous-unwind-tables -fno-builtin -fno-exceptions \\\\ -fno-rtti -fno-stack-protector -nostdlib -O3 -msse4 -mavx -mno-avx2 -DUSE_AVX=1 \\\\ -DUSE_AVX2=0 -S ./inner/*.c \",\"编译成功后，会在 inner 文件夹下生成一个 op.s 汇编文件，大致如下：\",\" .section __TEXT,__text,regular,pure_instructions .build_version macos, 11, 0 .globl _isspace ## -- Begin function isspace .p2align 4, 0x90 _isspace: ## @isspace ## %bb.0: pushq %rbp movq %rsp, %rbp movb $1, %al cmpb $13, %dil je LBB0_3 \",\"clang 默认生成的汇编是 AT&T 格式的，这种汇编 Go 是无法编译的(gccgo 除外)，因此这里有一步转换工作。\",\"负责将 AT&T 汇编转化成 plan9 汇编，而二者之间的语法差异其实是比较大的，因此这里借助一个转换asm2asm 工具 来完成。\",\"将 asm2asm clone 到本地，然后运行：\",\"$ git clone https://github.com/chenzhuoyu/asm2asm $ ./tools/asm2asm.py ./op.s ./inner/op.s \",\"执行后，会报错。原因在于，Go 对于 plan9 汇编文件需要一个对应的 .go 声明文件来对应。\",\"我们在 ./inner/op.h 文件中定义了 isspace 函数，因此需要新建一个同名的 op.go 文件来声明这个函数：\",\"//go:nosplit //go:noescape //goland:noinspection GoUnusedParameter func __isspace(ch byte) (ret byte) \",\"然后再次运行 asm2asm 工具来生成汇编：\",\"$ ./tools/asm2asm.py ./op.s ./inner/op.s $ tree . . |__ inner | |__ op.c | |__ op.h | |__ op.s |__ op.go |__ op.s |__ op_subr.go \",\"asm2asm 会生成两个文件：op.s 和 op_subr.go：\",\"op.s：翻译而来的 plan9 汇编文件；\",\"op_subr.go：函数调用辅助文件。\",\"生成后，op.go 中的 __isspace 函数就能顺利的链接上对应的汇编代码，并运行，如下：\",\"func Test___isspace(t *testing.T) { type args struct { ch byte } tests := []struct { name string args args wantRet byte }{ { name: \\\"false\\\", args: args{ch: '0'}, wantRet: 0, }, { name: \\\"true\\\", args: args{ch: '\\\\n'}, wantRet: 1, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if gotRet := __isspace(tt.args.ch); gotRet != tt.wantRet { t.Errorf(\\\"__isspace() = %v, want %v\\\", gotRet, tt.wantRet) } }) } } // output === RUN Test___isspace === RUN Test___isspace/false === RUN Test___isspace/true --- PASS: Test___isspace (0.00s) --- PASS: Test___isspace/false (0.00s) --- PASS: Test___isspace/true (0.00s) PASS \",\"__isspace 顺利运行，并通过了单测。\"]},\"213\":{\"h\":\"u32toa_small\",\"t\":[\"一个 isspace 函数有些简单，无法完全发挥出汇编的能力，下面我们来看一个稍微复杂一点的例子：将整数转化为字符串。\",\"在 Go 中，整数转化为字符串的方式有多种，比如说：strconv.Itoa 函数。\",\"这里，我选择用 C 来写一个简单的整数转字符串的函数：u32toa_small，然后将其编译为汇编代码供 Go 调用，并看看二者之间的性能差异。\",\"u32toa_small 的实现也比较简单，使用查表法(strconv.Itoa 使用的也是这种方法)，如下：\",\"#include \\\"op.h\\\" static const char Digits[200] = { '0', '0', '0', '1', '0', '2', '0', '3', '0', '4', '0', '5', '0', '6', '0', '7', '0', '8', '0', '9', '1', '0', '1', '1', '1', '2', '1', '3', '1', '4', '1', '5', '1', '6', '1', '7', '1', '8', '1', '9', '2', '0', '2', '1', '2', '2', '2', '3', '2', '4', '2', '5', '2', '6', '2', '7', '2', '8', '2', '9', '3', '0', '3', '1', '3', '2', '3', '3', '3', '4', '3', '5', '3', '6', '3', '7', '3', '8', '3', '9', '4', '0', '4', '1', '4', '2', '4', '3', '4', '4', '4', '5', '4', '6', '4', '7', '4', '8', '4', '9', '5', '0', '5', '1', '5', '2', '5', '3', '5', '4', '5', '5', '5', '6', '5', '7', '5', '8', '5', '9', '6', '0', '6', '1', '6', '2', '6', '3', '6', '4', '6', '5', '6', '6', '6', '7', '6', '8', '6', '9', '7', '0', '7', '1', '7', '2', '7', '3', '7', '4', '7', '5', '7', '6', '7', '7', '7', '8', '7', '9', '8', '0', '8', '1', '8', '2', '8', '3', '8', '4', '8', '5', '8', '6', '8', '7', '8', '8', '8', '9', '9', '0', '9', '1', '9', '2', '9', '3', '9', '4', '9', '5', '9', '6', '9', '7', '9', '8', '9', '9', }; // < 10000 int u32toa_small(char *out, uint32_t val) { int n = 0; uint32_t d1 = (val / 100) << 1; uint32_t d2 = (val % 100) << 1; /* 1000-th digit */ if (val >= 1000) { out[n++] = Digits[d1]; } /* 100-th digit */ if (val >= 100) { out[n++] = Digits[d1 + 1]; } /* 10-th digit */ if (val >= 10) { out[n++] = Digits[d2]; } /* last digit */ out[n++] = Digits[d2 + 1]; return n; } \",\"然后在 op.go 中加入对应的 __u32toa_small 函数：\",\"// < 10000 //go:nosplit //go:noescape //goland:noinspection GoUnusedParameter func __u32toa_small(out *byte, val uint32) (ret int) \",\"使用 clang 重新编译 op.c 文件，并用 asm2asm 工具来生成对应的汇编代码(节选部分)：\",\"_u32toa_small: BYTE $0x55 // pushq %rbp WORD $0x8948; BYTE $0xe5 // movq %rsp, %rbp MOVL SI, AX IMUL3Q $1374389535, AX, AX SHRQ $37, AX LEAQ 0(AX)(AX*1), DX WORD $0xc06b; BYTE $0x64 // imull $100, %eax, %eax MOVL SI, CX SUBL AX, CX ADDQ CX, CX CMPL SI, $1000 JB LBB1_2 LONG $0x60058d48; WORD $0x0000; BYTE $0x00 // leaq $96(%rip), %rax /* _Digits(%rip) */ MOVB 0(DX)(AX*1), AX MOVB AX, 0(DI) MOVL $1, AX JMP LBB1_3 \",\"然后在 Go 中调用该函数：\",\"func Test___u32toa_small(t *testing.T) { var buf [32]byte type args struct { out *byte val uint32 } tests := []struct { name string args args wantRet int }{ { name: \\\"9999\\\", args: args{ out: &buf[0], val: 9999, }, wantRet: 4, }, { name: \\\"1234\\\", args: args{ out: &buf[0], val: 1234, }, wantRet: 4, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { got := __u32toa_small(tt.args.out, tt.args.val) assert.Equalf(t, tt.wantRet, got, \\\"__u32toa_small(%v, %v)\\\", tt.args.out, tt.args.val) assert.Equalf(t, tt.name, string(buf[:tt.wantRet]), \\\"ret string must equal name\\\") }) } } \",\"测试成功，__u32toa_small 函数不仅成功运行，而且通过了测试。\",\"最后，我们来做一个性能跑分看看 __u32toa_small 和 strconv.Itoa 之间的性能差异：\",\"func BenchmarkGoConv(b *testing.B) { val := int(rand.Int31() % 10000) b.ResetTimer() for n := 0; n < b.N; n++ { strconv.Itoa(val) } } func BenchmarkFastConv(b *testing.B) { var buf [32]byte val := uint32(rand.Int31() % 10000) b.ResetTimer() for n := 0; n < b.N; n++ { __u32toa_small(&buf[0], val) } } \",\"使用 go test -bench 运行这两个性能测试函数，结果如下：\",\"BenchmarkGoConv BenchmarkGoConv-12 60740782 19.52 ns/op BenchmarkFastConv BenchmarkFastConv-12 122945924 9.455 ns/op \",\"从结果中，可以明显看出 __u32toa_small 优于 Itoa，大概有一倍的提升。\"]},\"214\":{\"h\":\"总结\",\"t\":[\"至此，Go 的两个黑魔法技巧已经介绍完毕了，感兴趣的同学可以自己实践看看。\",\"Go 的黑魔法一定程度上都使用了 unsafe 的能力，这也是 Go 不提倡的，当然使用 unsafe 其实就和普通的 C 代码编写一样，因此也无需有太强的心理负担。\",\"实际上，上述的两种方法都被 sonic 用在了生产环境上，而且带来的很大的性能提升，节约大量资源。\",\"因此，当 Go 现有的标准库无法满足你的需求时，不要受到语言本身的限制，而是用虽然少见但有效的方式去解决 它。\",\"希望上面的两个黑魔法能带你对 Go 不一样的认识。\"]},\"215\":{\"h\":\"参考资料\",\"t\":[\"https://github.com/bytedance/sonic\",\"https://juejin.cn/post/6974581261192921095\",\"https://www.keil.com/support/man/docs/armclang_intro/armclang_intro_ddx1471430827125.htm\",\"https://karthikkaranth.me/blog/calling-c-code-from-go/\",\"https://chai2010.cn/advanced-go-programming-book/ch2-cgo/ch2-03-cgo-types.html\",\"https://blog.csdn.net/lastsweetop/article/details/78830772\"]},\"216\":{\"h\":\"go 另外几个黑魔法技巧\",\"t\":[\"在上一篇文章中，笔者分享了 go 中两个有意思的技巧。\",\"而最近一段时间，笔者重新梳理了一下 go 知识点，并深入地看看了它的源码，在实践中又有了新的沉淀，于是写下这篇文章和大家分享一下。\"]},\"217\":{\"h\":\"魔法 1：最小化运行时(minimal runtime)\",\"t\":[\"我们知道，go 有一层很重的运行时(runtime)，包括内存管理、goroutine 调度等重要组件；这些组件极大地方便了应用程序的开发和迭代，但也带来了一些问题，比如：\",\"Go 程序自动接管了内存，并自带 GC，使我们无法直接操纵内存；\",\"Go 程序自动化了内存、调度等重要模块，但这些组件本身就占用了一定资源；\",\".....\",\"对于应用程序而言，runtime 是良药，能够很大程度上简化机械工作，让开发者集中于核心业务开发和迭代上，但对于一些其它场景，比如操作系统，那么 runtime 会严重破坏其核心资源管理能力，那么有没有方案能让 go 摆脱掉 runtime 的束缚，使其成为一个真正的系统级编程语言呢？\",\"肯定是有的，任何一个可执行文件而言，本质上都是目标文件被链接后生成的（以下均以 Linux 作为实践平台）。\",\"go 编译器默认编译生成的文件，其程序的入口是 runtime 包中的 _rt0_amd64_linux 函数：\",\"TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8 JMP _rt0_amd64(SB) TEXT _rt0_amd64(SB),NOSPLIT,$-8 MOVQ 0(SP), DI // argc LEAQ 8(SP), SI // argv JMP runtime·rt0_go(SB) \",\"经 _rt0_amd64_linux 入口跳转到 _rt0_amd64、 rt0_go；在 rt0_go 中，go 程序会初始化一系列的内存、调度、GC 等资源，如下图所示：\",\"每个 go 程序都会走这么一遭，这也是其 runtime 很重的原因；想要规避掉 runtime，那么最好的方法肯定是从根源入手，将程序入口 _rt0_amd64_linux 换掉，不再进入 rt0_go 函数，也就不会初始化 runtime，那么自然就能摆脱掉 runtime。\",\"既然有了正确的思路，那么实现起来也就不会难了。\",\"首先，我们从一个简单的 Hello Runtime! 入手：\",\"// .... func main() { fmt.Println(\\\"Hello Runtime!\\\") } \",\"绝大多数情况下，我们会选择 go run 来运行这个简单的程序，或者使用 go build 来直接将其编译为可执行文件。\",\"但这种做法无疑屏蔽了太多的细节，因此我们选择先编译、后链接的“笨”方法来做：\",\"$ go tool compile -p main -o main.o main.go $ go tool pack c main.a main.o # internal 表示使用go内置的链接器 $ go tool link -linkmode=internal main.a \",\"使用工具 compile 将 main.go 编译为目标文件 main.o；\",\"使用工具 pack 将目标文件 main.o 打包为 main.a；\",\"使用工具 link 将打包文件链接，生成可执行文件 a.out。\",\"这 3 个命令分别生成了目标文件 main.o，归档文件 main.a，以及可执行文件 a.out：\",\"$ tree -L 1 . . |__a.out |__main.a |__main.go |__main.o \",\"运行 a.out：\",\"$ ./a.out Hello Runtime! \",\"这样就展示了一个程序编译、生成到运行的全过程。\",\"为了改变程序的入口，使其摆脱 runtime，我们可以这样做：\",\"定义一个新的函数，比如：entry；\",\"指定链接生成可执行文件时，将 entry 作为程序入口。\",\"改造 main.go 文件，新增一个 entry 函数：\",\"//go:nosplit //go:noescape func entry() func main() { fmt.Println(\\\"Hello Runtime!\\\") entry() } \",\"这里，我们没有删掉原来的代码，而是直接新增了一个 entry 函数，并在 main 函数中调用，是为了更好的展示入口函数的作用。\",\"entry 函数体定义在一个单独的汇编文件中，如下：\",\"# linux 下 # main_linux_amd64.s TEXT ·entry(SB), $0-0 MOVL $33, DI MOVL $60, AX SYSCALL RET \",\"entry 的功能也很简单，系统调用 exit 退出程序，并返回退出码 33。\",\"由于很多使用 MAC 的同学，其对应的 entry 函数略有不同，如下：\",\"# mac 下 # main_darwin_amd64.s TEXT ·entry(SB), $0-0 MOVL $33, DI MOVL $(0x2000000+1), AX SYSCALL RET \",\"然后，我们需要在链接时指定程序入口为 entry，如下：\",\"$ go tool asm -gensymabis -o symabis main_linux_amd64.s $ go tool compile -symabis symabis -p main -o x1.o main.go $ go tool asm -o x2.o main_linux_amd64.s $ go tool pack c x.a x1.o x2.o $ go tool link -linkmode=internal -E 'main.entry' x.a \",\"使用 asm 工具为 main_linux_amd64.s 生成符号文件；\",\"使用 compile 工具编译 main.go 文件，生成 x1.o 目标文件；\",\"使用 asm 工具为 main_linux_amd64 生成目标文件 x2.o；\",\"使用 pack 工具打包 x1.o，x2.o 并生成 x.a 归档文件；\",\"使用 link 工具链接生成 a.out 可执行文件。\",\"go 链接器提供 E 参数来设置执行文件入口，这里我们指定 main.entry 为程序入口，这样链接生成的文件就不会再走原来的执行流，执行结果如下：\",\"$ ./a.out $ echo $? 33 \",\"从运行结果来看，程序并没有调用 Println 函数，而是直接从 entry 进入，调用 exit 后退出程序，退出码为 33。\",\"这样，程序也不会进入 rt0_go 中，不会初始化 runtime 资源，从而达到规避 runtime 的作用。\",\"这种方式虽然不会初始化 runtime，但由于 go 编译器的默认行为，runtime 代码也会被打包进执行文件，因此笔者才没有说丢掉 runtime，而是最小化 runtime。\"]},\"218\":{\"h\":\"魔法 2：即时编译 JIT(just-in-time)\",\"t\":[\"目前很多脚本语言都加入了即时编译的新特性。即时编译的原理很简单，那就是在运行时生成机器码，然后执行，达到提升程序性能的效果。\",\"Python 脚本是通过虚拟机(VM)以字节码的方式解释执行的。一个简单的字节码样例大致如下：\",\">>> def add(x, y): ... return x + y >>> import dis >>> dis.dis(add) 2 0 LOAD_FAST 0 (x) 2 LOAD_FAST 1 (y) 4 BINARY_ADD 6 RETURN_VALUE \",\"这里，我们定义了一个简单的 add 函数，并通过 dis 模块来查看 add 函数对应的字节码。Python 虚拟机是一个典型的栈机，其字节码执行都是基于栈来执行的，以 add 为例：\",\"0 LOAD_FAST 0 (x) 2 LOAD_FAST 1 (y) 4 BINARY_ADD 6 RETURN_VALUE \",\"LOAD_FAST指令会从局部变量中拿到变量值并入栈，这里会将 x，y 入栈，然后调用 BINARY_ADD 指令将栈顶的两个值出栈、相加后将结果再入栈，最后调用 RETURN_VALUE指令将栈顶值返回。\",\"如下图所示：\",\"与直接运行机器码相比，字节码执行具有良好的跨平台性，一次编译，处处运行（装有 Python 虚拟机的前提下），但也损耗了一定的性能。\",\"而即时编译会在程序运行时，将字节码编译为机器码运行，一定程度上补偿了这种损耗。\",\"下面，我们就用 go 来实现一个简单的 Python JIT 编译器来领略即时编译的魅力。\",\"即时编译原理虽然简单明了，但实现却很复杂，我们只会实现一个简单的 JIT 编译器，它会将类似下面的 Python 函数即时编译为机器码，然后写入内存并执行：\",\"def foo(x, y): return x * x - y * y \",\"这个函数会进行简单的四则运算，并将结果返回。其对应的字节码如下：\",\"0 LOAD_FAST 0 (x) 2 LOAD_FAST 0 (x) 4 BINARY_MULTIPLY 6 LOAD_FAST 1 (y) 8 LOAD_FAST 1 (y) 10 BINARY_MULTIPLY 12 BINARY_SUBTRACT 14 RETURN_VALUE \",\"笔者没有写代码去实现如何将 Python 代码翻译为字节码，这些编译器前端知识感兴趣的同学可以自行去查阅词法分析、语法分析等资料，或者直接去阅读 CPython 源码。\",\"想要将字节码直接翻译为机器码可不简单，我们需引入中间代码（IR，Intermediate Representation），即先将字节码翻译为 IR，然后再将 IR 翻译为机器码。\",\"很多同学会不会疑惑多此一举？其实 IR 的存在是非常有必要的，几乎所有的编译器都有 IR，甚至可能不止一种 IR，至于 IR 的作用，在后文中笔者带领大家来体会。\",\"我们以 foo 函数为例，看看如何将其字节码翻译为 IR。foo 的第一条字节码指令：\",\"LOAD_FAST 0 (x) \",\"LOAD_FAST会从局部变量中拿到数据，然后推入栈，LOAD_FAST 指令附带一个参数，即后面的 0，表示第 0 个局部变量，也就是 x 参数。\",\"使用寄存器来暂存局部变量，我们可以设计出类似下面的 IR：\",\"push rax \",\"与绝大多数汇编一样，这里将一段内存看作一个栈来操作，push 表示入栈，即将 rax 入栈。反过来，pop 表示出栈：\",\"pop rdi \",\"这里将栈顶的值推出后，复制到 rdi。当然对于一些计算操作，比如加法：\",\"add rdi rsi # rdi = rdi + rsi \",\"会将两个寄存器的值相加后再置入第一个寄存器中。每一个指令只做一件小事情，比如赋值、四则运算等等，类似这样的 IR 指令称为SSA。\",\"另外，我们的 IR 指令一般都是一个操作命令，一个操作数或者两个操作数，比如：\",\"mov rax 100 push rax \",\"为了保证统一，我们将所有 IR 指令严格限制在两个操作数中，如果不足两个，则添加一个 none，如下；\",\"mov rax 100 push rax none \",\"这样的指令形式被称为 Three-address code(TAC)。\",\"SSA 和 TAC 都有严格的定义，这里只做了简单说明，有兴趣的同学可以点开链接查看。\",\"你肯定会眼熟，这不就是汇编吗？是的，我们的终极目标是翻译成机器码，而汇编是目前对机器码最好的解释码，因此我们的 IR 差不多就是一种汇编方言(Dialect)。\",\"由于目前我们支持的字节码比较少，我们的翻译代码也很简洁明了，如下：\",\"func (c *Compiler) Compile() ([]*SSA, error) { ir := make([]*SSA, 0) pushSSA := func(a string, b, c interface{}) { ssa := &SSA{ Action: a, Arg1: b, Arg2: c, } ir = append(ir, ssa) } for c.index < len(c.Opcodes) { op := c.fetch() switch op.Code { case \\\"LOAD_FAST\\\": pushSSA(\\\"push\\\", c.variable(op.Arg.(int)), nil) case \\\"STORE_FAST\\\": pushSSA(\\\"pop\\\", \\\"rdi\\\", nil) pushSSA(\\\"move\\\", c.variable(op.Arg.(int)), \\\"rdi\\\") case \\\"LOAD_CONST\\\": // 加载立即数 pushSSA(\\\"immediate\\\", \\\"rdi\\\", c.Constants[op.Arg.(int)]) pushSSA(\\\"push\\\", \\\"rdi\\\", nil) case \\\"BINARY_MULTIPLY\\\": // 乘法 pushSSA(\\\"pop\\\", \\\"rdi\\\", nil) pushSSA(\\\"pop\\\", \\\"rsi\\\", nil) pushSSA(\\\"imul\\\", \\\"rdi\\\", \\\"rsi\\\") pushSSA(\\\"push\\\", \\\"rdi\\\", nil) case \\\"BINARY_ADD\\\", \\\"INPLACE_ADD\\\": // 加法 pushSSA(\\\"pop\\\", \\\"rdi\\\", nil) pushSSA(\\\"pop\\\", \\\"rsi\\\", nil) pushSSA(\\\"add\\\", \\\"rdi\\\", \\\"rsi\\\") pushSSA(\\\"push\\\", \\\"rdi\\\", nil) case \\\"BINARY_SUBTRACT\\\", \\\"INPLACE_SUBTRACT\\\": // 减法 pushSSA(\\\"pop\\\", \\\"rsi\\\", nil) pushSSA(\\\"pop\\\", \\\"rdi\\\", nil) pushSSA(\\\"sub\\\", \\\"rdi\\\", \\\"rsi\\\") pushSSA(\\\"push\\\", \\\"rdi\\\", nil) case \\\"UNARY_NEGATIVE\\\": // -x pushSSA(\\\"pop\\\", \\\"rdi\\\", nil) pushSSA(\\\"neg\\\", \\\"rdi\\\", nil) pushSSA(\\\"push\\\", \\\"rdi\\\", nil) case \\\"RETURN_VALUE\\\": // 返回 pushSSA(\\\"pop\\\", \\\"rax\\\", nil) pushSSA(\\\"ret\\\", nil, nil) default: return nil, fmt.Errorf(\\\"%s not support\\\", op.Code) } } return ir, nil } \",\"Compile 函数负责将字节码翻译为 IR(SSA)，借助寄存器和栈，能够很迅速的将字节码翻译为对应的 IR。\",\"运行程序，翻译 foo 函数的字节码，可以得到如下的输出：\",\"push rax none push rax none pop rdi none pop rsi none imul rdi rsi push rdi none push rbx none push rbx none pop rdi none pop rsi none imul rdi rsi push rdi none pop rsi none pop rdi none sub rdi rsi push rdi none pop rax none ret none none \",\"可以看到，foo 函数仅有 8 条字节码指令，但翻译为 IR 后，数量就翻倍了，而指令数量直接影响到了程序执行效率。\",\"因此，我们加入一个简单的优化器，来优化 IR。这里不会涉及到太复杂的优化算法，我们只罗列几个简单的优化实现，比如：\",\"push rax none push rax none pop rdi none \",\"这里 push rax 明显重复了两次，也对应了两次 LOAD_FAST，但对于寄存器分配而言，这明显重复了。\",\"另外：\",\"push rax none pop rdi none \",\"现将 rax 的栈入栈，然后再将栈顶的值推出，并赋值给 rdi，这两个操作明显可以直接优化成一个操作：\",\"mov rdi rax \",\"这里直接将 rax 的值拷贝到 rdi 就行了。对应的优化代码如下：\",\"if op1 == \\\"push\\\" && op2 == \\\"pop\\\" { index += 2 pushSSA(\\\"mov\\\", a2, a1) continue } \",\"如果出现类似 mov rdi rdi 这样无效的复制指令，也是可以直接优化的，对应的代码如下：\",\"if op1 == \\\"mov\\\" && a1 == b1 { index += 1 continue } \",\"当然也有一些其它的优化，它们都是对多余指令、重复指令的精简，整体代码如下：\",\"func Optimize(ir []*SSA) []*SSA { ret := make([]*SSA, 0) fetch := func(n int) (string, interface{}, interface{}) { if n < len(ir) { return ir[n].Action, ir[n].Arg1, ir[n].Arg2 } return \\\"\\\", nil, nil } pushSSA := func(a string, b, c interface{}) { ssa := &SSA{ Action: a, Arg1: b, Arg2: c, } ret = append(ret, ssa) } index := 0 for index < len(ir) { op1, a1, b1 := fetch(index) op2, a2, b2 := fetch(index + 1) op3, a3, _ := fetch(index + 2) if op1 == \\\"mov\\\" && a1 == b1 { index += 1 continue } if op1 == \\\"mov\\\" && op2 == \\\"mov\\\" && a1 == b2 { index += 2 pushSSA(\\\"mov\\\", a2, b1) continue } if op1 == \\\"push\\\" && op2 == \\\"pop\\\" { index += 2 pushSSA(\\\"mov\\\", a2, a1) continue } if op1 == \\\"push\\\" && op3 == \\\"pop\\\" && op2 != \\\"push\\\" && op2 != \\\"pop\\\" { if a2 != a3 { index += 3 pushSSA(\\\"mov\\\", a3, a1) pushSSA(op2, a2, b2) continue } } index++ pushSSA(op1, a1, b1) } return ret } \",\"我们实现了一个简单的优化器，虽然简单，但效果却很好，将字节码生成的 IR 优化后，新的 IR 如下：\",\"mov rsi rax mov rdi rax imul rdi rsi push rdi none mov rsi rbx mov rdi rbx imul rdi rsi mov rsi rdi pop rdi none sub rdi rsi mov rax rdi ret none none \",\"IR 被精简了一半，大幅提高了程序运行效率。其实在这里已经体现出 IR 的强大作用，IR 具有很强的表现力，并且适合程序进行分析和优化，比起直接翻译为机器码，添加 IR 中间层是很有必要的。\",\"得到 IR 后，我们需要将 IR 翻译为具体的机器码，这个地方的翻译是比较枯燥的，实际上就是人肉翻译，以 mov 指令为例：\",\"func (as *Assembler) mov(a, b string) { as.emit(0x48, 0x89, 0xc0|as.register(b, a)) } func (as *Assembler) register(a, b string) byte { order := map[string]byte{ \\\"rax\\\": 0, \\\"rcx\\\": 1, \\\"rdx\\\": 2, \\\"rbx\\\": 3, \\\"rsp\\\": 4, \\\"rbp\\\": 5, \\\"rsi\\\": 6, \\\"rdi\\\": 7, } enc := order[a] if b != \\\"\\\" { enc = enc<<3 | order[b] } return enc } \",\"mov 指令对应的机器码实际上就是唯一的，区别在于不同的寄存器，指令的操作数会不一样，比如 rax 对应序号 0，其它操作寄存器的指令也类似于此，因此这里不做过多介绍，感兴趣的同学可以自己将程序编译为执行文件后，使用 objdump 工具来查看，整体的翻译代码如下：\",\"func (as *Assembler) Assembly(ir []*SSA) []byte { for _, ssa := range ir { name, a, b := ssa.Action, ssa.Arg1, ssa.Arg2 switch name { case \\\"ret\\\": as.ret() case \\\"push\\\": as.push(a.(string)) case \\\"pop\\\": as.pop(a.(string)) case \\\"imul\\\": as.imul(a.(string), b.(string)) case \\\"add\\\": as.add(a.(string), b.(string)) case \\\"sub\\\": as.sub(a.(string), b.(string)) case \\\"neg\\\": as.neg(a.(string)) case \\\"mov\\\": as.mov(a.(string), b.(string)) case \\\"immediate\\\": as.immediate(a.(string), b.(int)) } } return as.code[:as.index] } \",\"得到机器码后，JIT 的工作差不多就完成了，剩下的就是将机器码写入内存，然后执行了，如下：\",\"func main() { opcodes := []*py.Opcode{ /* ... */ } c := py.NewCompiler(opcodes, []interface{}{nil}) ir, err := c.Compile() // ... 可根据实际的情况，来选择优化几次 ir = py.Optimize(ir) ir = py.Optimize(ir) // .... assembler := py.NewAssembler(4096) code := assembler.Assembly(ir) // ... area, err := syscall.Mmap( -1, 0, 4096, syscall.PROT_READ|syscall.PROT_WRITE|syscall.PROT_EXEC, syscall.MAP_PRIVATE|syscall.MAP_ANON) // linux for MAP_ANONYMOUS if err != nil { fmt.Printf(\\\"mmap err: %v\\\", err) } for i, by := range code { // 选择 copy 无疑更佳 area[i] = by } type fooFunc func(x, y int64) int64 unsafePrintFunc := (uintptr)(unsafe.Pointer(&area)) foo := *(*fooFunc)(unsafe.Pointer(&unsafePrintFunc)) ret := foo(3, 2) fmt.Println(ret) } \",\"这里使用 mmap 映射出一段内存后，将生成的机器码写入内存，然后将其通过指针强转为函数指针，最后通过函数指针调用 foo(3,2)，得到如下结果：\",\"5 \",\"提示一下，由于不同语言的调用约定是不一样的，go 自 1.17 使用寄存器来传参后，其参数是按照 rax, rcx, rdx 来排列的，因此如果是在其它语言下，生成的机器码是不同的。\",\"从结果可以发现，JIT 是成功的，一个简单的 Python JIT 编译器就这样被实现了。\"]},\"219\":{\"h\":\"魔法 3：自举(bootstrap)\",\"t\":[\"go 是自举实现的，而且是一个完全自举的编译器实现，即编译器、链接器等等都是用 go 实现的；不仅如此，go 把编译器的前端部分直接开放在了标准库中，这意味着我们不仅可以直接使用前端部分，还可以替换另外的中、后端平台来编译 go。如下：\",\"我们借助 go 标准库和 LLVM 就能实现一个非常简单的编译器，不再使用 go 默认编译器独有的 IR 和机器码生成器。\",\"目标很明确：\",\"package main import \\\"fmt\\\" func add(x int, y int) int { return x + y } func main() { fmt.Println(add(10, 2)) } \",\"实现一个极简编译器，将这段 go 代码编译为可执行文件即可。\",\"首先，使用 go/parser 等标准库来等 go 源代码进行解析，如下：\",\"func main() { fset := token.NewFileSet() // 相对于fset的position src := `package main import \\\"fmt\\\" func add(x int, y int) int { return x + y } func main() { fmt.Println(add(10, 2)) }` f, err := parser.ParseFile(fset, \\\"\\\", src, parser.AllErrors) if err != nil { fmt.Println(err) return } ast.Print(fset, f) } \",\"由于 go 良好的自举设计，我们可以轻松得到这段代码的 AST 树：\",\"0 *ast.File { 1 . Package: 1:1 2 . Name: *ast.Ident { 3 . . NamePos: 1:9 4 . . Name: \\\"main\\\" 5 . } 6 . Decls: []ast.Decl (len = 3) { 7 . . 0: *ast.GenDecl { 8 . . . TokPos: 3:1 9 . . . Tok: import .... 省略 \",\"LLVM 为了屏蔽不同平台架构之间的指令差异性，设计了一种 IR，举例：\",\"define i32 @add(i32 %a, i32 %b) { %1 = add i32 %a, %b ret i32 %1 } \",\"LLVM 的 IR 不同于上面提到的汇编方言，而是一种更加高级的抽象，有基本的函数定义、分支等，更像是一种 low level C。\",\"LLVM 的编译器 clang 是支持直接将 IR 编译为可执行文件的，在编译的过程中会自动对 IR、机器码进行优化，这也是 LLVM 近些年火爆的原因，很多语言搭上了 LLVM 的快车，比如 Rust 等。\",\"所以，任务更加简单了，只需要在 AST 树翻译为 LLVM IR 即可。实际上，有一些项目就是采用这种做法，比如 gollvm和 tinygo 等。\",\"当然，一门语言的语法翻译也不是一件易事，感兴趣的同学可以点开 gollvm 和 tinygo 的链接看看它们是如何做的，这里笔者仅简单的翻译上面的例子。\",\"得到 AST 树后，我们需要拿到 add、main 函数的定义，并将其翻译为 IR，如下：\",\"for _, decl := range f.Decls { if fn, ok := decl.(*ast.FuncDecl); ok { if fn.Name.Name == \\\"add\\\" { translateAdd(m, fn, funcMap) } else if fn.Name.Name == \\\"main\\\" { translateMain(m, fn, funcMap) } else { continue } } } \",\"对于 add 函数，没有复杂的函数体，我们提取出参数、返回值然后生成对应的 IR 即可：\",\"func translateAdd(m *ir.Module, decl *ast.FuncDecl, funcMap map[string]*ir.Func) *ir.Func { params := make([]*ir.Param, 0) for _, field := range decl.Type.Params.List { paramName := field.Names[0].Name paramType := field.Type.(*ast.Ident).Name if paramType != \\\"int\\\" { // 暂不支持 continue } params = append(params, ir.NewParam(paramName, types.I32)) } returnType := decl.Type.Results.List[0].Type.(*ast.Ident).Name if returnType != \\\"int\\\" { // 暂不支持 panic(returnType + \\\" return type is not support\\\") } funcDefine := m.NewFunc(decl.Name.Name, types.I32, params...) ab := funcDefine.NewBlock(\\\"\\\") ab.NewRet(ab.NewAdd(funcDefine.Params[0], funcDefine.Params[1])) funcMap[decl.Name.Name] = funcDefine return funcDefine } \",\"而在 main 函数中，我们不仅需要调用 add 函数，还需要调用 println 函数来打印结果，所以，我们提前定义一个 printf 内置函数，并将其加入到哈希表中方便后续查找：\",\"// builtin printf := m.NewFunc( \\\"printf\\\", types.I32, ir.NewParam(\\\"\\\", types.NewPointer(types.I8)), ) printf.Sig.Variadic = true funcMap := map[string]*ir.Func{ \\\"printf\\\": printf, } \",\"main 函数中，需要对 add 函数的参数进行处理，如下：\",\"func translateMain(m *ir.Module, decl *ast.FuncDecl, funcMap map[string]*ir.Func) *ir.Func { zero := constant.NewInt(types.I32, 0) stmt := decl.Body.List[0].(*ast.ExprStmt).X.(*ast.CallExpr).Args[0].(*ast.CallExpr) args := make([]value.Value, 0) for _, item := range stmt.Args { val := item.(*ast.BasicLit).Value i, err := strconv.ParseInt(val, 10, 64) if err != nil { continue } args = append(args, constant.NewInt(types.I32, i)) } funcMain := m.NewFunc(\\\"main\\\", types.I32) mb := funcMain.NewBlock(\\\"\\\") result := mb.NewCall(funcMap[\\\"add\\\"], args...) formatStr := m.NewGlobalDef(\\\"formatStr\\\", constant.NewCharArrayFromString(\\\"%d\\\\n\\\")) format := constant.NewGetElementPtr(types.NewArray(3, types.I8), formatStr, zero, zero) mb.NewCall(funcMap[\\\"printf\\\"], format, result) mb.NewRet(zero) return funcMain } \",\"然后，我们将得到的 IR 打印并写入文件，并调用 clang 编译为执行文件：\",\"func main() { fset := token.NewFileSet() // 相对于fset的position src := `package main import \\\"fmt\\\" func add(x int, y int) int { return x + y } func main() { fmt.Println(add(10, 2)) }` f, err := parser.ParseFile(fset, \\\"\\\", src, parser.AllErrors) if err != nil { fmt.Println(err) return } m := ir.NewModule() // builtin printf := m.NewFunc( \\\"printf\\\", types.I32, ir.NewParam(\\\"\\\", types.NewPointer(types.I8)), ) printf.Sig.Variadic = true funcMap := map[string]*ir.Func{ \\\"printf\\\": printf, } for _, decl := range f.Decls { if fn, ok := decl.(*ast.FuncDecl); ok { if fn.Name.Name == \\\"add\\\" { translateAdd(m, fn, funcMap) } else if fn.Name.Name == \\\"main\\\" { translateMain(m, fn, funcMap) } else { continue } } } fmt.Println(m.String()) err = ioutil.WriteFile(\\\"./add.ll\\\", []byte(m.String()), 0666) if err != nil { panic(err) } err = exec.Command(\\\"clang\\\", \\\"./add.ll\\\").Run() if err != nil { panic(err) } } \",\"运行程序，我们可以在命令行中看到生成的 IR：\",\"@formatStr = global [3 x i8] c\\\"%d\\\\0A\\\" declare i32 @printf(i8* %0, ...) define i32 @add(i32 %x, i32 %y) { 0: %1 = add i32 %x, %y ret i32 %1 } define i32 @main() { 0: %1 = call i32 @add(i32 10, i32 2) %2 = call i32 (i8*, ...) @printf(i8* getelementptr ([3 x i8], [3 x i8]* @formatStr, i32 0, i32 0), i32 %1) ret i32 0 } \",\"且在当前文件夹下有 a.out 可执行文件，我们尝试运行它：\",\"$ ./a.out 12 \",\"至此，一个极简的 go 自举编译器就实现了，我们也顺利得到了正确的结果。\"]},\"220\":{\"h\":\"总结\",\"t\":[\"很明显，本文内容与编译器强相关，编译器是一个极其有意思的主题，希望本文能带给你一个新的编译器视角，然后去学习、实践它。\",\"体验不一样的乐趣。\"]},\"221\":{\"h\":\"参考资料\",\"t\":[\"go\",\"gopher-os\",\"eggos\",\"Go 1.17 的新调用规约\",\"JIT compiling a subset of Python to x86-64\",\"Exit_(system_call)\",\"tinygo\",\"llir\"]},\"222\":{\"h\":\"go黑魔法——新增关键字\"},\"223\":{\"h\":\"前言\",\"t\":[\"几乎所有人都遇到过类似下面的 go 代码：\",\"if err != nil { return nil, err } \",\"负责任的说，笔者每天都得写很多次这样的 err 处理代码，以至于一个函数中，半数代码都是在 处理 error。所以很多人用下面这张图来调侃：\",\"遇到如此重复错误处理代码，大家都会下意识的想办法去封装和简化，比如这里的两篇文章GO 编程模式：错误处理 和 Go error 处理最佳实践。\",\"一定程度上，这种技巧解决了 go error 处理的繁琐，但显然这种方式还是不够优雅。\",\"思来想去，根本原因在于 go 本身 error 的哲学和机制问题，go 创始人希望工程师能够认真对待每一个 error，从而提升代码质量； 另外 go 语言本身又没有提供错误处理语法糖，这使得 error 处理十分原始和重复。\",\"既然常规方法不行，笔者就把视角放到了 go 本身上面：给 go 编译器新增关键字来处理 error。\"]},\"224\":{\"h\":\"编译源码\",\"t\":[\"话不多说，我们直接开搞。\",\"从 github 上下载 go 的源码，并将其切到（当前）最新的 go1.19 版上：\",\"# git clone https://github.com/golang/go # cd go && git checkout go1.19 # git checkout -b pedro \",\"切换到了一个新的分支用于开发新的特性。然后设置目录变量，通过脚本编译出最新的 go1.19：\",\"# pwd=$(pwd) # cd $pwd/src # ./make.bash Building Go cmd/dist using xxx/go1.18.3. (go1.18.3 linux/amd64) Building Go toolchain1 using xxx/go1.18.3. Building Go bootstrap cmd/go (go_bootstrap) using Go toolchain1. Building Go toolchain2 using go_bootstrap and Go toolchain1. Building Go toolchain3 using go_bootstrap and Go toolchain2. Building packages and commands for linux/amd64. --- Installed Go for linux/amd64 in xxx/go Installed commands in xxx/go/bin \",\"从构建输出可以看出，go 的自举其实颇为复杂。首先使用旧 go1.18.3 编译构建 toolchain1， 然后再用 toolchain1 构建出 bootstrap，最后几次迭代编译构建出 go1.19 和其它工具， 感兴趣的可以 点击 看看 go 的构建过程。\",\"这样就通过已有的 go1.18 编译出最新的 go1.19 了：\",\"# $pwd/bin/go version # go version go1.19 linux/amd64 \",\"设置 GOROOT 和 GOPATH：\",\"# export GOROOT=$pwd # export GOPATH=$pwd/lab \"]},\"225\":{\"h\":\"ereturn\",\"t\":[\"对于下面的 error 处理代码：\",\"err := testErr() if err != nil { return 123, err } // 继续 \",\"我们新引入一个关键字 ereturn 来简化。ereturn 会自动判断 error 是否为 nil， 如果不为 nil，则直接返回，否则继续向下运行，如下：\",\" err := testErr() ereturn 123, err \",\"ereturn 判断最后一个返回参数 err 是否为 nil，当为 nil 则函数继续，否则函数返回。\",\"这样就省去了重复多次的 if 判空操作，减少了重复代码。\",\"那么如何实现 ereturn 了？思路其实很简单，ereturn 语句是将 if, return 两条语句合并，将 error 判断操作放在了编译期生成，而不是由工程师手动判断；因此我们只需在 go 编译器中新增 ereturn 关键字， 并在程序编译的时候将 ereturn 语句 重写为 if+return 语句即可。\",\"首先，添加新的关键字 ereturn：\",\"--- a/src/cmd/compile/internal/syntax/tokens.go +++ b/src/cmd/compile/internal/syntax/tokens.go @@ -60,6 +60,7 @@ const ( _Package // package _Range // range _Return // return + _Ereturn // ereturn _Select // select _Struct // struct _Switch // switch \",\"然后通过 go generate 命令自动生成该关键字的解析程序：\",\"# $pwd/bin/go generate $pwd/src/cmd/compile/internal/syntax/tokens.go stringer -type token -linecomment tokens.go tokens.go:9: running \\\"stringer\\\": exec: \\\"stringer\\\": executable file not found in $PATH \",\"提示缺少 stringer，通过 go install 下载，然后再次运行：\",\"# $pwd/bin/go install golang.org/x/tools/cmd/stringer@latest # export PATH=$GOPATH/bin:$PATH # $pwd/bin/go generate $pwd/src/cmd/compile/internal/syntax/tokens.go \",\"generate 会自动解析 tokens.go，然后生成对应的解析程序部分 token_string.go：\",\"--- a/src/cmd/compile/internal/syntax/token_string.go +++ b/src/cmd/compile/internal/syntax/token_string.go @@ -49,17 +49,18 @@ func _() { _ = x[_Package-39] _ = x[_Range-40] _ = x[_Return-41] + _ = x[_Ereturn-42] \",\"有了关键字后，修改 parser.stmtOrNil 方法，将 ereturn 语句改写为 if+return 语句：\",\"--- a/src/cmd/compile/internal/syntax/parser.go +++ b/src/cmd/compile/internal/syntax/parser.go @@ -2613,6 +2613,56 @@ func (p *parser) stmtOrNil() Stmt { } return s + case _Ereturn: + pos := p.pos() + e := new(ReturnStmt) + e.pos = pos + p.next() + if p.tok != _Semi && p.tok != _Rbrace { + e.Results = p.exprList() + } + // return block + b1 := new(BlockStmt) + b1.pos = pos + b1.Rbrace = pos + b1.List = []Stmt{e} + + set := false + f := new(IfStmt) + f.pos = pos + switch ep := e.Results.(type) { + case *ListExpr: + if len(ep.ElemList) > 0 { + if eep, ok := ep.ElemList[len(ep.ElemList)-1].(*Name); ok && strings.HasPrefix(eep.Value, \\\"err\\\") { + op := &Operation{ + Op: Neq, + X: eep, + Y: NewName(pos, \\\"nil\\\"), + } + op.pos = pos + f.Cond = op + set = true + } + } + case *Name: + if strings.HasPrefix(ep.Value, \\\"err\\\") { + op := &Operation{ + Op: Neq, + X: ep, + Y: NewName(pos, \\\"nil\\\"), + } + op.pos = pos + f.Cond = op + set = true + } + } + f.Then = b1 + if set { + return f + } else { + return e + } + case _Semi: s := new(EmptyStmt) s.pos = p.pos() \",\"这里运用了一个小技巧，那就是：语句重写。\",\"ereturn 关键字本身可以视为 if，return 语句的联合体，当 return 语句最后一个返回值为 error 且不为空时，就将其解析为 ereturn 语句。 因此这里先将 ereturn 语句解析为 return 语句，然后判断 Results 列表的最后一个元素是否为 error， 如果是则将其包装为 if 语句，即在 return 之前先对 error 进行 nil 判断，如果 error 不为 nil，则调用 return，否则不做任何事情。\",\"修改完毕后，重新生成新的 go.19：\",\"# cd $pwd/src # ./make.bash Building Go cmd/dist using /root/.go/go1.18.3. (go1.18.3 linux/amd64) Building Go toolchain1 using /root/.go/go1.18.3. Building Go bootstrap cmd/go (go_bootstrap) using Go toolchain1. Building Go toolchain2 using go_bootstrap and Go toolchain1. Building Go toolchain3 using go_bootstrap and Go toolchain2. Building packages and commands for linux/amd64. --- Installed Go for linux/amd64 in /root/workspace/go Installed commands in /root/workspace/go/bin \",\"编译完成后，用一个例子看看效果：\",\"func testErr() error { return errors.New(\\\"err\\\") } func testNoErr() error { return nil } func hello() (string, error) { err := testNoErr() ereturn \\\"111\\\", err // r1 err = testNoErr() ereturn \\\"777\\\", err // r2 err = testErr() ereturn \\\"222\\\", err // r3 return \\\"333\\\", nil // r4 } func main() { fmt.Println(hello()) } \",\"运行：\",\"# $pwd/bin/go run $pwd/lab/examples/example1/main.go 222 err \",\"程序输入 222，err，证明函数 hello 从 r3 处退出，显然 r1，r2 处的 error 都是 nil，因此判断不成立， 所以函数继续执行，而到 r3 处时，error 不为 nil，所以直接返回。\",\"到此一个新的 ereturn 关键字就顺利完成了，具体实现可以参考这个 commit。\"]},\"226\":{\"h\":\"go 编译器\",\"t\":[\"到这里，我们可以发现 go 编译器设计良好、代码易读，新增一个可用的关键字竟如此简单。但是旅程绝不仅限于此， 就目前而言，我们只接触到 go 编译器中极其小的一部分，甚至这些都不是 go 编译器中的核心点。\",\"go 编译器是按照程序编译过程来设计实现的，大致可分为如下 4 个大阶段：\",\"以上图片按照 go 官方文档介绍绘制而成，感兴趣的可以点击这里查看一下 go 编译器的 简单介绍。文档可能会随着迭代更新。\",\"解析阶段：将 go 源代码词法、句法、语法分析，生成程序可读的语法树（syntax tree）；\",\"检查、转换阶段：对生成的语法树做语法检查，补充元信息；\",\"生成 SSA 节点，通过流程图分析对代码进行优化、重写；\",\"生成机器码，即最后的可执行代码。\",\"关于 SSA，可点击此处了解。\",\"而 ereturn 语句的处理，只停留在了第 1 阶段，即解析阶段的时候，就被转化为了 if、return 语句，后面的 2、3、4 阶段都是以其它语句的身份来参与。\",\"下面，我们就通过另外一个关键字 dowhile 来一起看看 go 编译的 4 个阶段。\"]},\"227\":{\"h\":\"dowhile\",\"t\":[\"有一定 c 语言基础的同学肯定熟悉 do while 这两个关键字，因此它们联合可以实现如下语句：\",\"do { // body // do something } while( condition ); \",\"do while 语句最大的好处在于，即使 condition 不满足，那么也能执行 body 里面的代码，如果满足，那么会重复执行 直到不满足为止。\",\"在 go 中是没有 do、while 两个关键字的，对于循环执行也只提供了 for 语句。\",\"千万不要使用 do 作为关键字，因为 go 中大量使用了 do 作为变量名，如果使用 do {} while 这类语法，那么 go 无法编译成功。\",\"因此，我们决定在 go 中新增 dowhile 关键字，可达到下面的效果：\",\"i := 3 dowhile i != 0 { i-- // do something } \",\"变量 i 在 dowhile 语句外部初始化，dowhile 执行到 i 不满足条件为止。\",\"或者：\",\"dowhile i := 3; i != 0 { i-- // do something } \",\"变量 i 在 dowhile 语句上初始化，dowhile 执行到 i 不满足条件为止。\",\"或者：\",\"i := 4 dowhile i != 4 { // do something } \",\"变量 i 在 dowhile 语句外部初始化，不满足循环条件，但 dowhile 仍会执行 body 中的语句。\",\"下面我们就来为 go 新增 dowhile 支持。\",\"首先，添加新的 dowhile 关键字：\",\"--- a/src/cmd/compile/internal/syntax/tokens.go +++ b/src/cmd/compile/internal/syntax/tokens.go @@ -50,6 +50,7 @@ const ( _For // for + _Dowhile // dowhile _Func // func \",\"定义新的 dowhile 语句：\",\"--- a/src/cmd/compile/internal/syntax/nodes.go +++ b/src/cmd/compile/internal/syntax/nodes.go @@ -410,6 +410,19 @@ type ( stmt } + /** + init、cond 均可省略 + dowhile <init>; <cond> { + <body> + } + */ + DowhileStmt struct { + Init SimpleStmt // incl. *RangeClause + Cond Expr + Body *BlockStmt + stmt + } \",\"新增关键字后再次生成 token_string 用于解析新的关键字：\",\"# export PATH=$GOPATH/bin:$PATH # $pwd/bin/go generate $pwd/src/cmd/compile/internal/syntax/tokens.go \",\"检查 token_string.go 中 dowhile 关键字是否成功：\",\"--- a/src/cmd/compile/internal/syntax/token_string.go +++ b/src/cmd/compile/internal/syntax/token_string.go @@ -39,28 +39,29 @@ func _() { _ = x[_Else-29] _ = x[_Fallthrough-30] _ = x[_For-31] + _ = x[_Dowhile-32] \",\"改造 parser 使其支持 dowhile 关键字解析：\",\"--- a/src/cmd/compile/internal/syntax/parser.go +++ b/src/cmd/compile/internal/syntax/parser.go @@ -2269,6 +2269,20 @@ func (p *parser) forStmt() Stmt { return s } +func (p *parser) dowhileStmt() Stmt { + if trace { + defer p.trace(\\\"dowhileStmt\\\")() + } + + s := new(DowhileStmt) + s.pos = p.pos() + + s.Init, s.Cond, _ = p.header(_Dowhile) + s.Body = p.blockStmt(\\\"dowhile clause\\\") + + return s +} + func (p *parser) header(keyword token) (init SimpleStmt, cond Expr, post SimpleStmt) { p.want(keyword) @@ -2567,6 +2581,9 @@ func (p *parser) stmtOrNil() Stmt { case _For: return p.forStmt() + case _Dowhile: + return p.dowhileStmt() \",\"这样，go 编译器就支持 dowhile 语句的解析了，我们可以测试看看解析一个 dowhile 例子：\",\"package main import ( \\\"fmt\\\" ) func main() { i := 4 dowhile i > 0 { fmt.Println(i) i-- } } \",\"编译 go：\",\"# cd $pwd/src # ./make.bash \",\"在 dumper_test 中新增测试用例：\",\"index 1ba85cc8d9..dcfaf063e7 100644 --- a/src/cmd/compile/internal/syntax/dumper_test.go +++ b/src/cmd/compile/internal/syntax/dumper_test.go @@ -19,3 +19,12 @@ func TestDump(t *testing.T) { + +func TestDump1(t *testing.T) { + file := \\\"./lab/examples/example2/main.go\\\" + ast, _ := ParseFile(file, func(err error) { t.Error(err) }, nil, CheckBranches) + + if ast != nil { + Fdump(testOut(), ast) + } +} \",\"运行测试，输出语法 AST 树：\",\"# $pwd/bin/go test -c -o dump.test ./src/cmd/compile/internal/syntax/ -run TestDump1 # ./dump.test -test.run TestDump1 -test.v === RUN TestDump1 # ... 35 . . . . . 1: *syntax.DowhileStmt { 36 . . . . . . Init: nil 37 . . . . . . Cond: *syntax.Operation { 38 . . . . . . . Op: > 39 . . . . . . . X: i @ ./lab/examples/example2/main.go:9:10 40 . . . . . . . Y: *syntax.BasicLit { 41 . . . . . . . . Value: \\\"0\\\" 42 . . . . . . . . Kind: 0 43 . . . . . . . . Bad: false 44 . . . . . . . } 45 . . . . . . } # ... --- PASS: TestDump1 (0.00s) \",\"解析成功。当然有了定义还不够，还需新增 DowhileStmt 语句遍历函数：\",\"--- a/src/cmd/compile/internal/syntax/walk.go +++ b/src/cmd/compile/internal/syntax/walk.go @@ -289,6 +289,15 @@ func (w walker) node(n Node) { } w.node(n.Body) + case *DowhileStmt: // 新增 + if n.Init != nil { + w.node(n.Init) + } + if n.Cond != nil { + w.node(n.Cond) + } + w.node(n.Body) + case *SwitchStmt: \",\"新增对 dowhile 语句语法检查 case：\",\"--- a/src/cmd/compile/internal/types2/stmt.go +++ b/src/cmd/compile/internal/types2/stmt.go @@ -652,6 +652,21 @@ func (check *Checker) stmt(ctxt stmtContext, s syntax.Stmt) { } check.stmt(inner, s.Body) + case *syntax.DowhileStmt: + inner |= breakOk | continueOk + + check.openScope(s, \\\"do while\\\") + defer check.closeScope() + check.simpleStmt(s.Init) + if s.Cond != nil { + var x operand + check.expr(&x, s.Cond) + if x.mode != invalid && !allBoolean(x.typ) { + check.error(s.Cond, \\\"non-boolean condition in for statement\\\") + } + } + check.stmt(inner, s.Body) + default: check.error(s, \\\"invalid statement\\\") \",\"语法解析、检查后，go 会将语法树转化为 IR（中间码），新增 ODOWHILE IR 关键字：\",\"--- a/src/cmd/compile/internal/ir/node.go +++ b/src/cmd/compile/internal/ir/node.go @@ -273,14 +273,15 @@ const ( // } OFORUNTIL + ODOWHILE // dowhile Init; Cond { Body }; \",\"新增 IR 语句定义：\",\"--- a/src/cmd/compile/internal/ir/stmt.go +++ b/src/cmd/compile/internal/ir/stmt.go @@ -223,6 +223,35 @@ func (n *ForStmt) SetOp(op Op) { n.op = op } +// A DowhileStmt is a non-range for loop: dowhile Init; Cond { Body } +type DowhileStmt struct { + miniStmt + Label *types.Sym + Cond Node + Body Nodes + HasBreak bool // break in body +} + +// New dowhile statement +func NewDowhileStmt(pos src.XPos, init Node, cond Node, body []Node) *DowhileStmt { + n := &DowhileStmt{Cond: cond} // condition + n.pos = pos + n.op = ODOWHILE + if init != nil { // init + n.init = []Node{init} + } + n.Body = body // body + return n +} + +func (n *DowhileStmt) SetOp(op Op) { + if op != ODOWHILE { + panic(n.no(\\\"SetOp \\\" + op.String())) + } + n.op = op +} \",\"有了关键字、语句定义后，通过脚本生成 IR 关键字：\",\"# $pwd/bin/go generate $pwd/src/cmd/compile/internal/ir/node.go # $pwd/bin/go run -mod=mod $pwd/src/cmd/compile/internal/ir/mknode.go # mv $pwd/node_gen.go $pwd/src/cmd/compile/internal/ir/ \",\"generate 命令会重新生成op_string.go文件， 用于将 ODOWHILE 关键字转化为字符串方便 debug。\",\"run 命令会重新生成node_gen.go文件， 用于自动实现 DowhileStmt 语句的格式化、拷贝等操作。\",\"为了方便 DowhileStmt 语句的 debug，因此新增 ODOWHILE 格式化的 case：\",\"--- a/src/cmd/compile/internal/ir/fmt.go +++ b/src/cmd/compile/internal/ir/fmt.go @@ -435,6 +435,25 @@ func stmtFmt(n Node, s fmt.State) { fmt.Fprintf(s, \\\" { %v }\\\", n.Body) + case ODOWHILE: + n := n.(*DowhileStmt) + opname := \\\"dowhile\\\" + if !exportFormat { + fmt.Fprintf(s, \\\"%s loop\\\", opname) + break + } + fmt.Fprint(s, opname) + if simpleinit { + fmt.Fprintf(s, \\\" %v;\\\", n.Init()[0]) + } + if n.Cond != nil { + fmt.Fprintf(s, \\\" %v\\\", n.Cond) + } + if simpleinit { + fmt.Fprint(s, \\\";\\\") + } + fmt.Fprintf(s, \\\" { %v }\\\", n.Body) + case ORANGE: \",\"有了 AST、IR 的 dowhile 定义后，我们需要在 noder 中实现二者之间的转化， 即将 syntax.DowhileStmt 转化为 ir.DowhileStmt，如下：\",\"--- a/src/cmd/compile/internal/noder/stmt.go +++ b/src/cmd/compile/internal/noder/stmt.go @@ -118,6 +118,8 @@ func (g *irgen) stmt(stmt syntax.Stmt) ir.Node { return g.ifStmt(stmt) case *syntax.ForStmt: return g.forStmt(stmt) + case *syntax.DowhileStmt: + return g.dowhileStmt(stmt) case *syntax.SelectStmt: n := g.selectStmt(stmt) @@ -260,6 +262,10 @@ func (g *irgen) forStmt(stmt *syntax.ForStmt) ir.Node { return ir.NewForStmt(g.pos(stmt), g.stmt(stmt.Init), g.expr(stmt.Cond), g.stmt(stmt.Post), g.blockStmt(stmt.Body)) } +func (g *irgen) dowhileStmt(stmt *syntax.DowhileStmt) ir.Node { + return ir.NewDowhileStmt(g.pos(stmt), g.stmt(stmt.Init), g.expr(stmt.Cond), g.blockStmt(stmt.Body)) +} \",\"AST 转换为 IR node 后，编译就进入到了第 3 步，下面就需要对 IR 进行一系列的分析和优化。\",\"比如，先对 ir.DowhileStmt 语句进行逃逸分析：\",\"--- a/src/cmd/compile/internal/escape/stmt.go +++ b/src/cmd/compile/internal/escape/stmt.go @@ -82,6 +82,13 @@ func (e *escape) stmt(n ir.Node) { e.block(n.Body) e.loopDepth-- + case ir.ODOWHILE: + n := n.(*ir.DowhileStmt) + e.loopDepth++ + e.discard(n.Cond) + e.block(n.Body) + e.loopDepth-- + case ir.ORANGE: // for Key, Value = range X { Body } n := n.(*ir.RangeStmt) \",\"接着将节点拆分为更加简单的节点，比如拆分 dowhile 中的初始化、条件、执行体等节点：\",\"--- a/src/cmd/compile/internal/syntax/walk.go +++ b/src/cmd/compile/internal/syntax/walk.go @@ -289,6 +289,15 @@ func (w walker) node(n Node) { } w.node(n.Body) + case *DowhileStmt: // 新增 + if n.Init != nil { + w.node(n.Init) + } + if n.Cond != nil { + w.node(n.Cond) + } + w.node(n.Body) + case *SwitchStmt: if n.Init != nil { w.node(n.Init) \",\"再针对 dowhile 中的一些语句执行顺序尝试进行重排序：\",\"--- a/src/cmd/compile/internal/walk/order.go +++ b/src/cmd/compile/internal/walk/order.go @@ -829,6 +829,15 @@ func (o *orderState) stmt(n ir.Node) { o.out = append(o.out, n) o.cleanTemp(t) + case ir.ODOWHILE: + n := n.(*ir.DowhileStmt) + t := o.markTemp() + n.Cond = o.exprInPlace(n.Cond) + n.Body.Prepend(o.cleanTempNoPop(t)...) + orderBlock(&n.Body, o.free) + o.out = append(o.out, n) + o.cleanTemp(t) + // Clean temporaries from condition at // beginning of both branches. case ir.OIF: \",\"完成了一系列检查、优化后，编译器 需将 dowhile 节点转化为控制流图 CFG （Control-flow Graph），如下：\",\"--- a/src/cmd/compile/internal/ssagen/ssa.go +++ b/src/cmd/compile/internal/ssagen/ssa.go @@ -1821,6 +1821,34 @@ func (s *state) stmt(n ir.Node) { s.startBlock(bEnd) + case ir.ODOWHILE: // dowhile Init; Cond { Body }; + // TODO 增加 break、continue 支持 + n := n.(*ir.DowhileStmt) + bCond := s.f.NewBlock(ssa.BlockPlain) + bBody := s.f.NewBlock(ssa.BlockPlain) + bEnd := s.f.NewBlock(ssa.BlockPlain) + bBody.Pos = n.Pos() + // 上一个 block + b := s.endBlock() + // 上一个紧接着 body, dowhile 的效果 + b.AddEdgeTo(bBody) + // 处理 body + s.startBlock(bBody) + s.stmtList(n.Body) + b = s.endBlock() + // 条件处理 + b.AddEdgeTo(bCond) + s.startBlock(bCond) + if n.Cond != nil { + s.condBranch(n.Cond, bBody, bEnd, 1) + } else { + b := s.endBlock() + b.Kind = ssa.BlockPlain + b.AddEdgeTo(bBody) + } + // 结束 + s.startBlock(bEnd) + case ir.OSWITCH, ir.OSELECT: // These have been mostly rewritten by the front end into their Nbody fields. // Our main task is to correctly hook up any break statements. \",\"CFS 基本已经接近人类理解的程序执行流程图了，上面的代码会将 dowhile 生成如下控制流图：\",\"dowhile 开始时，直接进入 body 中执行，执行完后再来判断 cond 是否满足，如果满足则再次跳入到 body 中执行，否则 dowhile 结束。\",\"可以看到，从一个基本的 dowhile 语句到 CFS，编译器做了大量工作，一步步将语言向下演化（这个过程也称 lower）。\",\"最后，就是编译器的最后一步了，将 CFS 图转化为对应平台的机器码，对应 obj包； 包下有对各个平台的机器码支持，由于平台之间的差异都比较大，因此我们对 dowhile 的支持其实到 IR 这一步就够了，剩下的工作 go 编译器会帮助我们来处理。\",\"再次编译 go1.19，此时的 go1.19 已经支持 dowhile 关键字：\",\"# cd $pwd/src # ./make.bash \",\"我们可以测试看看，一个 dowhile 例子：\",\"func main() { i := 4 dowhile i > 0 { fmt.Println(i) i-- } } \",\"输出：\",\"# $pwd/bin/go run $pwd/lab/examples/example2/main.go 4 3 2 1 \",\"例子 2：dowhile 语句上初始化：\",\"func main() { dowhile i := 4; i > 0 { fmt.Println(i) i-- } } \",\"输出：\",\"# $pwd/bin/go run $pwd/lab/examples/example3/main.go 4 3 2 1 \",\"例子 3：dowhile 条件不满足：\",\"func main() { i := 4 dowhile i != 4 { fmt.Println(i) } } \",\"输出：\",\"# $pwd/bin/go run $pwd/lab/examples/example4/main.go 4 \",\"可以发现，即 i != 4 不满足，但仍然执行了一次 fmt.Println。\",\"关于 dowhile 的具体实现可以参考这个commit。\"]},\"228\":{\"h\":\"结语\",\"t\":[\"至此，我们完成了 go 编译器新增关键字的挑战，在这一段路的旅程中，我们见识到了编译原理的魅力，感受到了 go 编译器设计之精巧、功能之完善； 无论是编译器本身、还是 runtime 的实现，都是学习（任意）语言实现的巨大宝库。\",\"按照 go 文档的说法，go 编译器被称为 gc编译器，虽然这一度让我怀疑这是垃圾回收的代码包，但明显这不是。go 自从 1.4 版本自举后，参与编译器工作的 门槛降低了很多，在开发和实践中，我们都能直接去看源码来 debug 程序问题；当然遇到 go 无法解决的问题，我们也能 fork 然后自己来解决。\",\"c/cpp 编译器一直都是 gcc、clang、MSVC 三家争霸，而 go 编译器似乎一直都是一家独大，这也直接导致了 go 团队的傲慢，当然也避免了分裂和撕逼。\",\"可能不久的将来，因为或多或少的政治原因，go 编译器也会走向多元化，期待那一天的到来，让 go 拥有更多的活力。\"]},\"229\":{\"h\":\"参考资料\",\"t\":[\"go compiler internals\",\"静态分析-中间表示\",\"golang\",\"GO 编程模式：错误处理\",\"Go error 处理最佳实践\",\"Go compiler: SSA optimization rules description language\"]},\"230\":{\"h\":\"Go 内存管理设计与实现\"},\"231\":{\"h\":\"概述\",\"t\":[\"在冯·诺伊曼的设计理念的指导下，计算机将计算与存储这个两大核心模块进行分离，二者通过总线连接，协调工作：\",\"对于计算而言，CPU 无疑是核心（CPU 内部结构无需过多关注），但对于存储而言，则要麻烦的多。\",\"带来这个麻烦的主要因素在于：CPU 与存储设备之间巨大的速度差异。\",\"以 CPU 的指令周期为单位，如果数据在高速缓存中，那么 CPU 访问到数据只需 4 ～ 75 个周期，如果在内存中，则需要上百个周期，而如果在磁盘中，那么就需要几千万个周期。\",\"存储设备类型的不同也会带来存储性能巨大的差异，比如 SRAM（Static Random-Access Memory）存储设备性能很高，被用来作为 CPU 的高速缓存，CPU 访问它们只需几个时钟周期，而 DRAM（Dynamic Random-Access Memory）被用做主存（内存），CPU 访问它们需要上百个周期；而磁盘存储被用来保存大量数据，磁盘读比 SRAM 慢了足足 100 万倍。\",\"即使速度差距如此之大，计算机的主要存储设备仍然是 DRAM（内存）和磁盘（或者 SSD）。\",\"这是因为，SRAM 虽然性能强劲，却也十分昂贵，CPU 旁边的高速缓存容量一般也就几百 KB，或者几 MB。它们之间的速度差异可以用存储器山来直观的展示：\",\"计算机往往是多种存储设备共存，相互协助让 CPU 充分发挥其性能。而内存（Main Memory，也称主存）作为山中最核心的一层，担任着缓冲与加速的重要工作，其重要性不言而喻。\",\"也因此，内存管理 模块是操作系统、编程语言中极为重要且不可或缺的一部分。\",\"操作系统对内存的抽象和管理是很复杂的，里面涉及到大量概念和机制 (比如虚拟内存、分页、权限、缺页中断等等)，不熟悉的同学 可以点击这里回顾一下。 编程语言工作在操作系统之上，所管理的内存在进程地址空间上，因此笔者 不会介绍地址空间之下的内容。\"]},\"232\":{\"h\":\"内存布局\",\"t\":[\"对于一个程序而言，当其以进程的形式被创建时，操作系统会为其分配一片巨大的虚拟内存，被称为地址空间。如下：\",\"如图所示，内存空间被划分为了多个区：\",\"栈区(Stack)：存储执行期间的局部变量、参数等，从高地址向地址增长；\",\"堆区(Heap)：动态内存分配区，也是内存管理的主战场；\",\"数据区(BSS、Data)：数据区可以划分为两个部分，BSS 表示存储但未被初始化的全局变量和静态变量，而 Data 区表示已经初始化完毕的全局、静态变量；\",\"代码区(Text)：存储只读的机器指令。\",\"按照这些区各自的特点，代码区的指令会自动根据 PC 寄存器的值加载至 CPU 并运行，栈区用于保存局部变量、参数，内存会自动随着函数调用而开辟和释放，数据区的内存由于是全局、静态变量，因此也不会被释放调，它们在程序启动的时候就已经被分配了，在整个程序的生命周期中一直存在。\",\"而剩下的堆区则是程序内存管理的最主要战场了，事实上堆内存也占据了地址空间上最大的一块。堆内存具有如下特点：\",\"生命周期灵活，由用户程序自己管理；\",\"大小可变，可按块分配大内存，也可按字节分配小内存；\",\"按需分配，由 sbrk 指针管理，指针上移则开辟内存，下移则释放内存；\",\"堆内存虽然灵活，但同时也带来了一些问题：\",\"如果开辟的内存未使用，但也未释放，就会造成内存泄漏；\",\"如果开辟的内存仍在使用，但被释放了，就会造成悬挂指针。\",\"这些内存问题也一直困扰着 C/C++程序员们，尤其是初学者。\"]},\"233\":{\"h\":\"管理方式\",\"t\":[\"既然内存管理如此重要，因此几乎所有编程语言都将内存管理内置到了语言中，而它们的管理方式可以分为两大类：\",\"手动管理：如 C 中 malloc/free 函数分别用来开辟、释放内存；\",\"自动管理：如 Java、Go、Python 等内置了垃圾回收器(GC)来追踪内存使用，自动释放未用的内存（垃圾）。\"]},\"234\":{\"h\":\"手动管理\",\"t\":[\"手动内存管理应该算是内存管理的经典流派了，其核心思想是充分信任程序员，待程序需要更多内存时，通过 malloc(或者 new) 函数来开辟内存，当内存不再需要的时候，调用 free(或者 delete) 函数来释放。\",\"理想情况下，一个高素质的工程师不仅能合理完成业务需求，还要对程序内存使用做到精准管理，这样内存不仅能够得到完善的管理，也不会造成内存安全问题。\",\"C/C++ 是手动内存管理语言的代表，举个简单的例子：\",\"int main(int argc, char const *argv[]) { // 开辟内存 int *a = (int *)malloc(sizeof(int)); *a = 1; printf(\\\"%d\\\\n\\\", *a); // 用完后释放 free(a); return 0; } // output: // 1 \",\"在这个简单的 C 语言例子中，开发者必须手动调用 malloc 来为变量 a 分配内存，待使用完后，又需要手动调用 free 将内存还给进程。\",\"试想一下，对于少量的变量，精准控制它们的分配与释放是较为简单的，可是一旦代码量急剧攀升，变量也极具攀升，而人的精力总是有限的，难免会出现错误导致内存问题。\",\"而且很多时候，为了性能考虑，开发者还需抉择内存是在堆上分配，还是栈上分配，如此机械的开辟、释放工作无疑会占开发者很多的时间和精力。\",\"C++为了改善一点，引入了构造、析构函数，智能指针（本质上是引用计数）来改善内存的自动管理，一些 C++的拥趸者觉得这已经够了，但更多的人觉得这不够，因此他们引入了纯自动内存管理的编程语言。\"]},\"235\":{\"h\":\"自动管理\",\"t\":[\"自动内存管理几乎是现代语言的标准，第一个使用内存自动管理的语言是 Lisp，它的作者 John 为其实现了一个非常简单的 GC(Garbage Collection)算法，被称为标记清理算法(Mark-Sweep)。\",\"这个算法管理内存的思路很简单：\",\"标记：实时追踪程序变量，标记出可达对象；\",\"清理：标记完成后，未标记的对象都是不可达的，可以作为垃圾清理掉。\",\"这个算法思路虽然简单，但至今仍在使用，是学习 GC 算法的必经之路。当然 GC 算法还有很多，每个语言的实现不尽相同，后文我们再来细谈。\",\"内存从手动管理到自动管理是语言的一大步，这种机制彻底解放了开发者们，并且让普通人开始着手写代码，体验创造的乐趣。此后，工程师只需将精力集中在核心的业务逻辑上，无疑这提升了开发效率。\",\"但好东西都是有代价的，内存自动管理虽然帮助开发者节约了时间和精力，解决了基本的内存问题，但同时也带来了一定量的性能损害，这其中就有最臭名昭举的 STW(Stop The World)问题。\"]},\"236\":{\"h\":\"内存管理\",\"t\":[\"在对内存、内存布局、内存管理简单介绍后，我们进入真正的正文部分：用 Go 来实现内存管理。\",\"肯定很多人觉得 Go 是一门自带 GC 的语言，有必要再去管理其内存吗？\",\"理论上来说，是不需要的，但最近一段时间笔者分别看到了三篇文章，它们不约而同地指向了一件事情：Go 的 GC 不稳定，我们需要另外的内存管理方式。\",\"这三篇文章分别是：\",\"2019 年 Ross 在 twitch 上发表了一篇名为Go memory ballast: How I learnt to stop worrying and love the heap的文章；Ross 提出了一种 ballast 的内存管理方式，显著地降低了 GC 带来的延时。\",\"2022 年 2 月，danscales 在 Go 的官方 Github 仓库上提出了一个名为proposal: arena: new package providing memory arenas的提案，这个提案希望 Go 能提供一种手动内存管理的 Area API。\",\"同样在 2022 年 2 月，heiyeluren 在 Github 上开源了一个名为XMM的 Go 三方内存管理库，旨在完美逃逸掉 Go 的内存 GC 机制，构建高性能基础设施。\",\"受这 3 篇文章的启发，以及抱着对内存管理的兴趣，笔者决定在 Go 上分别实现手动、自动内存管理两种方式，以此为契机来深入理解 Go 的内存管理。\"]},\"237\":{\"h\":\"内存分配原理\",\"t\":[\"在前面的内存布局中，我们了解到内存管理的最主要模块是堆内存。由于是虚拟内存，这个堆非常大，现阶段几乎不可能用完，因此暂时无需考虑堆越界的问题。\",\"堆(heap)存在于进程地址空间中，而进程地址空间(mm)又被定义在进程(task_struct)中，它们之间的关系如下所示：\",\"在代码层面上，以 Linux 操作系统为例，它们之间的定义如下：\",\"struct task_struct { // ... struct thread_info thread_info; // 处理器特有数据 // ... struct mm_struct *mm; // 指向进程内存结构 // ... }; struct mm_struct { // ... // 进程应用程序堆区的开始、当前地址、栈开始地址 unsigned long start_brk, brk, start_stack; // 进程应用程序参数区开始、结束地址 unsigned long arg_start, arg_end, env_start, env_end; // ... }; \",\"代码里，笔者已经注释了与堆相关的两个变量，分别是：\",\"start_brk：堆开始地址；\",\"brk：堆当前地址。\",\"以进程的视角来看，管理堆其实就是移动 brk 这个地址指针，start_brk 在创建后就不会改变；brk 指针增加，表示分配堆内存，brk 指针减少，则会释放堆内存。如下：\",\"以应用程序的视角来看，管理内存的本质实质就是通过进程提供的 API 来移动 brk 指针，而这个 API 就是著名的 BRK API：\",\" BRK(2) NAME brk, sbrk - change data segment size SYNOPSIS #include <unistd.h> int brk(void *addr); void *sbrk(intptr_t increment); \",\"以函数 sbrk 为例，其接收一个参数 increment，当 increment 大于 0 时，则将 brk 指针向上移动，小于 0 时，则向下移动，调用成功后返回分配地址的内存，调用失败则返回 -1。\",\"我们来实操一下，看 sbrk 是否能真的分配内存，如下：\",\"/* #include <stdio.h> #include <unistd.h> static void* Sbrk(int size) { void *r = sbrk(size); if(r == (void *)-1){ return NULL; } return r; } */ import \\\"C\\\" // ... 省略 func main() { mem := C.Sbrk(C.int(100)) fmt.Println(mem) } \",\"运行程序，会得到以下输出(得到的内存地址可能不同)：\",\"0xba00000 \",\"这说明，sbrk 确实真正的向进程申请到了内存，而这个内存是可以直接读写的。\",\"除了这种方式，操作系统还提供另外的一种系统调用 mmap 也能达到申请堆内存的效果：\",\"NAME mmap, munmap - map or unmap files or devices into memory SYNOPSIS #include <sys/mman.h> void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); int munmap(void *addr, size_t length); \",\"当然，mmap 的实现机制与 sbrk 有很大的不同，而且用途更多，简单而言，它会映射堆中的一块内存供程序操纵，这块内存大小由参数控制，因此可以提前申请一大块内存，然后用这块内存来用于程序其它数据的分配。\",\"mmap 的内容比较多，本文的重点是简单使用它，因此关于它的其它用法，或者实现机制可以参考这里。 另外无论是 sbrk 还是 mmap 看似都从堆里面分配了内存，但实际上这些都是虚拟内存，而当程序使用内存时，物理内存才会真正的分配，这种懒加载的机制被称为缺页中断(demand paging)，感兴趣的同学可以查看相关的资料。\",\"事实上，我们在 C 中使用的 malloc/free 两个函数内部的都是通过调用 sbrk，mmap 等 API 来分配、释放内存的。\",\"另外，对于 C 而言，标准库提供的 malloc/free API 是由 glibc 实现的，而内存分配显然是一个很棘手的问题，不同的场景下有不同的分配算法实现，比如另外两个比较知名的实现：jemalloc和tcmalloc。它们各有优缺点，感兴趣的同学可以点开看看。\"]},\"238\":{\"h\":\"GC 实践\",\"t\":[\"在 Go 程序中，我们几乎不用关注内存管理，runtime(运行时)会为程序接管进程内存，当需要内存分配对象时，直接新建对象即可，当对象不再使用时，会被自动回收掉(GC) 。\",\"举个例子：\",\"func main() { PrintMemUsage() pid := os.Getpid() fmt.Printf(\\\"process: %d\\\\n\\\", pid) time.Sleep(time.Second * 1) var overall [][]byte for i := 0; i < 4; i++ { a := make([]byte, 0, 1024*1024*50) overall = append(overall, a) PrintMemUsage() time.Sleep(time.Second) } overall = nil PrintMemUsage() runtime.GC() PrintMemUsage() } // PrintMemUsage 输出当前程序内存情况 func PrintMemUsage() { var m runtime.MemStats runtime.ReadMemStats(&m) // For info on each, see: https://golang.org/pkg/runtime/#MemStats fmt.Printf(\\\"Alloc = %v MiB\\\", bToMb(m.Alloc)) fmt.Printf(\\\"\\\\tTotalAlloc = %v MiB\\\", bToMb(m.TotalAlloc)) fmt.Printf(\\\"\\\\tSys = %v MiB\\\", bToMb(m.Sys)) fmt.Printf(\\\"\\\\tNumGC = %v\\\\n\\\", m.NumGC) } func bToMb(b uint64) uint64 { return b / 1024 / 1024 } \",\"运行该程序，会得到如下输出：\",\"Alloc = 0 MiB TotalAlloc = 0 MiB Sys = 8 MiB NumGC = 0 process: 1855 Alloc = 50 MiB TotalAlloc = 50 MiB Sys = 60 MiB NumGC = 1 Alloc = 100 MiB TotalAlloc = 100 MiB Sys = 114 MiB NumGC = 2 Alloc = 150 MiB TotalAlloc = 150 MiB Sys = 168 MiB NumGC = 2 Alloc = 200 MiB TotalAlloc = 200 MiB Sys = 222 MiB NumGC = 2 Alloc = 200 MiB TotalAlloc = 200 MiB Sys = 223 MiB NumGC = 3 Alloc = 0 MiB TotalAlloc = 200 MiB Sys = 223 MiB NumGC = 4 \",\"代码第 8 行，通过 make 关键字大量分配内存，每次 50M，共 4 次； 代码第 13 行，当对象不再被需要时，直接置为 nil 即可；注意：通过此时的输出发现，200M 内存仍然占用，而在最后的一行输出中，被分配的内存瞬间回到了 0M。 原因在于，代码的第 15 行，调用了 runtime 提供的 GC 函数，回收掉了不需要的垃圾对象。\",\"通过这个例子，我们已经见识到了 GC 的强大能力，而在真实的场景中，应用程序是不用手动调用 GC 的(这里之所以调用，是为了展示)，runtime 会自动监测内存使用情况，然后在合适的时机自动 GC。\",\"这样，自动内存管理的好处就显现出来了，写代码时无需关注内存的回收问题，也不会产生内存的安全问题，将全部精力和时间放在核心业务上，自然就能提高代码、项目质量，也能让程序员朝九晚五的工作(梦想还是要有的)。\",\"但这个例子也暴露出 GC 的一个问题：overall 被置为 nil 后，显然此时它被分配的 200M 内存就已经是垃圾，但 runtime 并没有立即回收，因此这里才手动调用了 GC 函数来回收垃圾。而真实的场景远比这复杂，可能有大量的垃圾没有及时回收，但它们仍然占用了内存，这样内存资源就被浪费了。\",\"更棘手的是，即使 runtime 发现了大量垃圾，比如 200M，但是回收垃圾也是需要时间的，而此时程序仍然运行，仍有可能在分配新的对象，这样边回收边开辟会非常复杂。因此，runtime 会选择暂停程序运行，回收掉垃圾后再恢复，而这个暂停就是上文谈到的 STW；直观上，STW 的时间越少肯定越好，如果 STW 时，仍有大量用户请求，那么服务就无法服务用户。这也是为什么Go memory ballast: How I learnt to stop worrying and love the heap这文章的作者要提出 Go memory ballast 来降低 GC 时延的原因。\",\"那么，有没有一种方式能让内存逃开 GC 的限制？从而减少 STM 的发生。\",\"无疑，是有的。Go memory ballast 就是其中的一种方式，而且它的原理很简单，如下：\",\"func main() { big := make([]byte, 1024*1024*200) runtime.KeepAlive(big) } \",\"Go memory ballast 会预先分配一大块内存，如这里的 200M，然后调用 runtime.KeepAlive 函数，这样 runtime 会一直认为 big 这段内存是存活的，不会尝试去回收它。从此，我们就能在程序中接管 big 这段内存，并且按需使用，且无需被 GC 掉，从而减少 STM 的发生频率，这种方式也被 TiDB 用在了生产环境上。\",\"除此之外，还有一种更加彻底的方式来逃开 GC，有了上面的进程内存管理的铺垫，这不难想到，那就是直接通过 mmap 系统调用向进程要内存，绕开 runtime 这一层。如下：\",\"func main() { PrintMemUsage() pid := os.Getpid() fmt.Printf(\\\"process: %d\\\\n\\\", pid) time.Sleep(time.Second * 1) var overall []*Area // 1216 KB for i := 0; i < 5; i++ { area, err := Init(1024 * 1024 * 50) if err != nil { log.Fatalln(err) } overall = append(overall, area) PrintMemUsage() } runtime.GC() PrintMemUsage() } \",\"这里，我们不再通过 make 函数来向 runtime 中申请内存，而是使用 mmap 申请内存，将其包装为 Area 返回：\",\"type Area struct { addr uintptr // 首地址 mem []byte // 内存 size int // 内存大小 allocated int // 已分配内存 blocks int // 内存块个数 } // 通过 mmap 来分配内存 func Init(size int) (*Area, error) { mem, err := syscall.Mmap(-1, 0, size, syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_ANON|syscall.MAP_PRIVATE) if err != nil { return nil, fmt.Errorf(\\\"mmap err: %s\\\", err) } addr := unsafe.Pointer(&mem[0]) hdr := (*header)(addr) hdr.size = size - headerSize m := &Area{ addr: uintptr(addr), mem: mem, size: size, allocated: 0, blocks: 0, } return m, nil } \",\"运行程序，输出如下：\",\"Alloc = 0 MiB TotalAlloc = 0 MiB Sys = 8 MiB NumGC = 0 process: 19282 Alloc = 0 MiB TotalAlloc = 0 MiB Sys = 8 MiB NumGC = 0 Alloc = 0 MiB TotalAlloc = 0 MiB Sys = 8 MiB NumGC = 0 Alloc = 0 MiB TotalAlloc = 0 MiB Sys = 8 MiB NumGC = 0 Alloc = 0 MiB TotalAlloc = 0 MiB Sys = 8 MiB NumGC = 0 Alloc = 0 MiB TotalAlloc = 0 MiB Sys = 8 MiB NumGC = 0 \",\"我们发现，无论怎么调用 mmap 函数分配内存，但 runtime 打印的内存指标一直为 0，而且没有触发任何 GC，即使手动去调用 GC，但 GC 也没有真正的发生。\",\"这也映证了刚才谈到的，mmap 绕开了 runtime 这一层，直接向进程要内存。\"]},\"239\":{\"h\":\"手动内存管理实践\",\"t\":[\"拿到了进程下放的内存后，我们又该如何管理了？其实很简单，借鉴[抄]！\",\"思路也比较简单，仿照 C 语言内存管理，即手动管理，将拿到的大块内存(Area)作为内存资源缓存在程序中，然后需要内存时，向 Area 请求(Alloc)内存，待内存使用完毕后，调用 Area 的 Free 方法将内存放入 Area 中。\",\"实际上，这种方式几乎就是 arena: new package providing memory arenas 提案的简单实现方式了。\",\"现在，急需解决的问题是：Area 如何管理这一大块内存？\"]},\"240\":{\"h\":\"First-fit\",\"t\":[\"我们先选择一种简单的管理方式，通过链表来管理，示意图如下：\",\"具体的方案为：\",\"将 Area 分成很多小块，每小块都有一个头部(header)来存储元数据，比如：该块是否使用，块大小，并且头部中还有一个 next 指针指向下一个可分配的块；\",\"调用 Area.Alloc 时，从内存起始地址依次沿链表寻找，当找到一个大小合适且未被使用的内存块时，返回该块的地址即可；\",\"调用 Area.Free 时，拿到被回收块的 header，将其标记为可用。\",\"将其翻译为代码，对于 Alloc，接受 size 参数，即分配内存的大小；然后判断 Area 是否还有可用内存，没有则直接返回错误，然后拿到 Area 的首地址，依次向后搜索，找到第一个大小合适，且未分配的块，找到后将该块标记为已用，并将 next 指针指向下一块。\",\"type header struct { size int // 块大小 allocated bool // 是否分配 next *header // 下一块 } func (m *Area) Alloc(size int) (unsafe.Pointer, error) { if m.allocated+size+headerSize > m.size { return nil, fmt.Errorf(\\\"can't alloc any more\\\") } h := (*header)(unsafe.Pointer(m.addr)) // 如果内存已分配，且大小不够，则下一个 for h.allocated || h.size < size { h = h.next } // 没有找到可用的 block if h == nil { return nil, fmt.Errorf(\\\"can't alloc any more\\\") } prevSz := h.size cur := unsafe.Pointer(h) p := unsafe.Pointer(uintptr(cur) + uintptr(headerSize)) // 下一个 hdr := (*header)(unsafe.Pointer(uintptr(cur) + uintptr(headerSize) + uintptr(size))) hdr.size = prevSz - size - headerSize h.size = size h.allocated = true h.next = hdr m.allocated += size + headerSize m.blocks++ return p, nil } \",\"对于 Free 函数则要简单的多，通过指针操作(指针偏移)拿到块 header 后，将 allocated 标记为 false 即可。\",\"func (m *Area) Free(p unsafe.Pointer) error { h := (*header)(unsafe.Pointer(uintptr(p) - uintptr(headerSize))) if !h.allocated { return fmt.Errorf(\\\"can't free %x twice\\\", p) } h.allocated = false m.allocated -= h.size + headerSize m.blocks-- return nil } \",\"这种简单的内存管理方式被称为 First-fit，此外还有 Best-fit，Next-fit 等一些列的分配算法。不过这些算法都不够好用，举例来说：\",\"如图所示，块 1 较大，50 字节，块 2 较小，20 字节，且都已经被分配；一段时间后，块 1 被释放了，而此时 Alloc 又被调用了，但只需 10 字节的内存，按照 First-fit 的原则，那么块 1 就应该被返回，那就意味着有 40 字节的内存时被浪费的。\",\"还比如，在一些场景中，小内存的分配很频繁，如下：\",\"由于小内存的块很小，比如 10 字节，而块的头部 header 也是需要占内存的，这样会显得头重脚轻，大量的内存都被用于存储元数据了，也会造成内存浪费。等等，First-fit 内存分配算法的问题很多，当然也因为它最够简单，所以也是学习内存管理必经的一步。\"]},\"241\":{\"h\":\"tcmalloc\",\"t\":[\"如何实现更好的内存管理方式呢？思路很简单，借鉴[抄]。\",\"前面在内存分配原理中，我们提到 malloc/free 有多种优秀的内存管理实现，比如 tcmalloc 就是 Google 开源的一款内存分配器。tcmalloc 全程 thread cache malloc，即核心思想就在于线程缓存，当然 tcmalloc 优秀的设计不止这一点，主要如下：\",\"tcmalloc 对内存以页为基本单位，每个向进程申请内存时，至少申请 1 页内存；\",\"tcmalloc 小、大对象内存分配策略不同，小内存的块大小固定，如 8 字节、16 字节、32 字节等，每个页都装满了相同尺寸的块，当调用 Malloc 时，会按照参数计算合适的块大小，然后去页中拿到空间块返回；对于大内存，就没有与之对应的块，而是直接按照页来分配；\",\"tcmalloc 适合多线程下的内存分配场景，每个线程都有一定量的内存缓存，当申请这些内存时，无需加锁，而是直接通过缓存拿到，这样减少了数据竞争，提升了分配性能；\",\"tcmalloc 的架构比较复杂，这里笔者会简单介绍它的核心概念以及实现，感兴趣的同学可以点开这里慢慢了解。\",\"tcmalloc 对内存块进行了分类(class)，同一个 class 的块内存大小是一样的，这样就不用在 header 中记录每个块的大小了，另外 tcmalloc 通过 freelist(空闲链表) 的方式来连接内存块，如下：\",\"如图所示，对于 class0，其大小 8 字节，那么它所对应的 freelist 中的每一个内存块都是 8 字节；freelist 本身是一个页，被组织为一个单向链表，当内存分配时，从 freelist 中拿出(pop)一个块返回，块无需再与其它块链接，因此整个块都是可用内存，没有元数据浪费。\",\"但是这也会引出一个问题，调用 Free 的时候，块又该放回那个 freelist 呢？\",\"tcmalloc 定义每个页都有一个 ID，这个 ID 不是 tcmalloc 直接分配的，而是按照页的首地址算出来的，因此就每个块的首地址除以页大小就能得到对应的页 ID：\",\"pageNum := p / pageSize \",\"这样就能拿到对应的页，也能找到对应的 freelist。\",\"内存分配的场景十分复杂，如果某个 class 的内存块被大量申请，一个页很快就会被用完，因此 tcmalloc 引入了 span 这个概念。\",\"span 由一个或多个页组成，而且这些页是连续的，且这些页的 class 是一样大的，span 也会有一个固定的 class 大小，如下：\",\"最后回到 tcmalloc 最重要的一环上来，那就是缓存(cache)，当一个线程申请内存的时候，会优先去缓存(cache)中去拿，如果缓存中没有的话，才去请求全局内存(central)。central 管理着全局内存，由它负责向进程申请内存，然后将内存拿到后放入 PageHeap 和 PageMap 中管理，这里又引入了两个新的概念：\",\"PageHeap：页堆，存储 central 所申请的页内存；\",\"PageMap：页表，存储页 ID 与 span 之间的映射关系。\",\"当 cache 向 central 申请内存时，central 会优先从页堆中拿出空闲页返回，如果没有空闲页再向进程申请；当内存块释放时，拿到页 ID 后，通过 PageMap 查询到对应的 span 后，将内存块放回 span，这样 Free 的工作就完成了。\",\"central、cache、PageMap、PageHeap 的关系如下：\",\"介绍完 tcmalloc 的核心概念和原理后，我们再来看看如何用 Go 实现 tcmalloc。这里说明，由于在 Go 中没有提供线程缓存的 API，我们无法使用线程缓存，所以实现中定义的 Cache 仅仅只能模拟出 Cache 的机制，而无法发挥线程缓存的作用。\",\"对于内存开辟(Malloc)，实现如下：\",\"// Malloc 分配内存 func Malloc(size int) uintptr { if size <= 0 { return 0 } // 小对象 if size <= smallObjectSize { // 计算 size 对应的 class class := size2Class(size) obj, err := threadCache.getObject(class) if err != nil { log.Printf(\\\"malloc err: %s\\\", err) return 0 } if obj == nil { return 0 } return uintptr(unsafe.Pointer(obj)) } // 大对象 numPages := (size-1)/pageSize + 1 globalLock.Lock() defer globalLock.Unlock() s, err := globalPageHeap.getSpan(numPages) if err != nil { log.Printf(\\\"malloc err: %s\\\", err) return 0 } s.state = allocatedLarge return s.pageStart } \",\"和刚才谈到的一样，对象分配有两种情况；对于小内存，计算出对应的 class 后直接去线程缓存 threadCache 中去拿即可，对于大内存，则是直接计算出页个数去全局的 PageHeap 中拿到内存。\",\"这里麻烦的是 threadCache.getObject(class) 函数，因为它实际上是一条很长的链路，如下：\",\"首先，cache 会先判断缓存中是否有可用的块内存，如有直接返回；若没有，则需向 central 申请，若 central 有则返回，否则还需向进程申请，然后返回。\",\"对于内存释放(Free)，过程相对简单一些，实现如下：\",\"// Free 释放内存 func Free(p uintptr) { if p == 0 { return } // 先获取对应的 span pageNum := p / pageSize addr := globalPageMap.get(int(pageNum)) if addr == 0 { return } s := (*span)(unsafe.Pointer(addr)) // 无需再次释放 if s.state == free { return } // 小对象，回收至缓存 if s.state == allocatedSmall { threadCache.insert(s.objectClass, (*object)(unsafe.Pointer(p))) return } // 大对象直接放回 pageHeap globalLock.Lock() defer globalLock.Unlock() s.coalesce(globalPageHeap) err := globalPageHeap.insertSpan(s) if err != nil { log.Printf(\\\"free err: %s\\\", err) } } \",\"为了避免二次释放，所以会先判断对应 span 的状态；如果是小对象，直接插入回 cache 中，方便下次分配；对于大对象，前面说到大对象是按页来分配的，因此是无法插入会 cache 的，只能将其重新插入 PageHeap。\",\"由于 tcmalloc 的实现细节还有很多，比如：\",\"页之间的分裂与合并；\",\"span 之间如何链接；\",\"PageMap 如何存储页 ID 和 span 之间的映射；\",\"这些内容比较多，放在这里一一细讲会浪费很大的篇幅，因此这里选择略过，感兴趣的可以查看源码。当然笔者的实现略显粗糙，暂时无法应用在实际场景，你也可以直接阅读 tcmalloc 的源码。\",\"最后，我们来测试一下 tcmalloc：\",\"func TestFree4(t *testing.T) { assert := assert.New(t) pointers := make([]uintptr, 0, 1000) for i := 0; i < 1000; i++ { p1 := Malloc(100) assert.NotEqual(int(p1), 0) t.Logf(\\\"%d\\\\n\\\", p1) pointers = append(pointers, p1) } for i := 0; i < 1000; i++ { Free(pointers[i]) } } \"]},\"242\":{\"h\":\"自动内存管理实践\",\"t\":[\"现在，手动内存管理将告一段落了，下面的内容，我们将谈谈如何实现自动内存管理，也就是上面谈到的 GC 实现。\",\"之所以在自动内存管理放在手动内存管理的后面，那是因为自动内存管理依赖于手动内存管理，就比如 Java 的 GC 实际还是依靠 malloc/free 来实现的，只不过这些由 GC 算法来自动调用，解放了我们的双手。\",\"我们刚才实现了两个版本的 malloc/free，已经对内存管理有了一定的认识与理解，对这种机械式的内存管理方式，我们现在需要改造它。\",\"提一下：实际上 Go 本来就有 GC，那为什么还要再谈 GC 实现了？主要是笔者一直觉得 GC 虽然好，但是隐藏了太多的内存细节，而这些细节有时候又很重要，因此才写下这篇文章来龙去脉的来谈谈内存管理。\",\"在前面的自动管理处，笔者曾说过，Lisp 是第一个用上 GC 的语言，且其算法是标记清理算法(Mark-sweep)。Mark-sweep 易懂，而且十分的经典，虽然目前有很多的 GC 算法实现，但或多或少保留着它的影子，包括 Go 的 GC 算法——三色标记法。\"]},\"243\":{\"h\":\"Mark Sweep(标记清理法)\",\"t\":[\"因此，我们首先来谈谈 Mark-sweep 算法是如何实现的？\",\"这里我们需要先引入几个概念。\",\"一、可达性\",\"程序在运行时，会产生大量的垃圾对象，GC 算法需要找到这些垃圾对象然后才能清理。那么如何定义对象是否为垃圾呢？大多数 GC 实现都采用可达性分析来判断对象是否存活，如果存活则保留，非存活则当成垃圾回收。\",\"二、GC roots\",\"如果将程序对象视为一个网状图，判断对象是否可达实际就是在图中搜索出路径不可达的对象，而图的搜索需要一个起点，这个起点就被称作 GC roots。\",\"如下图所示，是一个简单程序的对象分布图：\",\"图中底部的菱形图标就是 GC roots，从 GC roots 出发，遍历对象图，红色圆圈表示可达，白色圆圈为不可达。\",\"GC roots 主要有如下几类对象：\",\"寄存器变量；\",\"局部变量；\",\"全局变量；\",\"。。。\",\"当 Mark-sweep 开始工作时，从所有 GC roots 出发，沿着连接搜索图中对象，将可达队对象依次标记（Mark 阶段），标记完成后，将所有不可达的对象全部清理掉（Sweep 阶段）。工作流程如下图所示：\",\"下面，我们来看看如何实现 Mark-sweep 算法。首先，我们定义通用对象结构体 Object：\",\"// ObjectType 对象类型 type ObjectType int const ( // ObjInt int 对象 ObjInt ObjectType = iota + 1 // ObjPair 元组对象 ObjPair ) // Object 对象 type Object struct { typ ObjectType // 8 next *Object // 8 marked bool // 8 inner interface{} // 16 } \",\"Object 用于表示任意对象，如 integer 对象，或者 pair 对象；它有 4 个字段：\",\"typ：对象类型；\",\"next：指向下一个对象的指针，所有对象由链表连接；\",\"marked：标记对象是否存活；\",\"inner：真正的数据，如：integer 对象，inner 可能为 998。\",\"这样每个新建的对象都有类型、标记、连接等元数据信息，next 指针会将所有对象连接成一个大链表，方便在清理阶段找到不可达(mark 为 false)对象，然后将其清理掉。\",\"提一点：在 GC 阶段，对象图之间的连接不是 next 指针，而是对象之间的相互引用，next 指针是为了跟踪所有的对象。\",\"同时，我们定义一个 VM 结构体用于对象分配、GC 等，VM（虚拟机）是实现 GC 最重要的数据结构，它主要由如下功能点：\",\"负责新建对象、维护对象之间的引用关系；\",\"负责管理所有对象，维护对象个数等信息；\",\"负责实时监控对象数据信息，在合适的时间触发 GC。\",\"定义如下：\",\"type VM struct { numObjects int // 当前对象个数 maxObjects int // 最大对象个数，超过这个值则触发GC link *Object // 对象链表，所有分配对象通过链表连接 stack [stackMax]*Object // 栈，用栈来模拟 GC roots stackSize int // 当前栈大小 } \",\"字段说明都已注明，这里仍需简单说一下：\",\"GC roots 的范围是比较广的，由于我们没有重新实现一门语言，因此寄存器、局部变量、全局变量这些数据是追踪不到的，因此这里选择使用栈来模拟 GC roots，即在栈上的变量都是 GC roots；实际上很多带虚拟机的语言实现基本也是这个思路；\",\"对于 GC 的触发机制，这里选择最简单的数量阈值触发，当对象个数超过了阈值，则触发；\",\"另外由于 link、next 指针是为了将所有对象连接起来，因此对象之间的引用关系，即对象图中的路径连接，就需要新的机制来模拟，这里我们引入了元祖(Pair)类型：\",\"type Pair struct { head *Object // 头 tail *Object // 尾 } \",\"通过 Pair 对象中的头、尾指针来模拟对象之间的引用，Pair 本身也是一个对象，每一个 pair 对象会引用另外两个对象。\",\"新建对象都必须通过 VM 来操作，VM 向 tcmalloc 申请内存后，将其加入到全局链表并入栈，这样对象不仅可以通过链表被找到，同时也是 GC roots。如下：\",\"// 对象入栈，加入 GC roots func (v *VM) push(value *Object) { v.stack[v.stackSize] = value v.stackSize++ } // 整数对象入栈 func (v *VM) pushInt(n int) { obj := v.newObject(ObjInt) obj.inner = n v.push(obj) } // 新建对象，调用 tcmalloc，并加入全局链表，然后返回 func (v *VM) newObject(typ ObjectType) *Object { if v.numObjects == v.maxObjects { v.GC() } addr := tcmalloc.Malloc(objSiz) obj := (*Object)(unsafe.Pointer(addr)) obj.typ = typ obj.next = v.link obj.marked = false v.link = obj v.numObjects++ return obj } \",\"这里，VM 分别为 int、pair 类型提供对应的新建、入栈 API；对于 int 类型，分配内存、加入全局链表后即可入栈，而 pair 对象则相对麻烦一点，需要从栈顶弹出两个对象然后再入栈：\",\"// 元组对象入栈，先从栈中pop出两个对象，建立关联后再入栈 func (v *VM) pushPair() *Object { obj := v.newObject(ObjPair) addr := tcmalloc.Malloc(pairSiz) pair := (*Pair)(unsafe.Pointer(addr)) pair.head = v.pop() pair.tail = v.pop() obj.inner = pair v.push(obj) return obj } \",\"这样，两个对象之间就存在引用关系，即使二者不在栈中，仍可通过图扫描被找到。而那些既不在栈中，也没法通过扫描找到的对象，自然就是垃圾对象，它们将会被回收。因此，VM 提供了 pop 来让一个对象出栈，从而就不再是 GC roots 了。\",\"// 栈顶对象出栈，不再是 GC roots func (v *VM) pop() *Object { v.stackSize-- return v.stack[v.stackSize] } \",\"下面则是 mark-sweep 算法的具体实现了，在标记阶段，从每个 GC roots 开始，标记它们所有可达的对象，如下：\",\"// 标记所有 GC roots 及可达对象 func (v *VM) markAll() { for i := 0; i < v.stackSize; i++ { v.stack[i].mark() } } // 标记对象 func (o *Object) mark() { if o.marked { return } o.marked = true if o.typ == ObjPair { p := o.inner.(*Pair) p.head.mark() p.tail.mark() } } \",\"栈中所有对象都是 GC roots，如果是 int 对象，直接设置 mark 为 true 即可，而如果是 pair 对象则还需标记它的两个头、尾指针；头、尾指针虽然不在栈中，但它们是 GC roots 可达的，标记完成后，剩余的对象就是不可达的，我们调用 sweep 将其清理掉：\",\"// 清理 func (v *VM) sweep() { obj := v.link for obj != nil { if !obj.marked { unreached := obj obj = unreached.next addr := uintptr(unsafe.Pointer(unreached)) tcmalloc.Free(addr) v.numObjects-- } else { obj.marked = false obj = obj.next } } } \",\"由于所有对象都会连接在全局链表 link 上，sweep 从 link 的头节点开始遍历，如果对象未被标记则表示不可达，因此将其 Free 掉，如果对象可达，则跳到下一个链表节点，这样扫描完毕后，垃圾也会被清理完毕。\",\"最后，将标记、清理放在一起：\",\"func (v *VM) GC() { numObjects := v.numObjects if numObjects == 0 { return } // mark v.markAll() // sweep v.sweep() if v.numObjects == 0 { v.maxObjects = initialGCThreshold } else { v.maxObjects *= 2 } fmt.Printf(\\\"Collected %d objects, %d remaining.\\\\n\\\", numObjects-v.numObjects, v.numObjects) } \",\"至此，一个简单的 mark-sweep 算法已经实现完毕，当然 GC 一般都是被动触发的，这里选择将触发时机放在 newObject 中：\",\"func (v *VM) newObject(typ ObjectType) *Object { if v.numObjects == v.maxObjects { v.GC() } // .... } \",\"当目前对象个数超过了阈值后，就会触发 GC，而且阈值也会随着运行情况而改变(见 GC 函数)。\",\"简单测试一下 mark-sweep 算法：\",\"func TestVM_GC4(t *testing.T) { assert := assert.New(t) vm := NewVM() vm.pushInt(1) vm.pushInt(2) a := vm.pushPair() vm.pushInt(3) vm.pushInt(4) b := vm.pushPair() // 改变a,b的引用，不再指向 2,4，因此2,4就变成了垃圾 a.inner.(*Pair).tail = b b.inner.(*Pair).tail = a // 此时已分配 6 个对象 assert.Equal(vm.numObjects, 6) vm.GC() // GC assert.Equal(vm.numObjects, 4) // 2,4 被回收了 vm.Free() } \",\"在这个例子中，vm 新建了 6 个对象，但栈中只有 2 个 GC roots，其他 4 个则是引用可达，最后改变 a，b 的引用，不再引用 2，4，它们也就成了垃圾，当调用 GC 时，会被回收掉，对象就剩 4 个了。\",\"显然，自动内存管理的本质仍是 malloc/free 两个函数，只是它们不再由用户主动调用，而是由 GC 算法选择合适的时机来调用。\"]},\"244\":{\"h\":\"tricolor(三色标记法)\",\"t\":[\"mark-sweep 算法简单易理解，但却有一个很大的问题：mark 和 sweep 这两个阶段必须先后进行，且不可被打断，而且必须 STW。\",\"因此，STW 的时间肯定比较长，一个程序长时间暂停服务肯定是不被允许的，因此 mark-sweep 有非常多的改进版本，其中一个非常著名的改进算法，也是 Go 采用的 GC 算法——三色标记法。\",\"下面，我们就一起来看看三色标记法(tricolor)。\",\"三色标记法是标记清理法的一个改进算法，主要目的是将标记阶段分开成多个小阶段，每个小阶段都可以完成一部分标记工作，待全部标记完成后再来一次清理。\",\"由于标记阶段占用了 GC 的大量时间，这样就能显著地降低标记 STW 时间。\",\"三个标记法将对象抽象为 3 种三种颜色：\",\"黑色：对象已经扫描，且其引用对象也已经扫描\",\"灰色：对象已经扫描，但其引用对象未被扫描\",\"白色：对象未被扫描\",\"颜色抽象是这样将标记阶段分为多阶段的：\",\"使用一个栈专门用来存储灰色对象，被称为灰色栈(grayStack)；\",\"开始标记时，所有对象都是白色的，GC roots 是可达的，将 GC roots 标记为灰色，并入栈；\",\"依次将对象从栈顶出栈，找到出栈对象的所有引用，将引用对象入栈，然后将出栈对象标记为黑色；\",\"重复步骤 3，直到栈中再无灰色对象，则代表所有可达对象都被标记为黑色；\",\"剩下的白色对象都是垃圾对象，等待回收清理。\",\"整体流程如下图所示：\",\"这样灰色对象由栈来管理，一次性的扫描就可以通过栈来分为多次，待栈为空时，则扫描完毕。\",\"因此，我们为 VM 结构体添加一个灰色栈：\",\"type VM struct { numObjects int maxObjects int link *Object stack [stackMax]*Object stackSize int grayStack [grayMax]*Object // 灰色栈 grayCount int } \",\"GC 函数也会有相应的改造：\",\"func (v *VM) GC() { // ... // mark v.markRoots() // traceReference 跟踪灰色对象 v.traceReference() // sweep v.sweep() // ... } \",\"GC 分为了三个阶段：\",\"markRoots：标记所有 GC roots 对象为黑色，将其引用对象入栈；\",\"traceReference：跟踪栈中的灰色对象，依次出栈，然后将其引用对象入栈，注意：这一步是可以多批次进行的；\",\"sweep：清理掉不可达的白色对象。\",\"实现分别如下：\",\"func (v *VM) markRoots() { for i := 0; i < v.stackSize; i++ { v.markObject(v.stack[i]) } } \",\"仍然将栈(不是灰色栈)中对象作为 GC roots；\",\"func (v *VM) traceReference() { for v.grayCount > 0 { v.grayCount -= 1 object := v.grayStack[v.grayCount] // 出栈，然后搜索连接对象 v.blacken(object) } } \",\"跟踪灰色栈中的对象，将其引用对象入栈，且颜色变为黑色：\",\"func (v *VM) blacken(o *Object) { if o.typ == ObjInt { return } if o.typ == ObjPair { p := o.inner.(*Pair) v.markObject(p.head) // 入栈 v.markObject(p.tail) // 入栈 } } func (v *VM) markObject(o *Object) { o.mark() v.grayStack[v.grayCount] = o v.grayCount++ } \",\"最后，当灰色栈为空时，调用 sweep 函数清理白色对象：\",\"func (v *VM) sweep() { obj := v.link for obj != nil { if !obj.marked { // 未被标记的，就是白色对象 unreached := obj obj = unreached.next addr := uintptr(unsafe.Pointer(unreached)) tcmalloc.Free(addr) v.numObjects-- } else { obj.marked = false obj = obj.next } } } \",\"至此，一个简单版的三色标记算法就被实现出来了，我们来测试一下：\",\"func TestVM_GC2(t *testing.T) { assert := assert.New(t) vm := NewVM() vm.pushInt(1) vm.pushInt(2) vm.pop() vm.pop() vm.GC() assert.Equal(vm.numObjects, 0) vm.Free() } \",\"这里，vm 新建了对象 1，2，但都不是 GC roots，且不可达，因此 GC 后，对象个数为 0。\",\"灰色栈的机制巧妙地将灰色标记分成了多阶段，而且黑色、灰色、白色并不是严格意义上的颜色标记，未标记的对象自然是白色，标记了且在灰色栈中的对象是灰色，标记了且出栈的对象才是黑色对象。\"]},\"245\":{\"h\":\"Go 内存管理\",\"t\":[\"终于铺垫到了这里，在前面的内容中，我们分别介绍手动内存管理与自动内存管理的原理，在此基础上，实现了手动内存管理的 tcmalloc 以及鼎鼎大名的 GC 算法——三色标记法。\",\"那么为什么要说是铺垫呢？因为 Go 的内存管理的两大核心正是 tcmalloc 和 三色标记 GC 算法。这个局布到这里，是为了让读者更清晰、更直观、更深入地了解 Go 是如何管理内存的。\",\"Go 的内存模块其实非常复杂，虽然它的核心实现是三色标记法，但也大量借鉴了 tcmalloc，如果一开始就直入主题，很多人都会不知所云，笔者最开始就是这样的，因此笔者铺垫了大量的内存、GC 知识，就是为了此刻能够将 Go 的内存管理变得容易理解一些。\",\"Go 的内存管理是一个真正的工业级实现，我们可以简单的将其分为：用户程序(Mutator)、内存分配(Allocator)和垃圾回收(Garbage Collector)三大模块。\",\"下面，我们就来依次看看 Go 是如何实现这三大模块的。\",\"内存分配：\",\"在前面的基础上，它引入了屏障技术、三色不变性来实现并发、增量对象标记，\"]},\"246\":{\"h\":\"总结\",\"t\":[\"写到这里，笔者不经感叹，这篇文章写的实在是不容易！\",\"由于 Go GC 本身的复杂性。\"]},\"247\":{\"h\":\"参考资料\",\"t\":[\"xmm\",\"minigc\",\"crafting interpreters\",\"golang-garbage-collector\",\"garbage-collect\",\"gc impl\",\"垃圾回收算法实现之-标记-清除\",\"A visual guide to Go Memory Allocator from scratch (Golang)\",\"Gravity— An MMAP Allocator\",\"go-slab - slab allocator in go\",\"Discovering and exploring mmap using Go\",\"The Slab Allocator: An Object-Caching Kernel Memory Allocator\",\"malloc\",\"Write a simple memory allocator\",\"tcmalloc\",\"golang-memory-allocator\",\"The Slab Allocator in the Linux kernel\",\"Linux 内核 | 内存管理——Slab 分配器\",\"20 张图揭开「内存管理」的迷雾，瞬间豁然开朗\",\"认真分析 mmap\"]},\"248\":{\"h\":\"go 汇编简单入门\",\"t\":[\"在 Go runtime 中存在了大量由 plan9 汇编书写的代码，想要了解 runtime 的实现和机制，掌握 plan9 汇编的基本使用是必须的。(Go 的作者们在选择汇编语言的时候没有选择 intel，也没有选择 AT&T，而是选择了 plan9，哎，一群固执老古董们）。\",\"plan9 语法虽然与 intel 和 AT&T 略有不同，但整体而言相差不大，如果你之前有其它汇编语言的基本，相信入手也很快。\",\"下面会介绍一些 plan9 中的常见语法，想要深入了解的可以查看本文的参考资料。\"]},\"249\":{\"h\":\"基本介绍\"},\"250\":{\"h\":\"寄存器\",\"t\":[\"plan9 中对寄存器的命名略有不同，全部大写而且不要前缀，它们之间的对应关系如下：\",\"rax\",\"rbx\",\"rcx\",\"rdx\",\"rdi\",\"rsi\",\"rbp\",\"rsp\",\"r8\",\"r9\",\"r10\",\"r11\",\"r12\",\"r13\",\"r14\",\"rip\",\"AX\",\"BX\",\"CX\",\"DX\",\"DI\",\"SI\",\"BP\",\"SP\",\"R8\",\"R9\",\"R10\",\"R11\",\"R12\",\"R13\",\"R14\",\"PC\",\"表格第一行是通用寄存器的真实名称，第二行是 plan9 中对通用寄存器的称呼。\",\"除了通用寄存器外，plan9 还定义了几个特殊寄存器来代表一些特殊值，即伪寄存器：\",\"PC：对应 64 位机中 rip 寄存器，一般称为 ip 寄存器；\",\"SB：Static Base Pointer 全局静态基地址，一般用来申明全局函数和变量，静态区的首地址；\",\"SP：Stack Poninter 当前函数调用栈帧基地址，即局部变量的首地址；\",\"FP：Frame Pointer 帧地址，用来访问函数的参数。\"]},\"251\":{\"h\":\"栈操作\",\"t\":[\"plan9 支持 push 和 pop 指令来操作当前调用栈：\",\"// 分配栈内存，将 AX 中的数据入栈 PUSHQ AX // 回收栈内存，将出栈数据拷贝到 AX POPQ AX \",\"例子：\",\"MOVQ $runtime·mainPC(SB), AX // entry 设置程序入口 AX = runtime.main PUSHQ AX // 入栈，传递参数 PUSHQ $0 // arg size，参数内存大小为 0，第一个参数最后入栈 CALL runtime·newproc(SB) // 新建 G，来启动 runtime.main，AX 寄存器上存储的是 runtime.main 函数的地址 POPQ AX // 两次出栈 POPQ AX \",\"这是 runtime 中的一个例子，runtime·newproc 函数通过栈接受两个参数，这里通过 PUSHQ 指令来将两个参数入栈，待调用完毕后，再执行 POPQ 出栈。\"]},\"252\":{\"h\":\"数据移动\",\"t\":[\"plan9 使用 MOV 指令来实现数据移动，与 AT&T 类似，MOV 的原数据在左侧，目标地址在右侧，格式如下：\",\"MOV SRC DST \",\"移动数据的大小由 MOV 指令后缀决定，如下：\",\"MOVB $1, DI MOVQ $-10, AX \",\"B 表示移动一个字节，即 byte，Q 表示四个字节，即 4 byte。\"]},\"253\":{\"h\":\"数据计算\",\"t\":[\"plan9 支持计算指令直接在寄存器上进行数据操作：\",\"ADDQ AX, BX // BX += AX SUBQ AX, BX // BX -= AX IMULQ AX, BX // BX *= AX \",\"指令不同的后缀表示操作数据大小，如 Q 表示 4 字节。\"]},\"254\":{\"h\":\"流程跳转\",\"t\":[\"plan9 支持 JMP 无条件直接跳转，如下：\",\"JMP _rt0_amd64(SB) // 入口 \",\"当然也支持有条件跳转：\",\"CMPQ AX, $0x123 // 比较 AX 与 0x123，如果不等直接 abort JEQ 2(PC) // 相等，直接跳过 2 行，到 get_tls \",\"这个例子中，CMPQ 指令比较 AX 是否与 0x123 相等，如果相等，JEQ 会跳到 PC+2 的指令位置处。\"]},\"255\":{\"h\":\"变量定义\",\"t\":[\"在汇编中，变量存储在 .data 和 .rodata 区，其中 .data 区全局可变，如 var 定义的全局变量，而 .rodata 全局不可变，如 const 定义的全局变量。\",\"plan9 中使用 DATA 结合 GLOBAL 来定义一个变量，基本语法如下：\",\"DATA symbol+offset(SB)/width, value GLOBL ·symbol(SB), [flags,], width \",\"symbol 表示符号，即变量名称；\",\"offset 表示相对于符号的偏移，即与变量首地址的偏移值；\",\"width 表示变量大小；\",\"value 表示是变量值\",\"flags 表示一些标志，如 RODATA 只读，这里不做过多介绍，感兴趣 戳这 。\",\"SB 是全局变量的首地址，必须加上，其实无实际意义。 举个实际例子：\",\"DATA age+0x00(SB)/4, $25 GLOBL age(SB), RODATA, $4 \",\"这里定义了一个全局变量 age，其大小为 4 字节，值为 25，RODATA 表示 age 只读。 在定义符号变量的时候，offset 一般都是 0，而如果定义数组和字符串，那 offset 就可以为其它值了：\",\"DATA msg<>+0(SB)/8, $\\\"oh yes i\\\" DATA msg<>+8(SB)/8, $\\\"am here \\\" GLOBL msg<>(SB), RODATA, $16 \",\"<> 是一个特殊符号，表明当前变量只在自己的文件中生效，类似于 C 中的 static。\",\"msg 大小总共 16，由于是分开定义，所以第一个 offset 是 0，而第二个是 8。\"]},\"256\":{\"h\":\"函数定义\",\"t\":[\"函数定义语法如下：\",\"TEXT symbol(SB), [flags,] $framesize[-argsize] \",\"symbol 表示函数名\",\"flags 标志位\",\"framesize 函数栈帧大小\",\"argsize 函数参数大小 以一个简单函数定义为例：\",\"func add(a, b int) int \",\"该函数对应的汇编代码如下：\",\"TEXT main·add(SB), NOSPLIT, $0-8 MOVQ a+0(FP), AX MOVQ a+8(FP), BX ADDQ AX, BX MOVQ BX, ret+16(FP) RET \",\"使用 TEXT 指令来定义函数，对应 ELF 中的 .text 段。add 函数说明如下：\",\"main 表示包名，add 函数定义在 main 包下\",\"add 是函数名\",\"NOSPLIT 表示该函数跳过堆栈溢出的检查\",\"$0-8 中：0 表示栈帧大小，8 表示返回值大小，即 int 类型大小，很明显由于直接使用寄存器相加，没有局部变量产生，所以栈帧为 0 对于已经定义的函数，可直接通过 CALL 指令来调用，如下：\",\"CALL runtime·args(SB) \"]},\"257\":{\"h\":\"小例子\",\"t\":[\"接下来，我们以一个 Hello World 小例子来看看 plan9 汇编是如何使用的(linux 平台下)。项目结构如下：\",\"├── go.mod # go 模块文件 ├── helloworld # helloworld 包 │ ├── helloworld.go # go 源代码文件 │ └── helloworld.s # go 汇编文件 └── main.go # main 入口文件 \",\"在 Go 中如果需要使用汇编函数，那么需要一个同包同文件名且同名的函数来与之对应，即 helloworld.s 与 helloworld.go 对应。 其中 helloworld.go 文件内容：\",\"package helloworld func Say() \",\"在文件中声明了一个 Say 函数，但函数却没有函数体，该函数在 helloworld.s 文件中实现。 helloworld.s 文件内容如下：\",\"#include \\\"textflag.h\\\" DATA msg<>+0x00(SB)/6, $\\\"Hello \\\" DATA msg<>+0x06(SB)/6, $\\\"World\\\\n\\\" GLOBL msg<>(SB),NOPTR,$12 TEXT ·Say(SB), NOSPLIT, $0 MOVL $1, AX // 在 Go 中 sys_write 系统调用数字编号为 1 MOVQ $1, DI // 第 1 个参数 stdout 编号 1 LEAQ msg<>(SB), SI // 第 2 个参数 msg 指针地址 MOVL $12, DX // 第 3 个参数 count，字符串长度 SYSCALL // 系统调用 RET \",\"结合上面的汇编基本介绍，我们来理一理 plan9 汇编究竟是如何使用的。 代码第 3 ～ 4 行，定义了 msg 变量，即字符串 Hello World\\\\n。\",\"// 指令 变量名 偏移 长度 字符串内容 DATA msg<>+0x00(SB)/6, $\\\"Hello \\\" \",\"DATA 用来表示变量，msg 是字符串名称，<> 符号表明 msg 变量仅当前包可用，0x00(SB) 表示变量偏移，这里是 0，而下面是 6，/6 表示字符串长度为 6，DATA 可以分开定义同一个变量，如这里的 msg 变量，被分为了两个部分，注意偏移和长度即可。 代码第 5 行，通过 GLOBL 声明 msg 为全局变量，<> 表示仅在当前包可用，NOPTR 可以不予理会，$12 表示字符串长度。\",\"代码第 7 行，通过 TEXT 指令来定义函数，注意函数名前面的中点 ·，NOSPLIT 可以不理会，$0 表示返回值大小为 0。\",\"代码第 8 ～ 13 行，将参数赋值给特定寄存器，然后 SYSCALL 系统调用，注意在 Go 中 sys_write 的编号竟然是 1，而且寄存器的使用也与 C 中不同，笔者一直按照 C 语言的约定来调用，一直失败，后面看了源码以后才恍然大悟。\",\"最后是入口文件 main.go：\",\"package main import \\\"passembly/helloworld\\\" func main() { helloworld.Say() } \",\"直接运行 main.go 文件：\",\"$ go run main.go Hello World \",\"看到 Hello World 即代表运行成功。 通过 strace 可以查看一下 Say 函数是否成功调用了 write 系统调用：\",\"$ go build main.go $ strace ./main .... .... write(1, \\\"Hello World\\\\n\\\", 12Hello World ) = 12 exit_group(0) = ? +++ exited with 0 +++ \",\"通过输出可以清晰的看到 Say 函数通过汇编成功的调用了 write 系统调用。\"]},\"258\":{\"h\":\"参考资料\",\"t\":[\"A Quick Guide to Go's Assembler\",\"Go 系列文章 3 ：plan9 汇编入门\",\"汇编是深入理解 Go 的基础 \",\"Go 系列文章 6: syscall\",\"Go 语言汇编入门\"]},\"259\":{\"h\":\"go pool 池化学习、实践总结\"},\"260\":{\"h\":\"概述\",\"t\":[\"最近在业务性能优化过程中，大量使用到了 pool 池化、缓存等技术。在用 pool 的时候一知半解 地怼了上去，待上线过后就得抽时间系统学习、总结一下，于是就有了这篇文章。\",\"首先，我们从一个场景出发，在一个简单的 http 接口服务中，如下：\",\"func handleV1(writer http.ResponseWriter, req *http.Request) { var ( err error data []byte ) // .... data, err = ioutil.ReadAll(req.Body) if err != nil { return } // ...... json.Unmarshal 之类的 } \",\"都避免不了从请求体中读取数据，然后将其解析为 json 处理。每次服务收到请求调用 handleV1函数 都避免不了在堆中(如果数据量很小，可能在栈中)开辟新的 data []byte 数据，而 data 数据在 请求完毕后就成为了垃圾数据待回收。\",\"在并发量、请求体都很大的情况下，内存就会迅速被占满，从而无法开启新的内存接受新的请求。\",\"一般遇到这种内存大量开辟且迅速消亡的场景，做性能优化的时，可以采用对象池的方式， 把不用的对象回收起来，避免被垃圾回收掉，这样使用的时候就不必重新创建。\",\"类似的情况还有：数据库连接、TCP 长连接、HTTP 客户端连接等，这些连接在创建的时候是一个非常耗时的操作。\",\"如果每次都创建一个新的连接对象，耗时较长，很可能整个业务的大部分耗时都花在了创建连接上。 如果把这些连接保存下来，避免每次使用的时候都重新创建，不仅可以减少业务的耗时，还能提高应用程序的整体性能。\"]},\"261\":{\"h\":\"Go pool\",\"t\":[\"Go 标准库中提供了一个通用的 pool 数据结构，也就是 sync.Pool，来帮助我们来处理这类问题。\",\"但，Go pool 也有不适合的场景，它池化的对象可能会被垃圾回收掉， 这对于数据库长连接等场景是不合适的，因此我们可以使用其它的池化方式， 后面我们再来谈这个。\",\"sync.Pool 用来保存一组可独立访问的临时对象。\",\"注意这里的“临时”这两个字，它说明 pool 中的对象可能会被垃圾回收(GC)给干掉。\",\"pool 可以有效地减少新对象的申请，提升内存的应用效率，所以 Go 标准库也用到了 pool。 在 fmt 包中，使用了一个动态大小的 buffer 池做输出缓存，当大量的 goroutine 并发输出的时候， 就会创建比较多的 buffer，并且在不需要的时候回收掉。\",\"pool 有两个重要的知识点：\",\"pool 本身就是线程安全的，多个 goroutine 可以并发地调用它的方法存取对象；\",\"pool 不可在使用之后再复制使用，内嵌了 noCopy 结构体，go vet 时检查。\",\"另外，pool API 非常易用，对外提供了三个方法，分别是 New，Put 和 Get。\",\"New：struct Pool 包含了一个 New 字段，这个字段的类型是函数 func() interface{}。 当调用 pool 的 Get 方法从池中获取元素，没有更多的空闲元素可返回时，就会调用这个 New 方法来创建新的元素。 如果没有设置 New 字段，没有更多的空闲元素可返回时，Get 方法将返回 nil，表明当前没有可用的元素。\",\"Get：调用该方法，就会从 pool 取走一个元素，该元素会从 pool 中移除，返回给调用者。 不过，除了返回值是正常实例化的元素，Get 方法的返回值还可能会是一个 nil(Pool.New 字段没有设置，又没有空闲元素可以返回)， 所以在使用的时候，可能需要判断。\",\"Put：将一个元素返还给 pool，pool 会把这个元素保存到池中(内部队列)，并且可以复用。 但如果 Put 一个 nil 值，Pool 就会忽略这个值。\"]},\"262\":{\"h\":\"缓存池 bufferPool\",\"t\":[\"回到刚才的业务场景上，字节切片(byte slice) data 被频繁创建然后销毁， 浪费了大量内存。我们使用 pool 来优化这些场景，如下：\",\"var bufferPool = sync.Pool{ New: func() interface{} { return new(bytes.Buffer) }, } func GetBuffer() *bytes.Buffer { return bufferPool.Get().(*bytes.Buffer) } func PutBuffer(buf *bytes.Buffer) { buf.Reset() bufferPool.Put(buf) } \",\"定义 bufferPool 缓存池，New 函数用于返回一个新的 bytes.Buffer；\",\"GetBuffer 返回池中一个 Buffer；\",\"PutBuffer 将 Buffer 重新放入池中。\",\"这样就达到了对象重复利用的效果，减少了非必要内存的分配。pool 的使用就是这么简单， 当然，对于 http 请求来说，如果请求体的大小是可预测的，完全可以在New的时候预分配 足够的切片容量，即：\",\"var bufferPool = sync.Pool{ New: func() interface{} { return bytes.NewBuffer(make([]byte, 0, 20*1024)) // 20KB }, } \",\"但是这段代码是有问题的，它会产生内存泄漏。产生内存泄漏的原因在于 pool 的具体实现(可以自行 Google)， pool 中的对象通过自定义 GC 函数poolCleanup来实现回收，该函数在一次 GC 时 不会将对象直接 GC 掉，而是移动到 victim 队列中，下次还是可以使用，但两次 GC 之后就被回收了。\",\"为什么会有内存浪费、内存泄漏(样例见附录 Pool 内存泄漏样例)：\",\"Get 方法从队列中取元素，本质上是随机的；\",\"如果缓存了很大的[]byte，比如 256MB，那么 pool 占据了很大的内存容量；\",\"如果后续 Get 方法取出了 256MB 的[]byte，但实际上只使用了 1KB 的小内存，就会浪费大量的内存；\",\"由于 pool 的 GC 机制，一次 GC 并不会直接回收，所以就会有大量的大内存切片在队列中， 只有下次 GC 才能回收，就会导致内存泄漏。\",\"Go fmt 包中，也踩了这个坑，而修复方法也很简单，当判断回收切片内存过大时，直接丢弃，不再 进入池中：\",\"func PutBuffer(buf *bytes.Buffer) { if buf.Cap() > 2*1024*1024 { return } buf.Reset() bufferPool.Put(buf) } \",\"总而言之，标准库中的 pool 是不够好用的，因此有很多三方库来解决这些问题， 比如bucketpool 提供了多层级的 pool 实现，按照输入的尺寸大小来返回合适的 pool：\",\"// Get returns pointer to []byte which has len size. // If there is no bucket with buffers >= size, slice will be allocated. func (p *Pool) Get(size int) *[]byte { sp := p.findPool(size) if sp == nil { return makeSlicePointer(size) } buf := sp.pool.Get().(*[]byte) *buf = (*buf)[:size] return buf } \"]},\"263\":{\"h\":\"连接池 connPool\",\"t\":[\"对于连接池而言，sync.Pool 自然就不再适用了，连接池的作用就在于能够一直保持连接， 在需要使用的时候无需再次创建、握手、认证，省掉了一系列的步骤，就能直接使用。\",\"连接池在 Go 的标准库中，也在大量使用。比如 http.Client 就通过 map 缓存了一定 数量的 http 连接，如下：\",\"type Transport struct { idleMu sync.Mutex closeIdle bool // user has requested to close all idle conns idleConn map[connectMethodKey][]*persistConn // most recently used at end idleConnWait map[connectMethodKey]wantConnQueue // waiting getConns idleLRU connLRU reqMu sync.Mutex reqCanceler map[cancelKey]func(error) // ... } \",\"在 sql.DB 中，Go 也提供了一个通用的数据库连接池：\",\"type DB struct { // Atomic access only. At top of struct to prevent mis-alignment // on 32-bit platforms. Of type time.Duration. waitDuration int64 // Total time waited for new connections. connector driver.Connector // numClosed is an atomic counter which represents a total number of // closed connections. Stmt.openStmt checks it before cleaning closed // connections in Stmt.css. numClosed uint64 mu sync.Mutex // protects following fields freeConn []*driverConn // free connections ordered by returnedAt oldest to newest connRequests map[uint64]chan connRequest // ... } \",\"freeConn 字段用来缓存数据库连接，当需要访问数据的时候，拿来即用，另外还提供了 API 来设置空闲连接数的大小：\",\"func (db *DB) SetMaxIdleConns(n int); func (db *DB) SetMaxOpenConns(n int); // ...so on \",\"另外还有一些连接使用的是 TCP 协议，这就需要三方库的支持了，比如fatih/pool 就是一种 TCP 连接池的实现，不过它的实现略有不同，采用 channel 来缓存连接：\",\"// PoolConn is a wrapper around net.Conn to modify the the behavior of // net.Conn's Close() method. type PoolConn struct { net.Conn mu sync.RWMutex c *channelPool unusable bool } \",\"连接池的使用太频繁，以至于很多人都忘记了它的存在。\"]},\"264\":{\"h\":\"协程池 goroutinePool\",\"t\":[\"熟悉其它语言的同学肯定知道，在业务中会大量地使用线程池，但是 Go 将线程完美的封装了起来， 并提供了 go 关键字来直接开辟协程，虽然协程相对轻量，开启几万个乃至十万个都没啥问题，但每次 请求来时开启协程，请求完后协程又得回收，这也是一种协程资源的浪费。\",\"并且，如此大量的协程的创建也给调度器带来了极大的压力，因此参考线程池的使用方式，我们也可以 来使用协程池。\",\"ants 是三方的一个高性能、低损耗的 goroutine 池库， 提供了简单易用的 API，如下：\",\"// Set 10000 the size of goroutine pool p, _ := ants.NewPool(10000) p.Submit(func(){}) \",\"协程池最多只能有 10000 个 goroutine，当提交的任务过多则会新建 goroutine， 当有大量 goroutine 空闲时，pool 会释放掉一批 goroutine 来保证内存。\",\"关于 goroutine pool 的实现，ants 的作者有一篇介绍其实现的文章， 感兴趣的同学可以参考参考。\",\"当然 goroutine pool 的实现还有很多，它们特性各异，各有优缺点，可以选择适合自己业务的来使用。\",\"比如：\",\"gammazero/workerpool：可以无限制地提交任务，提供了更便利的 Submit 和 SubmitWait 方法提交任务， 还可以提供当前的 worker 数和任务数以及关闭 Pool 的功能。\",\"ivpusic/grpool：提供 Worker 的数量和等待执行的任务的最大数量，任务的提交是直接往 Channel 放入任务。\",\"dpaks/goworkers：提供了更便利的 Submit 方法提交任务以及 Worker 数、任务数等查询方法、关闭 Pool 的方法。\",\"so on...\"]},\"265\":{\"h\":\"总结\",\"t\":[\"至此，关于在 Go 中，池化的三种方式均以介绍完毕。\",\"池化几乎可以作为性能、内存优化方案中最常见的一种了，希望下次遇到性能问题时， 我们都能够精准感知系统已有的池化方案，并能在新的地方使用合适的池化方案。\"]},\"266\":{\"h\":\"参考资料\",\"t\":[\"https://github.com/fatih/pool\",\"https://www.cnblogs.com/qcrao-2018/p/12736031.html\",\"https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/\",\"https://marksuper.xyz/2021/09/02/sync_pool/\",\"https://github.com/panjf2000/ants\",\"https://strikefreedom.top/high-performance-implementation-of-goroutine-pool\"]},\"267\":{\"h\":\"附录\"},\"268\":{\"h\":\"Pool 内存泄漏样例\",\"t\":[\"pool := sync.Pool{New: func() interface{} { return new(bytes.Buffer) }} processRequest := func(size int) { b := pool.Get().(*bytes.Buffer) // Get 从队列里面拿，实际上是随机的 time.Sleep(500 * time.Millisecond) // Simulate processing time b.Grow(size) // 扩容后再put fmt.Printf(\\\"buffer size: %d, cap: %d\\\\n\\\", b.Len(), b.Cap()) fmt.Printf(\\\"address of buffer %p\\\\n\\\", b) pool.Put(b) time.Sleep(1 * time.Millisecond) // Simulate idle time } // Simulate a set of initial large writes. for i := 0; i < 10; i++ { go func() { processRequest(1 << 28) // 256MiB }() } time.Sleep(time.Second) // Let the initial set finish // Simulate an un-ending series of small writes. for i := 0; i < 10; i++ { go func() { for { processRequest(1 << 10) // 1KiB } }() } // Continually run a GC and track the allocated bytes. // 40 Cycles 才被完全 free var stats runtime.MemStats for i := 0; ; i++ { runtime.ReadMemStats(&stats) fmt.Printf(\\\"Cycle %d: %dMB\\\\n\\\", i, stats.Alloc/(1024*1024)) time.Sleep(time.Second) runtime.GC() } \"]},\"269\":{\"h\":\"谈谈用户态 TCP 协议实现\"},\"270\":{\"h\":\"TCP 概述\",\"t\":[\"TCP 协议是目前名气最大、使用最广泛的传输层网络协议。\",\"TCP 是一个可靠的（reliable）、面向连接的（connection-oriented）、基于字节流（byte-stream）、全双工的（full-duplex）协议。\",\"正是因为这些优点，TCP 协议成为了网络协议重点中的重点，是学习、面试、考试上的常客，这也导致了 TCP 的资料很多，但是普遍集中在“形”上面，很多人将三次握手、四次挥手、滑动窗口等知识点背得滚瓜烂熟，但却没有理解 TCP “可靠” 协议的精髓。\",\"因此，本着实践加深理解的初衷，笔者跟随 CS144 这门课，会头到尾实现了一个用户态简易版 TCP 协议。\",\"说明：CS144 最终会实现一个全栈的网络协议栈，包含数据链路层、网络层和传输层，但是本文的重点聚焦在 TCP 协议上，因此对于其它层协议不做详细介绍，感兴趣的可以自行查询。\"]},\"271\":{\"h\":\"TCP 简单介绍\",\"t\":[\"下面我们分别简单介绍一下 TCP 的特点。\"]},\"272\":{\"h\":\"面向连接\",\"t\":[\"面向连接是 TCP 显著特点，在正式数据传输之前 TCP 需要三次握手来协商建立连接，结束传输后又需要四次挥手来结束连接。\",\"以三次握手为例，TCP 需要通过三次握手来确认对端状态，交换起始序号、窗口大小等信息，如下：\",\"三次握手流程如下：\",\"客户端向服务器发送 SYN 包；\",\"服务器收到 SYN 包后，向客户端发送 SYN+ACK 包；\",\"客户端收到 SYN+ACK 包后，回复 ACK 包至客户端。 在三次握手的过程中，重点在于 SYN 和 ACK 包的交互，当然也涉及到初始化序号、窗口大小、状态转换等工作，这些细节后面会在实现中详细介绍。\"]},\"273\":{\"h\":\"可靠性\",\"t\":[\"可靠性是 TCP 最大的功能点(个人观点，欢迎斧正)，TCP 为了保证数据传输的可靠性，做了很多事情，虽然这增加了实现的复杂性，但却是值得的：\",\"校验和，TCP 每个报文都有校验和字段，防止数据丢失或出错；\",\"序列化和确认号，保证每个序号的字节都交付，解决丢失、重复等问题；\",\"超时重传，对于超时未能确认的豹纹，TCP 会重传这些包，确保数据达到对端；\",\"等等 如下：\",\"虽然 TCP 在可靠性上做了很多努力，但仍然不能保证完美的可靠性，只能做到尽最大努力交付。对于可靠性的细节，我们将在后面的实现中详细介绍。\"]},\"274\":{\"h\":\"基于字节流\",\"t\":[\"TCP 数据传输是基于流的，意味着 TCP 传输数据是没有边界的，没有大小限制的，可以传输无限量的字节。\",\"但是 TCP 报文大小是有限制的，这主要取决于滑动窗口大下、路径最大传输单元 MTU 等因素。\",\"TCP 数据写、读、传入都是基于字节流，因此常常会有字节流乱序发生，所以 TCP 需要一个重组器组件专门用于流序号的重组工作，当然这涉及到 TCP 具体实现，我们将实现部分详细介绍。\"]},\"275\":{\"h\":\"全双工\",\"t\":[\"全双工意味着 TCP 协议通信的双方既可以发送数据，又可以接受数据，双方拥有独立的序号、窗口等信息。\",\"简单来说，一个 TCP 连接既可以是 sender 也可以是 receiver，同时连接拥有两个字节流，一个输出流，被 sender 控制，另一个是输入流，由 receiver 管理。关于这二者的细节，我们将在实现部分详细介绍。\"]},\"276\":{\"h\":\"Sponge 协议介绍\"},\"277\":{\"h\":\"Socket API\",\"t\":[\"绝大多数操作系统会在内核中提供 TCP 协议的实现，并对外暴露 socket API，借助 nc 工具，我们可以快速的使用 socket API，并领略它的风采，如下：\",\"$ nc -v -l -p 9090 Ncat: Version 6.40 ( http://nmap.org/ncat ) Ncat: Listening on :::9090 Ncat: Listening on 0.0.0.0:9090 \",\"首先，在一个窗口中通过 -l 参数来监听本地的 9090 端口，然后在另一个窗口中连接该端口：\",\"$ telnet localhost 9090 \",\"回到 nc 端口，会发现多出了如下日志：\",\"Ncat: Connection from 127.0.0.1. Ncat: Connection from 127.0.0.1:37731. \",\"可以看到，通过 nc 和 telnet 这两个工具，我们很轻易的就建立起了 TCP 连接，而这两个工具本身都是在调用 socket API。 TCP 由操作系统实现在了内核态，并提供 socket API，虽然使用方便，但是却屏蔽了大量信息，给错误调试和定位带来了很大困难。\"]},\"278\":{\"h\":\"用户态协议\",\"t\":[\"在用户态上实现协议是一个很有趣且很有挑战的事情，目前最著名的当属 QUIC 协议，QUIC 协议是建立在 UDP 上的一个用户态可靠协议。而 CS144 实现的 TCP 协议，也就是本文后面所实现的 TCP 协议和 QUIC 协议定位非常类似，当然 QUIC 协议在功能特性上完胜，但是这不影响我们以此来学习一个简单可靠的类 TCP 协议。\",\"为了与其它协议进行区分，本文实现的协议我们统称为 Sponge 协议。下面，对 Sponge 协议做一些简单的介绍：\",\"Sponge 协议建立在 UDP 之上(也可以建立在 IP 协议之上，为了避免引入 TUN/TAP 带来复杂，暂时不做延伸)；\",\"Sponge 协议是一种简易版 TCP 协议，和 TCP 协议一样有滑动窗口、重传、校验和等功能，但是一些复杂的特性暂时不支持，如：紧急指针、拥塞控制、Options 中的一些选项均不支持；\",\"Sponge 协议并不特别复杂，在 CS144 的课程带领下，完全可以自主实现，并没有什么高深莫测的技术，每个人都有能力去理解和实现。\"]},\"279\":{\"h\":\"Sponge 协议概览\",\"t\":[\"下面，我们就以先整体后局部的方式来详细介绍 Sponge 协议。Sponge 协议的主体类为 TCPConnection，该类主要维护 TCP 连接、TCP 状态机等信息数据，并将接收到的报文交给 TCPReceiver 处理，从 TCPSender 获取报文并发送。类图如下：\",\"TCPConnection 负责维护连接，报文发送、接收分别由 TCPSender 和 TCPReceiver 来负责；\",\"TCPSender 负责发送报文，接收确认号(ackno)确认报文，记录发送但未确认的报文，对超时未确认的报文进行重发；\",\"TCPReceiver 负责接收报文，对报文数据进行重组(报文可能乱序、损坏等，由 StreamReassembler 负责重组)；\",\"StreamReassembler 负责对报文数据进行重组，每个报文中的每个字节都有唯一的序号，将字节按照序号进行重组得到正确的字节流，并将字节流写入到 ByteStream 中；\",\"ByteStream 是 Sponge 协议中的字节流类，一个 TCPConnection 拥有两个字节流，一个输出流，一个输入流。输出流为 TCPSender 中的 _output 字段，该流负责接收程序写入的数据，并将其包装成报文并发送，输入流为 StreamReassembler 中的 _output 字段，该流由 StreamReassembler 重组报文数据而来，并将流数据交付给应用程序。 Sponge 协议巧妙地将连接分为了 sender 和 receiver 两个部分，并通过重组器、字节流等类将 TCP 连接完美抽象，使代码更易维护和阅读，也使功能迭代和完善更加方便。\",\"Sponge 的数据流图如下所示：\",\"从这个图中可以总结出 Sponge(基于 UDP 而非 IPv4) 数据流过程：\",\"内核态下 UDP 数据包中的 payload 被解析为 TCPSegment(TCP 报文)后，交给用户态下的 TCPConnection，即调用 segment_received 方法；\",\"TCPConnection 收到报文后，将报文交给 TCPReceiver，即调用 TCPReceiver.segment_received 方法，并将报文中的 ackno(确认号)与 window_size(窗口大小)交给 TCPSender，即调用 ack_received 方法；\",\"TCPReceiver 处理 TCP 报文，并将报文中的 payload 推入 StreamReassembler 中，并重组后交给应用程序，随后尝试发送报文；\",\"TCPConnection 调用 TCPSender.fill_window 方法尝试得到待发送报文(可能得不到，视具体情况而定)，若有报文，则设置报文 payload 以及其它字段，如 SYN、ackno(从 receiver 获取)、window_size 等，设置完毕后包装为 TCP 报文，将报文交给 UDP；\",\"UDP 将其打包为数据报，并发送给远端。\"]},\"280\":{\"h\":\"Sponge 协议实现\",\"t\":[\"在粗略介绍 Sponge 协议后，我们一起来看看 Sponge 协议的具体实现逻辑和一些细节。\",\"在介绍 Sponge 协议时，采用的是先整体后局部的方式，而在说明具体实现时，需要先从局部出发，逐渐上升到整体，因此我们会先从 ByteStream 数据流开始，逐步添砖加瓦最后实现一个完成的 TCPConnection。\",\"这里先给出 Sponge 协议代码核心文件：\",\"libsponge/ ├── byte_stream.cc // ByteStream(数据流) 实现文件 ├── byte_stream.hh // ByteStream 头文件 ├── stream_reassembler.cc // StreamReassembler(数据流重组器) 实现文件 ├── stream_reassembler.hh // StreamReassembler 头文件 ├── tcp_connection.cc // TCPConnection(TCP连接) 实现文件 ├── tcp_connection.hh // TCPConnection 头文件 ├── tcp_receiver.cc // TCPReceiver(TCP接收者) 实现文件 ├── tcp_receiver.hh // TCPReceiver 头文件 ├── tcp_sender.cc // TCPSender(TCP发送者) 实现文件 ├── tcp_sender.hh // TCPSender 头文件 ├── wrapping_integers.cc // WrappingIntegers(包装32位seqno、ackno)实现文件 └── wrapping_integers.hh // WrappingIntegers 头文件 \"]},\"281\":{\"h\":\"ByteStream\",\"t\":[\"ByteStream 是一个基于内存、可靠的数据流实现类。Sponge 协议类似于 TCP 协议，也是一个基于字节流的网络协议，数据流是协议最核心的数据载体，在上面也谈到了，一个 TCPConnection 有两个数据流，分别用于数据输入和输出。\",\"ByteStream 是一个可读且可写且有容量限制的数据流。ByteStream 在初始化时，会被设置一个 capacity(容量) 参数，表示该数据流不能存储超过容量的字节数。ByteStream 实现是比较简单的，既可以直接使用 string(字符串)来实现，也可以使用 sponge 项目提供的 BufferList 来实现。\",\"推荐使用 BufferList，内部通过共享指针来实现字符串容器，减少字符串拷贝带来的性能、内存损耗。\",\"这里摘出 ByteStream 中几个重要的实现方法加以说明：\",\"ByteStream::ByteStream(const size_t capacity) : _capacity(capacity) {} size_t ByteStream::write(const string &data) { size_t sz = data.size(); // 如果数据超过了窗口大小，那么等于窗口大小 if (sz > _capacity - _buffer_size) { sz = _capacity - _buffer_size; } _stream.append(BufferList(move(string().assign(data.begin(), data.begin() + sz)))); _buffer_size += sz; _bytes_written += sz; return sz; } string ByteStream::peek_output(const size_t len) const { // peek 的长度不能超过 buffer_size const size_t peek_length = len > _buffer_size ? _buffer_size : len; string str = _stream.concatenate(); return string().assign(str.begin(), str.begin() + peek_length); } void ByteStream::pop_output(const size_t len) { // 不能超过 buffer_size size_t pop_length = len > _buffer_size ? _buffer_size : len; _stream.remove_prefix(pop_length); _bytes_read += pop_length; _buffer_size -= pop_length; // 更新 buffer_size } std::string ByteStream::read(const size_t len) { const string result = peek_output(len); pop_output(len); return result; } \",\"这段代码展示了 ByteStream 中最重要的 5 个方法：\",\"ByteStream 构造函数，用于初始化一个字节流；\",\"write 函数，向字节流中写入数据，注意写入数据的大小和当前缓冲区的大小加起来不能超过容量大小，然后将数据加入到 _stream 容器中，并且更新 buffer_size 和 bytes_written；\",\"peek_output 函数，查看字节流的前 len 个字节，peek_out 方法不会消费字节流，只会查看前 len 个字节，并且查询字节数量不能超过当前缓冲区字节的数量；\",\"pop_out 函数，移除字节流中的前 len 个字节，然后更新 bytes_read 和 buffer_size；\",\"read 函数，读取字节流中的前 len 个字节，注意 read 会消费流数据，读取后会移除前 len 个字节。 ByteStream 是 spong 项目中最简单的一部分，但也是最容易忽略的一部分，笔者最开始在实现的时候小觑了这里，以为通过了全部单测就没有问题了，但是在后面的测试中，发现数据有错误，debug 了好久才察觉是 ByteStream 有问题。\"]},\"282\":{\"h\":\"StreamReassembler\",\"t\":[\"一个 TCP 连接只有一个 StreamReassembler，用于 receiver 重组乱序的报文数据。由于 TCP 报文可能存在乱序、重复、缺少等各种各样的问题，receiver 收到的 TCP 报文数据不能直接写入到 ByteStream 中交付给应用程序。\",\"因此为了解决 TCP 报文数据乱序等问题，sponge 将重组这部分工作抽象为数据流重组器。由于网络延迟、丢包等场景，比如：\",\"发送 A、B 包，结果 B 包比 A 包更早到达，因此 B 包到达时，不可直接写入字节流；\",\"发送 A、B 包，接收 A 包丢了，只有 B 包达到，那么 B 包到达后也不可直接写入字节流，必须等待 A 包重发达到后。 为了解决这些问题，我们必须有序的组装 TCP 报文，如下：\",\"class StreamReassembler { private: ByteStream _output; //!< The reassembled in-order byte stream size_t _capacity; //!< The maximum number of bytes size_t _head_index; //!< 当前序号 // 重组节点 struct node { size_t begin = 0; size_t size = 0; std::string data{}; // 重载 < 符号，用于序列重组 bool operator<(const node &a) const { return begin < a.begin; } }; // 节点合并 long merge(node &n1, const node &n2); std::set<node> _set{}; // 数据容器，二叉树 size_t _unassembled_bytes; // 未组装字节个数 } \",\"我们在 StreamReassembler 的定义中添加了 _head_index 和 _set 字段：\",\"_head_index：当前已组装的字节序号，默认为 0，即没有字节被重组；\",\"_set：TCP 报文容器，每个 TCP 报文都被当作一个 node，包含了数据、序号等信息，node 存储在 set 中，set 内部是一个红黑树实现，支持节点有序化。 当一个报文数据被推入到重组器后，重组器判断报文头字节序号与 _head_index 之间的关系，对数据进行裁剪，得到当前数据节点，由于 set 中的 node 是按照 index 有序排列，寻找节点尝试合并数据重复的节点，合并完毕后，判断节点 index 与 _head_index 之间的关系，将 index 刚好等于 _head_index 的节点数据写入字节流中。如下：\",\"void StreamReassembler::push_substring(const string &data, const size_t index, const bool eof) { // 接收到 data 后，将新的连续的字节写入到流中 // 如果超过了 capacity 那么丢弃掉数据 // 如果 eof 为 true，那么接收的为最后一个字符串 size_t sz = data.size(); if (eof) { this->_eof = eof; } // 如果 sz == 0 或者 data 已经被重组了，那么直接返回 if (sz == 0 || sz + index < _head_index) { handle_eof(); return; } node cur; if (index < _head_index) { // 当前 index 小于 _head_index // 那么截取 index 后面有用的部分 size_t offset = _head_index - index; cur.begin = _head_index; cur.size = sz - offset; cur.data = data.substr(offset); } else { // 当 index >= _head_index cur.begin = index; cur.size = sz; cur.data = data; } _unassembled_bytes += cur.size; // 未重组 // 如果节点之间有数据重合，那么依次合并节点 long total = 0; // 向后合并 while (true) { // 找到第一个 >= cur.begin 的节点 auto next = _set.lower_bound(cur); if (next == _set.end()) { break; // 没有找到 } // next 是第一个 >= cur 的节点 // 合并 cur 和 next 到 cur long merged_count = merge(cur, *next); if (merged_count < 0) { break; // 小于 0，证明无法合并，直接 break } total += merged_count; // 合并 next 后然后删除 next，注意所有数据都被合并到了 cur 节点中 _set.erase(next); } // 向前合并 auto next = _set.lower_bound(cur); while (next != _set.begin()) { next--; // 得到前一个节点 long merged_count = merge(cur, *next); if (merged_count < 0) { break; } total += merged_count; _set.erase(next); next = _set.lower_bound(cur); // 找到下一个 } // 向前、向后一起合并了 total _unassembled_bytes -= total; // 插入 cur _set.insert(cur); // 合并完成以后，再来推进 _head_index while (!_set.empty() && _set.begin()->begin == _head_index) { auto begin = _set.begin(); size_t written = _output.write(begin->data); _head_index += written; _unassembled_bytes -= written; _set.erase(begin); // 删除已经合并的头节点 } handle_eof(); } \",\"上面代码已经对节点合并、_head_index 推进给出了详细注释。push_substring 是 StreamReassembler 中最复杂、最重要的函数，它接受三个参数：\",\"data：报文数据(不含 TCP header)；\",\"index：报文数据第一个字节的序号，注意是字节流的序号，根 seqno 有缺别，后面再细说；\",\"eof：是否收到了 fin 包数据，即是否要关闭输入数据流。 由于 set 容器中节点的有序性(node 重载了< 保证了 begin 小的节点在前面)，可通过 lower_bound 函数直接找到第一个大于等于当前节点 begin 的节点，然后尝试去合并二者。\",\"StreamReassembler 另外一个需要注意的点是何时关闭输入流，如下：\",\"void StreamReassembler::handle_eof() { if (_eof && empty()) { // 如果标记了结束，且为空 _output.end_input(); } } \",\"当收到 eof 为 true 时，不能立马关闭 _output，因为 fin 包可能先于其它数据包达到，因此我们必须缓存 eof，等待重组器中数据为空时再关闭输入流。\"]},\"283\":{\"h\":\"TCPReceiver\",\"t\":[\"TCPReceiver 是 TCP 连接的接收方，负责接收报文，并将报文数据(payload)交给 StreamReassembler 重组，得到正确的字节流序列。定义如下：\",\"class TCPReceiver { //! Our data structure for re-assembling bytes. StreamReassembler _reassembler; //! The maximum number of bytes we'll store. size_t _capacity; // 省略一些字段 std::optional<WrappingInt32> _isn{std::nullopt}; // absolute ack number uint64_t _abs_ackno; } \",\"_reassembler：数据流重组器；\",\"_capacity：容量，用于 _reassembler 初始化；\",\"_isn：收到的第一个 seqno；\",\"_abs_ackno：绝对确认序号。 这里需要额外说明一点：关于 WrappingInt32(seqno,ackno) 与 uint64_t(abs_seqno,abs_ackno)。\",\"在 TCP header 中 seqno 与 ackno 都是 32 位整数，但是 isn 是发送者随机生成的数字，那么可能会产生一个问题：如何随机生成的 isn 十分接近 2^32-1 怎么办？\",\"这代表，TCP 数据流很快就会溢出 seqno。为了解决这个问题，sponge 实现了两个序号，一个是正常的 TCP header seqno，32 位，使用 WrappingInt32 表示，初始化为随机数，另一个是绝对 seqno 序号，使用 uint64_t 表示，初始化为 0。用绝对序号来表示数据流上字节的数量，最大数量为 2^64-1，这几乎是不可能达成的目标。\",\"另外在 StreamIndex 中的 push_string 函数有一个 index 参数，index 表示字节在数据流中的序号，那么这个序号与绝对 seqo 序号，以及 seqno 有什么联系呢？\",\"假设 isn = 2^32−2 且向数据流中写入 \\\"cat\\\" 三个字节，那么 seqno、abs_seqno、stream_index 之间的对应关系如下表：\",\"element\",\"syn\",\"c\",\"a\",\"t\",\"fin\",\"seqno\",\"2^32−2\",\"2^32−1\",\"0\",\"1\",\"2\",\"absolute_seqno\",\"0\",\"1\",\"2\",\"3\",\"4\",\"stream_index\",\"0\",\"1\",\"2\",\"seqno 溢出后，重新从 0 开始；\",\"absolute_seqno 从 0 开始，并与 seqno 一一对应；\",\"syn 和 fin 均占一个序列；\",\"stream_index 从 0 开始，但是不能包括 syn 与 fin。 实现 TCPReceiver 的核心函数有三个，如下：\",\"void TCPReceiver::segment_received(const TCPSegment &seg) { // Corner Case: // 如果包头部没有 syn，且 receiver 也没有 _syn 过，那么直接返回 // 第一个接收的包一定包含了 syn WrappingInt32 seqno = seg.header().seqno; if (!seg.header().syn && !_syn) { return; } bool first_syn = false; // 第一次收到 syn 包： // 设置 _isn 和 _syn if (seg.header().syn && !_syn) { _isn = std::make_optional(seqno); _syn = true; first_syn = true; } // 收到 fin 包，且本地没有 _fin if (seg.header().fin && !_fin) { _fin = true; } Buffer payload = seg.payload(); // 得到 seqno 对应的 abs_seqno // In your TCP implementation, you’ll use the index of the last reassembled byte as the checkpoint. // checkpoint 为最后一个重组的字节序号，即 head_index uint64_t abs_seqno = unwrap(seqno, _isn.value(), _reassembler.head_index()); // 如果该 seqno 已经被接收过了，那么本次将忽略 // 如果超过了窗口阈值，那么也无法接收 if (abs_seqno + seg.length_in_sequence_space() <= _abs_ackno || abs_seqno >= _abs_ackno + window_size()) { return; } size_t stream_index = abs_seqno; // stream_index 默认为 abs_seqno string data = payload.copy(); // 如果 syn 也伴随着数据，那么 abs_seqno 应该等于 1 if (_syn && !first_syn && stream_index > 0) { // 如果 syn 那么 -= 1, syn 不算 stream_index -= 1; } // fin 会占有 seqno 序列，但是前提是内部已经关闭，数据流上达到了 fin if (_fin && _reassembler.stream_out().input_ended() && stream_index > 0) { // 如果 fin，那么 -= 1, fin 不算 stream_index -= 1; } // 推入数据 _reassembler.push_substring(data, stream_index, seg.header().fin); // 更新 _abs_ackno // 这个地方的 +1 直接抵消了 syn 包 _abs_ackno = _reassembler.head_index(); if (_syn) { _abs_ackno += 1; } // fin 且数据流关闭，才能确认 fin，这才是 fin 的真正关闭条件 // 即 FIN_RECV = stream_out().input_ended() if (_fin && _reassembler.stream_out().input_ended()) { _abs_ackno += 1; } return; } optional<WrappingInt32> TCPReceiver::ackno() const { // If the ISN hasn’t been set yet, return an empty optional if (!_isn.has_value()) { return std::nullopt; } // 注意：fin 包也占有一个序号 // This is the windows’s left edge: the first byte the receiver is interested in receiving. // _abs_ackno 已经在 segment_received 函数中做好了计算，直接 wrap 即可 return wrap(_abs_ackno, _isn.value()); } size_t TCPReceiver::window_size() const { // the distance between the “first unassembled” index (the index corresponding to the // ackno) and the “first unacceptable” index. // 已经确认的序列-未收到的序列 // 这里的 window_size 应该是 容量 - 已经在 StreamByte 中的字节数 // 即剩下可以接受且重组的字节数才是窗口大小 size_t sz = _capacity - _reassembler.stream_out().buffer_size(); return sz; } \",\"除了 segment_received 复杂一点，ackno 与 window_size 函数都比较简单，细节可以看看注释。这里额外说明一下：\",\"ackno 返回确认序号，注意是 WrappingInt32 类型，ackno 必须得 SYN 后才有，并通过 abs_ackno 与 isn 计算而来。\",\"window_size 返回当前接受者的窗口大小，其实就是字节流还能接收多少字节，用容量减去当前的缓冲区大小即可。 segment_received 是接收者最复杂的函数，需要处理很多边角逻辑，导致代码很多(主要也是因为笔者 C++菜的要死，也懒得重构)，有几个点需要说明一下：\",\"第一个包必须携带 SYN，否则直接拒绝；\",\"收到 FIN 后需要缓存；\",\"得到当前包序号 abs_seqno 后，需要判断是否超过了窗口；\",\"stream_index 与 abs_seqno 之间的关系转化，通过 first_syn 来帮助转换；\",\"_abs_ackno 实际为重组确认的当前序号，即 head_index，但必须包含 SYN 和 FIN。\"]},\"284\":{\"h\":\"TCPSender\",\"t\":[\"TCPSender 负责从输出流中读取数据并打包发送，主要功能点有：\",\"负责接收和缓存 ackno(确认序号)、window_size(窗口大小);\",\"缓存发送但没有被确认的报文，并在超时后重新发送；\",\"从输出流中读取数据并包装为报文，然后发送报文。 TCPSender 类定义如下：\",\"class TCPSender { private: //! our initial sequence number, the number for our SYN. WrappingInt32 _isn; //! outbound queue of segments that the TCPSender wants sent std::queue<TCPSegment> _segments_out{}; //! retransmission timer for the connection unsigned int _initial_retransmission_timeout; //! 当前的重试时间 unsigned int _current_retransmission_timeout; //! outgoing stream of bytes that have not yet been sent ByteStream _stream; //! the (absolute) sequence number for the next byte to be sent uint64_t _next_seqno{0}; //! 发送但未确认的包 std::queue<TCPSegment> _segments_in_flight{}; //! 发送但未确认的字节数 size_t _bytes_in_flight{0}; //! 滑动窗口大小，默认为 nullopt std::optional<uint16_t> _window_size{std::nullopt}; //! 确认序列 uint64_t _abs_ackno{0}; //! 已经重试的次数 unsigned int _consecutive_retransmissions{0}; //! 定时器 bool _timer{false}; //! 计时器 unsigned int _time_tick{0}; } \",\"_isn：初始序号，通过 random 随机生成，并设置到 header 中的 seqno 随报文发送到远端；\",\"_segments_out、_segments_in_flight：报文发送队列和报文已发送未确认队列，sender 只需将发送的报文推入到两个队列中即，其中 _segments_out 队列将会由上层的 TCPConnection 处理，而 _segments_in_flight 中的报文需要通过接受到的 ackno 来实时处理，将其中被确认的报文推出队列；\",\"_initial_retransmission_timeout、_current_retransmission_timeout、_time_tick 等：超时相关字段，对于发送但位确认的报文，一旦超时，sender 将重新发送 _segments_in_flight 中的报文，且重试时间是依次递增(*2)的，一旦将报文推入 _segments_in_flight 那么就开启计时，一旦 _segments_in_flight 为空，即报文均被确认，那么将关闭计时器。 相较于 TCPReceiver，TCPSender 的实现稍微复杂一些，有三个核心函数。\",\"核心函数 fill_window：负责从输出流中读取数据并打包为 TCP 报文，注意报文大小是有限制的，主要根据窗口大小来实时改变，因此一次可能打包多个报文，如下：\",\"void TCPSender::fill_window() { // 根据 window_size 填充数据到包中 // 首先要发送一个 SYN 包 if (!_first_syn) { _first_syn = true; TCPSegment seg; seg.header().syn = true; send_segment(seg); return; // 发送 syn 包后等待 ack 才继续发包 } // Corner Case: // 再没有 syn 的情况下，不填充 if (!_first_syn) { return; // 其它情况下，未 syn 则不进行任何发送操作 } // Corner Case: if (_fin) { return; // 都已经 fin 了，还发个鬼啊 } // _window_size 是 0 的时候，sender 将 _window_size 当作 1 看待 // 为什么需要看做为 1：因为可以同步 ackno 和 window_size size_t win = _window_size.value_or(0) > 0 ? _window_size.value() : 1; size_t remain; // 剩余窗口大小 // 当窗口没有满，且无 fin // _next_seqno - _abs_ackno 是窗口中待确认的字节数量大小 // 因此还可以发送的字节数 = win - (_next_seqno - _abs_ackno) while ((remain = (win - (_next_seqno - _abs_ackno))) > 0 && !_fin) { size_t sz = min(remain, TCPConfig::MAX_PAYLOAD_SIZE); TCPSegment seg; string payload = _stream.read(sz); seg.payload() = Buffer(move(payload)); // 如果包的大小小于窗口大小，且流已经 eof 了，那么作为 fin(最后一个) 包发送 if (seg.length_in_sequence_space() < win && _stream.eof()) { seg.header().fin = true; _fin = true; } // 注意：fin 包可能没有任何数组，但是如果提前判读包的大小，那么 fin 包 // 在被设置 header 之前就被 return 了，当前的 fin 包就丢失了 if (seg.length_in_sequence_space() == 0) { return; // 空包直接返回，注意 } // 每次发送一个包，就会更新 _next_seqno，直到无包可发送 send_segment(seg); } } \",\"具体逻辑参考注释，这里额外说明几点：\",\"如果是第一次填充，那么必须为 SYN 包，并且打包后直接发送；\",\"在没有 SYN 或者已经 FIN 的情况下，直接返回；\",\"窗口大小可能为空，必须在接受对端包的情况下才知道对端的接受窗口大小；\",\"如果输出流已经关闭，且包长度小于窗口大小，那么作为最后一个包发送，设置为 FIN；\",\"如果包长度为 0，那么直接返回，不用发送，空包有另外的处理。 核心函数 ack_received：接受确认序号(ackno)和窗口大小(window_size)，处理_segments_in_flight 中的包，将已经确认的报文推出队列，如下：\",\"void TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size) { // 得到绝对序号 abs_ackno uint64_t abs_ackno = unwrap(ackno, _isn, _next_seqno); // Corner Case: if (abs_ackno > _next_seqno) { // 太大了，确认不了 return; } // 设置 _window_size _window_size = make_optional(window_size); // Corner Case: if (abs_ackno <= _abs_ackno) { return; // 已经确认过了，不用再确认 } // 设置 _abs_ackno _abs_ackno = abs_ackno; // 根据 ackno 移除掉 _segments_in_flight 中的包 while (!_segments_in_flight.empty()) { TCPSegment front = _segments_in_flight.front(); uint64_t abs_seqno = unwrap(front.header().seqno, _isn, _next_seqno); size_t len = front.length_in_sequence_space(); // 如果包头部序号 + 长度 <= 确认序号 // 那么表示包被确认了 if (abs_seqno + len <= _abs_ackno) { _segments_in_flight.pop(); // 计数 _bytes_in_flight -= len; } else { break; } } // 收到确认包后，必须重置定时器时间和重试次数 _current_retransmission_timeout = _initial_retransmission_timeout; _consecutive_retransmissions = 0; // 如果新的包被确认，且还有包未确认，则重新开始定时 if (!_segments_in_flight.empty()) { _timer = true; _time_tick = 0; } return; } \",\"说明：\",\"_segments_in_flight 中的报文如何被确认？很简单，比较报文中的序号、报文长度与确认序号之间的关系，如果报文头部序号 + 长度 <= 确认序号，那么该报文被确认，并且推出队列；\",\"另外一旦收到 ackno，那么必须重置超时时间为最初超时时间，且重试次数为 0；\",\"所有包确认后，关闭定时器。 核心函数 tick：增加定时器时间，如果发生了超时那么重新发送报文，如下：\",\"void TCPSender::tick(const size_t ms_since_last_tick) { // 重新发送最早的包，注意不是所有过期的包 if (!_timer) { return; } _time_tick += ms_since_last_tick; // 重试一次就 double 重试时间 if (_time_tick >= _current_retransmission_timeout && !_segments_in_flight.empty()) { TCPSegment front = _segments_in_flight.front(); // 重新发送 _segments_out.push(front); // 定时器重置 _time_tick = 0; _timer = true; // 超时次数+1 // 注意：When filling window, treat a '0' window size as equal to '1' but don't back off RTO // 所以如果 window_size == 0，那么不能对超时时间进行翻倍，只能增加重试次数 _consecutive_retransmissions += 1; // 窗口没有设置过 或者 窗口大小不为 0 if (!_window_size.has_value() || (_window_size.has_value() && _window_size.value() != 0)) { _current_retransmission_timeout *= 2; } } // 所有数据都被确认了，关闭定时器 if (_segments_in_flight.empty()) { _timer = false; } } \",\"说明：\",\"如果定时器没有开启，那么直接返回，注意定时器在包进入 _segments_in_flight 后才会开启，在队列清空后停止；\",\"每次超时重发，只会重发队首的报文，不会重发所有报文；\",\"重发后，重试次数 +1，且超时时间 *=2。\"]},\"285\":{\"h\":\"TCPConnection\",\"t\":[\"TCPConnection 负责将 TCPSender 和 TCPReceiver 组合起来，维护 TCP 状态机、收、发包等功能。定义如下：\",\"class TCPConnection { private: TCPConfig _cfg; TCPReceiver _receiver{_cfg.recv_capacity}; TCPSender _sender{_cfg.send_capacity, _cfg.rt_timeout, _cfg.fixed_isn}; //! outbound queue of segments that the TCPConnection wants sent std::queue<TCPSegment> _segments_out{}; //! Should the TCPConnection stay active (and keep ACKing) //! for 10 * _cfg.rt_timeout milliseconds after both streams have ended, //! in case the remote TCPConnection doesn't know we've received its whole stream? bool _linger_after_streams_finish{true}; // 上一个包接受距现在时间 size_t _time_since_last_segment_received{0}; //! 是否处于激活状态 bool _active{true}; } \",\"TCPConnection 的字段比较少：\",\"_cfg：TCP 配置，如默认超时时间，最大包长度等；\",\"_receiver：接收者；\",\"_sender：发送者；\",\"_time_since_last_segment_received：最后报文接受到现在时间间隔；\",\"_active：连接是否处于激活状态；\",\"_linger_after_streams_finish：是否在数据流结束后等待(涉及到连接关闭，下面会介绍)。 TCPConnection 主要做如下三件事情：\",\"接收报文，当 TCP 报文达到时，TCPConnection 的 segment_received 方法会被调用，并做如下处理：\",\"如果报文头部含有 RST，将输入、输出流设置为错误状态，并且永久关闭连接；\",\"将报文传递给 receiver，即调用 receiver.segment_received 方法；\",\"如果报文头部中含有 ACK，那么调用 sender.ack_received 方法；\",\"如果收到的报文的长度 > 0(包含数据、SYN、FIN)，那么必须至少回复一个报文，来告诉对端 ackno 和 window_size。\",\"发送报文：\",\"任何时候，sender 将报文推入到其队列后，TCPConnection 负责将队列中的报文拿出来，设置额外的字段，并放入自己的队列，等待被发送；\",\"在推入报文到队列之前，TCPConnection 必须从 receiver 哪里拿到 ack、ackno 和 window_size 并填充到报文中。\",\"计时： _ 每当计时(tick)发生时，TCPConnection 负责将消耗时间告诉 sender； _ 如果报文重试次数超过了 MAX_RETX_ATTEMPTS，那么发送 RST 包，并关闭连接； 核心函数 segment_received 负责接收报文工作：\",\"void TCPConnection::segment_received(const TCPSegment &seg) { // 接收包 if (!_active) { return; } _time_since_last_segment_received = 0; // 刷新时间 auto header = seg.header(); // Corner Case: // ACKs in LISTEN should be ignored // 如果处于 listen 状态，那么无法接受 ack 包，必须先接受 syn 包 if (header.ack && state() == TCPState::State::LISTEN) { return; } // 如果 header 中有 ack, 那么调用 _sender.ack_received if (header.ack) { _sender.ack_received(header.ackno, header.win); } // _receiver 接收包 _receiver.segment_received(seg); // if the rst (reset) flag is set, sets both the inbound and outbound streams to the error state // and kills the connection permanently. // 无论是客户端还是服务端，收到 rst 包后，都应该准备关闭输入、输出 if (header.rst) { // Corner Case: // all RSTs should be ignored in LISTEN // 如果在 listen 状态，那么所有 RST 都应该忽略 if (state() == TCPState::State::LISTEN) { return; } // 关闭连接 unclean_shutdown(); } // 是否需要发送空包，空包用于 ack bool send_empty = false; // Corner Case: // if the incoming segment occupied any sequence numbers, // the TCPConnection makes sure that at least one segment is sent in reply, // to reflect an update in the ackno and window size. // 任何长度大于 0 的包，都应该 ack 回应 if (seg.length_in_sequence_space() > 0) { send_empty = true; } // Corner Case: // 如果没有 ackno 确认，即 _receiver.segment_received(seg) 失败，则不能发送空包 if (!_receiver.ackno().has_value()) { send_empty = false; } // 尝试去发包回复，注意是尝试，因为如果 _sender 中无数据发送且也无需发送空包 // 那么 send_segment 并不会发包 send_segment(false, false, send_empty); } void TCPConnection::send_segment(bool syn, bool rst, bool send_empty) { // 从 sender 中拿出包，然后再 push_out _sender.fill_window(); // 填充包 // 如果填充后仍然为空，但必须发送一个空包 if (_sender.segments_out().empty() && send_empty) { _sender.send_empty_segment(); } TCPSegment seg; while (!_sender.segments_out().empty()) { // 从 _sender 的队列中拿出 seg = _sender.segments_out().front(); _sender.segments_out().pop(); if (syn) { seg.header().syn = true; } if (rst) { seg.header().rst = true; } // 如果 receiver ack 过，那么填充 win, ack, ackno if (_receiver.ackno().has_value()) { seg.header().ack = true; seg.header().ackno = _receiver.ackno().value(); seg.header().win = _receiver.window_size(); } _segments_out.push(seg); // 当前发送队列 } clean_shutdown(); } \",\"代码上有详细的注释，尤其是一些 Corner Case 需要注意，这里额外说明一下：\",\"必须在有 ack 的情况下，才能调用 _sender.ack_received；\",\"记得调用 _receiver.segment_received；\",\"任何长度大于 0 的包，都应该至少回应一个包，这个包可能为空包，因此需设置 send_empty。 发送空包是 sender 提供的函数，如下：\",\"void TCPSender::send_empty_segment() { // 发送空包 TCPSegment seg; seg.header().seqno = wrap(_next_seqno, _isn); _segments_out.push(seg); } \",\"那么为什么需要发送空包呢？其实很简单，因为对于远端的包，我们需要及时的回复，但是本端可能没有数据回复，也无需确认(无需加入 _segments_in_flight 队列)，因此需要一个空包(无数据)携带 ackno，window_size 等字段到达对端同步信息。 注意，TCPConnection 应在任何时候都调用 send_segment 尝试发送报文，如：\",\"size_t TCPConnection::write(const string &data) { // Write data to the outbound byte stream // 向输出流写数据，即 sender if (data.size() == 0) { return 0; } size_t sz = _sender.stream_in().write(data); send_segment(); return sz; } \",\"应用程序通过 write 函数向输出流写入数据后，也应该调用 send_segment 尝试发送报文。 TCPConnection 另一个重要的工作在于计时：\",\"void TCPConnection::tick(const size_t ms_since_last_tick) { if (!_active) { return; } _time_since_last_segment_received += ms_since_last_tick; // 1. tell the TCPSender about the passage of time. _sender.tick(ms_since_last_tick); // 2. abort the connection, and send a reset segment to the peer (an empty segment with the rst flag set), // if the number of consecutive retransmissions is more than an upper limit TCPConfig::MAX RETX ATTEMPTS. // 如果超过了重试次数，那么准备关闭连接 if (_sender.consecutive_retransmissions() > TCPConfig::MAX_RETX_ATTEMPTS) { // 3. end the connection cleanly if necessary unclean_shutdown(); send_segment(false, true); // 发送 rst 包 } // 4. 重试发送 // 超时，_sender 会发送到队列中 // Corner Case: // 如果处于 listen 状态，那么只应该等待，不应该 send if (state() != TCPState::State::LISTEN) { send_segment(); } } \",\"每当调用 tick 函数时，增加 _time_since_last_segment_received 并且调用 _sender.tick，然后判断重试次数，如果超过了默认重试次数，那么发送 RST 包，并且关闭连接。 在刚才的代码中，unclean_shutdown 和 clean_shutdown 函数多次出现，这两个函数都与连接关闭有直接关系，并且涉及到不同的连接关闭方式。\",\"方式 1：非干净关闭，TCP 连接接收 RST 包，或者被析构、重试次数超过了默认次数，立马关闭输入、输出流，然后设置 active 为 false；\",\"方式 2：干净关闭，没有任何错误产生，双方都全部完成了数据交付和接收，然后设置 active 为 false。\",\"unclean_shutdown(非干净关闭)是比较简单的，在收到 RST 包、析构、重试失败的时机下调用即可：\",\"void TCPConnection::unclean_shutdown() { _receiver.stream_out().set_error(); _sender.stream_in().set_error(); _active = false; } \",\"而 clean_shutdown 是比较麻烦，建立在数据完全交付的情况下，需要满足一下几个条件：\",\"输入流(receiver)已经完全重组且结束；\",\"输出流(sender)已结束，并且已经全部发送到对端；\",\"输出流已经完全被对端确认；\",\"： 1. 数据流结束后不等待，即 _linger_after_streams_finish 为 false； 2. _time_since_last_segment_received 已经超过了 10 倍超时时间。 clean_shutdown 必须同时满足条件 1，3，以及 4 的一个字条件，如下：\",\"void TCPConnection::clean_shutdown() { // The inbound stream has been fully assembled and has ended. if (_receiver.stream_out().input_ended()) { // The outbound stream has been ended by the local application and fully sent (including // the fact that it ended, i.e. a segment with fin ) to the remote peer. if (!_sender.stream_in().eof()) { // If the inbound stream ends before the TCPConnection // has reached EOF on its outbound stream, this variable needs to be set to false. _linger_after_streams_finish = false; } else if (_sender.bytes_in_flight() == 0) { // The outbound stream has been fully acknowledged by the remote peer. if (!_linger_after_streams_finish || _time_since_last_segment_received >= 10 * _cfg.rt_timeout) { _active = false; } } } } \",\"input_ended 表示输入流结束，bytes_in_flight 为 0，表示输出流已经完全被对端接收且确认。 关于 _linger_after_streams_finish 这个变量需要额外说明一下，它表示流结束后是否需要等待，默认为 true，表示需要等待，因为即使流结束了，但是可能对端没有完全确认，因此需要等待，等待时间为 10 * _cfg.rt_timeout，即子条件 b。\",\"那么如何不等待了？当输入流关闭，而输出流没有结束时，这表示远端已经发送了 FIN 包，所以输入流才能关闭，因此这个状态属于被动关闭，所以无需考虑输出流能否全部交付的问题，因此对端已经不再接受包了，所以彼端可以直接设置 active 为 false。\"]},\"286\":{\"h\":\"Sponge 使用\",\"t\":[\"到此一个简易版 TCP——Sponge 协议已经实现完毕了，详细代码见参考资料链接。接下来，我们需要去使用一下该协议，从中来看看三次握手是如何发生的。\",\"首先，通过新建 UDPSocket 监听本地 3000 端口：\",\"int main(/*int argc, char **argv*/) { try { TCPConfig c_fsm{}; FdAdapterConfig c_filt{}; Address addr{\\\"127.0.0.1\\\", 3000}; c_filt.source = addr; UDPSocket udp_sock; udp_sock.bind(c_filt.source); LossyTCPOverUDPSpongeSocket tcp_socket(LossyTCPOverUDPSocketAdapter(TCPOverUDPSocketAdapter(move(udp_sock)))); // 开始监听 tcp_socket.listen_and_accept(c_fsm, c_filt); while (!tcp_socket.eof()) { const string res = tcp_socket.read(); cout << \\\"INFO: received from remote: \\\" << res << \\\" \\\\n\\\"; } tcp_socket.wait_until_closed(); } catch (const exception &e) { cerr << \\\"Exception: \\\" << e.what() << endl; return EXIT_FAILURE; } return EXIT_SUCCESS; } \",\"UDPSocket 为对 socket API UDP 协议的封装，然后通过 LossyTCPOverUDPSocketAdapter 等适配器将其适配适配到 TCPConnection 上，感兴趣的可以查看源码(非常值得一读)。 绑定本地 3000 端口，然后从 socket 中读取数据。\",\"然后新建客户端连接 3000 端口：\",\"int main(/*int argc, char **argv*/) { try { TCPConfig c_fsm{}; FdAdapterConfig c_filt{}; Address addr{\\\"127.0.0.1\\\", 3000}; c_filt.destination = addr; UDPSocket udp_sock; LossyTCPOverUDPSpongeSocket tcp_socket(LossyTCPOverUDPSocketAdapter(TCPOverUDPSocketAdapter(move(udp_sock)))); // 连接 tcp_socket.connect(c_fsm, c_filt); // 发送数据 for (size_t i = 0; i < 10; i++) { cout << \\\"INFO: wite Hello Pedro! to stream \\\\n\\\"; tcp_socket.write(\\\"Hello Pedro!\\\"); // 休眠 1s std::this_thread::sleep_for(std::chrono::milliseconds(1000)); } tcp_socket.wait_until_closed(); } catch (const exception &e) { cerr << \\\"Exception: \\\" << e.what() << endl; return EXIT_FAILURE; } return EXIT_SUCCESS; } \",\"同样的通过 UDPSocket 新建 socket 然后适配到 TCPConnection 中，调用 connect 发起连接，然后向 socket 中定时写入数据。 先运行服务端、再运行客户端。\",\"服务端：\",\"$ ./apps/tcp_udp_server DEBUG: Listening for incoming connection... DEBUG: [三次握手第二步] 服务端发送 SYN + ACK 包 New connection from 127.0.0.1:39239. INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! INFO: received from remote: Hello Pedro! DEBUG: Inbound stream from 127.0.0.1:39239INFO: received from remote: DEBUG: Waiting for clean shutdown... finished cleanly. DEBUG: Outbound stream to 127.0.0.1:39239 finished (1 byte still in flight). DEBUG: Outbound stream to 127.0.0.1:39239 has been fully acknowledged. DEBUG: TCP connection finished cleanly. done. \",\"客户端：\",\"$ ./apps/tcp_udp_client DEBUG: Connecting to 127.0.0.1:3000... DEBUG: [三次握手第一步] 客户端发送 SYN 包 DEBUG: [三次握手第三步] 客户端发送 ACK 包 Successfully connected to 127.0.0.1:3000. INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream INFO: wite Hello Pedro! to stream DEBUG: Waiting for clean shutdown... DEBUG: Outbound stream to 127.0.0.1:3000 finished (1 byte still in flight). DEBUG: Outbound stream to 127.0.0.1:3000 has been fully acknowledged. DEBUG: Inbound stream from 127.0.0.1:3000 finished cleanly. DEBUG: Waiting for lingering segments (e.g. retransmissions of FIN) from peer... DEBUG: TCP connection finished cleanly. done. \",\"从终端输出中可以看到，双方三次握手的过程，在代码中是这样发生。 首先，客户端调用 connect 函数发出连接，即 SYN 包，这是三次握手的第一步：\",\"void TCPConnection::connect() { // Initiate a connection by sending a SYN segment // 客户端发起连接，向服务端发送 SYN 包，三次握手第一步 if (_first_syn) { cerr << \\\"DEBUG: [三次握手第一步] 客户端发送 SYN 包 \\\" << endl; _first_syn = false; } send_segment(true, false); } \",\"在 connect 函数且没有发生过 SYN 的情况下，就是三次握手的第一步。 三次握手第二步，由服务器发送 SYN + ACK 包：\",\"void TCPConnection::segment_received(const TCPSegment &seg) { // 省略代码... if (header.syn && !header.ack && send_empty) { cerr << \\\"DEBUG: [三次握手第二步] 服务端发送 SYN + ACK 包 \\\" << endl; } send_segment(false, false, send_empty); } \",\"服务器收到 SYN 包后，判断头部没有 ACK，且发送空包，则向客户端发送 SYN + ACK 包，即三次握手第二步。 三次握手第三步，客户端收到 SYN + ACK 包，发送 ACK 包：\",\"void TCPConnection::segment_received(const TCPSegment &seg) { // 省略代码... if (header.ack) { if (_first_ack && state() == TCPState::State::SYN_SENT) { cerr << \\\"DEBUG: [三次握手第三步] 客户端发送 ACK 包 \\\" << endl; _first_ack = false; } _sender.ack_received(header.ackno, header.win); } // 省略代码... } \",\"客户端在收到第一个 ACK 包，且处于 SYN_SENT 状态下，接收 ackno，并向服务器发送 ACK 包。至此，三次握手全部完成，双方进入可靠通信阶段，即终端输出的 10 次 Hello Pedro! 。 当客户端数据全部发送完毕，且被确认，客户端会关闭输出流，然后干净地关闭连接，服务端在收到对端关闭后，进入被动关闭状态，等待超时，然后干净地关闭连接(参考终端输出的 DEBUG 日志)。\",\"那么 Sponge 协议的性能怎么样呢？sponge 项目提供了 benchmark 程序，运行结果如下：\",\"./apps/tcp_benchmark CPU-limited throughput : 2.35 Gbit/s CPU-limited throughput with reordering: 1.58 Gbit/s \"]},\"287\":{\"h\":\"总结\",\"t\":[\"网络协议是一个非常有趣的东西，在互联网普及的今天，基本覆盖了我们生活的方方面面。CS144 是一门好课，将理论知识巧妙和实践结合，在完成 sponge 项目的过程中可以从理论、实践上充分的吸收网络知识，当然 sponge 中还有 IPv4 协议、ARP 协议、路由跳转等多个网络层协议的实现，基本覆盖了网络知识的方方面面，这里就不展开讲了，感兴趣的可以点开参考资料上的连接了解一下。\",\"最后，我们下一个系列再见～\"]},\"288\":{\"h\":\"参考资料\",\"t\":[\"CS 144: Introduction to Computer Networking, Fall 2020\",\"深入理解 TCP 协议：从原理到实战\",\"sponge 项目代码\"]},\"289\":{\"h\":\"带你修改一次 Linux 内核\"},\"290\":{\"h\":\"使用\",\"t\":[\"运行容器：\",\"$ git clone https://github.com/pedrogao/qemu-linux $ cd qemu-linux && docker build . -t qemu-linux $ docker run -it qemu-linux /bin/bash \",\"进入容器后，运行脚本启动 qemu：\",\"# ./run.sh \",\"运行结果： \"]},\"291\":{\"h\":\"环境搭建\",\"t\":[\"依赖：\",\"Docker 通过 docker 搭建 ubuntu20.04 环境，Dockerfile 如下：\",\"FROM ubuntu:20.04 ENV DEBIAN_FRONTEND=noninteractive RUN echo \\\"deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse \\\\n \\\\ deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse \\\\n \\\\ deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse \\\\n \\\\ deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse \\\\n \\\\ deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse \\\\n \\\\ deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse \\\\n \\\\ deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse \\\\n \\\\ deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse \\\\n \\\\ deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse \\\\n \\\\ deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\\\">/etc/apt/sources.list RUN cat /etc/apt/sources.list RUN apt update RUN apt-get install -y wget \\\\ gcc \\\\ gcc-multilib \\\\ git \\\\ make \\\\ bc \\\\ texinfo \\\\ gdb \\\\ cgdb \\\\ qemu-system-x86-64 \\\\ libncurses5-dev \\\\ vim \\\\ cpio \",\"然后将其编译为一个本地镜像：\",\"docker build -t qemu-20 . \",\"这样就有一个装有 qemu 的 ubuntu20.04 的镜像环境了：\",\"docker run -it qemu-20 /bin/bash \",\"进入容器后，编译 Linux 源码：\",\"$ cd home/ $ wget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v4.x/linux-4.9.301.tar.gz $ tar -xzf ./linux-4.9.301.tar.gz $ make menuconfig \",\"开启 debug 信息，路径如下：\",\"Kernel hacking ---> Compile-time checks and compiler options ---> [ ] Compile the kernel with debug info \",\"按空格选中，其它默认。生成 .config 配置文件后，开始编译内核：\",\"make -j8 \",\"查询内核镜像：\",\"# ls ./arch/x86_64/boot/ bzImage \",\"下载 busybox：\",\"# cd .. # wget https://busybox.net/downloads/busybox-1.32.1.tar.bz2 # tar -xf busybox-1.32.1.tar.bz2 # cd busybox-1.32.1 \",\"编译 busybox：\",\"# make menuconfig \",\"选择 settings -> build options -> build static binary，保存并退出，然后编译：\",\"# make -j8 && make install # ls ./_install/ bin linuxrc sbin usr \",\"构建 initramfs 根文件系统：\",\"# cd .. # mkdir initramfs # cd initramfs/ # cp -rf ../busybox-1.32.1/_install/* ./ # mkdir dev proc sys # ln -sf /dev/null /dev/tty1 # ln -sf /dev/null /dev/tty2 # ln -sf /dev/null /dev/tty3 # ln -sf /dev/null /dev/tty4 # cp -a /dev/{null,console,tty,tty1,tty2,tty3,tty4} dev/ # rm -f linuxrc \",\"新建 init 文件，并添加如下内容：\",\"#!/bin/busybox sh echo \\\"{==DBG==} INIT SCRIPT\\\" mount -t proc none /proc mount -t sysfs none /sys echo -e \\\"{==DBG==} Boot took $(cut -d' ' -f1 /proc/uptime) seconds\\\" exec /sbin/init \",\"如下：\",\"# chmod a+x init # ls bin dev init proc sbin sys usr \",\"打包 initramfs：\",\"# find . -print0 | cpio --null -ov --format=newc | gzip -9 > ../initramfs.cpio.gz # cd .. # ls | grep 'initramfs' initramfs initramfs.cpio.gz \",\"运行内核：\",\"# qemu-system-x86_64 -kernel ./linux-4.9.301/arch/x86/boot/bzImage -initrd ./initramfs.cpio.gz -append \\\"nokaslr console=ttyS0\\\" -nographic \",\"或者：\",\"# qemu-system-x86_64 -nographic -kernel ./linux-4.9.301/arch/x86/boot/bzImage -initrd ./initramfs.cpio.gz -append \\\"noapic console=ttyS0 norandmaps\\\" \",\"运行成功截图： \",\"或者调试内核，监听在 1234 端口：\",\"# qemu-system-x86_64 -kernel ./linux-4.9.301/arch/x86/boot/bzImage -initrd ./initramfs.cpio.gz -append \\\"nokaslr console=ttyS0\\\" -s -S -nographic \",\"通过 vscode attch 至容器，然后在容器中安装 cpp 插件，在 init/main.c 中打上断点，调试配置如下：\",\"{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \\\"version\\\": \\\"0.2.0\\\", \\\"configurations\\\": [ { \\\"name\\\": \\\"kernel-debug\\\", \\\"type\\\": \\\"cppdbg\\\", \\\"request\\\": \\\"launch\\\", \\\"miDebuggerServerAddress\\\": \\\"127.0.0.1:1234\\\", \\\"program\\\": \\\"${workspaceFolder}/vmlinux\\\", \\\"args\\\": [], \\\"stopAtEntry\\\": false, \\\"cwd\\\": \\\"${workspaceFolder}\\\", \\\"environment\\\": [], \\\"externalConsole\\\": false, \\\"logging\\\": { \\\"engineLogging\\\": false }, \\\"MIMode\\\": \\\"gdb\\\", } ] } \",\"如下图： \",\"然后开始愉快的调试 Linux 内核：\"]},\"292\":{\"h\":\"Crosstool-ng\",\"t\":[\"下载 ng：\",\"# wget http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.25.0.tar.xz # tar -xf ./crosstool-ng-1.25.0.tar.xz # cd crosstool-ng-1.25.0 # export CROSSTOOL_DIR=`pwd` # mkdir install # cd install # export CROSSTOOL_INSTALL_DIR=`pwd` \",\"配置：\",\"# cd $CROSSTOOL_DIR # apt-get install flex bison unzip help2man gawk libtool libtool-bin # ./configure --prefix=$CROSSTOOL_INSTALL_DIR # make && make install \",\"安装新的编译器：\",\"# ./ct-ng x86_64-unknown-linux-gnu # ./ct-ng menuconfig \",\"设置 root 用户可编译：\",\"Paths and misc options Try features marked as EXPERIMENTAL\",\"Allow building as root user (READ HELP!)\",\"Are you sure?\",\"选择内核版本为 4.9.301，编译：\",\"# ./ct-ng build \",\"直接通过 docker 编译，参考 https://hub.docker.com/r/bensuperpc/crosstool-ng 。\"]},\"293\":{\"h\":\"Buildroot\",\"t\":[\"安装 buildroot：\",\"# wget https://buildroot.org/downloads/buildroot-2022.02.3.tar.gz # tar -xzf ./buildroot-2022.02.3.tar.gz # cd buildroot-2022.02.3 # export BUILDROOT=/home/buildroot-2022.02.3 # mkdir buildroot-build # export BUILDROOT_BUILD=/home/buildroot-build # cd $BUILDROOT_BUILD # touch Config.in external.mk # echo 'name: mini_linux' > external.desc # echo 'desc: minimal linux system with buildroot' >> external.desc # mkdir configs overlay # cd $BUILDROOT \",\"Ctrl-a + x 退出 qemu，没有反应就多按几下。\",\"# make menuconfig Toolchain ---> Toolchain type ---> External toolchain Toolchain ---> Toolchain ---> Custom toolchain Toolchain ---> Toolchain origin ---> Pre-installed toolchain Toolchain ---> Toolchain path ---> /opt/toolchains/x86_64-unknown-linux-gnu Toolchain ---> Toolchain prefix ---> x86_64-unknown-linux-gnu Toolchain ---> External toolchain gcc version ---> 5.x Toolchain ---> External toolchain kernel headers series ---> 4.3.x Toolchain ---> External toolchain C library ---> glibc/eglibc Toolchain ---> Toolchain has C++ support? ---> yes System configuration ---> System hostname ---> mini_linux System configuration ---> System banner ---> Welcome to mini_linux System configuration ---> Run a getty (login prompt) after boot ---> TTY port ---> ttyS0 System configuration ---> Network interface to configure through DHCP ---> System configuration ---> Root filesystem overlay directories ---> $(BR2_EXTERNAL)/overlay Kernel ---> Linux Kernel ---> no Filesystem images ---> cpio the root filesystem (for use as an initial RAM filesystem) ---> yes Filesystem images ---> Compression method ---> gzip \"]},\"294\":{\"h\":\"修改源代码\",\"t\":[\"系统调用定义：\",\"arch/x86/include/generated/uapi/asm/unistd_64.h arch/x86/include/generated/asm/syscalls_64.h arch/x86/entry/syscalls/syscall_64.tbl \",\"新增一个系统调用定义：\",\"// arch/x86/entry/syscalls/syscall_64.tbl // ... 536 x32 rt_tgsigqueueinfo compat_sys_rt_tgsigqueueinfo 537 x32 recvmmsg compat_sys_recvmmsg 538 x32 sendmmsg compat_sys_sendmmsg 539 x32 process_vm_readv compat_sys_process_vm_readv 540 x32 process_vm_writev compat_sys_process_vm_writev 541 x32 setsockopt compat_sys_setsockopt 542 x32 getsockopt compat_sys_getsockopt 543 x32 io_setup compat_sys_io_setup 544 x32 io_submit compat_sys_io_submit 545 x32 execveat compat_sys_execveat/ptregs 546 x32 preadv2 compat_sys_preadv64v2 547 x32 pwritev2 compat_sys_pwritev64v2 + 998 common get_cpus sys_get_cpus \",\"// include/linux/syscalls.h // ... asmlinkage long sys_pkey_mprotect(unsigned long start, size_t len, unsigned long prot, int pkey); asmlinkage long sys_pkey_alloc(unsigned long flags, unsigned long init_val); asmlinkage long sys_pkey_free(int pkey); + asmlinkage long sys_get_cpus(void); \",\"系统调用代码\",\"// kernel/sys.c // ... + SYSCALL_DEFINE0(get_cpus) { + // 获取系统中有多少 CPU + return num_present_cpus(); + } \",\"num_present_cpus 定义在：\",\"// include/linux/cpumask.h // ... #if NR_CPUS > 1 #define num_online_cpus() cpumask_weight(cpu_online_mask) #define num_possible_cpus() cpumask_weight(cpu_possible_mask) #define num_present_cpus() cpumask_weight(cpu_present_mask) #define num_active_cpus() cpumask_weight(cpu_active_mask) #define cpu_online(cpu) cpumask_test_cpu((cpu), cpu_online_mask) #define cpu_possible(cpu) cpumask_test_cpu((cpu), cpu_possible_mask) #define cpu_present(cpu) cpumask_test_cpu((cpu), cpu_present_mask) #define cpu_active(cpu) cpumask_test_cpu((cpu), cpu_active_mask) #else #define num_online_cpus() 1U #define num_possible_cpus() 1U #define num_present_cpus() 1U #define num_active_cpus() 1U #define cpu_online(cpu) ((cpu) == 0) #define cpu_possible(cpu) ((cpu) == 0) #define cpu_present(cpu) ((cpu) == 0) #define cpu_active(cpu) ((cpu) == 0) #endif \",\"在容器中重新编译内核。\",\"# cd linux-4.9.301 # make -j8 # ls ./arch/x86/boot/bzImage ./arch/x86/boot/bzImage \",\"编译完成后，写个简单的程序来调用一下 sys_get_cpus：\",\"// get_cpus.c #include <stdio.h> #include <unistd.h> #include <sys/syscall.h> int main(int argc, char const *argv[]) { long number = syscall(998); printf(\\\"number of cpu is: %ld\\\\n\\\", number); return 0; } \",\"将其编译为可执行文件，并加入 rootfs 中：\",\"# gcc get_cpus.c -static -o get_cpus # mv ./get_cpus ./initramfs/usr/bin/ # cp -a ../get_cpus ./usr/bin/ # cd initramfs # find . -print0 | cpio --null -ov --format=newc | gzip -9 > ../initramfs.cpio.gz # cd .. # ls -lh | grep initramfs.cpio.gz -rw-r--r-- 1 root root 1.4M Jul 14 01:29 initramfs.cpio.gz \",\"记住：一定要加上 -static！！！ 再次通过 qemu 运行新的内核：\",\"# qemu-system-x86_64 -kernel ./linux-4.9.301/arch/x86/boot/bzImage -initrd ./initramfs.cpio.gz -append \\\"nokaslr console=ttyS0\\\" -nographic / # ls ./usr/bin/ | grep 'cpu' \",\"可以看到在 /usr/bin 目录下存在新的可执行文件 get_cpus，我们运行它：\",\"# ./get_cpus number of cpu is: 1 \",\"结果输出 1。 结果没问题，但有个点很奇怪，目前来说 1 核的 CPU，即使是虚拟机也不多见，那么为什么这里的 cpu 个数结果恰好是 1 呢？\",\"原因其实在 docker 上，由于我们的环境跑在容器中，而 docker 默认就对每个容器的 CPU 进行了限制，这样就不会因为容器过度使用 CPU 而使宿主机资源不够。\",\"通过 cat 命令查看容器的 CPU 限制：\",\"# cat /sys/fs/cgroup/cpu/cpu.shares 1024 \",\"1024/1024 就能得到容器 CPU 大概的限制了，恰好结果就是 1。\"]},\"295\":{\"h\":\"参考资料\",\"t\":[\"https://juejin.cn/post/6856591451418329101\",\"https://bbs.huaweicloud.com/blogs/348654\",\"https://zhuanlan.zhihu.com/p/109442115\",\"ubuntu 20.04 更换阿里源 https://www.jianshu.com/p/ec76a50bef0b\",\"解决构建 docker 镜像时交互问题 https://blog.csdn.net/jiangjiang_jian/article/details/100731400\",\"rootfs 文件构建 http://www.wowotech.net/x_project/simple_busybox.html\",\"https://www.cnblogs.com/schips/p/12125736.html\",\"busybox 新增命令 http://www.4k8k.xyz/article/weixin_48983798/107547837\",\"https://www.linuxjournal.com/article/4395\",\"顶 https://gist.github.com/chrisdone/02e165a0004be33734ac2334f215380e\",\"https://buildroot.org/\"]},\"296\":{\"h\":\"Ai\"},\"297\":{\"h\":\"Posts\"},\"298\":{\"h\":\"Co\"},\"299\":{\"h\":\"Database\"},\"300\":{\"h\":\"Distribute\"},\"301\":{\"h\":\"Engineering\"},\"302\":{\"h\":\"Go\"},\"303\":{\"h\":\"Network\"},\"304\":{\"h\":\"Os\"}},\"dirtCount\":0,\"index\":[[\"顶\",{\"1\":{\"295\":1}}],[\"镜像时交互问题\",{\"1\":{\"295\":1}}],[\"恰好结果就是\",{\"1\":{\"294\":1}}],[\"恰好能获取一个节点的数据\",{\"1\":{\"69\":1}}],[\"限制\",{\"1\":{\"294\":1}}],[\"限流\",{\"1\":{\"150\":1}}],[\"安装\",{\"1\":{\"293\":1}}],[\"安装新的编译器\",{\"1\":{\"292\":1}}],[\"安全\",{\"1\":{\"73\":2}}],[\"搭建\",{\"1\":{\"291\":1}}],[\"依赖\",{\"1\":{\"291\":1}}],[\"依次出栈\",{\"1\":{\"244\":1}}],[\"依次将对象从栈顶出栈\",{\"1\":{\"244\":1}}],[\"依次向后搜索\",{\"1\":{\"240\":1}}],[\"依次向上递归\",{\"1\":{\"71\":1}}],[\"环境\",{\"1\":{\"291\":1}}],[\"环境搭建\",{\"0\":{\"291\":1}}],[\"环境变量\",{\"1\":{\"200\":1}}],[\"带你修改一次\",{\"0\":{\"289\":1}}],[\"带来复杂\",{\"1\":{\"278\":1}}],[\"带来的延时\",{\"1\":{\"236\":1}}],[\"带来的成本\",{\"1\":{\"164\":1}}],[\"带来这个麻烦的主要因素在于\",{\"1\":{\"231\":1}}],[\"休眠\",{\"1\":{\"286\":1}}],[\"监听在\",{\"1\":{\"291\":1}}],[\"监听本地\",{\"1\":{\"286\":1}}],[\"监控\",{\"1\":{\"161\":1}}],[\"倍超时时间\",{\"1\":{\"285\":1}}],[\"析构\",{\"1\":{\"285\":1}}],[\"析构函数\",{\"1\":{\"234\":1}}],[\"干净关闭\",{\"1\":{\"285\":1}}],[\"尝试发送报文\",{\"1\":{\"285\":2}}],[\"尝试去发包回复\",{\"1\":{\"285\":1}}],[\"携带\",{\"1\":{\"285\":1}}],[\"填充包\",{\"1\":{\"285\":1}}],[\"填充数据到包中\",{\"1\":{\"284\":1}}],[\"哪里拿到\",{\"1\":{\"285\":1}}],[\"涉及到连接关闭\",{\"1\":{\"285\":1}}],[\"涉及到好几个类和几千行代码\",{\"1\":{\"69\":1}}],[\"组合起来\",{\"1\":{\"285\":1}}],[\"太大了\",{\"1\":{\"284\":1}}],[\"滑动窗口大小\",{\"1\":{\"284\":1}}],[\"滑动窗口等知识点背得滚瓜烂熟\",{\"1\":{\"270\":1}}],[\"细节可以看看注释\",{\"1\":{\"283\":1}}],[\"细心一点就能完成\",{\"1\":{\"135\":1}}],[\"复杂一点\",{\"1\":{\"283\":1}}],[\"复制到\",{\"1\":{\"218\":1}}],[\"复制粘贴等操作\",{\"1\":{\"24\":1,\"45\":1}}],[\"均占一个序列\",{\"1\":{\"283\":1}}],[\"均可省略\",{\"1\":{\"227\":1}}],[\"溢出后\",{\"1\":{\"283\":1}}],[\"假设\",{\"1\":{\"283\":1}}],[\"假设日志的提交序号为\",{\"1\":{\"127\":1}}],[\"十分接近\",{\"1\":{\"283\":1}}],[\"十分适合作为分布式存储底座\",{\"1\":{\"107\":1}}],[\"刚好等于\",{\"1\":{\"282\":1}}],[\"刚好处于半满状态\",{\"1\":{\"72\":1}}],[\"符号\",{\"1\":{\"282\":1}}],[\"符号表明\",{\"1\":{\"257\":1}}],[\"丢包等场景\",{\"1\":{\"282\":1}}],[\"移除掉\",{\"1\":{\"284\":1}}],[\"移除字节流中的前\",{\"1\":{\"281\":1}}],[\"移动数据的大小由\",{\"1\":{\"252\":1}}],[\"移动\",{\"1\":{\"200\":1}}],[\"逐步添砖加瓦最后实现一个完成的\",{\"1\":{\"280\":1}}],[\"逐步完成软件开发\",{\"1\":{\"164\":1}}],[\"逐渐上升到整体\",{\"1\":{\"280\":1}}],[\"视具体情况而定\",{\"1\":{\"279\":1}}],[\"输入流\",{\"1\":{\"285\":1}}],[\"输入流为\",{\"1\":{\"279\":1}}],[\"输出流已经完全被对端确认\",{\"1\":{\"285\":1}}],[\"输出流\",{\"1\":{\"285\":2}}],[\"输出流设置为错误状态\",{\"1\":{\"285\":1}}],[\"输出流为\",{\"1\":{\"279\":1}}],[\"输出如下\",{\"1\":{\"238\":1}}],[\"输出当前程序内存情况\",{\"1\":{\"238\":1}}],[\"输出语法\",{\"1\":{\"227\":1}}],[\"输出最后的结果\",{\"1\":{\"181\":1}}],[\"输出的情况下\",{\"1\":{\"164\":1}}],[\"输出\",{\"1\":{\"164\":1,\"227\":3,\"285\":1}}],[\"损坏等\",{\"1\":{\"279\":1}}],[\"拥塞控制\",{\"1\":{\"278\":1}}],[\"拥有两个字节流\",{\"1\":{\"279\":1}}],[\"拥有更多的活力\",{\"1\":{\"228\":1}}],[\"拥有了\",{\"1\":{\"71\":1}}],[\"紧急指针\",{\"1\":{\"278\":1}}],[\"紧接着\",{\"1\":{\"116\":1}}],[\"窗口没有设置过\",{\"1\":{\"284\":1}}],[\"窗口等信息\",{\"1\":{\"275\":1}}],[\"窗口大小不为\",{\"1\":{\"284\":1}}],[\"窗口大小可能为空\",{\"1\":{\"284\":1}}],[\"窗口大小\",{\"1\":{\"272\":1,\"279\":1,\"284\":1}}],[\"窗口大小等信息\",{\"1\":{\"272\":1}}],[\"路径如下\",{\"1\":{\"291\":1}}],[\"路径最大传输单元\",{\"1\":{\"274\":1}}],[\"路由跳转等多个网络层协议的实现\",{\"1\":{\"287\":1}}],[\"路由负载均衡交给其它方\",{\"1\":{\"151\":1}}],[\"路由层之间\",{\"1\":{\"149\":1}}],[\"路由层通过不同的策略来选择合适的连接\",{\"1\":{\"145\":1}}],[\"路由层\",{\"0\":{\"145\":1},\"1\":{\"143\":1,\"150\":1}}],[\"报文达到时\",{\"1\":{\"285\":1}}],[\"报文长度与确认序号之间的关系\",{\"1\":{\"284\":1}}],[\"报文都被当作一个\",{\"1\":{\"282\":1}}],[\"报文容器\",{\"1\":{\"282\":1}}],[\"报文数据第一个字节的序号\",{\"1\":{\"282\":1}}],[\"报文数据\",{\"1\":{\"282\":1}}],[\"报文数据乱序等问题\",{\"1\":{\"282\":1}}],[\"报文数据不能直接写入到\",{\"1\":{\"282\":1}}],[\"报文可能存在乱序\",{\"1\":{\"282\":1}}],[\"报文可能乱序\",{\"1\":{\"279\":1}}],[\"报文\",{\"1\":{\"279\":3,\"282\":1,\"284\":1}}],[\"报文发送队列和报文已发送未确认队列\",{\"1\":{\"284\":1}}],[\"报文发送\",{\"1\":{\"279\":1}}],[\"报文大小是有限制的\",{\"1\":{\"274\":1}}],[\"报名+函数名\",{\"1\":{\"207\":1}}],[\"意味着\",{\"1\":{\"274\":1}}],[\"防止数据丢失或出错\",{\"1\":{\"273\":1}}],[\"校验和等功能\",{\"1\":{\"278\":1}}],[\"校验和\",{\"1\":{\"273\":1}}],[\"欢迎斧正\",{\"1\":{\"273\":1}}],[\"欢迎大家探讨\",{\"1\":{\"168\":1}}],[\"形\",{\"1\":{\"270\":1}}],[\"形成新的\",{\"1\":{\"4\":1}}],[\"形成新的sstable文件\",{\"1\":{\"4\":3}}],[\"考试上的常客\",{\"1\":{\"270\":1}}],[\"考虑到\",{\"1\":{\"179\":1}}],[\"考虑到很多同学对其不熟悉\",{\"1\":{\"178\":1}}],[\"考虑到服务提供者会发生下线\",{\"1\":{\"148\":1}}],[\"考虑如何与常用框架spring的接入\",{\"1\":{\"143\":1}}],[\"附录\",{\"0\":{\"267\":1}}],[\"附带订阅地址信息变更通知\",{\"1\":{\"148\":1}}],[\"放入任务\",{\"1\":{\"264\":1}}],[\"放在这里一一细讲会浪费很大的篇幅\",{\"1\":{\"241\":1}}],[\"各有优缺点\",{\"1\":{\"264\":1}}],[\"低损耗的\",{\"1\":{\"264\":1}}],[\"省掉了一系列的步骤\",{\"1\":{\"263\":1}}],[\"省略代码\",{\"1\":{\"286\":3}}],[\"省略一些字段\",{\"1\":{\"283\":1}}],[\"省略了部分代码\",{\"1\":{\"203\":1}}],[\"省略了一堆判断代码\",{\"1\":{\"200\":1}}],[\"省略\",{\"1\":{\"126\":1,\"130\":2,\"131\":1,\"133\":12,\"134\":3,\"136\":6,\"137\":4,\"219\":1,\"237\":1}}],[\"握手\",{\"1\":{\"263\":1}}],[\"占据了很大的内存容量\",{\"1\":{\"262\":1}}],[\"占用空间大\",{\"1\":{\"147\":1}}],[\"样例见附录\",{\"1\":{\"262\":1}}],[\"产生内存泄漏的原因在于\",{\"1\":{\"262\":1}}],[\"产品的实现都有所不同\",{\"1\":{\"158\":1}}],[\"产品\",{\"1\":{\"152\":1}}],[\"足够的切片容量\",{\"1\":{\"262\":1}}],[\"浪费了大量内存\",{\"1\":{\"262\":1}}],[\"池库\",{\"1\":{\"264\":1}}],[\"池做输出缓存\",{\"1\":{\"261\":1}}],[\"池化几乎可以作为性能\",{\"1\":{\"265\":1}}],[\"池化的三种方式均以介绍完毕\",{\"1\":{\"265\":1}}],[\"池化\",{\"1\":{\"260\":1}}],[\"池化学习\",{\"0\":{\"259\":1}}],[\"临时\",{\"1\":{\"261\":1}}],[\"耗时较长\",{\"1\":{\"260\":1}}],[\"地怼了上去\",{\"1\":{\"260\":1}}],[\"地址存储到\",{\"1\":{\"200\":1}}],[\"地址到\",{\"1\":{\"198\":1}}],[\"地址从注册中心获取\",{\"1\":{\"153\":1}}],[\"地址信息\",{\"1\":{\"148\":2}}],[\"地址\",{\"1\":{\"110\":1,\"155\":1,\"200\":1}}],[\"地址访问\",{\"1\":{\"104\":1}}],[\"系列文章\",{\"1\":{\"258\":2}}],[\"系统监控\",{\"1\":{\"200\":1}}],[\"系统调用代码\",{\"1\":{\"294\":1}}],[\"系统调用定义\",{\"1\":{\"294\":1}}],[\"系统调用数字编号为\",{\"1\":{\"257\":1}}],[\"系统调用向进程要内存\",{\"1\":{\"238\":1}}],[\"系统调用运行后\",{\"1\":{\"199\":1}}],[\"系统调用来新建多个线程\",{\"1\":{\"199\":1}}],[\"系统调用来新建线程\",{\"1\":{\"198\":1}}],[\"系统调用来创建的\",{\"1\":{\"199\":1}}],[\"系统调用新建线程\",{\"1\":{\"198\":1,\"203\":1}}],[\"系统调用可以说是无处不在\",{\"1\":{\"198\":1}}],[\"系统调用严格遵循了刚才介绍的系统调用流程\",{\"1\":{\"197\":1}}],[\"系统调用的第一个参数\",{\"1\":{\"197\":1}}],[\"系统调用的编号是\",{\"1\":{\"197\":1}}],[\"系统调用完成相应功能\",{\"1\":{\"197\":1}}],[\"系统调用是如何产生的\",{\"1\":{\"197\":1}}],[\"系统调用\",{\"0\":{\"195\":1},\"1\":{\"192\":1,\"196\":1,\"197\":2,\"198\":3,\"217\":1,\"257\":4}}],[\"声明\",{\"1\":{\"257\":1}}],[\"声明文件来对应\",{\"1\":{\"212\":1}}],[\"偏移\",{\"1\":{\"257\":1}}],[\"段\",{\"1\":{\"256\":1}}],[\"段基址到\",{\"1\":{\"200\":1}}],[\"戳这\",{\"1\":{\"255\":1}}],[\"帧地址\",{\"1\":{\"250\":1}}],[\"位\",{\"1\":{\"283\":1}}],[\"位整数\",{\"1\":{\"283\":1}}],[\"位机中\",{\"1\":{\"250\":1}}],[\"位于节点\",{\"1\":{\"72\":1}}],[\"略有不同\",{\"1\":{\"248\":1}}],[\"哎\",{\"1\":{\"248\":1}}],[\"认证\",{\"1\":{\"263\":1}}],[\"认真分析\",{\"1\":{\"247\":1}}],[\"认为文档是插入操作的集合\",{\"1\":{\"43\":1}}],[\"瞬间豁然开朗\",{\"1\":{\"247\":1}}],[\"张图揭开\",{\"1\":{\"247\":1}}],[\"知识\",{\"1\":{\"245\":1}}],[\"知识点\",{\"1\":{\"216\":1}}],[\"颜色抽象是这样将标记阶段分为多阶段的\",{\"1\":{\"244\":1}}],[\"白色并不是严格意义上的颜色标记\",{\"1\":{\"244\":1}}],[\"白色\",{\"1\":{\"244\":1}}],[\"白色圆圈为不可达\",{\"1\":{\"243\":1}}],[\"灰色栈的机制巧妙地将灰色标记分成了多阶段\",{\"1\":{\"244\":1}}],[\"灰色栈\",{\"1\":{\"244\":1}}],[\"灰色\",{\"1\":{\"244\":2}}],[\"黑色\",{\"1\":{\"244\":1}}],[\"采用\",{\"1\":{\"263\":1}}],[\"采用的是先整体后局部的方式\",{\"1\":{\"280\":1}}],[\"采用的\",{\"1\":{\"244\":1}}],[\"采用了上面的转换方式之后\",{\"1\":{\"117\":1}}],[\"剩余窗口大小\",{\"1\":{\"284\":1}}],[\"剩余的对象就是不可达的\",{\"1\":{\"243\":1}}],[\"剩下的白色对象都是垃圾对象\",{\"1\":{\"244\":1}}],[\"剩下的工作\",{\"1\":{\"227\":1}}],[\"剩下的就是将机器码写入内存\",{\"1\":{\"218\":1}}],[\"及可达对象\",{\"1\":{\"243\":1}}],[\"及时跟\",{\"1\":{\"165\":1}}],[\"建立关联后再入栈\",{\"1\":{\"243\":1}}],[\"建立在数据完全交付的情况下\",{\"1\":{\"285\":1}}],[\"建立在当前\",{\"1\":{\"136\":1}}],[\"建立在双方任期一致的情况下\",{\"1\":{\"124\":1}}],[\"尾指针虽然不在栈中\",{\"1\":{\"243\":1}}],[\"尾指针\",{\"1\":{\"243\":1}}],[\"尾指针来模拟对象之间的引用\",{\"1\":{\"243\":1}}],[\"尾\",{\"1\":{\"243\":1}}],[\"头\",{\"1\":{\"243\":2}}],[\"头文件\",{\"1\":{\"59\":1,\"280\":6}}],[\"维护\",{\"1\":{\"285\":1}}],[\"维护对象个数等信息\",{\"1\":{\"243\":1}}],[\"维护对象之间的引用关系\",{\"1\":{\"243\":1}}],[\"维护着当前节点的日志应用序号\",{\"1\":{\"131\":1}}],[\"连接接收\",{\"1\":{\"285\":1}}],[\"连接是否处于激活状态\",{\"1\":{\"285\":1}}],[\"连接的接收方\",{\"1\":{\"283\":1}}],[\"连接只有一个\",{\"1\":{\"282\":1}}],[\"连接完美抽象\",{\"1\":{\"279\":1}}],[\"连接既可以是\",{\"1\":{\"275\":1}}],[\"连接\",{\"1\":{\"263\":1,\"277\":1,\"279\":1,\"286\":1}}],[\"连接池的使用太频繁\",{\"1\":{\"263\":1}}],[\"连接池的实现\",{\"1\":{\"263\":1}}],[\"连接池的作用就在于能够一直保持连接\",{\"1\":{\"263\":1}}],[\"连接池在\",{\"1\":{\"263\":1}}],[\"连接池\",{\"0\":{\"263\":1}}],[\"连接等元数据信息\",{\"1\":{\"243\":1}}],[\"连接管理更加简单方便\",{\"1\":{\"105\":1}}],[\"真正的数据\",{\"1\":{\"243\":1}}],[\"真的不好用文字描述\",{\"1\":{\"169\":1}}],[\"沿着连接搜索图中对象\",{\"1\":{\"243\":1}}],[\"沿着树向下遍历\",{\"1\":{\"73\":1}}],[\"局部变量\",{\"1\":{\"243\":2}}],[\"易懂\",{\"1\":{\"242\":1}}],[\"易用rpc框架\",{\"1\":{\"141\":1}}],[\"申请\",{\"1\":{\"241\":1}}],[\"申请内存后\",{\"1\":{\"243\":1}}],[\"申请内存时\",{\"1\":{\"241\":1}}],[\"申请内存\",{\"1\":{\"238\":1}}],[\"仅仅只能模拟出\",{\"1\":{\"241\":1}}],[\"仅有5个字段\",{\"1\":{\"146\":1}}],[\"呢\",{\"1\":{\"241\":1,\"294\":1}}],[\"较小\",{\"1\":{\"240\":1}}],[\"较大\",{\"1\":{\"240\":1}}],[\"块又该放回那个\",{\"1\":{\"241\":1}}],[\"块无需再与其它块链接\",{\"1\":{\"241\":1}}],[\"块\",{\"1\":{\"240\":3}}],[\"块大小\",{\"1\":{\"240\":2}}],[\"示意图如下\",{\"1\":{\"240\":1}}],[\"急需解决的问题是\",{\"1\":{\"239\":1}}],[\"仿照\",{\"1\":{\"239\":1}}],[\"抄\",{\"1\":{\"239\":1,\"241\":1}}],[\"首地址\",{\"1\":{\"238\":1}}],[\"首先要发送一个\",{\"1\":{\"284\":1}}],[\"首先使用旧\",{\"1\":{\"224\":1}}],[\"首先看\",{\"1\":{\"200\":1}}],[\"首先看看insert函数\",{\"1\":{\"47\":1}}],[\"首先将需求分解为功能点\",{\"1\":{\"164\":1}}],[\"首先第\",{\"1\":{\"136\":1}}],[\"首先比较任期\",{\"1\":{\"130\":1}}],[\"首先领导者通过\",{\"1\":{\"129\":1}}],[\"首先代码\",{\"1\":{\"129\":1}}],[\"首先判断节点是否为协调者\",{\"1\":{\"124\":1}}],[\"首先我们需要对节点这个概念进行抽象\",{\"1\":{\"123\":1}}],[\"首先是该函数的前面部分\",{\"1\":{\"200\":1}}],[\"首先是创建阶段\",{\"1\":{\"183\":1}}],[\"首先是编码\",{\"1\":{\"146\":1}}],[\"首先是数据建模\",{\"1\":{\"26\":1}}],[\"首先是\",{\"1\":{\"10\":1,\"13\":1}}],[\"首先检查进行中的事务字典中是否有对应的事务\",{\"1\":{\"4\":1}}],[\"首先\",{\"1\":{\"4\":1,\"25\":1,\"43\":1,\"47\":2,\"68\":1,\"69\":1,\"94\":1,\"181\":1,\"212\":1,\"217\":1,\"219\":1,\"225\":1,\"227\":1,\"241\":1,\"243\":1,\"260\":1,\"277\":1,\"286\":2}}],[\"首先客套一下\",{\"1\":{\"4\":1}}],[\"绕开了\",{\"1\":{\"238\":1}}],[\"绕开\",{\"1\":{\"238\":1}}],[\"梦想还是要有的\",{\"1\":{\"238\":1}}],[\"物理内存才会真正的分配\",{\"1\":{\"237\":1}}],[\"篇文章的启发\",{\"1\":{\"236\":1}}],[\"篇幅有限\",{\"1\":{\"79\":1}}],[\"受这\",{\"1\":{\"236\":1}}],[\"机制\",{\"1\":{\"236\":1,\"262\":1}}],[\"机器码进行优化\",{\"1\":{\"219\":1}}],[\"仓库上提出了一个名为proposal\",{\"1\":{\"236\":1}}],[\"月\",{\"1\":{\"236\":2}}],[\"显著特点\",{\"1\":{\"272\":1}}],[\"显著地降低了\",{\"1\":{\"236\":1}}],[\"显然此时它被分配的\",{\"1\":{\"238\":1}}],[\"显然\",{\"1\":{\"207\":1,\"225\":1,\"243\":1}}],[\"显然领导者也不指望一次能够同步成功\",{\"1\":{\"129\":1}}],[\"显然不是的\",{\"1\":{\"84\":1}}],[\"显然是不能的\",{\"1\":{\"25\":1}}],[\"问题\",{\"1\":{\"235\":1}}],[\"智能指针\",{\"1\":{\"234\":1}}],[\"难免会出现错误导致内存问题\",{\"1\":{\"234\":1}}],[\"难点在于节点分裂\",{\"1\":{\"71\":1}}],[\"精准控制它们的分配与释放是较为简单的\",{\"1\":{\"234\":1}}],[\"精妙的抽象\",{\"1\":{\"79\":1}}],[\"理论上来说\",{\"1\":{\"236\":1}}],[\"理想情况下\",{\"1\":{\"234\":1}}],[\"理解需求\",{\"1\":{\"164\":1,\"165\":1,\"168\":1}}],[\"理解它被提出的背景\",{\"1\":{\"139\":1}}],[\"手动内存管理将告一段落了\",{\"1\":{\"242\":1}}],[\"手动内存管理实践\",{\"0\":{\"239\":1}}],[\"手动内存管理应该算是内存管理的经典流派了\",{\"1\":{\"234\":1}}],[\"手动管理\",{\"0\":{\"234\":1},\"1\":{\"233\":1}}],[\"垃圾回收算法实现之\",{\"1\":{\"247\":1}}],[\"垃圾也会被清理完毕\",{\"1\":{\"243\":1}}],[\"垃圾\",{\"1\":{\"233\":1}}],[\"管理\",{\"1\":{\"275\":1}}],[\"管理着全局内存\",{\"1\":{\"241\":1}}],[\"管理内存的本质实质就是通过进程提供的\",{\"1\":{\"237\":1}}],[\"管理堆其实就是移动\",{\"1\":{\"237\":1}}],[\"管理方式\",{\"0\":{\"233\":1}}],[\"管理比较复杂\",{\"1\":{\"158\":1}}],[\"事实上\",{\"1\":{\"237\":1}}],[\"事实上堆内存也占据了地址空间上最大的一块\",{\"1\":{\"232\":1}}],[\"事务共享锁加入\",{\"1\":{\"88\":1}}],[\"事务获取某条记录的共享锁\",{\"1\":{\"88\":1}}],[\"事务淘汰策略有多种\",{\"1\":{\"87\":1}}],[\"事务释放锁\",{\"1\":{\"86\":1}}],[\"事务请求\",{\"1\":{\"86\":1}}],[\"事务不能再加锁\",{\"1\":{\"88\":1}}],[\"事务不能再获取锁\",{\"1\":{\"85\":1}}],[\"事务不用关系其它事务之间的数据依赖\",{\"1\":{\"86\":1}}],[\"事务无法再获取新的锁\",{\"1\":{\"85\":1}}],[\"事务是数据访问的基本单位\",{\"1\":{\"85\":1}}],[\"事务是数据库访问\",{\"1\":{\"83\":1}}],[\"事务已终止\",{\"1\":{\"85\":1}}],[\"事务已提交\",{\"1\":{\"85\":1}}],[\"事务向锁管理器请求锁\",{\"1\":{\"85\":1}}],[\"事务一般有三个操作\",{\"1\":{\"85\":1}}],[\"事务第一次查询有\",{\"1\":{\"84\":1}}],[\"事务第一次读取数据\",{\"1\":{\"84\":1}}],[\"事务再次读取\",{\"1\":{\"84\":1}}],[\"事务更改了数据\",{\"1\":{\"84\":1}}],[\"事务发生错误并执行回滚操作\",{\"1\":{\"84\":1}}],[\"事务尚未提交的数据\",{\"1\":{\"84\":1}}],[\"事务读取到的数据就是脏数据\",{\"1\":{\"84\":1}}],[\"事务读取\",{\"1\":{\"84\":1}}],[\"事务隔离级别\",{\"0\":{\"84\":1},\"1\":{\"84\":1}}],[\"事务应确保数据库的状态从一个一致状态转变为另一个一致状态\",{\"1\":{\"83\":1}}],[\"事务作为一个整体被执行\",{\"1\":{\"83\":1}}],[\"事务具有如下四个特性\",{\"1\":{\"83\":1}}],[\"事务\",{\"0\":{\"83\":1},\"1\":{\"86\":2,\"88\":1}}],[\"事务管理器\",{\"1\":{\"58\":1,\"59\":1,\"82\":1}}],[\"静态区的首地址\",{\"1\":{\"250\":1}}],[\"静态变量\",{\"1\":{\"232\":2}}],[\"静态分析\",{\"1\":{\"229\":1}}],[\"缺少等各种各样的问题\",{\"1\":{\"282\":1}}],[\"缺页中断等等\",{\"1\":{\"231\":1}}],[\"缺点\",{\"1\":{\"144\":1,\"147\":1}}],[\"担任着缓冲与加速的重要工作\",{\"1\":{\"231\":1}}],[\"旁边的高速缓存容量一般也就几百\",{\"1\":{\"231\":1}}],[\"万倍\",{\"1\":{\"231\":1}}],[\"慢了足足\",{\"1\":{\"231\":1}}],[\"诺伊曼的设计理念的指导下\",{\"1\":{\"231\":1}}],[\"概述\",{\"0\":{\"231\":1,\"260\":1,\"270\":1}}],[\"概念\",{\"0\":{\"196\":1}}],[\"期待那一天的到来\",{\"1\":{\"228\":1}}],[\"团队的傲慢\",{\"1\":{\"228\":1}}],[\"团队内以及跨团队协作你如何完成\",{\"1\":{\"162\":1}}],[\"门槛降低了很多\",{\"1\":{\"228\":1}}],[\"门槛低\",{\"1\":{\"144\":1}}],[\"感兴趣\",{\"1\":{\"255\":1}}],[\"感兴趣的同学可以参考参考\",{\"1\":{\"264\":1}}],[\"感兴趣的同学可以参考这里\",{\"1\":{\"208\":1,\"210\":1}}],[\"感兴趣的同学可以查看相关的资料\",{\"1\":{\"237\":1}}],[\"感兴趣的同学可以点开这里慢慢了解\",{\"1\":{\"241\":1}}],[\"感兴趣的同学可以点开看看\",{\"1\":{\"237\":1}}],[\"感兴趣的同学可以点开\",{\"1\":{\"219\":1}}],[\"感兴趣的同学可以自己将程序编译为执行文件后\",{\"1\":{\"218\":1}}],[\"感兴趣的同学可以自己实践看看\",{\"1\":{\"214\":1}}],[\"感兴趣的可以自行查询\",{\"1\":{\"270\":1}}],[\"感兴趣的可以自行查阅资料\",{\"1\":{\"73\":1}}],[\"感兴趣的可以\",{\"1\":{\"224\":1}}],[\"感兴趣的可以参考这里\",{\"1\":{\"208\":1}}],[\"感兴趣的可以参考a\",{\"1\":{\"19\":1}}],[\"感兴趣的可以点开参考资料上的连接了解一下\",{\"1\":{\"287\":1}}],[\"感兴趣的可以点开参考资料查阅\",{\"1\":{\"79\":1}}],[\"感兴趣的可以点击这里查看一下\",{\"1\":{\"226\":1}}],[\"感兴趣的可以点击\",{\"1\":{\"64\":1}}],[\"感兴趣的可以查看源码\",{\"1\":{\"51\":1,\"241\":1,\"286\":1}}],[\"感兴趣的人\",{\"1\":{\"27\":1}}],[\"感受到了\",{\"1\":{\"228\":1}}],[\"步\",{\"1\":{\"227\":1}}],[\"格式如下\",{\"1\":{\"252\":1}}],[\"格式化的\",{\"1\":{\"227\":1}}],[\"格式的\",{\"1\":{\"212\":1}}],[\"千万不要使用\",{\"1\":{\"227\":1}}],[\"千万别被名字吓到了\",{\"1\":{\"23\":1}}],[\"里面涉及到大量概念和机制\",{\"1\":{\"231\":1}}],[\"里面的代码\",{\"1\":{\"227\":1}}],[\"里面会涉及到大量\",{\"1\":{\"200\":1}}],[\"补充元信息\",{\"1\":{\"226\":1}}],[\"句法\",{\"1\":{\"226\":1}}],[\"官方文档介绍绘制而成\",{\"1\":{\"226\":1}}],[\"判空操作\",{\"1\":{\"225\":1}}],[\"判断头部没有\",{\"1\":{\"286\":1}}],[\"判断节点\",{\"1\":{\"282\":1}}],[\"判断节点大小是否小于叶子节点最大个数\",{\"1\":{\"71\":1}}],[\"判断对象是否可达实际就是在图中搜索出路径不可达的对象\",{\"1\":{\"243\":1}}],[\"判断操作放在了编译期生成\",{\"1\":{\"225\":1}}],[\"判断最后一个返回参数\",{\"1\":{\"225\":1}}],[\"判断字符为空\",{\"1\":{\"212\":1}}],[\"判断是否存在定时任务触发\",{\"1\":{\"200\":1}}],[\"判断是否有\",{\"1\":{\"200\":1}}],[\"判断是否为\",{\"1\":{\"200\":1}}],[\"判断是否为系统栈\",{\"1\":{\"200\":1}}],[\"判断是否需要删除根节点\",{\"1\":{\"72\":1}}],[\"判断消息是否有效\",{\"1\":{\"146\":1}}],[\"判断任期与状态\",{\"1\":{\"136\":1}}],[\"判断任期是否需要成为追随者\",{\"1\":{\"136\":1}}],[\"判断当前快照的\",{\"1\":{\"136\":1}}],[\"判断事务隔离级别\",{\"1\":{\"89\":1}}],[\"判断迭代器是否结束\",{\"1\":{\"79\":1}}],[\"判断\",{\"1\":{\"72\":1,\"136\":1,\"138\":1,\"225\":1}}],[\"判断一下\",{\"1\":{\"72\":1}}],[\"判断出o与item之间是否满足\",{\"1\":{\"47\":1}}],[\"话不多说\",{\"1\":{\"224\":1}}],[\"创始人希望工程师能够认真对待每一个\",{\"1\":{\"223\":1}}],[\"创建和初始化\",{\"1\":{\"200\":1}}],[\"创建一个waigroup对象\",{\"1\":{\"187\":1}}],[\"创建一个新的\",{\"1\":{\"4\":1}}],[\"创建一个新的空的\",{\"1\":{\"4\":1}}],[\"创建新的无缓冲channel\",{\"1\":{\"187\":1}}],[\"创建阶段\",{\"0\":{\"183\":1,\"187\":1},\"1\":{\"182\":1}}],[\"创建了那些\",{\"1\":{\"155\":1}}],[\"创建item\",{\"1\":{\"47\":1}}],[\"错误处理\",{\"1\":{\"223\":1,\"229\":1}}],[\"遇到如此重复错误处理代码\",{\"1\":{\"223\":1}}],[\"半数代码都是在\",{\"1\":{\"223\":1}}],[\"半满\",{\"1\":{\"72\":1}}],[\"体验创造的乐趣\",{\"1\":{\"235\":1}}],[\"体验不一样的乐趣\",{\"1\":{\"220\":1}}],[\"体验一把\",{\"1\":{\"177\":1}}],[\"近些年火爆的原因\",{\"1\":{\"219\":1}}],[\"近几年最大的一次变动\",{\"1\":{\"178\":1}}],[\"源代码文件\",{\"1\":{\"257\":1}}],[\"源代码词法\",{\"1\":{\"226\":1}}],[\"源代码进行解析\",{\"1\":{\"219\":1}}],[\"源码\",{\"1\":{\"218\":1,\"291\":1}}],[\"源码解析系列\",{\"1\":{\"119\":1}}],[\"把不用的对象回收起来\",{\"1\":{\"260\":1}}],[\"把编译器的前端部分直接开放在了标准库中\",{\"1\":{\"219\":1}}],[\"把视角放到\",{\"1\":{\"207\":1}}],[\"区全局可变\",{\"1\":{\"255\":1}}],[\"区\",{\"1\":{\"255\":1}}],[\"区表示已经初始化完毕的全局\",{\"1\":{\"232\":1}}],[\"区别在于不同的寄存器\",{\"1\":{\"218\":1}}],[\"区域中\",{\"1\":{\"105\":1}}],[\"添加新的\",{\"1\":{\"227\":1}}],[\"添加新的关键字\",{\"1\":{\"225\":1}}],[\"添加\",{\"1\":{\"218\":1}}],[\"添加一个新的类\",{\"1\":{\"4\":1}}],[\"明显重复了两次\",{\"1\":{\"218\":1}}],[\"明确前提条件\",{\"1\":{\"43\":1}}],[\"减法\",{\"1\":{\"218\":1}}],[\"减少字符串拷贝带来的性能\",{\"1\":{\"281\":1}}],[\"减少了非必要内存的分配\",{\"1\":{\"262\":1}}],[\"减少了重复代码\",{\"1\":{\"225\":1}}],[\"减少无效劳动\",{\"1\":{\"164\":1}}],[\"减少磁盘访问次数\",{\"1\":{\"62\":1}}],[\"减少磁盘和内存之间的数据\",{\"1\":{\"62\":1}}],[\"减少计数器\",{\"1\":{\"13\":1,\"14\":1}}],[\"乘法\",{\"1\":{\"218\":1}}],[\"差不多就是一种汇编方言\",{\"1\":{\"218\":1}}],[\"甚至这些都不是\",{\"1\":{\"226\":1}}],[\"甚至可能不止一种\",{\"1\":{\"218\":1}}],[\"甚至去实现一个小巧的数据库\",{\"1\":{\"56\":1}}],[\"装有\",{\"1\":{\"218\":1}}],[\"虚拟机\",{\"1\":{\"243\":1}}],[\"虚拟机的前提下\",{\"1\":{\"218\":1}}],[\"虚拟机是一个典型的栈机\",{\"1\":{\"218\":1}}],[\"虚拟节点\",{\"1\":{\"26\":1}}],[\"脚本是通过虚拟机\",{\"1\":{\"218\":1}}],[\"资源\",{\"1\":{\"217\":1}}],[\"资源文件\",{\"1\":{\"194\":1}}],[\"退出\",{\"1\":{\"293\":1}}],[\"退出码为\",{\"1\":{\"217\":1}}],[\"退出程序\",{\"1\":{\"197\":1,\"217\":1}}],[\"归档文件\",{\"1\":{\"217\":2}}],[\"笨\",{\"1\":{\"217\":1}}],[\"绝对确认序号\",{\"1\":{\"283\":1}}],[\"绝大多数操作系统会在内核中提供\",{\"1\":{\"277\":1}}],[\"绝大多数情况下\",{\"1\":{\"217\":1}}],[\"绝知此事要躬行\",{\"1\":{\"11\":1}}],[\"换掉\",{\"1\":{\"217\":1}}],[\"肯定很多人觉得\",{\"1\":{\"236\":1}}],[\"肯定是有的\",{\"1\":{\"217\":1}}],[\"肯定都非常喜欢其\",{\"1\":{\"177\":1}}],[\"摆脱掉\",{\"1\":{\"217\":1}}],[\"希望下次遇到性能问题时\",{\"1\":{\"265\":1}}],[\"希望本文能带给你一个新的编译器视角\",{\"1\":{\"220\":1}}],[\"希望上面的两个黑魔法能带你对\",{\"1\":{\"214\":1}}],[\"希望能够帮助读者对\",{\"1\":{\"38\":1}}],[\"希望能帮助到对\",{\"1\":{\"27\":1}}],[\"顺利运行\",{\"1\":{\"212\":1}}],[\"翻译为具体的机器码\",{\"1\":{\"218\":1}}],[\"翻译为机器码\",{\"1\":{\"218\":1}}],[\"翻译\",{\"1\":{\"218\":1}}],[\"翻译而来的\",{\"1\":{\"212\":1}}],[\"翻译成代码\",{\"1\":{\"124\":1}}],[\"别忘了\",{\"1\":{\"210\":1}}],[\"别人也可以同时访问\",{\"1\":{\"73\":1}}],[\"掉\",{\"1\":{\"238\":1,\"243\":1,\"262\":1}}],[\"掉而导致缓存失效\",{\"1\":{\"210\":1}}],[\"掉它\",{\"1\":{\"210\":1}}],[\"扩容后再put\",{\"1\":{\"268\":1}}],[\"扩容后的切片容量\",{\"1\":{\"208\":1}}],[\"扩容成功后\",{\"1\":{\"208\":1}}],[\"扩展性是一个rpc框架另一个重要的特性\",{\"1\":{\"149\":1}}],[\"旧切片\",{\"1\":{\"208\":1}}],[\"旧消息清理等\",{\"1\":{\"157\":1}}],[\"链接器等等都是用\",{\"1\":{\"219\":1}}],[\"链接器提供\",{\"1\":{\"217\":1}}],[\"链接包内的私有函数\",{\"1\":{\"206\":1}}],[\"链路层不仅仅可以在代理层\",{\"1\":{\"149\":1}}],[\"链路层\",{\"0\":{\"149\":1},\"1\":{\"143\":1,\"150\":1}}],[\"确认\",{\"1\":{\"285\":1}}],[\"确认不了\",{\"1\":{\"284\":1}}],[\"确认序列\",{\"1\":{\"284\":1}}],[\"确认序号\",{\"1\":{\"284\":3}}],[\"确认号\",{\"1\":{\"279\":1}}],[\"确认报文\",{\"1\":{\"279\":1}}],[\"确保数据达到对端\",{\"1\":{\"273\":1}}],[\"确保操作的原子性\",{\"1\":{\"92\":1}}],[\"确实真正的向进程申请到了内存\",{\"1\":{\"237\":1}}],[\"确实是需要的\",{\"1\":{\"206\":1}}],[\"封装良好的包是友好的\",{\"1\":{\"206\":1}}],[\"控制\",{\"1\":{\"275\":1}}],[\"控制内部数据\",{\"1\":{\"206\":1}}],[\"控制追随者勿发起新的选举\",{\"1\":{\"129\":1}}],[\"导入后使用\",{\"1\":{\"206\":1}}],[\"导致代码很多\",{\"1\":{\"283\":1}}],[\"导致文本变成123\",{\"1\":{\"48\":1}}],[\"导致最终文本内容不一致\",{\"1\":{\"25\":2}}],[\"导致副本之间状态不一致\",{\"1\":{\"13\":1}}],[\"导致大部分技术债实际上是架构和设计阶段的债务\",{\"1\":{\"0\":1}}],[\"公共\",{\"1\":{\"206\":1}}],[\"公共模块\",{\"1\":{\"59\":1}}],[\"私有变量\",{\"1\":{\"206\":1}}],[\"私有\",{\"1\":{\"206\":1}}],[\"魔法\",{\"0\":{\"206\":1,\"209\":1,\"217\":1,\"218\":1,\"219\":1}}],[\"魔数\",{\"1\":{\"146\":1}}],[\"详尽干货\",{\"1\":{\"204\":2}}],[\"详细代码见参考资料链接\",{\"1\":{\"286\":1}}],[\"详细阐述其设计与实现\",{\"1\":{\"154\":1}}],[\"详细设计\",{\"0\":{\"108\":1,\"143\":1,\"154\":1}}],[\"详细介绍请参考论文\",{\"1\":{\"10\":1}}],[\"详细探讨了分布式环境下\",{\"1\":{\"8\":1}}],[\"几乎所有人都遇到过类似下面的\",{\"1\":{\"223\":1}}],[\"几乎所有的编译器都有\",{\"1\":{\"218\":1}}],[\"几乎一致\",{\"1\":{\"136\":1}}],[\"几个重要的汇编\",{\"1\":{\"204\":1}}],[\"热点问题\",{\"0\":{\"201\":1}}],[\"造成程序\",{\"1\":{\"200\":1}}],[\"终于铺垫到了这里\",{\"1\":{\"245\":1}}],[\"终于\",{\"1\":{\"200\":1}}],[\"终于到执行\",{\"1\":{\"200\":1}}],[\"终止阶段\",{\"1\":{\"85\":1}}],[\"饿死\",{\"1\":{\"200\":1}}],[\"信号相关的初始化\",{\"1\":{\"200\":1}}],[\"信息\",{\"1\":{\"157\":1,\"160\":1,\"291\":1}}],[\"信息包装为请求结构体\",{\"1\":{\"124\":1}}],[\"拷贝等操作\",{\"1\":{\"227\":1}}],[\"拷贝之后\",{\"1\":{\"207\":2}}],[\"拷贝之前\",{\"1\":{\"207\":2}}],[\"拷贝\",{\"1\":{\"200\":1}}],[\"拷贝到切片\",{\"1\":{\"207\":1}}],[\"拷贝到\",{\"1\":{\"200\":4,\"207\":1}}],[\"拷贝到寄存器\",{\"1\":{\"200\":1}}],[\"禁止抢占\",{\"1\":{\"200\":1}}],[\"禁止origin连线交叉\",{\"1\":{\"43\":1}}],[\"置\",{\"1\":{\"200\":1,\"202\":1}}],[\"置换器\",{\"1\":{\"64\":1}}],[\"^\",{\"1\":{\"200\":1}}],[\"唤醒\",{\"1\":{\"200\":2}}],[\"属于编译器行为\",{\"1\":{\"200\":1}}],[\"看待\",{\"1\":{\"284\":1}}],[\"看到\",{\"1\":{\"257\":1}}],[\"看似都从堆里面分配了内存\",{\"1\":{\"237\":1}}],[\"看\",{\"1\":{\"237\":1}}],[\"看作是工作线程\",{\"1\":{\"200\":1}}],[\"看看如何将其字节码翻译为\",{\"1\":{\"218\":1}}],[\"看看明星\",{\"1\":{\"52\":1}}],[\"看看\",{\"1\":{\"24\":1,\"25\":1,\"224\":1}}],[\"看看能还能扒出什么\",{\"1\":{\"4\":1}}],[\"世界开始\",{\"1\":{\"200\":2}}],[\"见\",{\"1\":{\"200\":2,\"243\":1}}],[\"核的\",{\"1\":{\"294\":1}}],[\"核数\",{\"1\":{\"200\":2}}],[\"核心函数\",{\"1\":{\"284\":3,\"285\":1}}],[\"核心原理就是通过\",{\"1\":{\"198\":1}}],[\"核心是一套指导思想\",{\"1\":{\"168\":1}}],[\"核心是其核心数据counter是通过\",{\"1\":{\"9\":1}}],[\"核心流程是什么\",{\"1\":{\"162\":1}}],[\"核心点在nth即找到第index个item上\",{\"1\":{\"34\":1}}],[\"核心数据结构建模以及基本操作伪代码做一个简单的介绍\",{\"1\":{\"27\":1}}],[\"核心在于行为测试必须先写一篇测试实现代码\",{\"1\":{\"164\":1}}],[\"核心在于状态\",{\"1\":{\"14\":1}}],[\"核心在apply上\",{\"1\":{\"18\":1}}],[\"核心在\",{\"1\":{\"14\":2}}],[\"核心功能点\",{\"1\":{\"9\":1}}],[\"栈操作\",{\"0\":{\"251\":1}}],[\"栈中所有对象都是\",{\"1\":{\"243\":1}}],[\"栈中进行\",{\"1\":{\"200\":1}}],[\"栈顶对象出栈\",{\"1\":{\"243\":1}}],[\"栈顶寄存器\",{\"1\":{\"200\":1}}],[\"栈开始地址\",{\"1\":{\"237\":1}}],[\"栈区用于保存局部变量\",{\"1\":{\"232\":1}}],[\"栈区\",{\"1\":{\"232\":1}}],[\"栈拷贝到新\",{\"1\":{\"200\":1}}],[\"栈\",{\"1\":{\"200\":4,\"243\":1}}],[\"留出足够的栈空间\",{\"1\":{\"200\":1}}],[\"箭头所指向的地方是程序的起始点\",{\"1\":{\"200\":1}}],[\"入手\",{\"1\":{\"217\":1}}],[\"入栈\",{\"1\":{\"200\":2,\"218\":2,\"243\":1,\"244\":2,\"251\":1}}],[\"入口文件\",{\"1\":{\"257\":1}}],[\"入口跳转到\",{\"1\":{\"217\":1}}],[\"入口\",{\"1\":{\"200\":2,\"254\":1}}],[\"入门协同的必经之路\",{\"1\":{\"41\":1}}],[\"跳转到\",{\"1\":{\"200\":1}}],[\"跳转到核心启动函数\",{\"1\":{\"200\":1}}],[\"跳脱全局\",{\"1\":{\"200\":1}}],[\"跳过自己\",{\"1\":{\"124\":1}}],[\"高效运行的根本\",{\"1\":{\"199\":1}}],[\"高可靠\",{\"1\":{\"155\":1}}],[\"高可用性\",{\"1\":{\"4\":1}}],[\"充分发挥其性能\",{\"1\":{\"231\":1}}],[\"充分的发挥多核的能力\",{\"1\":{\"198\":1}}],[\"充分推演后\",{\"1\":{\"26\":1}}],[\"传递参\",{\"1\":{\"200\":1}}],[\"传递参数\",{\"1\":{\"200\":1,\"251\":1}}],[\"传递给了\",{\"1\":{\"200\":1}}],[\"传递给\",{\"1\":{\"200\":1}}],[\"传入都是基于字节流\",{\"1\":{\"274\":1}}],[\"传入的\",{\"1\":{\"208\":1}}],[\"传入到新建线程中\",{\"1\":{\"203\":1}}],[\"传入\",{\"1\":{\"198\":1,\"203\":1}}],[\"传输数据是没有边界的\",{\"1\":{\"274\":1}}],[\"传输高效\",{\"1\":{\"147\":1}}],[\"传输\",{\"1\":{\"18\":1}}],[\"绑定本地\",{\"1\":{\"286\":1}}],[\"绑定的\",{\"1\":{\"200\":1}}],[\"绑定的线程实则是通过\",{\"1\":{\"199\":1}}],[\"绑定\",{\"1\":{\"198\":1,\"200\":1}}],[\"寄存器变量\",{\"1\":{\"243\":1}}],[\"寄存器值\",{\"1\":{\"200\":1}}],[\"寄存器的值加载至\",{\"1\":{\"232\":1}}],[\"寄存器的值\",{\"1\":{\"200\":1}}],[\"寄存器上存储的是\",{\"1\":{\"200\":1,\"251\":1}}],[\"寄存器中\",{\"1\":{\"200\":3}}],[\"寄存器指向的是主线程的调用栈\",{\"1\":{\"200\":1}}],[\"寄存器指向当前\",{\"1\":{\"198\":1}}],[\"寄存器后\",{\"1\":{\"200\":1}}],[\"寄存器\",{\"0\":{\"250\":1},\"1\":{\"198\":1,\"200\":2,\"204\":1,\"250\":2}}],[\"寄存器是比较官方的名称\",{\"1\":{\"15\":1}}],[\"程序在运行时\",{\"1\":{\"243\":1}}],[\"程序在运行的时候会创建多个\",{\"1\":{\"199\":1}}],[\"程序中\",{\"1\":{\"238\":1}}],[\"程序问题\",{\"1\":{\"228\":1}}],[\"程序输入\",{\"1\":{\"225\":1}}],[\"程序也不会进入\",{\"1\":{\"217\":1}}],[\"程序并没有调用\",{\"1\":{\"217\":1}}],[\"程序都会走这么一遭\",{\"1\":{\"217\":1}}],[\"程序会初始化一系列的内存\",{\"1\":{\"217\":1}}],[\"程序自动化了内存\",{\"1\":{\"217\":1}}],[\"程序自动接管了内存\",{\"1\":{\"217\":1}}],[\"程序进入到了\",{\"1\":{\"200\":1}}],[\"程序将进入到\",{\"1\":{\"200\":1}}],[\"程序启动中最重要的函数\",{\"1\":{\"200\":1}}],[\"程序启动的绝大部分工作\",{\"1\":{\"200\":1}}],[\"程序启动过程中比较重要的两个系统调用\",{\"1\":{\"198\":1}}],[\"程序的第一个工作线程\",{\"1\":{\"200\":1}}],[\"程序的入口不是\",{\"1\":{\"200\":1}}],[\"程序的运行依托于操作系统\",{\"1\":{\"193\":1}}],[\"程序代码很简单\",{\"1\":{\"200\":1}}],[\"程序\",{\"1\":{\"199\":1,\"286\":1}}],[\"程序才能创建多个线程\",{\"1\":{\"198\":1}}],[\"程序运行时\",{\"1\":{\"198\":1}}],[\"程序一样的结果\",{\"1\":{\"197\":1}}],[\"陷入内核态后再进行\",{\"1\":{\"197\":1}}],[\"陷入内核态后再使用\",{\"1\":{\"194\":1}}],[\"权限\",{\"1\":{\"231\":1}}],[\"权限的\",{\"1\":{\"197\":1}}],[\"权当做个人\",{\"1\":{\"169\":1}}],[\"举个实际例子\",{\"1\":{\"255\":1}}],[\"举个简单的例子\",{\"1\":{\"234\":1}}],[\"举个例子\",{\"1\":{\"197\":1,\"238\":1}}],[\"举例来说\",{\"1\":{\"240\":1}}],[\"举例\",{\"1\":{\"219\":1}}],[\"举一个业务例子\",{\"1\":{\"164\":1}}],[\"现阶段几乎不可能用完\",{\"1\":{\"237\":1}}],[\"现将\",{\"1\":{\"218\":1}}],[\"现有的标准库无法满足你的需求时\",{\"1\":{\"214\":1}}],[\"现代操作系统都有明确的权限隔离\",{\"1\":{\"196\":1}}],[\"现在\",{\"1\":{\"136\":1,\"239\":1,\"242\":1}}],[\"现在再从树中删除\",{\"1\":{\"72\":1}}],[\"现在从树中删除\",{\"1\":{\"72\":1}}],[\"现在客户端\",{\"1\":{\"48\":1}}],[\"现在需要加入事务支持\",{\"1\":{\"4\":1}}],[\"堆当前地址\",{\"1\":{\"237\":1}}],[\"堆开始地址\",{\"1\":{\"237\":1}}],[\"堆\",{\"1\":{\"237\":1}}],[\"堆内存虽然灵活\",{\"1\":{\"232\":1}}],[\"堆内存具有如下特点\",{\"1\":{\"232\":1}}],[\"堆区\",{\"1\":{\"232\":1}}],[\"堆等等\",{\"1\":{\"194\":1}}],[\"堆数据存储在不同文件中\",{\"1\":{\"98\":1,\"99\":1}}],[\"堆数据存储在一个文件中\",{\"1\":{\"97\":1}}],[\"堆数据单文件存储\",{\"1\":{\"97\":1,\"98\":1,\"99\":1}}],[\"堆数据\",{\"1\":{\"97\":1,\"98\":1,\"99\":1}}],[\"睡眠等等\",{\"1\":{\"194\":1}}],[\"线程局部变量\",{\"1\":{\"200\":1}}],[\"线程与进程是同一种数据结构\",{\"1\":{\"194\":1}}],[\"线程与进程均有同一个结构体\",{\"1\":{\"194\":1}}],[\"线性数据插入算法\",{\"1\":{\"53\":1}}],[\"汇编是深入理解\",{\"1\":{\"258\":1}}],[\"汇编是如何使用的\",{\"1\":{\"257\":1}}],[\"汇编入门\",{\"1\":{\"258\":1}}],[\"汇编究竟是如何使用的\",{\"1\":{\"257\":1}}],[\"汇编的基本使用是必须的\",{\"1\":{\"248\":1}}],[\"汇编书写的代码\",{\"1\":{\"248\":1}}],[\"汇编简单入门\",{\"0\":{\"248\":1}}],[\"汇编转化成\",{\"1\":{\"212\":1}}],[\"汇编文件需要一个对应的\",{\"1\":{\"212\":1}}],[\"汇编文件\",{\"1\":{\"212\":2,\"257\":1}}],[\"汇编文件中\",{\"1\":{\"200\":1}}],[\"汇编函数\",{\"0\":{\"209\":1},\"1\":{\"204\":1}}],[\"汇编\",{\"0\":{\"211\":1},\"1\":{\"192\":1,\"200\":1,\"212\":1}}],[\"汇总函数不会再返回新的数据流\",{\"1\":{\"185\":1}}],[\"汇总函数调用后\",{\"1\":{\"185\":1}}],[\"汇总阶段\",{\"0\":{\"185\":1,\"189\":1},\"1\":{\"182\":1}}],[\"次就会从全局队列中获取\",{\"1\":{\"200\":1}}],[\"次\",{\"1\":{\"200\":1,\"238\":1,\"286\":1}}],[\"次停止即可\",{\"1\":{\"188\":1}}],[\"次数是数据库提升查询效率的主要途径之一\",{\"1\":{\"62\":1}}],[\"阻塞等待读取完成\",{\"1\":{\"187\":1}}],[\"异步读取待拼接stream的channel数据\",{\"1\":{\"187\":1}}],[\"异步从原channel读取数据\",{\"1\":{\"187\":1}}],[\"异步生产\",{\"1\":{\"159\":1}}],[\"截取流尾部数据\",{\"1\":{\"184\":1}}],[\"截取流头部数据\",{\"1\":{\"184\":1}}],[\"截取部分\",{\"1\":{\"180\":1}}],[\"越拥有强大的数据处理能力\",{\"1\":{\"184\":1}}],[\"越丰富的\",{\"1\":{\"184\":1}}],[\"越来越难以测试\",{\"1\":{\"165\":1}}],[\"四次挥手\",{\"1\":{\"270\":1}}],[\"四则运算等等\",{\"1\":{\"218\":1}}],[\"四个函数来初始化\",{\"1\":{\"183\":1}}],[\"四大模块中最简单的一部分\",{\"1\":{\"133\":1}}],[\"想着将二者结合\",{\"1\":{\"177\":1}}],[\"想要深入了解的可以查看本文的参考资料\",{\"1\":{\"248\":1}}],[\"想要了解\",{\"1\":{\"248\":1}}],[\"想要了解的可以阅读\",{\"1\":{\"121\":1}}],[\"想要将字节码直接翻译为机器码可不简单\",{\"1\":{\"218\":1}}],[\"想要规避掉\",{\"1\":{\"217\":1}}],[\"想要读懂其运行流程\",{\"1\":{\"193\":1}}],[\"想要尝试从源码级别上来搞懂这几个问题\",{\"1\":{\"56\":1}}],[\"泛型和函数式编程有了一定了解后\",{\"1\":{\"182\":1}}],[\"泛型约束均为item\",{\"1\":{\"181\":1}}],[\"泛型约束则是\",{\"1\":{\"181\":1}}],[\"泛型可以理解为\",{\"1\":{\"180\":1}}],[\"泛型原理\",{\"0\":{\"180\":1}}],[\"泛型t就能支持\",{\"1\":{\"179\":1}}],[\"泛型样例\",{\"0\":{\"179\":1,\"181\":1}}],[\"泛型非常了解\",{\"1\":{\"178\":1}}],[\"泛型是\",{\"1\":{\"178\":1}}],[\"泛型实现一个流式处理库\",{\"1\":{\"177\":1}}],[\"泛型\",{\"0\":{\"178\":1},\"1\":{\"177\":1,\"178\":1}}],[\"泛型的即将发布\",{\"1\":{\"177\":1}}],[\"泛型尝鲜\",{\"0\":{\"176\":1}}],[\"映射出一段内存后\",{\"1\":{\"218\":1}}],[\"映射\",{\"1\":{\"177\":1,\"182\":1}}],[\"筛选函数\",{\"1\":{\"181\":1}}],[\"筛选一个简单的数字列表\",{\"1\":{\"177\":1}}],[\"筛掉删除的item后的列表长度\",{\"1\":{\"47\":1}}],[\"筛掉被删除的操作\",{\"1\":{\"43\":1}}],[\"熟悉其它语言的同学肯定知道\",{\"1\":{\"264\":1}}],[\"熟悉\",{\"1\":{\"177\":1}}],[\"背景\",{\"0\":{\"177\":1}}],[\"拼接得到新的\",{\"1\":{\"183\":1}}],[\"拼接\",{\"1\":{\"174\":1}}],[\"渐进式开发\",{\"0\":{\"171\":1}}],[\"运行新的内核\",{\"1\":{\"294\":1}}],[\"运行成功截图\",{\"1\":{\"291\":1}}],[\"运行内核\",{\"1\":{\"291\":1}}],[\"运行结果\",{\"1\":{\"290\":1}}],[\"运行结果如下\",{\"1\":{\"207\":2,\"286\":1}}],[\"运行脚本启动\",{\"1\":{\"290\":1}}],[\"运行容器\",{\"1\":{\"290\":1}}],[\"运行该程序\",{\"1\":{\"238\":1}}],[\"运行时\",{\"1\":{\"238\":1}}],[\"运行\",{\"1\":{\"217\":1,\"225\":1}}],[\"运行这两个性能测试函数\",{\"1\":{\"213\":1}}],[\"运行程序\",{\"1\":{\"208\":1,\"210\":2,\"218\":1,\"219\":1,\"237\":1,\"238\":1}}],[\"运行在\",{\"1\":{\"199\":1}}],[\"运行流程\",{\"1\":{\"192\":1,\"200\":1}}],[\"运行测试\",{\"1\":{\"170\":1,\"227\":1}}],[\"运行性能\",{\"1\":{\"41\":1}}],[\"经\",{\"1\":{\"217\":1}}],[\"经常这样干\",{\"1\":{\"170\":1}}],[\"经过多年的迭代\",{\"1\":{\"152\":1}}],[\"经过这么多年的发展\",{\"1\":{\"152\":1}}],[\"笔记吧\",{\"1\":{\"169\":1}}],[\"笔者最开始在实现的时候小觑了这里\",{\"1\":{\"281\":1}}],[\"笔者最开始就是这样的\",{\"1\":{\"245\":1}}],[\"笔者跟随\",{\"1\":{\"270\":1}}],[\"笔者一直按照\",{\"1\":{\"257\":1}}],[\"笔者不经感叹\",{\"1\":{\"246\":1}}],[\"笔者曾说过\",{\"1\":{\"242\":1}}],[\"笔者已经注释了与堆相关的两个变量\",{\"1\":{\"237\":1}}],[\"笔者决定在\",{\"1\":{\"236\":1}}],[\"笔者就把视角放到了\",{\"1\":{\"223\":1}}],[\"笔者每天都得写很多次这样的\",{\"1\":{\"223\":1}}],[\"笔者没有写代码去实现如何将\",{\"1\":{\"218\":1}}],[\"笔者重新梳理了一下\",{\"1\":{\"216\":1}}],[\"笔者分享了\",{\"1\":{\"216\":1}}],[\"笔者的流程是这样的\",{\"1\":{\"168\":1}}],[\"笔者尝试去设计与实现一个极简\",{\"1\":{\"152\":1}}],[\"笔者尝试用自己的理解来解释规则\",{\"1\":{\"43\":1}}],[\"笔者基本每天都在与消息队列\",{\"1\":{\"152\":1}}],[\"笔者选择了最常见的双向链表+哈希表法\",{\"1\":{\"63\":1}}],[\"笔者在实现的过程中\",{\"1\":{\"74\":1}}],[\"笔者在\",{\"1\":{\"27\":1}}],[\"笔者实现了一个\",{\"1\":{\"27\":1}}],[\"勉强能看\",{\"1\":{\"169\":1}}],[\"怎么办\",{\"1\":{\"283\":1}}],[\"怎么可能写好代码\",{\"1\":{\"168\":1}}],[\"怎么做集成测试\",{\"1\":{\"162\":1}}],[\"误导排期和进度\",{\"1\":{\"168\":1}}],[\"严重依赖模块\",{\"1\":{\"168\":1}}],[\"严重拉低了工程质量\",{\"1\":{\"165\":1}}],[\"课程\",{\"1\":{\"167\":1}}],[\"课程实验\",{\"1\":{\"56\":1}}],[\"落地场景\",{\"1\":{\"165\":1}}],[\"沟通能力\",{\"1\":{\"165\":1}}],[\"沟通再来推进\",{\"1\":{\"165\":1}}],[\"业务层代码随时应变\",{\"1\":{\"165\":1}}],[\"能提供一种手动内存管理的\",{\"1\":{\"236\":1}}],[\"能够很迅速的将字节码翻译为对应的\",{\"1\":{\"218\":1}}],[\"能够很大程度上简化机械工作\",{\"1\":{\"217\":1}}],[\"能够推理正确就算理解\",{\"1\":{\"43\":1}}],[\"能让我们以链式调用和\",{\"1\":{\"177\":1}}],[\"能不能采用测试先行的方式了\",{\"1\":{\"165\":1}}],[\"持续提升代码质量\",{\"1\":{\"165\":1}}],[\"持久化快照\",{\"1\":{\"136\":1}}],[\"持久化\",{\"0\":{\"133\":1},\"1\":{\"102\":1,\"121\":1,\"123\":1}}],[\"持久化队列设计演进\",{\"1\":{\"158\":1}}],[\"持久化队列\",{\"0\":{\"99\":1}}],[\"持久性\",{\"1\":{\"83\":1}}],[\"持久性和数据恢复\",{\"1\":{\"4\":3}}],[\"交给\",{\"1\":{\"279\":1,\"283\":1}}],[\"交给用户态下的\",{\"1\":{\"279\":1}}],[\"交互界面后\",{\"1\":{\"200\":1}}],[\"交付后仍然可以后续再来绿灯重构\",{\"1\":{\"165\":1}}],[\"交换起始序号\",{\"1\":{\"272\":1}}],[\"交换状态\",{\"1\":{\"10\":1}}],[\"交换操作\",{\"1\":{\"10\":1}}],[\"伦敦学派可以先对其他组件\",{\"1\":{\"164\":1}}],[\"伦敦学派是在组件结构\",{\"1\":{\"164\":1}}],[\"风格\",{\"1\":{\"164\":1}}],[\"风险把控\",{\"1\":{\"162\":1}}],[\"让开发者集中于核心业务开发和迭代上\",{\"1\":{\"217\":1}}],[\"让\",{\"1\":{\"210\":1,\"228\":1}}],[\"让我们不必花费时间进行空对空的讨论\",{\"1\":{\"164\":1}}],[\"让你从根上理解\",{\"1\":{\"139\":1}}],[\"驱动功能上下文内的功能实现\",{\"1\":{\"164\":1}}],[\"驱动开发\",{\"1\":{\"164\":1}}],[\"驱动\",{\"1\":{\"164\":1}}],[\"间的分配\",{\"1\":{\"164\":1}}],[\"去掉重复的\",{\"1\":{\"188\":1}}],[\"去实践\",{\"1\":{\"167\":1}}],[\"去思考测试的效用与成本\",{\"1\":{\"164\":1}}],[\"去重\",{\"1\":{\"16\":1,\"188\":1}}],[\"去重操作\",{\"1\":{\"13\":1}}],[\"微服务调用\",{\"1\":{\"164\":1}}],[\"验证\",{\"1\":{\"164\":1}}],[\"验证方式\",{\"1\":{\"164\":1}}],[\"比较报文中的序号\",{\"1\":{\"284\":1}}],[\"比较\",{\"1\":{\"254\":1}}],[\"比较先后数量的差值为\",{\"1\":{\"164\":1}}],[\"比起直接翻译为机器码\",{\"1\":{\"218\":1}}],[\"比如fatih\",{\"1\":{\"263\":1}}],[\"比如bucketpool\",{\"1\":{\"262\":1}}],[\"比如另外两个比较知名的实现\",{\"1\":{\"237\":1}}],[\"比如虚拟内存\",{\"1\":{\"231\":1}}],[\"比如拆分\",{\"1\":{\"227\":1}}],[\"比如赋值\",{\"1\":{\"218\":1}}],[\"比如加法\",{\"1\":{\"218\":1}}],[\"比如操作系统\",{\"1\":{\"217\":1}}],[\"比如说\",{\"1\":{\"213\":1}}],[\"比如全局缓存\",{\"1\":{\"210\":1}}],[\"比如这里的两篇文章go\",{\"1\":{\"223\":1}}],[\"比如这里的\",{\"1\":{\"210\":1}}],[\"比如将数据从切片\",{\"1\":{\"207\":1}}],[\"比如我们未涉及到的\",{\"1\":{\"190\":1}}],[\"比如数据库\",{\"1\":{\"164\":1}}],[\"比如测试插入一条数据\",{\"1\":{\"164\":1}}],[\"比如缺少如下特性\",{\"1\":{\"161\":1}}],[\"比如知名的\",{\"1\":{\"147\":1}}],[\"比如日志同步实现后\",{\"1\":{\"121\":1}}],[\"比如都是共享锁\",{\"1\":{\"88\":1}}],[\"比如更新时\",{\"1\":{\"73\":1}}],[\"比如字符1的\",{\"1\":{\"25\":1}}],[\"比如\",{\"1\":{\"10\":1,\"23\":1,\"25\":2,\"79\":1,\"87\":1,\"88\":1,\"139\":1,\"147\":1,\"149\":1,\"152\":1,\"164\":1,\"217\":2,\"218\":3,\"219\":2,\"227\":1,\"231\":1,\"238\":1,\"240\":2,\"241\":2,\"262\":1,\"263\":1,\"264\":1,\"282\":1}}],[\"比如使用更复杂的合并策略来减少\",{\"1\":{\"4\":1}}],[\"先运行服务端\",{\"1\":{\"286\":1}}],[\"先从栈中pop出两个对象\",{\"1\":{\"243\":1}}],[\"先获取对应的\",{\"1\":{\"241\":1}}],[\"先对\",{\"1\":{\"227\":1}}],[\"先写入口测试用例\",{\"1\":{\"168\":1}}],[\"先写测试\",{\"1\":{\"168\":1}}],[\"先写代码\",{\"1\":{\"168\":1}}],[\"先查询已有数据数量\",{\"1\":{\"164\":1}}],[\"先移动一条腿\",{\"1\":{\"73\":1}}],[\"固化测试知识\",{\"1\":{\"164\":1}}],[\"固定时段去重新获取地址信息\",{\"1\":{\"148\":1}}],[\"唯有通过实践才能得知在当前条件下哪个路径是最佳的\",{\"1\":{\"164\":1}}],[\"唯一标识\",{\"1\":{\"85\":1,\"88\":1}}],[\"责任分配良好\",{\"1\":{\"164\":1}}],[\"责任链\",{\"1\":{\"149\":1}}],[\"责任链模式非常适合帮助框架提高扩展性\",{\"1\":{\"149\":1}}],[\"尽量使用可读的方法名替代注释\",{\"1\":{\"164\":1}}],[\"改造\",{\"1\":{\"217\":1,\"227\":1}}],[\"改变a\",{\"1\":{\"243\":1}}],[\"改变实现方式\",{\"1\":{\"164\":1}}],[\"改变的操作后\",{\"1\":{\"139\":1}}],[\"改生产代码\",{\"1\":{\"164\":1}}],[\"绿灯\",{\"1\":{\"164\":1}}],[\"绿\",{\"1\":{\"164\":4}}],[\"红色圆圈表示可达\",{\"1\":{\"243\":1}}],[\"红灯\",{\"1\":{\"164\":1}}],[\"红\",{\"1\":{\"164\":2}}],[\"克服恐惧\",{\"1\":{\"164\":2}}],[\"拆解一下需求\",{\"1\":{\"170\":1}}],[\"拆解任务\",{\"1\":{\"165\":1}}],[\"拆解需求\",{\"1\":{\"164\":1,\"165\":1}}],[\"拆分为如下\",{\"1\":{\"121\":1}}],[\"面向连接是\",{\"1\":{\"272\":1}}],[\"面向连接\",{\"0\":{\"272\":1}}],[\"面向连接的\",{\"1\":{\"270\":1}}],[\"面试\",{\"1\":{\"270\":1}}],[\"面试的常客\",{\"1\":{\"152\":1}}],[\"面对别人质疑时思考\",{\"1\":{\"162\":1}}],[\"超时\",{\"1\":{\"285\":1}}],[\"超时次数+1\",{\"1\":{\"284\":1}}],[\"超时相关字段\",{\"1\":{\"284\":1}}],[\"超时重传\",{\"1\":{\"273\":1}}],[\"超出预期\",{\"1\":{\"162\":1}}],[\"超过这个值则触发gc\",{\"1\":{\"243\":1}}],[\"超过了则回退\",{\"1\":{\"131\":1}}],[\"超过了长度\",{\"1\":{\"129\":1}}],[\"超过\",{\"1\":{\"129\":1,\"137\":1}}],[\"收\",{\"1\":{\"285\":1}}],[\"收获颇大\",{\"1\":{\"167\":1}}],[\"收获点\",{\"0\":{\"164\":1}}],[\"收益是符合预期\",{\"1\":{\"162\":1}}],[\"收到确认包后\",{\"1\":{\"284\":1}}],[\"收到的第一个\",{\"1\":{\"283\":1}}],[\"收到的\",{\"1\":{\"282\":1}}],[\"收到报文后\",{\"1\":{\"279\":1}}],[\"收到节点响应后\",{\"1\":{\"129\":1}}],[\"收到\",{\"1\":{\"25\":1,\"136\":1,\"283\":2,\"285\":1}}],[\"效率越来越高\",{\"1\":{\"164\":1}}],[\"效率也就越低\",{\"1\":{\"84\":1}}],[\"效果评估\",{\"1\":{\"162\":1}}],[\"影响面是什么\",{\"1\":{\"162\":1}}],[\"反过来\",{\"1\":{\"218\":1}}],[\"反而将程序性能提高了\",{\"1\":{\"212\":1}}],[\"反复访问非法地址\",{\"1\":{\"200\":1}}],[\"反测\",{\"1\":{\"162\":1}}],[\"反之亦然\",{\"1\":{\"16\":1,\"207\":1}}],[\"技术调研\",{\"1\":{\"162\":1}}],[\"技术架构是什么\",{\"1\":{\"162\":1}}],[\"技术方案\",{\"1\":{\"162\":1}}],[\"项目代码\",{\"1\":{\"288\":1}}],[\"项目的过程中可以从理论\",{\"1\":{\"287\":1}}],[\"项目提供了\",{\"1\":{\"286\":1}}],[\"项目提供的\",{\"1\":{\"281\":1}}],[\"项目中最简单的一部分\",{\"1\":{\"281\":1}}],[\"项目结构如下\",{\"1\":{\"257\":1}}],[\"项目质量\",{\"1\":{\"238\":1}}],[\"项目背景\",{\"1\":{\"162\":1}}],[\"项目本身\",{\"1\":{\"162\":1}}],[\"工作流程如下图所示\",{\"1\":{\"243\":1}}],[\"工作内容又繁又杂\",{\"1\":{\"152\":1}}],[\"工具来查看\",{\"1\":{\"218\":1}}],[\"工具来生成对应的汇编代码\",{\"1\":{\"213\":1}}],[\"工具来生成汇编\",{\"1\":{\"212\":1}}],[\"工具链接生成\",{\"1\":{\"217\":1}}],[\"工具打包\",{\"1\":{\"217\":1}}],[\"工具编译\",{\"1\":{\"217\":1}}],[\"工具为\",{\"1\":{\"217\":2}}],[\"工具\",{\"1\":{\"212\":1,\"277\":1}}],[\"工具查看一下该程序的系统调用\",{\"1\":{\"197\":1}}],[\"工程能力\",{\"1\":{\"165\":1}}],[\"工程师只需将精力集中在核心的业务逻辑上\",{\"1\":{\"235\":1}}],[\"工程师三驾马车\",{\"1\":{\"165\":1}}],[\"工程师思考\",{\"0\":{\"162\":1}}],[\"延时队列\",{\"1\":{\"161\":1}}],[\"延时重试\",{\"1\":{\"150\":1}}],[\"告警\",{\"1\":{\"161\":1}}],[\"拉取消息\",{\"1\":{\"160\":1}}],[\"拉模式\",{\"1\":{\"160\":1}}],[\"适合多线程下的内存分配场景\",{\"1\":{\"241\":1}}],[\"适合高频率消息生产\",{\"1\":{\"159\":1}}],[\"适合低频率消息生产\",{\"1\":{\"159\":1}}],[\"适合用于协同文本编辑场景\",{\"1\":{\"23\":1}}],[\"出栈\",{\"1\":{\"244\":1,\"251\":1}}],[\"出发\",{\"1\":{\"243\":2}}],[\"出队\",{\"1\":{\"157\":1}}],[\"出现了多个领导者\",{\"1\":{\"122\":1}}],[\"出现较晚\",{\"1\":{\"8\":1}}],[\"平台下\",{\"1\":{\"199\":2,\"257\":1}}],[\"平台访问\",{\"1\":{\"157\":1}}],[\"平分为两个节点\",{\"1\":{\"71\":1}}],[\"暴露的消息\",{\"1\":{\"157\":1}}],[\"拿来即用\",{\"1\":{\"263\":1}}],[\"拿来用是最好的选择\",{\"1\":{\"157\":1}}],[\"拿到页\",{\"1\":{\"241\":1}}],[\"拿到块\",{\"1\":{\"240\":1}}],[\"拿到被回收块的\",{\"1\":{\"240\":1}}],[\"拿到了进程下放的内存后\",{\"1\":{\"239\":1}}],[\"拿到\",{\"1\":{\"200\":1}}],[\"拿到父节点\",{\"1\":{\"71\":1}}],[\"承担着消息存储\",{\"1\":{\"156\":1}}],[\"端口\",{\"1\":{\"277\":2,\"286\":3,\"291\":1}}],[\"端口等\",{\"1\":{\"155\":1}}],[\"端实现\",{\"1\":{\"153\":1}}],[\"称为\",{\"1\":{\"152\":1}}],[\"市面上的\",{\"1\":{\"152\":1}}],[\"彻底搞懂\",{\"1\":{\"152\":1}}],[\"流处理就会终止\",{\"1\":{\"185\":1}}],[\"流式处理与工厂中的流水线作业非常类似\",{\"1\":{\"182\":1}}],[\"流程跳转\",{\"0\":{\"254\":1}}],[\"流程剖析\",{\"0\":{\"200\":1}}],[\"流程\",{\"0\":{\"168\":1},\"1\":{\"164\":1}}],[\"流程图如下\",{\"1\":{\"200\":1}}],[\"流程图如下图\",{\"1\":{\"64\":1}}],[\"流程图\",{\"1\":{\"64\":1}}],[\"流量削峰\",{\"1\":{\"152\":1}}],[\"掌握\",{\"1\":{\"248\":1}}],[\"掌握基本原型即可\",{\"1\":{\"152\":1}}],[\"掌握数据库系统设计\",{\"1\":{\"56\":1}}],[\"扫描\",{\"1\":{\"151\":1}}],[\"订阅事件\",{\"1\":{\"151\":1}}],[\"订阅时\",{\"1\":{\"148\":1}}],[\"距离生产可用还有很长的距离\",{\"1\":{\"151\":1}}],[\"旨在完美逃逸掉\",{\"1\":{\"236\":1}}],[\"旨在学习和实践\",{\"1\":{\"151\":1}}],[\"旨在探索\",{\"1\":{\"152\":1}}],[\"旨在探索超大容量缓存的架构实践\",{\"1\":{\"103\":1}}],[\"旨在探索分布式缓存的设计与实现\",{\"1\":{\"100\":1}}],[\"才继续发包\",{\"1\":{\"284\":1}}],[\"才被完全\",{\"1\":{\"268\":1}}],[\"才去请求全局内存\",{\"1\":{\"241\":1}}],[\"才会将错误信息上报到调用方\",{\"1\":{\"150\":1}}],[\"才能调用\",{\"1\":{\"285\":1}}],[\"才能确认\",{\"1\":{\"283\":1}}],[\"才能回收\",{\"1\":{\"262\":1}}],[\"才能开始执行\",{\"1\":{\"199\":1}}],[\"才能得到最后的几项\",{\"1\":{\"188\":1}}],[\"才能对\",{\"1\":{\"86\":1}}],[\"才能继续执行\",{\"1\":{\"84\":1}}],[\"才能释放所有持有的锁\",{\"1\":{\"73\":1}}],[\"才能释放祖先节点的锁\",{\"1\":{\"73\":1}}],[\"屏蔽底层通信\",{\"1\":{\"150\":1}}],[\"屏蔽通信\",{\"1\":{\"144\":1}}],[\"快速报错\",{\"1\":{\"150\":1}}],[\"快照请求与日志同步请求大同小异\",{\"1\":{\"138\":1}}],[\"快照机制并不复杂\",{\"1\":{\"138\":1}}],[\"快照主要工作可总结如下\",{\"1\":{\"138\":1}}],[\"快照中已经存在了\",{\"1\":{\"137\":1}}],[\"快照后的处理工作\",{\"1\":{\"136\":1}}],[\"快照后更新\",{\"1\":{\"136\":1}}],[\"快照和日志同步一样\",{\"1\":{\"136\":1}}],[\"快照应用也是通过发送\",{\"1\":{\"136\":1}}],[\"快照如何执行\",{\"1\":{\"136\":2}}],[\"快照只会从头开始\",{\"1\":{\"136\":1}}],[\"快照块所包含的最后一个日志任期\",{\"1\":{\"136\":1}}],[\"快照块所包含的最后一个日志序号\",{\"1\":{\"136\":1}}],[\"快照块的存储方式与日志不同\",{\"1\":{\"136\":1}}],[\"快照也影响着日志同步等等\",{\"1\":{\"121\":1}}],[\"快照\",{\"0\":{\"136\":1},\"1\":{\"121\":1,\"136\":1}}],[\"快照实现\",{\"1\":{\"59\":1}}],[\"快照管理器\",{\"1\":{\"58\":1}}],[\"失败\",{\"1\":{\"285\":1}}],[\"失败的可能\",{\"1\":{\"150\":1}}],[\"失去驱动力\",{\"1\":{\"164\":1}}],[\"失效等场景\",{\"1\":{\"148\":1}}],[\"熔断机制\",{\"1\":{\"150\":1}}],[\"熔断\",{\"1\":{\"150\":1}}],[\"打包\",{\"1\":{\"291\":1}}],[\"打包为\",{\"1\":{\"217\":1}}],[\"打交道\",{\"1\":{\"152\":1}}],[\"打印的内存指标一直为\",{\"1\":{\"238\":1}}],[\"打印并写入文件\",{\"1\":{\"219\":1}}],[\"打印调用日志就十分简单了\",{\"1\":{\"149\":1}}],[\"打印rpc调用日志\",{\"1\":{\"149\":1}}],[\"打开队列\",{\"1\":{\"98\":1}}],[\"定时器重置\",{\"1\":{\"284\":1}}],[\"定时器\",{\"1\":{\"284\":1}}],[\"定时刷新\",{\"1\":{\"148\":1}}],[\"定义在\",{\"1\":{\"294\":1}}],[\"定义的全局变量\",{\"1\":{\"255\":2}}],[\"定义每个页都有一个\",{\"1\":{\"241\":1}}],[\"定义后\",{\"1\":{\"227\":1}}],[\"定义新的\",{\"1\":{\"227\":1}}],[\"定义一个新的函数\",{\"1\":{\"217\":1}}],[\"定义为一个结构体\",{\"1\":{\"183\":1}}],[\"定义如下\",{\"1\":{\"63\":1,\"64\":1,\"94\":1,\"157\":1,\"185\":1,\"198\":1,\"243\":1,\"283\":1,\"285\":1}}],[\"定义了一系列函数方便访问日志数据\",{\"1\":{\"128\":1}}],[\"定义了\",{\"1\":{\"43\":1,\"79\":1,\"155\":1,\"158\":1,\"257\":1}}],[\"定义\",{\"1\":{\"4\":1,\"79\":1,\"262\":1}}],[\"定义存储引擎支持的数据类型\",{\"1\":{\"4\":1}}],[\"启动\",{\"1\":{\"200\":1}}],[\"启动定时任务\",{\"1\":{\"148\":1}}],[\"启动rpc服务\",{\"1\":{\"148\":1}}],[\"启动一个事务\",{\"1\":{\"85\":1}}],[\"消费消息\",{\"1\":{\"157\":1,\"160\":2}}],[\"消费进度没有存储至\",{\"1\":{\"153\":1}}],[\"消费者组\",{\"1\":{\"161\":1}}],[\"消费者主动从\",{\"1\":{\"160\":1}}],[\"消费者实现方式一般有两种\",{\"1\":{\"160\":1}}],[\"消费者\",{\"0\":{\"160\":1}}],[\"消费者访问\",{\"1\":{\"157\":1}}],[\"消费者发送变更通知\",{\"1\":{\"148\":1}}],[\"消费者拿到服务url后\",{\"1\":{\"148\":1}}],[\"消息存储\",{\"0\":{\"158\":1}}],[\"消息定时持久化\",{\"1\":{\"157\":1}}],[\"消息入队\",{\"1\":{\"157\":1}}],[\"消息\",{\"1\":{\"157\":1}}],[\"消息生产消费等核心\",{\"1\":{\"156\":1}}],[\"消息分区在\",{\"1\":{\"153\":1}}],[\"消息拆包\",{\"1\":{\"146\":1}}],[\"框架都会自定义通信层\",{\"1\":{\"157\":1}}],[\"框架选择\",{\"1\":{\"147\":1}}],[\"框架的整体结构基本分层为\",{\"1\":{\"143\":1}}],[\"抽象了\",{\"1\":{\"147\":1}}],[\"抽象出了新的item类\",{\"1\":{\"48\":1}}],[\"抽象出\",{\"1\":{\"47\":1}}],[\"冗余数据较多\",{\"1\":{\"147\":1}}],[\"便于调试\",{\"1\":{\"147\":1}}],[\"容器中节点的有序性\",{\"1\":{\"282\":1}}],[\"容器中\",{\"1\":{\"281\":1}}],[\"容量\",{\"1\":{\"207\":1,\"281\":1,\"283\":2}}],[\"容易理解\",{\"1\":{\"147\":1}}],[\"容错是一个系统稳定的根本\",{\"1\":{\"150\":1}}],[\"容错层主要处理如下一些异常情况\",{\"1\":{\"150\":1}}],[\"容错层\",{\"0\":{\"150\":1},\"1\":{\"143\":1}}],[\"容错性和高可用性等方面的实现\",{\"1\":{\"4\":2}}],[\"容错性\",{\"1\":{\"4\":1}}],[\"描述性强\",{\"1\":{\"147\":1}}],[\"粘包已被默认处理\",{\"1\":{\"146\":1}}],[\"良好的自举设计\",{\"1\":{\"219\":1}}],[\"良好的协议需要充分的调研和长时间的打磨\",{\"1\":{\"146\":1}}],[\"良好的工程设计以及丰富的特性\",{\"1\":{\"107\":1}}],[\"观测性差\",{\"1\":{\"147\":1}}],[\"观测\",{\"1\":{\"146\":1}}],[\"降级\",{\"1\":{\"146\":1,\"150\":2}}],[\"降低\",{\"1\":{\"164\":1}}],[\"降低延迟\",{\"1\":{\"146\":1}}],[\"降低客户端使用难度\",{\"1\":{\"105\":1}}],[\"性能十分可观\",{\"1\":{\"146\":1}}],[\"性能高\",{\"1\":{\"146\":1}}],[\"性能\",{\"1\":{\"146\":1}}],[\"性能是数据库一个重要的考量指标\",{\"1\":{\"84\":1}}],[\"动态内存分配区\",{\"1\":{\"232\":1}}],[\"动态字节码生成\",{\"1\":{\"144\":1}}],[\"动态收缩\",{\"1\":{\"102\":1}}],[\"方式\",{\"1\":{\"285\":2}}],[\"方便在清理阶段找到不可达\",{\"1\":{\"243\":1}}],[\"方便下次分配\",{\"1\":{\"241\":1}}],[\"方便后续扩展和迭代\",{\"1\":{\"158\":1}}],[\"方便后续迁移\",{\"1\":{\"153\":1}}],[\"方便迭代和优化\",{\"1\":{\"157\":1}}],[\"方便解析\",{\"1\":{\"147\":1}}],[\"方便调试\",{\"1\":{\"146\":1}}],[\"方案\",{\"1\":{\"144\":1,\"147\":1}}],[\"方法不会消费字节流\",{\"1\":{\"281\":1}}],[\"方法尝试得到待发送报文\",{\"1\":{\"279\":1}}],[\"方法提交任务以及\",{\"1\":{\"264\":1}}],[\"方法提交任务\",{\"1\":{\"264\":1}}],[\"方法提交事务\",{\"1\":{\"4\":2}}],[\"方法取出了\",{\"1\":{\"262\":1}}],[\"方法从队列中取元素\",{\"1\":{\"262\":1}}],[\"方法从池中获取元素\",{\"1\":{\"261\":1}}],[\"方法的返回值还可能会是一个\",{\"1\":{\"261\":1}}],[\"方法的意义在于封装\",{\"1\":{\"206\":1}}],[\"方法将返回\",{\"1\":{\"261\":1}}],[\"方法将内存放入\",{\"1\":{\"239\":1}}],[\"方法来创建新的元素\",{\"1\":{\"261\":1}}],[\"方法来做\",{\"1\":{\"217\":1}}],[\"方法来获取数据记录的\",{\"1\":{\"79\":1}}],[\"方法来获取所有符合条件的数据记录\",{\"1\":{\"78\":1}}],[\"方法会被调用\",{\"1\":{\"285\":1}}],[\"方法会根据事务隔离级别\",{\"1\":{\"88\":1}}],[\"方法会首先在进行中的事务中检索键值对\",{\"1\":{\"4\":1}}],[\"方法时\",{\"1\":{\"88\":1}}],[\"方法接受两个参数\",{\"1\":{\"88\":1}}],[\"方法主要流程如下\",{\"1\":{\"79\":1}}],[\"方法分别用来初始化表元数据\",{\"1\":{\"79\":1}}],[\"方法可根据\",{\"1\":{\"78\":1}}],[\"方法为例\",{\"1\":{\"64\":1}}],[\"方法删除页\",{\"1\":{\"63\":1}}],[\"方法向\",{\"1\":{\"63\":1}}],[\"方法设置值\",{\"1\":{\"18\":1}}],[\"方法\",{\"1\":{\"18\":1,\"78\":4,\"79\":1,\"200\":1,\"225\":1,\"279\":3,\"285\":2}}],[\"方法进行插入\",{\"1\":{\"4\":2}}],[\"方法开始一个新的事务\",{\"1\":{\"4\":2}}],[\"方法中就针对\",{\"1\":{\"13\":1}}],[\"方法中止事务\",{\"1\":{\"4\":2}}],[\"方法中添加了一个检查\",{\"1\":{\"4\":1}}],[\"方法中进行检查\",{\"1\":{\"4\":1}}],[\"极大地拉低了框架使用门槛\",{\"1\":{\"144\":1}}],[\"配置\",{\"1\":{\"285\":1,\"292\":1}}],[\"配置文件后\",{\"1\":{\"291\":1}}],[\"配置文件\",{\"0\":{\"172\":1}}],[\"配置动态调整等功能\",{\"1\":{\"143\":1}}],[\"配置更改发布\",{\"1\":{\"104\":1}}],[\"序列\",{\"1\":{\"283\":1}}],[\"序列化和确认号\",{\"1\":{\"273\":1}}],[\"序列化可能带来的异常\",{\"1\":{\"150\":1}}],[\"序列化\",{\"1\":{\"147\":1,\"153\":1}}],[\"序列化十分频繁\",{\"1\":{\"147\":1}}],[\"序列化方法\",{\"1\":{\"146\":1}}],[\"序列化等调用细节\",{\"1\":{\"144\":1}}],[\"序列化层核心功能是将业务数据序列化为二进制数据\",{\"1\":{\"147\":1}}],[\"序列化层\",{\"0\":{\"147\":1},\"1\":{\"143\":1,\"150\":1,\"157\":1}}],[\"序号等信息\",{\"1\":{\"282\":1}}],[\"序号\",{\"1\":{\"134\":1,\"283\":2}}],[\"序号为\",{\"1\":{\"127\":1}}],[\"统一发送给server方\",{\"1\":{\"142\":1}}],[\"探索一个简单\",{\"1\":{\"141\":1}}],[\"探讨了一些基础\",{\"1\":{\"22\":1}}],[\"独有的\",{\"1\":{\"139\":1}}],[\"独有的死循环\",{\"1\":{\"139\":1}}],[\"独占锁\",{\"1\":{\"86\":1}}],[\"却也十分昂贵\",{\"1\":{\"231\":1}}],[\"却也是一把利刃\",{\"1\":{\"207\":1}}],[\"却不知道它一直在为我们负重前行\",{\"1\":{\"192\":1}}],[\"却不知道日志发生了截断\",{\"1\":{\"137\":1}}],[\"却没有\",{\"1\":{\"136\":1}}],[\"之上\",{\"1\":{\"278\":1}}],[\"之后就被回收了\",{\"1\":{\"262\":1}}],[\"之类的\",{\"1\":{\"260\":1}}],[\"之所以在自动内存管理放在手动内存管理的后面\",{\"1\":{\"242\":1}}],[\"之所以需要介绍\",{\"1\":{\"198\":1}}],[\"之前就被\",{\"1\":{\"284\":1}}],[\"之前先对\",{\"1\":{\"225\":1}}],[\"之前\",{\"1\":{\"179\":1}}],[\"之前笔者编程的模式一直是\",{\"1\":{\"168\":1}}],[\"之前有幸学习过徐昊的\",{\"1\":{\"167\":1}}],[\"之前的日志记录\",{\"1\":{\"136\":1}}],[\"之间如何链接\",{\"1\":{\"241\":1}}],[\"之间的对应关系如下表\",{\"1\":{\"283\":1}}],[\"之间的映射\",{\"1\":{\"241\":1}}],[\"之间的映射关系\",{\"1\":{\"241\":1}}],[\"之间的性能差异\",{\"1\":{\"213\":1}}],[\"之间的桥梁\",{\"1\":{\"199\":1,\"210\":1}}],[\"之间的大小\",{\"1\":{\"136\":1}}],[\"之间的排序\",{\"1\":{\"69\":1}}],[\"之间的关系转化\",{\"1\":{\"283\":1}}],[\"之间的关系\",{\"1\":{\"64\":1,\"136\":1,\"282\":2}}],[\"之间是可比较的\",{\"1\":{\"13\":1}}],[\"拒绝\",{\"1\":{\"136\":2}}],[\"拒绝快照过的\",{\"1\":{\"136\":1}}],[\"达到提升程序性能的效果\",{\"1\":{\"218\":1}}],[\"达到时会调用\",{\"1\":{\"136\":1}}],[\"达到数据备份的效果\",{\"1\":{\"126\":1}}],[\"点\",{\"1\":{\"136\":1}}],[\"点击\",{\"1\":{\"9\":1,\"224\":1}}],[\"点击任意一方\",{\"1\":{\"9\":1}}],[\"何时快照\",{\"1\":{\"136\":2}}],[\"思来想去\",{\"1\":{\"223\":1}}],[\"思想指导后\",{\"1\":{\"168\":1}}],[\"思考点\",{\"0\":{\"165\":1}}],[\"思考一下\",{\"1\":{\"73\":1}}],[\"思路很简单\",{\"1\":{\"241\":1}}],[\"思路也比较简单\",{\"1\":{\"239\":1}}],[\"思路也很简单\",{\"1\":{\"134\":1}}],[\"思路其实很简单\",{\"1\":{\"225\":1}}],[\"思路是什么\",{\"1\":{\"162\":1}}],[\"投出选票等操作均会引起这三个字段的改变\",{\"1\":{\"133\":1}}],[\"投票\",{\"1\":{\"124\":1}}],[\"投票后需设置\",{\"1\":{\"124\":1}}],[\"投票后\",{\"1\":{\"124\":1,\"130\":1,\"133\":1}}],[\"投票记录\",{\"1\":{\"123\":1}}],[\"编号\",{\"1\":{\"257\":1}}],[\"编号为\",{\"1\":{\"197\":1}}],[\"编程语言工作在操作系统之上\",{\"1\":{\"231\":1}}],[\"编程语言中极为重要且不可或缺的一部分\",{\"1\":{\"231\":1}}],[\"编程模式\",{\"1\":{\"223\":1,\"229\":1}}],[\"编译就进入到了第\",{\"1\":{\"227\":1}}],[\"编译\",{\"1\":{\"227\":1,\"291\":2,\"292\":2}}],[\"编译的\",{\"1\":{\"226\":1}}],[\"编译的过程如下图所示\",{\"1\":{\"212\":1}}],[\"编译完成后\",{\"1\":{\"225\":1,\"294\":1}}],[\"编译出最新的\",{\"1\":{\"224\":1}}],[\"编译构建\",{\"1\":{\"224\":1}}],[\"编译源码\",{\"0\":{\"224\":1}}],[\"编译为执行文件\",{\"1\":{\"219\":1}}],[\"编译为可执行文件的\",{\"1\":{\"219\":1}}],[\"编译为目标文件\",{\"1\":{\"217\":1}}],[\"编译成功后\",{\"1\":{\"212\":1}}],[\"编译成汇编\",{\"1\":{\"212\":1}}],[\"编译该代码并使用\",{\"1\":{\"200\":1}}],[\"编译并运行\",{\"1\":{\"197\":1}}],[\"编译器也会走向多元化\",{\"1\":{\"228\":1}}],[\"编译器似乎一直都是一家独大\",{\"1\":{\"228\":1}}],[\"编译器一直都是\",{\"1\":{\"228\":1}}],[\"编译器被称为\",{\"1\":{\"228\":1}}],[\"编译器设计之精巧\",{\"1\":{\"228\":1}}],[\"编译器设计良好\",{\"1\":{\"226\":1}}],[\"编译器新增关键字的挑战\",{\"1\":{\"228\":1}}],[\"编译器新增关键字来处理\",{\"1\":{\"223\":1}}],[\"编译器会帮助我们来处理\",{\"1\":{\"227\":1}}],[\"编译器做了大量工作\",{\"1\":{\"227\":1}}],[\"编译器就支持\",{\"1\":{\"227\":1}}],[\"编译器就这样被实现了\",{\"1\":{\"218\":1}}],[\"编译器的\",{\"1\":{\"226\":1}}],[\"编译器的默认行为\",{\"1\":{\"217\":1}}],[\"编译器是按照程序编译过程来设计实现的\",{\"1\":{\"226\":1}}],[\"编译器是一个极其有意思的主题\",{\"1\":{\"220\":1}}],[\"编译器中的核心点\",{\"1\":{\"226\":1}}],[\"编译器中极其小的一部分\",{\"1\":{\"226\":1}}],[\"编译器中新增\",{\"1\":{\"225\":1}}],[\"编译器\",{\"0\":{\"226\":1},\"1\":{\"218\":1,\"227\":1}}],[\"编译器来领略即时编译的魅力\",{\"1\":{\"218\":1}}],[\"编译器默认编译生成的文件\",{\"1\":{\"217\":1}}],[\"编译器在做链接时就会将当前的\",{\"1\":{\"207\":1}}],[\"编译器通过泛型定义来生成不同的指令实现\",{\"1\":{\"180\":1}}],[\"编译器帮忙写不同类型的实现代码\",{\"1\":{\"180\":1}}],[\"编译原理\",{\"1\":{\"165\":1}}],[\"编写测试用例\",{\"1\":{\"168\":1}}],[\"编码能力\",{\"1\":{\"165\":1}}],[\"编码部分十分简单\",{\"1\":{\"146\":1}}],[\"编码\",{\"1\":{\"133\":1}}],[\"编辑双方需要通过网络传输编辑操作\",{\"1\":{\"9\":1}}],[\"推进给出了详细注释\",{\"1\":{\"282\":1}}],[\"推进日志应用\",{\"1\":{\"132\":1}}],[\"推荐使用\",{\"1\":{\"281\":1}}],[\"推入数据\",{\"1\":{\"283\":1}}],[\"推入\",{\"1\":{\"279\":1}}],[\"推模式\",{\"1\":{\"160\":1}}],[\"推演\",{\"0\":{\"25\":1}}],[\"答案自然是可以的\",{\"1\":{\"212\":1}}],[\"答案就是快照\",{\"1\":{\"135\":1}}],[\"答案就是\",{\"1\":{\"131\":1}}],[\"答案在\",{\"1\":{\"124\":1,\"203\":1}}],[\"应在任何时候都调用\",{\"1\":{\"285\":1}}],[\"应该是\",{\"1\":{\"283\":1}}],[\"应该等于\",{\"1\":{\"283\":1}}],[\"应该立马将可应用的日志应用到状态机中\",{\"1\":{\"131\":1}}],[\"应用程序通过\",{\"1\":{\"285\":1}}],[\"应用程序是不用手动调用\",{\"1\":{\"238\":1}}],[\"应用程序调用库函数\",{\"1\":{\"197\":1}}],[\"应用程序构建执行计划\",{\"1\":{\"58\":1}}],[\"应用的是快照\",{\"1\":{\"136\":1}}],[\"应用的是日志\",{\"1\":{\"136\":1}}],[\"应用的基础\",{\"1\":{\"22\":1}}],[\"应用快照\",{\"1\":{\"136\":1}}],[\"应用\",{\"1\":{\"18\":1}}],[\"应用成功\",{\"1\":{\"13\":1}}],[\"应用状态\",{\"1\":{\"13\":1}}],[\"似乎一直没有变过\",{\"1\":{\"131\":1}}],[\"节约大量资源\",{\"1\":{\"214\":1}}],[\"节选部分\",{\"1\":{\"213\":1}}],[\"节\",{\"1\":{\"130\":3}}],[\"节点转化为控制流图\",{\"1\":{\"227\":1}}],[\"节点不做处理\",{\"1\":{\"136\":1}}],[\"节点当前日志序号范围是\",{\"1\":{\"136\":1}}],[\"节点当前所在的任期\",{\"1\":{\"123\":1}}],[\"节点创建的时候调用它一次\",{\"1\":{\"133\":1}}],[\"节点本身是没有状态机实现的\",{\"1\":{\"131\":1}}],[\"节点将所有日志以追加的方式保存到了\",{\"1\":{\"128\":1}}],[\"节点将自己的末尾项\",{\"1\":{\"72\":1}}],[\"节点已同步的日志序号\",{\"1\":{\"126\":1}}],[\"节点下一个待同步的日志序号\",{\"1\":{\"126\":1}}],[\"节点日志数据\",{\"1\":{\"126\":1}}],[\"节点使用\",{\"1\":{\"126\":1}}],[\"节点任期发生了变化\",{\"1\":{\"124\":1}}],[\"节点成为协调者后\",{\"1\":{\"124\":1}}],[\"节点成为协调者后会增加任期\",{\"1\":{\"123\":1}}],[\"节点会通过\",{\"1\":{\"124\":1}}],[\"节点会切换为追随者状态\",{\"1\":{\"123\":1}}],[\"节点初始化时为追随者状态\",{\"1\":{\"124\":1}}],[\"节点需要新增一个\",{\"1\":{\"136\":1}}],[\"节点需要通过集群元数据信息与其它节点进行沟通\",{\"1\":{\"124\":1}}],[\"节点需要分裂\",{\"1\":{\"71\":1}}],[\"节点投过票\",{\"1\":{\"123\":1}}],[\"节点元数据\",{\"1\":{\"123\":1}}],[\"节点集群\",{\"1\":{\"123\":1}}],[\"节点状态改变\",{\"1\":{\"133\":1}}],[\"节点状态之间的转换函数\",{\"1\":{\"125\":1}}],[\"节点状态\",{\"0\":{\"123\":1},\"1\":{\"123\":2}}],[\"节点宕机后\",{\"1\":{\"112\":1}}],[\"节点注册到\",{\"1\":{\"105\":1}}],[\"节点组成的集群\",{\"1\":{\"105\":1}}],[\"节点变更\",{\"1\":{\"105\":1}}],[\"节点也需要合并\",{\"1\":{\"72\":1}}],[\"节点指向兄弟节点的指针\",{\"1\":{\"72\":1}}],[\"节点的快照时刻时\",{\"1\":{\"136\":1}}],[\"节点的一个抽象\",{\"1\":{\"123\":1}}],[\"节点的键\",{\"1\":{\"72\":1}}],[\"节点的指针\",{\"1\":{\"71\":1}}],[\"节点中\",{\"1\":{\"282\":1}}],[\"节点中需要持久化的字段保存至磁盘中\",{\"1\":{\"133\":1}}],[\"节点中还有\",{\"1\":{\"131\":1}}],[\"节点中指向\",{\"1\":{\"72\":1}}],[\"节点中的键值对也是有序的\",{\"1\":{\"70\":1}}],[\"节点加起来的大小为\",{\"1\":{\"72\":1}}],[\"节点是无法容忍日志数据无限增加的\",{\"1\":{\"136\":1}}],[\"节点是\",{\"1\":{\"72\":1}}],[\"节点是虚拟节点\",{\"1\":{\"26\":1}}],[\"节点大小为\",{\"1\":{\"72\":1}}],[\"节点大小会变小\",{\"1\":{\"72\":1}}],[\"节点合并后成为节点\",{\"1\":{\"72\":1}}],[\"节点合并\",{\"1\":{\"72\":1,\"282\":1}}],[\"节点分裂后会使父节点的孩子节点个数增加\",{\"1\":{\"71\":1}}],[\"节点分裂可分为如下两种情况\",{\"1\":{\"71\":1}}],[\"节点上的第一个键上移到节点\",{\"1\":{\"71\":1}}],[\"节点之间是有序的\",{\"1\":{\"70\":1}}],[\"节点类型\",{\"1\":{\"69\":1}}],[\"节点\",{\"1\":{\"69\":1,\"71\":12,\"72\":6,\"73\":1,\"123\":1,\"124\":1,\"226\":1}}],[\"冲突任期为\",{\"1\":{\"134\":1}}],[\"冲突则重新同步的方式来与其它节点同步数据\",{\"1\":{\"129\":1}}],[\"冲突解决\",{\"0\":{\"51\":1}}],[\"黄金铁律\",{\"1\":{\"129\":1}}],[\"取走一个元素\",{\"1\":{\"261\":1}}],[\"取\",{\"1\":{\"200\":1}}],[\"取名为\",{\"1\":{\"167\":1}}],[\"取得了那些收益\",{\"1\":{\"162\":1}}],[\"取两者的最小值\",{\"1\":{\"129\":1}}],[\"取整\",{\"1\":{\"68\":1}}],[\"追加日志中尚未存在的任何新条目\",{\"1\":{\"129\":1,\"133\":1}}],[\"追随领导者\",{\"1\":{\"123\":1}}],[\"追随者收到快照请求后\",{\"1\":{\"136\":1}}],[\"追随者直接使用快照就能迅速与其它节点保持数据一致\",{\"1\":{\"136\":1}}],[\"追随者在一定时间内收到日志同步请求或者心跳\",{\"1\":{\"126\":1}}],[\"追随者不可造反\",{\"1\":{\"126\":1}}],[\"追随者同步日志\",{\"1\":{\"126\":1}}],[\"追随者未收到日志同步\",{\"1\":{\"124\":1}}],[\"追随者更新任期后\",{\"1\":{\"123\":1}}],[\"追随者会自动切换为协调者\",{\"1\":{\"123\":1}}],[\"追随者\",{\"1\":{\"123\":1}}],[\"试试\",{\"1\":{\"210\":1}}],[\"试想\",{\"1\":{\"165\":1}}],[\"试想一下\",{\"1\":{\"134\":1,\"234\":1}}],[\"试\",{\"1\":{\"129\":1}}],[\"初始序号\",{\"1\":{\"284\":1}}],[\"初始值为\",{\"1\":{\"129\":1}}],[\"初始值为领导者最后的日志序号+1\",{\"1\":{\"129\":1}}],[\"初始化为\",{\"1\":{\"283\":1}}],[\"初始化为随机数\",{\"1\":{\"283\":1}}],[\"初始化当前\",{\"1\":{\"200\":1}}],[\"初始化栈池\",{\"1\":{\"200\":1}}],[\"初始化调度器\",{\"1\":{\"200\":2}}],[\"初始化\",{\"1\":{\"200\":7,\"283\":1}}],[\"初始化程序参数\",{\"1\":{\"200\":1}}],[\"初始化值为\",{\"1\":{\"129\":2}}],[\"初始化新的根节点\",{\"1\":{\"71\":1}}],[\"初始化根节点\",{\"1\":{\"71\":1}}],[\"号作为占位\",{\"1\":{\"136\":1}}],[\"号日志融合\",{\"1\":{\"136\":1}}],[\"号\",{\"1\":{\"129\":1}}],[\"号元素\",{\"1\":{\"73\":1}}],[\"切换到了一个新的分支用于开发新的特性\",{\"1\":{\"224\":1}}],[\"切换到系统栈\",{\"1\":{\"200\":2}}],[\"切换上下文后\",{\"1\":{\"200\":1}}],[\"切换上下文\",{\"1\":{\"200\":1}}],[\"切片容器中的数据类型\",{\"1\":{\"208\":1}}],[\"切片是\",{\"1\":{\"208\":1}}],[\"切片序号\",{\"1\":{\"136\":1}}],[\"切片序号仍然是\",{\"1\":{\"136\":1}}],[\"切片\",{\"1\":{\"128\":1,\"181\":1}}],[\"切无法加读锁\",{\"1\":{\"89\":1}}],[\"特有\",{\"1\":{\"126\":2}}],[\"霸道的领导者肯定不愿意这种情况发生\",{\"1\":{\"126\":1}}],[\"死信队列\",{\"1\":{\"161\":1}}],[\"死亡\",{\"1\":{\"126\":1}}],[\"死锁预防\",{\"1\":{\"87\":1}}],[\"死锁检测\",{\"1\":{\"87\":1}}],[\"死锁\",{\"0\":{\"87\":1}}],[\"死锁问题\",{\"1\":{\"85\":1}}],[\"尔等仍是太子\",{\"1\":{\"125\":1}}],[\"毕竟国不可一日无主\",{\"1\":{\"125\":1}}],[\"网络协议是一个非常有趣的东西\",{\"1\":{\"287\":1}}],[\"网络通信失败处理\",{\"1\":{\"150\":1}}],[\"网络层和传输层\",{\"1\":{\"270\":1}}],[\"网络层直接由\",{\"1\":{\"157\":1}}],[\"网络层\",{\"1\":{\"150\":1}}],[\"网络故障等问题\",{\"1\":{\"125\":1}}],[\"网络连接管理\",{\"1\":{\"112\":1}}],[\"立即持久化数据\",{\"1\":{\"139\":1}}],[\"立即解锁成功\",{\"1\":{\"89\":1}}],[\"立马关闭输入\",{\"1\":{\"285\":1}}],[\"立马调用\",{\"1\":{\"133\":1}}],[\"立马将\",{\"1\":{\"131\":1}}],[\"立马成为追随者\",{\"1\":{\"129\":1}}],[\"立马成为其追随者\",{\"1\":{\"124\":1}}],[\"立马退出循环\",{\"1\":{\"129\":1}}],[\"行将\",{\"1\":{\"200\":1}}],[\"行为测试对\",{\"1\":{\"164\":1}}],[\"行为验证会阻碍\",{\"1\":{\"164\":1}}],[\"行为验证本身并不能验证功能是否正确\",{\"1\":{\"164\":1}}],[\"行为验证的适用场景\",{\"1\":{\"164\":1}}],[\"行为验证没有状态验证直观和方便\",{\"1\":{\"164\":1}}],[\"行为验证\",{\"1\":{\"164\":1}}],[\"行也发生了改变\",{\"1\":{\"134\":1}}],[\"行\",{\"1\":{\"124\":2,\"129\":10,\"134\":4,\"136\":7,\"165\":1,\"200\":34,\"238\":3,\"254\":1,\"257\":4}}],[\"行左右的代码\",{\"1\":{\"44\":1}}],[\"～\",{\"1\":{\"124\":2,\"129\":4,\"134\":5,\"136\":4,\"165\":1,\"200\":7,\"231\":1,\"257\":2}}],[\"记住\",{\"1\":{\"294\":1}}],[\"记得调用\",{\"1\":{\"285\":1}}],[\"记得更新\",{\"1\":{\"124\":1,\"130\":1,\"133\":1}}],[\"记录发送但未确认的报文\",{\"1\":{\"279\":1}}],[\"记录多个消费者读\",{\"1\":{\"99\":1}}],[\"记录读\",{\"1\":{\"97\":1,\"98\":1}}],[\"记录事务处理期间的操作\",{\"1\":{\"92\":1}}],[\"记录的共享锁\",{\"1\":{\"88\":1}}],[\"记录查询等\",{\"1\":{\"77\":1}}],[\"记录每次写操作\",{\"1\":{\"4\":1}}],[\"成为领导者后\",{\"1\":{\"129\":1}}],[\"成为\",{\"1\":{\"124\":1,\"133\":1}}],[\"成功的事件\",{\"1\":{\"13\":1}}],[\"自然就不再适用了\",{\"1\":{\"263\":1}}],[\"自然就是垃圾对象\",{\"1\":{\"243\":1}}],[\"自然就能提高代码\",{\"1\":{\"238\":1}}],[\"自动内存管理的本质仍是\",{\"1\":{\"243\":1}}],[\"自动内存管理的好处就显现出来了\",{\"1\":{\"238\":1}}],[\"自动内存管理实践\",{\"0\":{\"242\":1}}],[\"自动内存管理两种方式\",{\"1\":{\"236\":1}}],[\"自动内存管理几乎是现代语言的标准\",{\"1\":{\"235\":1}}],[\"自动释放未用的内存\",{\"1\":{\"233\":1}}],[\"自动管理\",{\"0\":{\"235\":1},\"1\":{\"233\":1}}],[\"自动成为协调者\",{\"1\":{\"124\":1}}],[\"自从\",{\"1\":{\"228\":1}}],[\"自举编译器就实现了\",{\"1\":{\"219\":1}}],[\"自举\",{\"0\":{\"219\":1}}],[\"自\",{\"1\":{\"218\":1}}],[\"自定义去重逻辑\",{\"1\":{\"188\":1}}],[\"自定义业务处理失败\",{\"1\":{\"150\":1}}],[\"自测\",{\"1\":{\"162\":1}}],[\"自工作以来\",{\"1\":{\"152\":1}}],[\"自己除外\",{\"1\":{\"129\":1}}],[\"自己的一票\",{\"1\":{\"124\":1}}],[\"永远不会停止\",{\"1\":{\"124\":1}}],[\"除此之外\",{\"1\":{\"238\":1}}],[\"除外\",{\"1\":{\"212\":1}}],[\"除了\",{\"1\":{\"283\":1}}],[\"除了返回值是正常实例化的元素\",{\"1\":{\"261\":1}}],[\"除了通用寄存器外\",{\"1\":{\"250\":1}}],[\"除了这种方式\",{\"1\":{\"237\":1}}],[\"除了经典学派之外\",{\"1\":{\"164\":1}}],[\"除了根\",{\"1\":{\"68\":1}}],[\"除非节点被杀死\",{\"1\":{\"124\":1}}],[\"抛开\",{\"1\":{\"124\":1}}],[\"迫切的想要成为领导者\",{\"1\":{\"124\":1}}],[\"逻辑时钟\",{\"1\":{\"123\":1}}],[\"结果没问题\",{\"1\":{\"294\":1}}],[\"结果输出\",{\"1\":{\"294\":1}}],[\"结果\",{\"1\":{\"282\":1}}],[\"结果如下\",{\"1\":{\"213\":1}}],[\"结合上面的汇编基本介绍\",{\"1\":{\"257\":1}}],[\"结合\",{\"1\":{\"255\":1}}],[\"结束传输后又需要四次挥手来结束连接\",{\"1\":{\"272\":1}}],[\"结束地址\",{\"1\":{\"237\":1}}],[\"结束\",{\"1\":{\"227\":2}}],[\"结构体\",{\"1\":{\"261\":1}}],[\"结构体添加一个灰色栈\",{\"1\":{\"244\":1}}],[\"结构体用于对象分配\",{\"1\":{\"243\":1}}],[\"结构体用来保存节点日志\",{\"1\":{\"128\":1}}],[\"结构体来所示\",{\"1\":{\"207\":1}}],[\"结构体中增加了快照相关的字段\",{\"1\":{\"136\":1}}],[\"结构体是对\",{\"1\":{\"123\":1}}],[\"结语\",{\"0\":{\"19\":1,\"38\":1,\"52\":1,\"228\":1}}],[\"含自己的\",{\"1\":{\"123\":1}}],[\"票是不够\",{\"1\":{\"124\":1}}],[\"票\",{\"1\":{\"123\":2,\"124\":1}}],[\"选择内核版本为\",{\"1\":{\"292\":1}}],[\"选择\",{\"1\":{\"160\":1,\"218\":1,\"291\":1}}],[\"选择实现拉模式\",{\"1\":{\"160\":1}}],[\"选择合适的数据结构就能解决这个问题\",{\"1\":{\"63\":1}}],[\"选型众多\",{\"1\":{\"152\":1}}],[\"选举超时时间\",{\"1\":{\"126\":1}}],[\"选举指的是\",{\"1\":{\"124\":1}}],[\"选举\",{\"0\":{\"124\":1},\"1\":{\"132\":1}}],[\"选举过程是如何产生的\",{\"1\":{\"123\":1}}],[\"选举时会触发的状态\",{\"1\":{\"123\":1}}],[\"选票权\",{\"1\":{\"123\":1}}],[\"奇数\",{\"1\":{\"122\":1}}],[\"土皇帝来了\",{\"1\":{\"129\":1}}],[\"土皇帝\",{\"1\":{\"122\":1,\"124\":1}}],[\"模式\",{\"1\":{\"164\":1}}],[\"模型示意图如下\",{\"1\":{\"199\":1}}],[\"模型是\",{\"1\":{\"199\":1}}],[\"模型\",{\"0\":{\"199\":1},\"1\":{\"122\":1,\"192\":1,\"199\":1}}],[\"模块文件\",{\"1\":{\"257\":1}}],[\"模块是操作系统\",{\"1\":{\"231\":1}}],[\"模块初始化\",{\"1\":{\"200\":1}}],[\"模块\",{\"1\":{\"164\":2}}],[\"模块在转换数据时\",{\"1\":{\"117\":1}}],[\"模块还增加了\",{\"1\":{\"114\":1}}],[\"模块还增加了一个值\",{\"1\":{\"114\":1}}],[\"模块还在单值键值对的\",{\"1\":{\"114\":1}}],[\"模块就负责把\",{\"1\":{\"113\":1}}],[\"模块就需要处理这二者之间的转换\",{\"1\":{\"113\":1}}],[\"模块来查看\",{\"1\":{\"218\":1}}],[\"模块来负责完成\",{\"1\":{\"106\":1}}],[\"模块来实现在\",{\"1\":{\"4\":1}}],[\"模块之间如何协调\",{\"1\":{\"58\":1}}],[\"心跳\",{\"1\":{\"121\":1,\"123\":1,\"126\":1}}],[\"领导者在发现某个节点同步日志序号落后\",{\"1\":{\"136\":1}}],[\"领导者得到快照响应后做如下处理\",{\"1\":{\"136\":1}}],[\"领导者发送\",{\"1\":{\"136\":1}}],[\"领导者发送快照\",{\"1\":{\"136\":1}}],[\"领导者收到同步失败后\",{\"1\":{\"134\":1}}],[\"领导者收到这个响应后\",{\"1\":{\"129\":1}}],[\"领导者独有\",{\"1\":{\"132\":1}}],[\"领导者正是通过不间断的日志同步\",{\"1\":{\"129\":1}}],[\"领导者的\",{\"1\":{\"129\":1}}],[\"领导者的已知已提交的最高的日志条目的索引\",{\"1\":{\"126\":1}}],[\"领导者通过该函数向其它节点发送同步日志\",{\"1\":{\"129\":1}}],[\"领导者通过\",{\"1\":{\"129\":1,\"136\":1}}],[\"领导者并不知道\",{\"1\":{\"129\":1}}],[\"领导者并不知道其它节点的日志情况\",{\"1\":{\"129\":1}}],[\"领导者一直是安全的\",{\"1\":{\"126\":1}}],[\"领导者与追随者之间的日志同步有一种特殊情况\",{\"1\":{\"126\":1}}],[\"领导者与节点上一次同步的日志任期\",{\"1\":{\"126\":1}}],[\"领导者与节点上一次同步的日志序号\",{\"1\":{\"126\":1}}],[\"领导者日志提交序号\",{\"1\":{\"126\":1}}],[\"领导者将自己的日志数据同步到追随者\",{\"1\":{\"126\":1}}],[\"领导者宣示自己的主权\",{\"1\":{\"126\":1}}],[\"领导者向追随者发送日志\",{\"1\":{\"126\":1}}],[\"领导者\",{\"1\":{\"123\":1}}],[\"领导者是绝对的\",{\"1\":{\"122\":1}}],[\"领导者接受后再同步给其它节点\",{\"1\":{\"122\":1}}],[\"领导者选举主要工作可总结如下\",{\"1\":{\"125\":1}}],[\"领导者选举\",{\"0\":{\"122\":1},\"1\":{\"121\":1,\"122\":1}}],[\"领略大师风采\",{\"1\":{\"69\":1}}],[\"博客园\",{\"1\":{\"119\":1}}],[\"博文都数不胜数\",{\"1\":{\"56\":1}}],[\"随报文发送到远端\",{\"1\":{\"284\":1}}],[\"随机生成\",{\"1\":{\"284\":1}}],[\"随后尝试发送报文\",{\"1\":{\"279\":1}}],[\"随后根据删除后的节点大小来决定重组\",{\"1\":{\"72\":1}}],[\"随笔分类\",{\"1\":{\"119\":1}}],[\"😂\",{\"1\":{\"118\":1}}],[\"排序\",{\"1\":{\"117\":1}}],[\"排除掉删除字符\",{\"1\":{\"26\":1}}],[\"元组对象入栈\",{\"1\":{\"243\":1}}],[\"元组对象\",{\"1\":{\"243\":1}}],[\"元素的\",{\"1\":{\"117\":1}}],[\"元数据必须保证强一致性\",{\"1\":{\"155\":1}}],[\"元数据管理集群\",{\"1\":{\"103\":1}}],[\"元数据文件\",{\"1\":{\"98\":1}}],[\"元数据重置\",{\"1\":{\"64\":1}}],[\"元数据\",{\"0\":{\"155\":1},\"1\":{\"64\":1,\"97\":3,\"98\":3,\"99\":3}}],[\"元数据页\",{\"1\":{\"59\":1}}],[\"另一个重要的工作在于计时\",{\"1\":{\"285\":1}}],[\"另一个是绝对\",{\"1\":{\"283\":1}}],[\"另一个是输入流\",{\"1\":{\"275\":1}}],[\"另一类是\",{\"1\":{\"113\":1}}],[\"另外在\",{\"1\":{\"283\":1}}],[\"另外还有一些连接使用的是\",{\"1\":{\"263\":1}}],[\"另外还提供了\",{\"1\":{\"263\":1}}],[\"另外由于\",{\"1\":{\"243\":1}}],[\"另外无论是\",{\"1\":{\"237\":1}}],[\"另外几个黑魔法技巧\",{\"0\":{\"216\":1}}],[\"另外提一点\",{\"1\":{\"199\":1}}],[\"另外解码部分也十分简单\",{\"1\":{\"146\":1}}],[\"另外追随者在受到日志同步请求时\",{\"1\":{\"137\":1}}],[\"另外代理节点启动时\",{\"1\":{\"112\":1}}],[\"另外如果\",{\"1\":{\"64\":1}}],[\"另外\",{\"1\":{\"28\":1,\"48\":1,\"125\":1,\"134\":1,\"136\":2,\"164\":1,\"206\":1,\"218\":2,\"223\":1,\"237\":1,\"241\":1,\"261\":1}}],[\"另外一旦收到\",{\"1\":{\"284\":1}}],[\"另外一个需要注意的点是何时关闭输入流\",{\"1\":{\"282\":1}}],[\"另外一个重要的基础类型\",{\"1\":{\"15\":1}}],[\"另外一段数值不会发生变化\",{\"1\":{\"9\":1}}],[\"另外一端在及时收到操作后都能迅速达到双方一致的状态\",{\"1\":{\"9\":1}}],[\"转换为\",{\"1\":{\"227\":1}}],[\"转换阶段\",{\"1\":{\"226\":1}}],[\"转换方案并不是自己独有的\",{\"1\":{\"117\":1}}],[\"转发\",{\"1\":{\"156\":1}}],[\"转发时会根据信息转发到正确的缓存节点上\",{\"1\":{\"113\":1}}],[\"转变成为协调者\",{\"1\":{\"124\":1}}],[\"转化为代码如下\",{\"1\":{\"124\":1}}],[\"转化为叶子结点\",{\"1\":{\"70\":1}}],[\"转化为\",{\"1\":{\"69\":1,\"227\":1}}],[\"命令查看容器的\",{\"1\":{\"294\":1}}],[\"命令查看程序当前运行点\",{\"1\":{\"200\":1}}],[\"命令会重新生成node\",{\"1\":{\"227\":1}}],[\"命令会重新生成op\",{\"1\":{\"227\":1}}],[\"命令自动生成该关键字的解析程序\",{\"1\":{\"225\":1}}],[\"命令\",{\"1\":{\"128\":1,\"200\":1}}],[\"命令转化为\",{\"1\":{\"113\":1}}],[\"命令监控\",{\"1\":{\"112\":1}}],[\"注册数据\",{\"1\":{\"155\":1}}],[\"注册信息\",{\"1\":{\"155\":2,\"159\":1}}],[\"注册信息自动失效\",{\"1\":{\"112\":1}}],[\"注册中心选用\",{\"1\":{\"153\":1}}],[\"注册层\",{\"0\":{\"148\":1},\"1\":{\"143\":1}}],[\"注意定时器在包进入\",{\"1\":{\"284\":1}}],[\"注意不是所有过期的包\",{\"1\":{\"284\":1}}],[\"注意不是operation\",{\"1\":{\"34\":1}}],[\"注意报文大小是有限制的\",{\"1\":{\"284\":1}}],[\"注意是尝试\",{\"1\":{\"285\":1}}],[\"注意是\",{\"1\":{\"283\":1}}],[\"注意是字节流的序号\",{\"1\":{\"282\":1}}],[\"注意所有数据都被合并到了\",{\"1\":{\"282\":1}}],[\"注意写入数据的大小和当前缓冲区的大小加起来不能超过容量大小\",{\"1\":{\"281\":1}}],[\"注意这里的\",{\"1\":{\"261\":1}}],[\"注意在\",{\"1\":{\"257\":1}}],[\"注意在系统栈调用\",{\"1\":{\"200\":1}}],[\"注意函数名前面的中点\",{\"1\":{\"257\":1}}],[\"注意偏移和长度即可\",{\"1\":{\"257\":1}}],[\"注意一个点\",{\"1\":{\"208\":1}}],[\"注意\",{\"1\":{\"13\":1,\"47\":1,\"56\":1,\"64\":1,\"73\":1,\"77\":1,\"128\":1,\"136\":3,\"198\":2,\"199\":1,\"200\":1,\"203\":2,\"207\":1,\"212\":1,\"238\":1,\"244\":1,\"281\":1,\"283\":1,\"284\":3,\"285\":1}}],[\"供客户端使用\",{\"1\":{\"112\":1}}],[\"密集\",{\"1\":{\"112\":1}}],[\"生命周期灵活\",{\"1\":{\"232\":1}}],[\"生产消息\",{\"1\":{\"159\":1}}],[\"生产者\",{\"0\":{\"159\":1}}],[\"生产\",{\"1\":{\"157\":1}}],[\"生态\",{\"1\":{\"110\":1}}],[\"生成如下控制流图\",{\"1\":{\"227\":1}}],[\"生成机器码\",{\"1\":{\"226\":1}}],[\"生成程序可读的语法树\",{\"1\":{\"226\":1}}],[\"生成的机器码是不同的\",{\"1\":{\"218\":1}}],[\"生成目标文件\",{\"1\":{\"217\":1}}],[\"生成\",{\"1\":{\"217\":1,\"226\":1,\"291\":1}}],[\"生成符号文件\",{\"1\":{\"217\":1}}],[\"生成到运行的全过程\",{\"1\":{\"217\":1}}],[\"生成可执行文件\",{\"1\":{\"217\":1}}],[\"生成后\",{\"1\":{\"212\":1}}],[\"生成新的\",{\"1\":{\"32\":1,\"35\":1}}],[\"生成一个新的operation\",{\"1\":{\"31\":1,\"36\":1}}],[\"生成一个新的事务标识符\",{\"1\":{\"4\":1}}],[\"兼容\",{\"1\":{\"110\":1,\"111\":1,\"146\":1}}],[\"指针地址\",{\"1\":{\"257\":1}}],[\"指针是为了将所有对象连接起来\",{\"1\":{\"243\":1}}],[\"指针是为了跟踪所有的对象\",{\"1\":{\"243\":1}}],[\"指针会将所有对象连接成一个大链表\",{\"1\":{\"243\":1}}],[\"指针偏移\",{\"1\":{\"240\":1}}],[\"指针指向下一块\",{\"1\":{\"240\":1}}],[\"指针指向下一个可分配的块\",{\"1\":{\"240\":1}}],[\"指针向上移动\",{\"1\":{\"237\":1}}],[\"指针\",{\"1\":{\"237\":1,\"243\":1}}],[\"指针减少\",{\"1\":{\"237\":1}}],[\"指针增加\",{\"1\":{\"237\":1}}],[\"指针上移则开辟内存\",{\"1\":{\"232\":1}}],[\"指针管理\",{\"1\":{\"232\":1}}],[\"指令比较\",{\"1\":{\"254\":1}}],[\"指令不同的后缀表示操作数据大小\",{\"1\":{\"253\":1}}],[\"指令后缀决定\",{\"1\":{\"252\":1}}],[\"指令的操作数会不一样\",{\"1\":{\"218\":1}}],[\"指令对应的机器码实际上就是唯一的\",{\"1\":{\"218\":1}}],[\"指令为例\",{\"1\":{\"218\":1}}],[\"指令严格限制在两个操作数中\",{\"1\":{\"218\":1}}],[\"指令一般都是一个操作命令\",{\"1\":{\"218\":1}}],[\"指令称为ssa\",{\"1\":{\"218\":1}}],[\"指令附带一个参数\",{\"1\":{\"218\":1}}],[\"指令上\",{\"1\":{\"207\":1}}],[\"指令来调用\",{\"1\":{\"256\":1}}],[\"指令来定义函数\",{\"1\":{\"256\":1,\"257\":1}}],[\"指令来实现数据移动\",{\"1\":{\"252\":1}}],[\"指令来实现加法\",{\"1\":{\"180\":2}}],[\"指令来将两个参数入栈\",{\"1\":{\"251\":1}}],[\"指令来操作当前调用栈\",{\"1\":{\"251\":1}}],[\"指令来\",{\"1\":{\"206\":1}}],[\"指令来交换上下文数据\",{\"1\":{\"200\":1}}],[\"指令将栈顶的两个值出栈\",{\"1\":{\"218\":1}}],[\"指令将\",{\"1\":{\"200\":1}}],[\"指令要求\",{\"1\":{\"200\":1}}],[\"指令\",{\"1\":{\"200\":1,\"257\":1}}],[\"指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务\",{\"1\":{\"196\":1}}],[\"指的是能提供快速反馈的低成本的研发测试\",{\"1\":{\"164\":1}}],[\"指定链接生成可执行文件时\",{\"1\":{\"217\":1}}],[\"指定\",{\"1\":{\"110\":1}}],[\"指向下一个对象的指针\",{\"1\":{\"243\":1}}],[\"指向真实的字节数据\",{\"1\":{\"207\":1}}],[\"指向线程的局部存储变量地址\",{\"1\":{\"198\":1}}],[\"指向其父进程\",{\"1\":{\"194\":1}}],[\"指向进程内存结构\",{\"1\":{\"194\":1,\"237\":1}}],[\"指向孩子节点的指针则是值\",{\"1\":{\"68\":1}}],[\"指向父节点abstracttype\",{\"1\":{\"50\":1}}],[\"接收包\",{\"1\":{\"285\":2}}],[\"接收报文\",{\"1\":{\"285\":1}}],[\"接收者\",{\"1\":{\"285\":1}}],[\"接收到\",{\"1\":{\"282\":1}}],[\"接收\",{\"1\":{\"282\":1,\"286\":1}}],[\"接收确认号\",{\"1\":{\"279\":1}}],[\"接收分别由\",{\"1\":{\"279\":1}}],[\"接收领导者日志\",{\"1\":{\"123\":1}}],[\"接着将节点拆分为更加简单的节点\",{\"1\":{\"227\":1}}],[\"接着是一大堆代码\",{\"1\":{\"200\":1}}],[\"接下来\",{\"1\":{\"257\":1,\"286\":1}}],[\"接下来就是实现第一个小需求\",{\"1\":{\"172\":1}}],[\"接下来是插入操作\",{\"1\":{\"26\":1}}],[\"接入spring\",{\"1\":{\"151\":1}}],[\"接入层\",{\"1\":{\"143\":1}}],[\"接口服务中\",{\"1\":{\"260\":1}}],[\"接口定义的情况下开始\",{\"1\":{\"164\":1}}],[\"接口用于调用参数序列化抽象\",{\"1\":{\"147\":1}}],[\"接口\",{\"1\":{\"144\":1,\"145\":1,\"158\":1,\"181\":1}}],[\"接受确认序号\",{\"1\":{\"284\":1}}],[\"接受一个\",{\"1\":{\"189\":1}}],[\"接受两个参数\",{\"1\":{\"181\":1}}],[\"接受\",{\"1\":{\"136\":1,\"240\":1}}],[\"接受快照数据\",{\"1\":{\"136\":1}}],[\"接到请求后\",{\"1\":{\"106\":1}}],[\"哈希后选择的提供者也不会变\",{\"1\":{\"145\":1}}],[\"哈希槽位等信息注册到\",{\"1\":{\"113\":1}}],[\"哈希算法来分区\",{\"1\":{\"106\":1}}],[\"哈希表\",{\"1\":{\"63\":1}}],[\"哈希表等场景\",{\"1\":{\"23\":1}}],[\"哈希表存储\",{\"1\":{\"11\":1}}],[\"共\",{\"1\":{\"238\":1}}],[\"共有\",{\"1\":{\"106\":1}}],[\"共享锁\",{\"1\":{\"86\":1}}],[\"种三种颜色\",{\"1\":{\"244\":1}}],[\"种类型的加法\",{\"1\":{\"179\":1}}],[\"种状态\",{\"1\":{\"123\":1}}],[\"种基本类型的数据结构\",{\"1\":{\"110\":1}}],[\"种基本类型数据结构\",{\"1\":{\"103\":1}}],[\"种数据结构与基础\",{\"1\":{\"106\":1}}],[\"调度等重要模块\",{\"1\":{\"217\":1}}],[\"调度等重要组件\",{\"1\":{\"217\":1}}],[\"调度只在\",{\"1\":{\"200\":1}}],[\"调度中十分重要的一个机制\",{\"1\":{\"200\":1}}],[\"调度\",{\"1\":{\"200\":1,\"217\":1}}],[\"调度器\",{\"1\":{\"103\":1,\"204\":1}}],[\"调整\",{\"1\":{\"200\":3}}],[\"调试配置如下\",{\"1\":{\"291\":1}}],[\"调试工具来一步步的解析\",{\"1\":{\"200\":1}}],[\"调试困难\",{\"1\":{\"147\":1}}],[\"调用该方法\",{\"1\":{\"261\":1}}],[\"调用了\",{\"1\":{\"238\":1}}],[\"调用失败则返回\",{\"1\":{\"237\":1}}],[\"调用成功后返回分配地址的内存\",{\"1\":{\"237\":1}}],[\"调用当前函数不在当前\",{\"1\":{\"200\":1}}],[\"调用的样例如下\",{\"1\":{\"198\":1}}],[\"调用对应的内核函数\",{\"1\":{\"197\":1}}],[\"调用性能高\",{\"1\":{\"144\":1}}],[\"调用性能较差\",{\"1\":{\"144\":1}}],[\"调用流程如下图所示\",{\"1\":{\"142\":1}}],[\"调用本地方法\",{\"1\":{\"142\":1}}],[\"调用发快照过去\",{\"1\":{\"136\":1}}],[\"调用\",{\"0\":{\"206\":1,\"209\":1},\"1\":{\"18\":1,\"79\":1,\"89\":1,\"123\":1,\"129\":1,\"160\":1,\"197\":1,\"200\":4,\"213\":1,\"217\":1,\"234\":1,\"239\":1,\"240\":2,\"241\":1,\"243\":1,\"244\":1,\"279\":1,\"286\":1}}],[\"调用merge方法合并到本地\",{\"1\":{\"14\":1}}],[\"调用flush\",{\"1\":{\"13\":1}}],[\"调用flush方法\",{\"1\":{\"13\":1}}],[\"调用apply方法依次应用op\",{\"1\":{\"13\":1}}],[\"调用get方法\",{\"1\":{\"13\":1,\"14\":1}}],[\"集合元素的\",{\"1\":{\"116\":2}}],[\"集合元素是\",{\"1\":{\"113\":2}}],[\"集合类似\",{\"1\":{\"115\":1}}],[\"集合\",{\"0\":{\"115\":1,\"116\":1},\"1\":{\"114\":1,\"117\":1}}],[\"集合中的元素是有序的\",{\"1\":{\"114\":1}}],[\"集合的元素值\",{\"1\":{\"114\":1}}],[\"集合的\",{\"1\":{\"114\":1,\"115\":1,\"116\":1}}],[\"集群的稳定性至关重要\",{\"1\":{\"155\":1}}],[\"集群可能需要很久才都达到一致\",{\"1\":{\"134\":1}}],[\"集群一旦失去了领导者\",{\"1\":{\"125\":1}}],[\"集群节点初始化时\",{\"1\":{\"124\":1}}],[\"集群信息\",{\"1\":{\"123\":1}}],[\"集群土皇帝\",{\"1\":{\"123\":1}}],[\"集群中的节点通过日志来保存数据\",{\"1\":{\"127\":1}}],[\"集群中的某一个节点\",{\"1\":{\"124\":1}}],[\"集群中\",{\"1\":{\"123\":1}}],[\"集群动态收缩\",{\"1\":{\"111\":1}}],[\"集群后返回结果\",{\"1\":{\"106\":1}}],[\"集群部署\",{\"1\":{\"105\":1}}],[\"集群\",{\"1\":{\"103\":1,\"104\":1,\"111\":1,\"123\":1,\"126\":1}}],[\"集成\",{\"1\":{\"102\":1}}],[\"服务即可\",{\"1\":{\"157\":1}}],[\"服务过载保护机制\",{\"1\":{\"150\":1}}],[\"服务端在收到对端关闭后\",{\"1\":{\"286\":1}}],[\"服务端发送\",{\"1\":{\"286\":2}}],[\"服务端\",{\"1\":{\"149\":1,\"286\":1}}],[\"服务端接收到client发送的数据之后进行消息解包\",{\"1\":{\"142\":1}}],[\"服务提供者新增限流\",{\"1\":{\"150\":1}}],[\"服务提供者\",{\"1\":{\"148\":1}}],[\"服务提供者向注册中心注册服务\",{\"1\":{\"148\":1}}],[\"服务注册遵循目录规范\",{\"1\":{\"148\":1}}],[\"服务消费者\",{\"1\":{\"148\":1}}],[\"服务消费者从注册中心订阅服务\",{\"1\":{\"148\":1}}],[\"服务消费者通过注册中心感知服务提供者的地址信息\",{\"1\":{\"148\":1}}],[\"服务灰度策略等\",{\"1\":{\"145\":1}}],[\"服务轮训选择\",{\"1\":{\"145\":1}}],[\"服务权重选择\",{\"1\":{\"145\":1}}],[\"服务负载均衡\",{\"1\":{\"145\":1}}],[\"服务选择是路由层的核心功能\",{\"1\":{\"145\":1}}],[\"服务地址进行打包\",{\"1\":{\"142\":1}}],[\"服务名称\",{\"1\":{\"142\":1}}],[\"服务器收到\",{\"1\":{\"272\":1,\"286\":1}}],[\"服务器\",{\"1\":{\"142\":1}}],[\"服务宕机需要手动切换地址\",{\"1\":{\"104\":1}}],[\"服务\",{\"1\":{\"103\":1}}],[\"服务代理集群\",{\"1\":{\"103\":1}}],[\"服务发现组件的地址就能自动连接到\",{\"1\":{\"111\":1}}],[\"服务发现访问\",{\"1\":{\"104\":1}}],[\"服务发现\",{\"1\":{\"103\":1}}],[\"级别\",{\"1\":{\"102\":1}}],[\"级别越高\",{\"1\":{\"84\":1}}],[\"架构着重参考了\",{\"1\":{\"153\":1}}],[\"架构设计\",{\"0\":{\"101\":1,\"153\":1}}],[\"架构图\",{\"1\":{\"58\":1}}],[\"策略\",{\"1\":{\"98\":1}}],[\"频率可配置\",{\"1\":{\"98\":1}}],[\"队列\",{\"1\":{\"285\":1}}],[\"队列将会由上层的\",{\"1\":{\"284\":1}}],[\"队列中\",{\"1\":{\"262\":1}}],[\"队列消息存储又是一个大麻烦\",{\"1\":{\"158\":1}}],[\"队列类\",{\"1\":{\"157\":1}}],[\"队列名称\",{\"1\":{\"98\":1}}],[\"队列大小\",{\"1\":{\"97\":1,\"98\":2,\"99\":1}}],[\"单元模块推进下\",{\"1\":{\"164\":1}}],[\"单元\",{\"1\":{\"164\":1}}],[\"单元粒度要以独立的功能上下文或变化点为粒度\",{\"1\":{\"164\":1}}],[\"单元测试\",{\"1\":{\"164\":1}}],[\"单测通过\",{\"1\":{\"164\":1}}],[\"单测不通过\",{\"1\":{\"164\":1}}],[\"单调递增\",{\"1\":{\"129\":1}}],[\"单值键值对中的值只保存了数据的版本信息和剩余存活时间\",{\"1\":{\"117\":1}}],[\"单值键值对的值只保存了数据的版本信息和剩余存活时间\",{\"1\":{\"115\":1}}],[\"单值键值对的\",{\"1\":{\"115\":1}}],[\"单值键值对的键当中\",{\"1\":{\"115\":1}}],[\"单值寄存器是\",{\"1\":{\"15\":1}}],[\"单值寄存器\",{\"1\":{\"11\":1}}],[\"单点故障后\",{\"1\":{\"104\":1}}],[\"单文件持久化队列\",{\"0\":{\"97\":1}}],[\"做性能优化的时\",{\"1\":{\"260\":1}}],[\"做事如何实施这个闭环\",{\"1\":{\"162\":1}}],[\"做事闭环\",{\"0\":{\"162\":1}}],[\"做起\",{\"1\":{\"96\":1}}],[\"做了很多事情\",{\"1\":{\"273\":1}}],[\"做了\",{\"1\":{\"13\":1}}],[\"电源断开等情况又该如何恢复呢\",{\"1\":{\"94\":1}}],[\"碰到数据库崩溃\",{\"1\":{\"94\":1}}],[\"~logrecovery\",{\"1\":{\"94\":1}}],[\"~logmanager\",{\"1\":{\"93\":1}}],[\"~abstractexecutor\",{\"1\":{\"79\":1}}],[\"~abstractplannode\",{\"1\":{\"79\":1}}],[\"撤消期间记录更改\",{\"1\":{\"92\":1}}],[\"预写日志\",{\"1\":{\"92\":1}}],[\"预防\",{\"1\":{\"85\":1}}],[\"恢复\",{\"0\":{\"94\":1}}],[\"恢复算法主要思路\",{\"1\":{\"92\":1}}],[\"恢复算法主要工作包括如下两部分\",{\"1\":{\"92\":1}}],[\"恢复算法是确保数据库一致性\",{\"1\":{\"92\":1}}],[\"恢复机制是数据库必不可少的一部分\",{\"1\":{\"92\":1}}],[\"软件错误等\",{\"1\":{\"92\":1}}],[\"宕机自动切换\",{\"1\":{\"111\":1}}],[\"宕机\",{\"1\":{\"92\":1,\"148\":1}}],[\"未\",{\"1\":{\"284\":1}}],[\"未收到的序列\",{\"1\":{\"283\":1}}],[\"未重组\",{\"1\":{\"282\":1}}],[\"未组装字节个数\",{\"1\":{\"282\":1}}],[\"未标记的对象自然是白色\",{\"1\":{\"244\":1}}],[\"未标记的对象都是不可达的\",{\"1\":{\"235\":1}}],[\"未被标记的\",{\"1\":{\"244\":1}}],[\"未来演进\",{\"1\":{\"162\":1}}],[\"未实现\",{\"1\":{\"149\":1}}],[\"未应用\",{\"1\":{\"127\":1}}],[\"未加任何锁\",{\"1\":{\"89\":2}}],[\"未找到\",{\"1\":{\"64\":2}}],[\"清理掉不可达的白色对象\",{\"1\":{\"244\":1}}],[\"清理放在一起\",{\"1\":{\"243\":1}}],[\"清理\",{\"1\":{\"235\":1,\"243\":1}}],[\"清除\",{\"1\":{\"88\":1,\"247\":1}}],[\"清空事务中插入或更新的键值对\",{\"1\":{\"4\":1}}],[\"清空该事务中插入或更新的键值对\",{\"1\":{\"4\":1}}],[\"检查后\",{\"1\":{\"227\":1}}],[\"检查定时器\",{\"1\":{\"200\":2}}],[\"检查\",{\"1\":{\"137\":1,\"226\":1,\"227\":1}}],[\"检查是否存在死锁\",{\"1\":{\"88\":1}}],[\"检查clock是否连续\",{\"1\":{\"47\":1}}],[\"授予锁\",{\"1\":{\"88\":1}}],[\"状态转换等工作\",{\"1\":{\"272\":1}}],[\"状态等\",{\"1\":{\"200\":1}}],[\"状态和任务函数等信息\",{\"1\":{\"199\":1}}],[\"状态数据难以得到\",{\"1\":{\"164\":1}}],[\"状态验证就会先得很别扭\",{\"1\":{\"164\":1}}],[\"状态验证\",{\"1\":{\"164\":1}}],[\"状态切换的核心在于任期与心跳\",{\"1\":{\"139\":1}}],[\"状态的改变\",{\"1\":{\"133\":1}}],[\"状态机等信息数据\",{\"1\":{\"279\":1}}],[\"状态机在上层应用中\",{\"1\":{\"136\":1}}],[\"状态机数据\",{\"1\":{\"136\":1}}],[\"状态机应该由\",{\"1\":{\"131\":1}}],[\"状态机保证了不同节点在被应用了相同日志后\",{\"1\":{\"128\":1}}],[\"状态机\",{\"0\":{\"128\":1},\"1\":{\"285\":1}}],[\"状态为追随者\",{\"1\":{\"123\":1}}],[\"状态下\",{\"1\":{\"88\":1,\"286\":1}}],[\"状态\",{\"1\":{\"88\":1,\"200\":1,\"285\":3}}],[\"长连接\",{\"1\":{\"260\":1}}],[\"长期看还有那些问题需要解决\",{\"1\":{\"162\":1}}],[\"长度\",{\"1\":{\"97\":1,\"98\":1,\"99\":1,\"146\":1,\"257\":1,\"284\":2}}],[\"长度为\",{\"1\":{\"69\":1}}],[\"长事务先淘汰\",{\"1\":{\"87\":1}}],[\"正是因为这些优点\",{\"1\":{\"270\":1}}],[\"正是通过\",{\"1\":{\"198\":1}}],[\"正是这样的一个协议\",{\"1\":{\"73\":1}}],[\"正是这样一本书\",{\"1\":{\"56\":1}}],[\"正在运行的线程\",{\"1\":{\"198\":1}}],[\"正在等待\",{\"1\":{\"87\":1}}],[\"跟踪灰色栈中的对象\",{\"1\":{\"244\":1}}],[\"跟踪灰色对象\",{\"1\":{\"244\":1}}],[\"跟踪栈中的灰色对象\",{\"1\":{\"244\":1}}],[\"跟踪到这次代码跳转\",{\"1\":{\"200\":1}}],[\"跟踪哪些事务持有哪些锁以及哪些事务正在等待获取其它锁\",{\"1\":{\"86\":1}}],[\"跟着\",{\"0\":{\"2\":1}}],[\"决定事务是否可以动态地访问数据库中的对象\",{\"1\":{\"85\":1}}],[\"两条语句合并\",{\"1\":{\"225\":1}}],[\"两次出栈\",{\"1\":{\"200\":1,\"251\":1}}],[\"两个部分\",{\"1\":{\"279\":1}}],[\"两个对象之间就存在引用关系\",{\"1\":{\"243\":1}}],[\"两个函数\",{\"1\":{\"243\":1}}],[\"两个函数内部的都是通过调用\",{\"1\":{\"237\":1}}],[\"两个函数就\",{\"1\":{\"181\":1}}],[\"两个关键字的\",{\"1\":{\"227\":1}}],[\"两个快照应用函数\",{\"1\":{\"138\":1}}],[\"两个参数从栈中拷贝到\",{\"1\":{\"200\":1}}],[\"两个参数\",{\"1\":{\"136\":1}}],[\"两个字段\",{\"1\":{\"136\":1}}],[\"两个阶段\",{\"1\":{\"85\":1}}],[\"两阶段锁定协议\",{\"1\":{\"85\":1}}],[\"两种实现进行一下简单对比\",{\"1\":{\"14\":1}}],[\"又可以接受数据\",{\"1\":{\"275\":1}}],[\"又没有空闲元素可以返回\",{\"1\":{\"261\":1}}],[\"又被调用了\",{\"1\":{\"240\":1}}],[\"又被定义在进程\",{\"1\":{\"237\":1}}],[\"又需要手动调用\",{\"1\":{\"234\":1}}],[\"又恰逢\",{\"1\":{\"177\":1}}],[\"又在等待\",{\"1\":{\"87\":1}}],[\"又该如何实现事务了\",{\"1\":{\"85\":1}}],[\"又给它取了一个新名字\",{\"1\":{\"64\":1}}],[\"默认就对每个容器的\",{\"1\":{\"294\":1}}],[\"默认为\",{\"1\":{\"282\":1,\"283\":1,\"284\":1,\"285\":1}}],[\"默认编译器独有的\",{\"1\":{\"219\":1}}],[\"默认生成的汇编是\",{\"1\":{\"212\":1}}],[\"默认由\",{\"1\":{\"158\":1}}],[\"默认实现了\",{\"1\":{\"155\":1}}],[\"默认我们使用\",{\"1\":{\"147\":1}}],[\"默认隔离级别是\",{\"1\":{\"84\":1}}],[\"默认的隔离级别是\",{\"1\":{\"84\":1}}],[\"☑️\",{\"1\":{\"84\":6}}],[\"✖️\",{\"1\":{\"84\":6}}],[\"串行化\",{\"1\":{\"84\":2}}],[\"总而言之\",{\"1\":{\"262\":1}}],[\"总结一下\",{\"1\":{\"194\":1,\"260\":1}}],[\"总结\",{\"0\":{\"139\":1,\"190\":1,\"214\":1,\"220\":1,\"246\":1,\"265\":1,\"287\":1}}],[\"总是跟这个事务在启动时看到的数据是一致的\",{\"1\":{\"84\":1}}],[\"总览\",{\"0\":{\"55\":1,\"57\":1}}],[\"彼此的隔离状态\",{\"1\":{\"84\":1}}],[\"彼此之间需要进行通信\",{\"1\":{\"10\":1}}],[\"隔离级别越高\",{\"1\":{\"84\":1}}],[\"隔离级别用于控制多个事务并发访问时\",{\"1\":{\"84\":1}}],[\"隔离度也越好\",{\"1\":{\"84\":1}}],[\"隔离性\",{\"1\":{\"83\":1}}],[\"条字节码指令\",{\"1\":{\"218\":1}}],[\"条黄金铁律\",{\"1\":{\"139\":1}}],[\"条件不满足\",{\"1\":{\"227\":1}}],[\"条件处理\",{\"1\":{\"227\":1}}],[\"条件\",{\"1\":{\"130\":1,\"227\":1}}],[\"条\",{\"1\":{\"84\":2}}],[\"条规则\",{\"1\":{\"43\":1,\"44\":2,\"47\":1,\"51\":1}}],[\"幻读中的任何一个\",{\"1\":{\"84\":1}}],[\"幻读发生在其他事务\",{\"1\":{\"84\":1}}],[\"幻读\",{\"1\":{\"84\":2}}],[\"幻灯片页\",{\"0\":{\"1\":1}}],[\"脏读问题\",{\"1\":{\"85\":1}}],[\"脏读\",{\"1\":{\"84\":2}}],[\"脏页记得写回磁盘\",{\"1\":{\"64\":1}}],[\"脏页\",{\"1\":{\"62\":1}}],[\"原因其实在\",{\"1\":{\"294\":1}}],[\"原因在于\",{\"1\":{\"212\":1,\"238\":1}}],[\"原因在于其它事务插入了数据\",{\"1\":{\"84\":1}}],[\"原文\",{\"1\":{\"163\":1}}],[\"原型\",{\"1\":{\"157\":1,\"161\":1}}],[\"原生客户端\",{\"0\":{\"110\":1}}],[\"原生客户端兼容已有\",{\"1\":{\"104\":1}}],[\"原生\",{\"1\":{\"104\":1}}],[\"原子性和持久性的关键技术\",{\"1\":{\"92\":1}}],[\"原子性\",{\"1\":{\"83\":1}}],[\"原理则是利用\",{\"1\":{\"200\":1}}],[\"原理也很简单\",{\"1\":{\"63\":1}}],[\"原理和实现的\",{\"1\":{\"56\":1}}],[\"原理后\",{\"1\":{\"45\":1}}],[\"习惯上被称之为\",{\"1\":{\"83\":1}}],[\"谈关系数据库的设计与实现\",{\"0\":{\"81\":1}}],[\"谈谈用户态\",{\"0\":{\"269\":1}}],[\"谈谈\",{\"0\":{\"120\":1}}],[\"谈谈关系数据库的设计与实现\",{\"0\":{\"55\":1,\"61\":1,\"66\":1,\"76\":1,\"91\":1}}],[\"谈谈在线表格协同方案\",{\"0\":{\"54\":1}}],[\"得益于\",{\"1\":{\"79\":1}}],[\"得到绝对序号\",{\"1\":{\"284\":1}}],[\"得到正确的字节流序列\",{\"1\":{\"283\":1}}],[\"得到前一个节点\",{\"1\":{\"282\":1}}],[\"得到的内存地址可能不同\",{\"1\":{\"237\":1}}],[\"得到如下结果\",{\"1\":{\"218\":1}}],[\"得到机器码后\",{\"1\":{\"218\":1}}],[\"得到数据项总数\",{\"1\":{\"185\":1}}],[\"得到数据处理后的结果\",{\"1\":{\"182\":1}}],[\"得到每个元素后调用\",{\"1\":{\"181\":1}}],[\"得到事务上的所有\",{\"1\":{\"88\":1}}],[\"得到死锁的\",{\"1\":{\"88\":1}}],[\"得到当前包序号\",{\"1\":{\"283\":1}}],[\"得到当前数据节点\",{\"1\":{\"282\":1}}],[\"得到当前\",{\"1\":{\"79\":1,\"89\":1}}],[\"得到父节点\",{\"1\":{\"72\":1}}],[\"得到叶子结点\",{\"1\":{\"71\":1}}],[\"得到空闲页\",{\"1\":{\"64\":1}}],[\"得到\",{\"1\":{\"13\":1,\"71\":1,\"88\":1,\"218\":1,\"219\":1,\"283\":1}}],[\"巧妙将其解耦\",{\"1\":{\"79\":1}}],[\"循环调度的关键\",{\"1\":{\"200\":1}}],[\"循环\",{\"1\":{\"79\":1}}],[\"迭代器++\",{\"1\":{\"79\":1}}],[\"迭代器模型\",{\"1\":{\"78\":1}}],[\"赋值\",{\"1\":{\"79\":1,\"89\":1}}],[\"到\",{\"1\":{\"254\":1,\"282\":1}}],[\"到这里\",{\"1\":{\"226\":1}}],[\"到本地\",{\"1\":{\"212\":1}}],[\"到新的切片返回即可\",{\"1\":{\"181\":1}}],[\"到此一个简易版\",{\"1\":{\"286\":1}}],[\"到此一个新的\",{\"1\":{\"225\":1}}],[\"到此\",{\"1\":{\"132\":1}}],[\"到末尾了\",{\"1\":{\"79\":1,\"89\":1}}],[\"到文档树中\",{\"1\":{\"26\":1}}],[\"断言\",{\"1\":{\"79\":1}}],[\"谓词不为空\",{\"1\":{\"89\":1}}],[\"谓词\",{\"1\":{\"79\":1}}],[\"计时\",{\"1\":{\"285\":1}}],[\"计时器\",{\"1\":{\"284\":1}}],[\"计数\",{\"1\":{\"284\":1}}],[\"计数器\",{\"1\":{\"11\":1}}],[\"计算而来\",{\"1\":{\"283\":1}}],[\"计算出对应的\",{\"1\":{\"241\":1}}],[\"计算\",{\"1\":{\"241\":1}}],[\"计算机往往是多种存储设备共存\",{\"1\":{\"231\":1}}],[\"计算机的主要存储设备仍然是\",{\"1\":{\"231\":1}}],[\"计算机将计算与存储这个两大核心模块进行分离\",{\"1\":{\"231\":1}}],[\"计算机容易发生各种故障\",{\"1\":{\"92\":1}}],[\"计算更新\",{\"1\":{\"129\":1,\"134\":1}}],[\"计划都有一个对应的查询计划类\",{\"1\":{\"79\":1}}],[\"子查询计划列表\",{\"1\":{\"79\":1}}],[\"子查询计划\",{\"1\":{\"79\":1}}],[\"子节点枷锁\",{\"1\":{\"73\":1}}],[\"子节点加锁\",{\"1\":{\"73\":1}}],[\"子节点个数\",{\"1\":{\"71\":1}}],[\"子节点\",{\"1\":{\"26\":1,\"68\":1}}],[\"父执行器在\",{\"1\":{\"78\":1}}],[\"父节点解锁\",{\"1\":{\"73\":1}}],[\"父节点无需分裂\",{\"1\":{\"71\":1}}],[\"父节点一定是内部节点\",{\"1\":{\"71\":1}}],[\"父节点的子节点个数+1\",{\"1\":{\"71\":1}}],[\"父节点\",{\"1\":{\"69\":1,\"71\":1}}],[\"批处理模型\",{\"1\":{\"78\":1}}],[\"常见的\",{\"1\":{\"197\":1}}],[\"常见的消息生产方式有两种\",{\"1\":{\"159\":1}}],[\"常见的处理模型有\",{\"1\":{\"78\":1}}],[\"常见的淘汰算法有\",{\"1\":{\"63\":1}}],[\"规定了执行器如何去执行查询计划\",{\"1\":{\"78\":1}}],[\"规则\",{\"1\":{\"43\":3,\"50\":1}}],[\"处时\",{\"1\":{\"225\":1}}],[\"处的\",{\"1\":{\"225\":1}}],[\"处退出\",{\"1\":{\"225\":1}}],[\"处处运行\",{\"1\":{\"218\":1}}],[\"处\",{\"1\":{\"198\":1,\"200\":2}}],[\"处理十分原始和重复\",{\"1\":{\"223\":1}}],[\"处理的繁琐\",{\"1\":{\"223\":1}}],[\"处理最佳实践\",{\"1\":{\"223\":1,\"229\":1}}],[\"处理代码\",{\"1\":{\"223\":1,\"225\":1}}],[\"处理\",{\"1\":{\"208\":1,\"223\":1,\"227\":1,\"260\":1,\"279\":2,\"284\":2}}],[\"处理参数和环境变量\",{\"1\":{\"200\":1}}],[\"处理器特有数据\",{\"1\":{\"237\":1}}],[\"处理器\",{\"1\":{\"199\":1}}],[\"处理数据优雅又易读\",{\"1\":{\"190\":1}}],[\"处理等核心功能\",{\"1\":{\"156\":1}}],[\"处理中\",{\"1\":{\"134\":1}}],[\"处理请求是比较复杂的\",{\"1\":{\"129\":1}}],[\"处理响应数据\",{\"1\":{\"124\":1}}],[\"处理模型\",{\"0\":{\"78\":1},\"1\":{\"78\":1}}],[\"处增加了originright的判断\",{\"1\":{\"48\":1}}],[\"聚合函数\",{\"1\":{\"77\":1}}],[\"访问它们需要上百个周期\",{\"1\":{\"231\":1}}],[\"访问它们只需几个时钟周期\",{\"1\":{\"231\":1}}],[\"访问到数据只需\",{\"1\":{\"231\":1}}],[\"访问\",{\"1\":{\"77\":1}}],[\"往往花了好久才能定位问题\",{\"1\":{\"74\":1}}],[\"往往十分诡异\",{\"1\":{\"74\":1}}],[\"肉眼很难捕捉\",{\"1\":{\"74\":1}}],[\"尤其是一些\",{\"1\":{\"285\":1}}],[\"尤其是初学者\",{\"1\":{\"232\":1}}],[\"尤其是类架构的更改导致了大量的测试也更改\",{\"1\":{\"165\":1}}],[\"尤其是加上\",{\"1\":{\"74\":1}}],[\"尤其是支持并发的\",{\"1\":{\"74\":1}}],[\"尤其是介绍部分基本囊括了所有主流的协同算法\",{\"1\":{\"41\":1}}],[\"小的节点在前面\",{\"1\":{\"282\":1}}],[\"小例子来看看\",{\"1\":{\"257\":1}}],[\"小例子\",{\"0\":{\"257\":1}}],[\"小对象\",{\"1\":{\"241\":2}}],[\"小内存的块大小固定\",{\"1\":{\"241\":1}}],[\"小内存的分配很频繁\",{\"1\":{\"240\":1}}],[\"小\",{\"1\":{\"241\":1}}],[\"小巧可用\",{\"1\":{\"146\":1}}],[\"小结\",{\"0\":{\"74\":1,\"125\":1,\"132\":1,\"135\":1,\"138\":1}}],[\"小于等于\",{\"1\":{\"136\":1}}],[\"小于\",{\"1\":{\"71\":1,\"72\":1,\"136\":1,\"237\":1,\"282\":2}}],[\"搜索\",{\"1\":{\"73\":1}}],[\"搜索是\",{\"1\":{\"70\":1}}],[\"全双工意味着\",{\"1\":{\"275\":1}}],[\"全双工\",{\"0\":{\"275\":1}}],[\"全双工的\",{\"1\":{\"270\":1}}],[\"全部大写而且不要前缀\",{\"1\":{\"250\":1}}],[\"全部加锁\",{\"1\":{\"73\":1}}],[\"全局不可变\",{\"1\":{\"255\":1}}],[\"全局静态基地址\",{\"1\":{\"250\":1}}],[\"全局变量这些数据是追踪不到的\",{\"1\":{\"243\":1}}],[\"全局变量\",{\"1\":{\"243\":1}}],[\"全局开始函数\",{\"1\":{\"197\":1}}],[\"全程\",{\"1\":{\"241\":1}}],[\"全表扫描仅仅只是其中最简单的一种\",{\"1\":{\"79\":1}}],[\"全表扫描查询计划保存了当前查询的表\",{\"1\":{\"79\":1}}],[\"全被锁住了\",{\"1\":{\"73\":1}}],[\"全称最近最少使用算法\",{\"1\":{\"63\":1}}],[\"全称为远程调用\",{\"1\":{\"142\":1}}],[\"全称为\",{\"1\":{\"41\":1}}],[\"全称\",{\"1\":{\"8\":1,\"15\":1,\"23\":1,\"200\":1}}],[\"待上线过后就得抽时间系统学习\",{\"1\":{\"260\":1}}],[\"待调用完毕后\",{\"1\":{\"251\":1}}],[\"待栈为空时\",{\"1\":{\"244\":1}}],[\"待全部标记完成后再来一次清理\",{\"1\":{\"244\":1}}],[\"待内存使用完毕后\",{\"1\":{\"239\":1}}],[\"待使用完后\",{\"1\":{\"234\":1}}],[\"待程序需要更多内存时\",{\"1\":{\"234\":1}}],[\"待遍历完毕后\",{\"1\":{\"188\":1}}],[\"待优化\",{\"1\":{\"129\":1,\"134\":1}}],[\"待同步日志数据\",{\"1\":{\"126\":1}}],[\"待收到半数以上的选票时\",{\"1\":{\"123\":1}}],[\"待操作完毕后\",{\"1\":{\"73\":1}}],[\"待页慢需要淘汰时\",{\"1\":{\"63\":1}}],[\"粒度\",{\"1\":{\"73\":1}}],[\"蟹行协议\",{\"1\":{\"73\":1}}],[\"发起连接\",{\"1\":{\"286\":1}}],[\"发起rpc请求\",{\"1\":{\"148\":1}}],[\"发生时\",{\"1\":{\"285\":1}}],[\"发生重组\",{\"1\":{\"73\":1}}],[\"发包等功能\",{\"1\":{\"285\":1}}],[\"发布\",{\"1\":{\"148\":1,\"177\":1}}],[\"发送数据\",{\"1\":{\"286\":1}}],[\"发送空包\",{\"1\":{\"285\":1}}],[\"发送空包是\",{\"1\":{\"285\":1}}],[\"发送报文\",{\"1\":{\"285\":1}}],[\"发送者\",{\"1\":{\"285\":1}}],[\"发送但未确认的字节数\",{\"1\":{\"284\":1}}],[\"发送但未确认的包\",{\"1\":{\"284\":1}}],[\"发送消息\",{\"1\":{\"159\":1}}],[\"发送给了上层应用\",{\"1\":{\"136\":1}}],[\"发送给上层应用\",{\"1\":{\"136\":1}}],[\"发送完快照后\",{\"1\":{\"136\":1}}],[\"发送快照请求\",{\"1\":{\"136\":1}}],[\"发送\",{\"1\":{\"129\":2,\"136\":1,\"282\":2,\"284\":1,\"285\":1,\"286\":1}}],[\"发出的\",{\"1\":{\"124\":1}}],[\"发现数据有错误\",{\"1\":{\"281\":1}}],[\"发现数据变成了\",{\"1\":{\"84\":1}}],[\"发现了大量垃圾\",{\"1\":{\"238\":1}}],[\"发现了其特别有意思的两个奇技淫巧\",{\"1\":{\"205\":1}}],[\"发现不合理代码\",{\"1\":{\"168\":1}}],[\"发现错误后可快速定位\",{\"1\":{\"164\":1}}],[\"发现同步日志的序号小于自己的\",{\"1\":{\"137\":1}}],[\"发现一个\",{\"1\":{\"136\":1}}],[\"发现任期大的立即成为其追随者\",{\"1\":{\"139\":1}}],[\"发现任期大的\",{\"1\":{\"124\":1,\"129\":1,\"133\":1}}],[\"发现父节点未满足半满的性质\",{\"1\":{\"72\":1}}],[\"发现节点\",{\"1\":{\"71\":1,\"73\":1}}],[\"发现\",{\"1\":{\"71\":1}}],[\"释放工作无疑会占开发者很多的时间和精力\",{\"1\":{\"234\":1}}],[\"释放内存的\",{\"1\":{\"237\":1}}],[\"释放内存\",{\"1\":{\"233\":1,\"241\":1}}],[\"释放锁\",{\"1\":{\"87\":4,\"200\":1}}],[\"释放锁后\",{\"1\":{\"86\":1}}],[\"释放锁阶段\",{\"1\":{\"85\":1}}],[\"释放\",{\"1\":{\"73\":3,\"200\":1}}],[\"释放所有节点上的锁\",{\"1\":{\"73\":1}}],[\"释放父节点上的锁\",{\"1\":{\"73\":1}}],[\"释放该页\",{\"1\":{\"64\":1}}],[\"协程池最多只能有\",{\"1\":{\"264\":1}}],[\"协程池\",{\"0\":{\"264\":1}}],[\"协调工作\",{\"1\":{\"231\":1}}],[\"协调者立即成为领导者\",{\"1\":{\"124\":1}}],[\"协调者通过该函数向其它节点发送投票请求\",{\"1\":{\"124\":1}}],[\"协调者升级成为领导者\",{\"1\":{\"123\":1}}],[\"协调者\",{\"1\":{\"123\":1}}],[\"协议已经实现完毕了\",{\"1\":{\"286\":1}}],[\"协议类似于\",{\"1\":{\"281\":1}}],[\"协议代码核心文件\",{\"1\":{\"280\":1}}],[\"协议时\",{\"1\":{\"280\":1}}],[\"协议巧妙地将连接分为了\",{\"1\":{\"279\":1}}],[\"协议中的字节流类\",{\"1\":{\"279\":1}}],[\"协议概览\",{\"0\":{\"279\":1}}],[\"协议并不特别复杂\",{\"1\":{\"278\":1}}],[\"协议一样有滑动窗口\",{\"1\":{\"278\":1}}],[\"协议之上\",{\"1\":{\"278\":1}}],[\"协议建立在\",{\"1\":{\"278\":1}}],[\"协议做一些简单的介绍\",{\"1\":{\"278\":1}}],[\"协议在功能特性上完胜\",{\"1\":{\"278\":1}}],[\"协议定位非常类似\",{\"1\":{\"278\":1}}],[\"协议和\",{\"1\":{\"278\":1}}],[\"协议介绍\",{\"0\":{\"276\":1}}],[\"协议通信的双方既可以发送数据\",{\"1\":{\"275\":1}}],[\"协议上\",{\"1\":{\"270\":1}}],[\"协议成为了网络协议重点中的重点\",{\"1\":{\"270\":1}}],[\"协议是一种简易版\",{\"1\":{\"278\":1}}],[\"协议是建立在\",{\"1\":{\"278\":1}}],[\"协议是目前名气最大\",{\"1\":{\"270\":1}}],[\"协议是rpc的灵魂\",{\"1\":{\"146\":1}}],[\"协议实现\",{\"0\":{\"269\":1,\"280\":1}}],[\"协议编解码实现就非常简单了\",{\"1\":{\"146\":1}}],[\"协议版本\",{\"1\":{\"146\":1}}],[\"协议版本升\",{\"1\":{\"146\":1}}],[\"协议可读性好\",{\"1\":{\"146\":1}}],[\"协议包尽可能小\",{\"1\":{\"146\":1}}],[\"协议传输效率\",{\"1\":{\"146\":1}}],[\"协议层\",{\"0\":{\"146\":1},\"1\":{\"143\":1}}],[\"协议转发\",{\"1\":{\"112\":1}}],[\"协议解析\",{\"1\":{\"112\":1,\"113\":1}}],[\"协议请求\",{\"1\":{\"106\":1}}],[\"协议后\",{\"1\":{\"74\":1,\"280\":1}}],[\"协议也有很多优化点\",{\"1\":{\"73\":1}}],[\"协议也十分好理解\",{\"1\":{\"73\":1}}],[\"协议则复杂一些\",{\"1\":{\"73\":1}}],[\"协议的性能怎么样呢\",{\"1\":{\"286\":1}}],[\"协议的封装\",{\"1\":{\"286\":1}}],[\"协议的具体实现逻辑和一些细节\",{\"1\":{\"280\":1}}],[\"协议的主体类为\",{\"1\":{\"279\":1}}],[\"协议的精髓\",{\"1\":{\"270\":1}}],[\"协议的新客户端\",{\"1\":{\"111\":1}}],[\"协议的实现\",{\"1\":{\"73\":1,\"277\":1}}],[\"协议的核心点在于\",{\"1\":{\"73\":1}}],[\"协议的向下查找方式像极了螃蟹走路\",{\"1\":{\"73\":1}}],[\"协议\",{\"0\":{\"73\":1},\"1\":{\"263\":1,\"270\":2,\"278\":5,\"279\":1,\"281\":1,\"287\":2,\"288\":1}}],[\"协同库\",{\"1\":{\"41\":1}}],[\"孩子节点成为新的根节点\",{\"1\":{\"72\":1}}],[\"末尾\",{\"1\":{\"72\":1}}],[\"\\b末尾移到\",{\"1\":{\"72\":1}}],[\"兄弟节点\",{\"1\":{\"72\":1}}],[\"借鉴\",{\"1\":{\"239\":1,\"241\":1}}],[\"借鉴了\",{\"1\":{\"43\":1}}],[\"借助寄存器和栈\",{\"1\":{\"218\":1}}],[\"借助\",{\"1\":{\"186\":1,\"190\":1,\"277\":1}}],[\"借给兄弟节点\",{\"1\":{\"72\":1}}],[\"插件\",{\"1\":{\"291\":1}}],[\"插图流程图如图\",{\"1\":{\"71\":1}}],[\"插入后不会超过\",{\"1\":{\"73\":1}}],[\"插入后判断是否需要分裂\",{\"1\":{\"71\":1}}],[\"插入一个\",{\"1\":{\"73\":1}}],[\"插入父节点\",{\"1\":{\"71\":1}}],[\"插入失败\",{\"1\":{\"71\":1}}],[\"插入到叶子节点中\",{\"1\":{\"71\":1}}],[\"插入至叶子节点\",{\"1\":{\"71\":1}}],[\"插入执行器等\",{\"1\":{\"59\":1}}],[\"插入\",{\"1\":{\"58\":1,\"69\":1,\"71\":1,\"77\":1,\"282\":1}}],[\"插入等计划\",{\"1\":{\"58\":1}}],[\"插入时的左边节点\",{\"1\":{\"51\":1}}],[\"插入3时\",{\"1\":{\"48\":1}}],[\"插入算法\",{\"0\":{\"44\":1}}],[\"插入操作o就变成了这样\",{\"1\":{\"48\":1}}],[\"插入操作的contentk​\",{\"1\":{\"47\":1}}],[\"插入操作的核心是生成item\",{\"1\":{\"26\":1}}],[\"插入操作\",{\"1\":{\"44\":1,\"73\":1}}],[\"插入操作必须严格按照顺序排列\",{\"1\":{\"43\":2}}],[\"插入操作抽象为o\",{\"1\":{\"43\":1}}],[\"插入的内容\",{\"1\":{\"43\":1}}],[\"插入内容\",{\"1\":{\"25\":2}}],[\"插入意图\",{\"1\":{\"25\":3,\"26\":1}}],[\"插入数据\",{\"1\":{\"25\":1}}],[\"插入位置需要遵循\",{\"1\":{\"51\":1}}],[\"插入位置\",{\"1\":{\"25\":1}}],[\"设置额外的字段\",{\"1\":{\"285\":1}}],[\"设置为\",{\"1\":{\"284\":1}}],[\"设置为可运行的状态\",{\"1\":{\"200\":1}}],[\"设置完毕后包装为\",{\"1\":{\"279\":1}}],[\"设置状态\",{\"1\":{\"200\":1}}],[\"设置\",{\"1\":{\"200\":11,\"202\":3,\"224\":1,\"283\":1,\"284\":2,\"292\":1}}],[\"设置程序入口\",{\"1\":{\"200\":2,\"251\":1}}],[\"设置线程局部存储\",{\"1\":{\"200\":1}}],[\"设置或者获取线程局部变量地址\",{\"1\":{\"198\":1}}],[\"设置父节点\",{\"1\":{\"71\":1}}],[\"设计了一种\",{\"1\":{\"219\":1}}],[\"设计策略和实现细节\",{\"1\":{\"200\":1}}],[\"设计\",{\"0\":{\"182\":1}}],[\"设计理念\",{\"1\":{\"162\":1}}],[\"设计与实现\",{\"0\":{\"100\":1,\"141\":1},\"1\":{\"119\":1}}],[\"设计方式和实现思路都很有借鉴性\",{\"1\":{\"27\":1}}],[\"设计基于\",{\"1\":{\"4\":1}}],[\"设计数据结构\",{\"1\":{\"4\":1}}],[\"非干净关闭\",{\"1\":{\"285\":2}}],[\"非常值得一读\",{\"1\":{\"286\":1}}],[\"非常易用\",{\"1\":{\"261\":1}}],[\"非常抱歉\",{\"1\":{\"4\":1}}],[\"非存活则当成垃圾回收\",{\"1\":{\"243\":1}}],[\"非主干的代码都已删除\",{\"1\":{\"200\":1}}],[\"非主线程也有用户态调用栈\",{\"1\":{\"194\":1}}],[\"非主线程也会被分配调用栈\",{\"1\":{\"194\":1}}],[\"非自身当前绑定的\",{\"1\":{\"199\":1}}],[\"非\",{\"1\":{\"137\":1}}],[\"非空\",{\"1\":{\"71\":1}}],[\"空包用于\",{\"1\":{\"285\":1}}],[\"空包有另外的处理\",{\"1\":{\"284\":1}}],[\"空包直接返回\",{\"1\":{\"284\":1}}],[\"空闲时\",{\"1\":{\"264\":1}}],[\"空闲链表\",{\"1\":{\"241\":1}}],[\"空闲页列表\",{\"1\":{\"64\":1}}],[\"空接口\",{\"1\":{\"208\":1}}],[\"空树\",{\"1\":{\"71\":1}}],[\"引入了\",{\"1\":{\"241\":1}}],[\"引入了构造\",{\"1\":{\"234\":1}}],[\"引入了泛型后\",{\"1\":{\"179\":1}}],[\"引入了快照机制\",{\"1\":{\"136\":1}}],[\"引入了另外一个属性originright\",{\"1\":{\"48\":1}}],[\"引起了两次节点分裂\",{\"1\":{\"71\":1}}],[\"己有\",{\"1\":{\"71\":1}}],[\"已结束\",{\"1\":{\"285\":1}}],[\"已分配内存\",{\"1\":{\"238\":1}}],[\"已知\",{\"1\":{\"164\":1}}],[\"已快照过了\",{\"1\":{\"136\":1}}],[\"已应用\",{\"1\":{\"127\":1}}],[\"已应用的日志序号\",{\"1\":{\"126\":1}}],[\"已应用日志序号\",{\"1\":{\"126\":1}}],[\"已提交的日志被应用后才会生效\",{\"1\":{\"128\":1}}],[\"已提交的日志序号\",{\"1\":{\"126\":1}}],[\"已提交\",{\"1\":{\"127\":2}}],[\"已提交日志序号\",{\"1\":{\"126\":1}}],[\"已同步日志序号\",{\"1\":{\"126\":1,\"129\":1}}],[\"已被提交的事务对数据库的修改应该永久保存在数据库中\",{\"1\":{\"83\":1}}],[\"已经超过了\",{\"1\":{\"285\":1}}],[\"已经完全重组且结束\",{\"1\":{\"285\":1}}],[\"已经确认过了\",{\"1\":{\"284\":1}}],[\"已经确认的序列\",{\"1\":{\"283\":1}}],[\"已经重试的次数\",{\"1\":{\"284\":1}}],[\"已经在\",{\"1\":{\"283\":2}}],[\"已经被接收过了\",{\"1\":{\"283\":1}}],[\"已经被重组了\",{\"1\":{\"282\":1}}],[\"已经被锁了\",{\"1\":{\"88\":1}}],[\"已经对内存管理有了一定的认识与理解\",{\"1\":{\"242\":1}}],[\"已经支持\",{\"1\":{\"227\":1}}],[\"已经变得十分复杂和臃肿\",{\"1\":{\"152\":1}}],[\"已经同步好的日志都丢了怎么办\",{\"1\":{\"132\":1}}],[\"已经拥有\",{\"1\":{\"71\":1}}],[\"已经足够了\",{\"1\":{\"5\":1}}],[\"已有\",{\"1\":{\"71\":1}}],[\"祖先节点可能仍需分离\",{\"1\":{\"71\":1}}],[\"递归\",{\"1\":{\"71\":1}}],[\"递归情况\",{\"1\":{\"71\":1}}],[\"递增clock\",{\"1\":{\"17\":1}}],[\"势必会导致节点的子节点个数超过\",{\"1\":{\"71\":1}}],[\"二叉树\",{\"1\":{\"282\":1}}],[\"二\",{\"1\":{\"243\":1}}],[\"二进制协议\",{\"1\":{\"147\":2}}],[\"二次封装客户端基于服务发现\",{\"1\":{\"104\":1}}],[\"二次封装\",{\"1\":{\"102\":1,\"104\":1}}],[\"二阶段事务沿用了这三个操作\",{\"1\":{\"85\":1}}],[\"二阶段事务\",{\"0\":{\"85\":1},\"1\":{\"85\":1}}],[\"二分查找主要运用在如下两点\",{\"1\":{\"70\":1}}],[\"二分查找\",{\"1\":{\"70\":1}}],[\"二者通过总线连接\",{\"1\":{\"231\":1}}],[\"二者都是\",{\"1\":{\"200\":1}}],[\"二者并无本质区别\",{\"1\":{\"194\":1}}],[\"二者均由内核调度器来调度\",{\"1\":{\"194\":1}}],[\"二者各有优劣\",{\"1\":{\"160\":1}}],[\"二者处理也十分类似\",{\"1\":{\"139\":1}}],[\"二者几乎一致\",{\"1\":{\"129\":1}}],[\"二者大小加起来也只有\",{\"1\":{\"72\":1}}],[\"二者的区别在于进程拥有独立的地址空间和资源\",{\"1\":{\"194\":1}}],[\"二者的子节点\",{\"1\":{\"72\":2}}],[\"二者的数据结构不同\",{\"1\":{\"10\":1}}],[\"二者在数据通信上也大不一样\",{\"1\":{\"10\":1}}],[\"二者目标一致\",{\"1\":{\"10\":1}}],[\"获得\",{\"1\":{\"70\":1}}],[\"获取系统中有多少\",{\"1\":{\"294\":1}}],[\"获取报文并发送\",{\"1\":{\"279\":1}}],[\"获取到当前运行\",{\"1\":{\"200\":1}}],[\"获取下一个\",{\"1\":{\"200\":1}}],[\"获取入口函数地址\",{\"1\":{\"200\":1}}],[\"获取当前\",{\"1\":{\"200\":2}}],[\"获取硬件\",{\"1\":{\"200\":1}}],[\"获取线程局部变量地址并拷贝到\",{\"1\":{\"200\":1}}],[\"获取线程局部变量地址\",{\"1\":{\"198\":1}}],[\"获取原始数据\",{\"1\":{\"182\":1}}],[\"获取其对应\",{\"1\":{\"160\":1}}],[\"获取\",{\"1\":{\"159\":1,\"200\":11,\"279\":1}}],[\"获取提供者信息失败\",{\"1\":{\"150\":1}}],[\"获取发送节点下一个要同步的日志序号\",{\"1\":{\"129\":1}}],[\"获取锁阶段\",{\"1\":{\"85\":1}}],[\"获取列数据\",{\"1\":{\"79\":1,\"89\":1}}],[\"获取子执行器数据记录后\",{\"1\":{\"78\":1}}],[\"获取子节点\",{\"1\":{\"73\":2}}],[\"获取了数据页\",{\"1\":{\"64\":1}}],[\"获取数据页\",{\"1\":{\"64\":1}}],[\"获取对应页\",{\"1\":{\"64\":1}}],[\"获取所有数据页\",{\"1\":{\"64\":1}}],[\"获取文档内容时\",{\"1\":{\"26\":1}}],[\"进程应用程序参数区开始\",{\"1\":{\"237\":1}}],[\"进程应用程序堆区的开始\",{\"1\":{\"237\":1}}],[\"进程申请一段内存\",{\"1\":{\"210\":1}}],[\"进程本身\",{\"1\":{\"200\":1}}],[\"进程本身也是可执行单元\",{\"1\":{\"194\":1}}],[\"进程和线程都是抽象出来的概念\",{\"1\":{\"199\":1}}],[\"进程和线程是同一种数据结构\",{\"1\":{\"194\":1}}],[\"进程拥有独立地址空间与资源\",{\"1\":{\"194\":1}}],[\"进程用户地址空间\",{\"1\":{\"194\":1}}],[\"进程打开的所有文件\",{\"1\":{\"194\":1}}],[\"进程相关的文件系统信息\",{\"1\":{\"194\":1}}],[\"进程\",{\"1\":{\"194\":1}}],[\"进程内核栈地址\",{\"1\":{\"194\":1}}],[\"进程状态\",{\"1\":{\"194\":2}}],[\"进程与线程\",{\"0\":{\"194\":1},\"1\":{\"192\":1}}],[\"进一步处理返回\",{\"1\":{\"78\":1}}],[\"进入容器后\",{\"1\":{\"290\":1,\"291\":1}}],[\"进入被动关闭状态\",{\"1\":{\"286\":1}}],[\"进入池中\",{\"1\":{\"262\":1}}],[\"进入调度循环\",{\"1\":{\"200\":2}}],[\"进入红\",{\"1\":{\"164\":1}}],[\"进入循环后\",{\"1\":{\"124\":1}}],[\"进入\",{\"1\":{\"70\":1,\"200\":2,\"217\":1}}],[\"进行了限制\",{\"1\":{\"294\":1}}],[\"进行了绑定\",{\"1\":{\"203\":1}}],[\"进行一系列的分析和优化\",{\"1\":{\"227\":1}}],[\"进行\",{\"1\":{\"225\":1}}],[\"进行下一轮调度\",{\"1\":{\"200\":1}}],[\"进行和线程都由同一个\",{\"1\":{\"199\":1}}],[\"进行调度和运行\",{\"1\":{\"199\":1}}],[\"进行绑定\",{\"1\":{\"199\":1}}],[\"进行打桩\",{\"1\":{\"164\":2}}],[\"进行重组\",{\"1\":{\"72\":1}}],[\"进行分裂\",{\"1\":{\"71\":1}}],[\"进行合并\",{\"1\":{\"10\":1}}],[\"进行中的事务字典\",{\"1\":{\"4\":1}}],[\"合理利用好二分查找就足够了\",{\"1\":{\"70\":1}}],[\"合并完成以后\",{\"1\":{\"282\":1}}],[\"合并完毕后\",{\"1\":{\"282\":1}}],[\"合并数据流\",{\"1\":{\"183\":1}}],[\"合并组件\",{\"1\":{\"164\":1}}],[\"合并成一个快照块\",{\"1\":{\"136\":1}}],[\"合并成为节点\",{\"1\":{\"72\":1}}],[\"合并时\",{\"1\":{\"73\":1}}],[\"合并都是可以递归向上执行的\",{\"1\":{\"72\":1}}],[\"合并以后可能还需要合并或者重组\",{\"1\":{\"72\":1}}],[\"合并\",{\"1\":{\"72\":3,\"73\":3,\"282\":2}}],[\"合并后大小仍然大于\",{\"1\":{\"72\":1}}],[\"合并策略和压缩策略\",{\"1\":{\"4\":1}}],[\"合并策略和读缓存等\",{\"1\":{\"4\":1}}],[\"合并操作会将所有\",{\"1\":{\"4\":1}}],[\"合并操作\",{\"1\":{\"4\":2}}],[\"语法虽然与\",{\"1\":{\"248\":1}}],[\"语法解析\",{\"1\":{\"227\":1}}],[\"语法分析\",{\"1\":{\"226\":1}}],[\"语法分析等资料\",{\"1\":{\"218\":1}}],[\"语法来处理数据流\",{\"1\":{\"190\":1}}],[\"语言汇编入门\",{\"1\":{\"258\":1}}],[\"语言的约定来调用\",{\"1\":{\"257\":1}}],[\"语言内存管理\",{\"1\":{\"239\":1}}],[\"语言例子中\",{\"1\":{\"234\":1}}],[\"语言基础的同学肯定熟悉\",{\"1\":{\"227\":1}}],[\"语言本身又没有提供错误处理语法糖\",{\"1\":{\"223\":1}}],[\"语言函数\",{\"1\":{\"212\":1}}],[\"语言是可以直接内联汇编的\",{\"1\":{\"210\":1}}],[\"语言强大的系统编程能力\",{\"1\":{\"210\":1}}],[\"语言实现的巨大宝库\",{\"1\":{\"228\":1}}],[\"语言实现的核心数据结构\",{\"1\":{\"208\":1}}],[\"语言实现机制中的两个重要数据结构\",{\"1\":{\"208\":1}}],[\"语言为例\",{\"1\":{\"197\":1}}],[\"语言带来的便利\",{\"1\":{\"192\":1}}],[\"语言特性\",{\"1\":{\"69\":1}}],[\"语句到\",{\"1\":{\"227\":1}}],[\"语句进行逃逸分析\",{\"1\":{\"227\":1}}],[\"语句定义后\",{\"1\":{\"227\":1}}],[\"语句定义\",{\"1\":{\"227\":1}}],[\"语句语法检查\",{\"1\":{\"227\":1}}],[\"语句遍历函数\",{\"1\":{\"227\":1}}],[\"语句上初始化\",{\"1\":{\"227\":2}}],[\"语句外部初始化\",{\"1\":{\"227\":2}}],[\"语句最大的好处在于\",{\"1\":{\"227\":1}}],[\"语句最后一个返回值为\",{\"1\":{\"225\":1}}],[\"语句的\",{\"1\":{\"227\":1}}],[\"语句的格式化\",{\"1\":{\"227\":1}}],[\"语句的解析了\",{\"1\":{\"227\":1}}],[\"语句的处理\",{\"1\":{\"226\":1}}],[\"语句的联合体\",{\"1\":{\"225\":1}}],[\"语句解析为\",{\"1\":{\"225\":1}}],[\"语句重写\",{\"1\":{\"225\":1}}],[\"语句改写为\",{\"1\":{\"225\":1}}],[\"语句即可\",{\"1\":{\"225\":1}}],[\"语句是将\",{\"1\":{\"225\":1}}],[\"语句\",{\"0\":{\"174\":1},\"1\":{\"79\":1,\"225\":5,\"226\":1,\"227\":2}}],[\"语句后\",{\"1\":{\"77\":1}}],[\"语句转化为执行计划\",{\"1\":{\"58\":1}}],[\"叶子\",{\"1\":{\"71\":1}}],[\"叶子结点\",{\"1\":{\"69\":1}}],[\"叶子节点是值的个数\",{\"1\":{\"71\":1}}],[\"叶子节点能容纳的\",{\"1\":{\"69\":1}}],[\"叶子节点两种\",{\"1\":{\"69\":1}}],[\"叶子节点\",{\"1\":{\"69\":1}}],[\"叶子节点没有子节点\",{\"1\":{\"68\":1}}],[\"叶子节点三种节点\",{\"1\":{\"68\":1}}],[\"作为内存资源缓存在程序中\",{\"1\":{\"239\":1}}],[\"作为山中最核心的一层\",{\"1\":{\"231\":1}}],[\"作为变量名\",{\"1\":{\"227\":1}}],[\"作为关键字\",{\"1\":{\"227\":1}}],[\"作为程序入口\",{\"1\":{\"217\":1}}],[\"作为实践平台\",{\"1\":{\"217\":1}}],[\"作为目前最强劲性能的存在\",{\"1\":{\"212\":1}}],[\"作为线程的启动函数\",{\"1\":{\"198\":1,\"203\":1}}],[\"作为泛型约束\",{\"1\":{\"181\":1}}],[\"作为一个\",{\"1\":{\"157\":1,\"161\":1}}],[\"作为通信框架\",{\"1\":{\"153\":1}}],[\"作为\",{\"1\":{\"137\":1,\"207\":1}}],[\"作为所有查询计划的父类\",{\"1\":{\"79\":1}}],[\"作为主类\",{\"1\":{\"69\":1}}],[\"作为核心建模方式\",{\"1\":{\"28\":1}}],[\"说明如下\",{\"1\":{\"200\":1}}],[\"说明\",{\"1\":{\"69\":1,\"199\":1,\"270\":1,\"284\":2}}],[\"说起来挺玄乎的\",{\"1\":{\"9\":1}}],[\"参与编译器工作的\",{\"1\":{\"228\":1}}],[\"参数来监听本地的\",{\"1\":{\"277\":1}}],[\"参数来设置执行文件入口\",{\"1\":{\"217\":1}}],[\"参数等\",{\"1\":{\"232\":1}}],[\"参数是\",{\"1\":{\"208\":1}}],[\"参数内存大小为\",{\"1\":{\"200\":1,\"251\":1}}],[\"参数从\",{\"1\":{\"200\":2}}],[\"参数后\",{\"1\":{\"149\":1}}],[\"参数与响应定义如下\",{\"1\":{\"136\":1}}],[\"参数有几个重要字段\",{\"1\":{\"126\":1}}],[\"参数\",{\"1\":{\"69\":1,\"189\":1,\"200\":4,\"218\":1,\"232\":1,\"240\":1,\"281\":1,\"283\":1}}],[\"参数用于指定树名称\",{\"1\":{\"69\":1}}],[\"参考终端输出的\",{\"1\":{\"286\":1}}],[\"参考链接\",{\"0\":{\"204\":1}}],[\"参考\",{\"1\":{\"51\":1,\"134\":1,\"292\":1}}],[\"参考资料\",{\"0\":{\"6\":1,\"20\":1,\"39\":1,\"53\":1,\"60\":1,\"65\":1,\"75\":1,\"80\":1,\"90\":1,\"95\":1,\"119\":1,\"140\":1,\"175\":1,\"191\":1,\"215\":1,\"221\":1,\"229\":1,\"247\":1,\"258\":1,\"266\":1,\"288\":1,\"295\":1},\"1\":{\"161\":1}}],[\"构建\",{\"1\":{\"291\":1}}],[\"构建高性能基础设施\",{\"1\":{\"236\":1}}],[\"构建出\",{\"1\":{\"224\":1}}],[\"构建出完整的插入有序链表\",{\"1\":{\"43\":1}}],[\"构建sqlsessionfactory\",{\"1\":{\"170\":1}}],[\"构造函数\",{\"1\":{\"79\":1,\"281\":1}}],[\"构造\",{\"1\":{\"69\":1}}],[\"例子\",{\"1\":{\"227\":4,\"251\":1}}],[\"例子可以为\",{\"1\":{\"69\":1}}],[\"例如快照更新了\",{\"1\":{\"137\":1}}],[\"例如在合并操作期间\",{\"1\":{\"4\":1}}],[\"例如定期合并所有的\",{\"1\":{\"4\":1}}],[\"例如\",{\"1\":{\"4\":1,\"117\":1,\"136\":1}}],[\"键值对中的值还可以是集合类型\",{\"1\":{\"113\":1}}],[\"键比较器类型\",{\"1\":{\"69\":1}}],[\"键即是图中的数字\",{\"1\":{\"68\":1}}],[\"情况就不一样了\",{\"1\":{\"68\":1}}],[\"六阶\",{\"1\":{\"68\":1}}],[\"度一致\",{\"1\":{\"68\":1}}],[\"深入理解\",{\"1\":{\"288\":1}}],[\"深入理解crdt\",{\"0\":{\"7\":1,\"21\":1,\"40\":1}}],[\"深入\",{\"1\":{\"204\":1}}],[\"深\",{\"1\":{\"68\":1}}],[\"具有很强的表现力\",{\"1\":{\"218\":1}}],[\"具有优越的性能\",{\"1\":{\"107\":1}}],[\"具有\",{\"1\":{\"68\":1}}],[\"具有至少\",{\"1\":{\"68\":1}}],[\"具体逻辑参考注释\",{\"1\":{\"284\":1}}],[\"具体实现\",{\"1\":{\"274\":1}}],[\"具体实现可以参考这个\",{\"1\":{\"225\":1}}],[\"具体实现如下\",{\"1\":{\"145\":1}}],[\"具体的方案为\",{\"1\":{\"240\":1}}],[\"具体的缺点可以参考这里\",{\"1\":{\"210\":1}}],[\"具体的说是验证\",{\"1\":{\"164\":1}}],[\"具体的实现\",{\"1\":{\"16\":1}}],[\"具体可\",{\"1\":{\"134\":1}}],[\"具体怎么转换呢\",{\"1\":{\"113\":1}}],[\"具体关于如何实现在下面实践部分会详细介绍\",{\"1\":{\"10\":1}}],[\"具体有如下两点\",{\"1\":{\"10\":1}}],[\"必须同时满足条件\",{\"1\":{\"285\":1}}],[\"必须在有\",{\"1\":{\"285\":1}}],[\"必须在接受对端包的情况下才知道对端的接受窗口大小\",{\"1\":{\"284\":1}}],[\"必须从\",{\"1\":{\"285\":1}}],[\"必须重置定时器时间和重试次数\",{\"1\":{\"284\":1}}],[\"必须得\",{\"1\":{\"283\":1}}],[\"必须加上\",{\"1\":{\"255\":1}}],[\"必须由\",{\"1\":{\"200\":1}}],[\"必须是\",{\"1\":{\"197\":1}}],[\"必须建立在集群的大部分节点均已匹配的基础上\",{\"1\":{\"129\":1}}],[\"必须使用\",{\"1\":{\"92\":1}}],[\"必须先接受\",{\"1\":{\"285\":1}}],[\"必须先准备一些前置知识\",{\"1\":{\"193\":1}}],[\"必须先由日志写入磁盘\",{\"1\":{\"92\":1}}],[\"必须先尝试获取该记录的锁\",{\"1\":{\"88\":1}}],[\"必须等待\",{\"1\":{\"86\":1,\"282\":1}}],[\"必须对\",{\"1\":{\"86\":1}}],[\"必须满足如下几个条件\",{\"1\":{\"68\":1}}],[\"必不可少的架构和设计功夫\",{\"1\":{\"0\":1}}],[\"阶段都是以其它语句的身份来参与\",{\"1\":{\"226\":1}}],[\"阶段不能释放某一个锁\",{\"1\":{\"85\":1}}],[\"阶段\",{\"1\":{\"85\":1,\"226\":1,\"243\":3}}],[\"阶\",{\"1\":{\"68\":3,\"71\":1,\"72\":1}}],[\"根文件系统\",{\"1\":{\"291\":1}}],[\"根本原因在于\",{\"1\":{\"223\":1}}],[\"根\",{\"1\":{\"71\":1,\"282\":1}}],[\"根节点页\",{\"1\":{\"73\":1}}],[\"根节点不用更新\",{\"1\":{\"73\":1}}],[\"根节点还不是最后一个节点\",{\"1\":{\"72\":1}}],[\"根节点除外\",{\"1\":{\"71\":1}}],[\"根节点\",{\"1\":{\"68\":1,\"71\":1,\"72\":1}}],[\"根节点既可以是内部节点\",{\"1\":{\"68\":1}}],[\"根据结果来处理\",{\"1\":{\"129\":1}}],[\"根据领导者日志提交序号来更新日志提交序号\",{\"1\":{\"129\":1}}],[\"根据具体业务来实现\",{\"1\":{\"128\":1}}],[\"根据\",{\"1\":{\"106\":1,\"121\":1,\"128\":1,\"284\":2}}],[\"根据origin找到初始目标下标destindex\",{\"1\":{\"47\":1}}],[\"根据提供的事务标识符获取对应的\",{\"1\":{\"4\":2}}],[\"内嵌了\",{\"1\":{\"261\":1}}],[\"内置函数\",{\"1\":{\"219\":1}}],[\"内核态下\",{\"1\":{\"279\":1}}],[\"内核态拥有最高权限\",{\"1\":{\"196\":1}}],[\"内核\",{\"0\":{\"289\":1},\"1\":{\"247\":1,\"291\":1}}],[\"内核负责对这\",{\"1\":{\"199\":1}}],[\"内核中的中断处理函数根据系统调用号\",{\"1\":{\"197\":1}}],[\"内核栈\",{\"1\":{\"194\":1}}],[\"内核栈的内存区\",{\"1\":{\"194\":1}}],[\"内部是一个红黑树实现\",{\"1\":{\"282\":1}}],[\"内部队列\",{\"1\":{\"261\":1}}],[\"内部结构无需过多关注\",{\"1\":{\"231\":1}}],[\"内部处理逻辑稍有不同\",{\"1\":{\"189\":1}}],[\"内部通过共享指针来实现字符串容器\",{\"1\":{\"281\":1}}],[\"内部通过\",{\"1\":{\"183\":1}}],[\"内部实际是一个\",{\"1\":{\"181\":1}}],[\"内部节点只会存储键和子节点指针\",{\"1\":{\"68\":1}}],[\"内部节点的第一个键可以理解为是空的\",{\"1\":{\"68\":1}}],[\"内部节点\",{\"1\":{\"68\":1,\"69\":3}}],[\"内的实现方式\",{\"1\":{\"164\":1}}],[\"内存损耗\",{\"1\":{\"281\":1}}],[\"内存优化方案中最常见的一种了\",{\"1\":{\"265\":1}}],[\"内存泄漏样例\",{\"0\":{\"268\":1},\"1\":{\"262\":1}}],[\"内存泄漏\",{\"1\":{\"262\":1}}],[\"内存就会迅速被占满\",{\"1\":{\"260\":1}}],[\"内存就已经是垃圾\",{\"1\":{\"238\":1}}],[\"内存块个数\",{\"1\":{\"238\":1}}],[\"内存大小\",{\"1\":{\"238\":1}}],[\"内存仍然占用\",{\"1\":{\"238\":1}}],[\"内存分配\",{\"1\":{\"245\":2}}],[\"内存分配的场景十分复杂\",{\"1\":{\"241\":1}}],[\"内存分配算法的问题很多\",{\"1\":{\"240\":1}}],[\"内存分配原理\",{\"0\":{\"237\":1}}],[\"内存分配器\",{\"1\":{\"200\":2}}],[\"内存自动管理虽然帮助开发者节约了时间和精力\",{\"1\":{\"235\":1}}],[\"内存从手动管理到自动管理是语言的一大步\",{\"1\":{\"235\":1}}],[\"内存会自动随着函数调用而开辟和释放\",{\"1\":{\"232\":1}}],[\"内存空间被划分为了多个区\",{\"1\":{\"232\":1}}],[\"内存布局\",{\"0\":{\"232\":1},\"1\":{\"236\":1}}],[\"内存管理简单介绍后\",{\"1\":{\"236\":1}}],[\"内存管理\",{\"0\":{\"236\":1,\"245\":1},\"1\":{\"231\":1,\"247\":2}}],[\"内存管理设计与实现\",{\"0\":{\"230\":1}}],[\"内存\",{\"1\":{\"207\":1,\"231\":2,\"238\":1,\"239\":1}}],[\"内存是非常有限的\",{\"1\":{\"63\":1}}],[\"内存消耗方面都十分优异\",{\"1\":{\"41\":1}}],[\"内存表\",{\"1\":{\"4\":1}}],[\"主线程\",{\"1\":{\"200\":1}}],[\"主线程拥有地址空间和资源\",{\"1\":{\"194\":1}}],[\"主动向消费者推消息\",{\"1\":{\"160\":1}}],[\"主题操作\",{\"1\":{\"157\":1}}],[\"主题\",{\"1\":{\"157\":1}}],[\"主流的\",{\"1\":{\"157\":1}}],[\"主流的注册中心有\",{\"1\":{\"155\":1}}],[\"主流关系数据库\",{\"1\":{\"67\":1}}],[\"主要做如下三件事情\",{\"1\":{\"285\":1}}],[\"主要做了以下三件事\",{\"1\":{\"200\":1}}],[\"主要根据窗口大小来实时改变\",{\"1\":{\"284\":1}}],[\"主要功能点有\",{\"1\":{\"284\":1}}],[\"主要功能包括\",{\"1\":{\"157\":1}}],[\"主要也是因为笔者\",{\"1\":{\"283\":1}}],[\"主要目的是将标记阶段分开成多个小阶段\",{\"1\":{\"244\":1}}],[\"主要是笔者一直觉得\",{\"1\":{\"242\":1}}],[\"主要是为了保证领导者只能提交自己任期的日志\",{\"1\":{\"134\":1}}],[\"主要如下\",{\"1\":{\"241\":1}}],[\"主要负责\",{\"1\":{\"200\":1}}],[\"主要有如下几类对象\",{\"1\":{\"243\":1}}],[\"主要有如下几类元数据\",{\"1\":{\"155\":1}}],[\"主要有如下功能\",{\"1\":{\"112\":1}}],[\"主要分为三个部分\",{\"1\":{\"136\":1}}],[\"主要工作就是周期性的检查\",{\"1\":{\"131\":1}}],[\"主页\",{\"0\":{\"0\":1}}],[\"若有报文\",{\"1\":{\"279\":1}}],[\"若\",{\"1\":{\"241\":1}}],[\"若没有\",{\"1\":{\"241\":1}}],[\"若小于\",{\"1\":{\"134\":1}}],[\"若所有节点日志均已同步完成\",{\"1\":{\"129\":1}}],[\"若事务释放了一个数据的锁\",{\"1\":{\"85\":1}}],[\"若符合则取出值\",{\"1\":{\"79\":1}}],[\"若查询谓词为空\",{\"1\":{\"79\":1}}],[\"若结束\",{\"1\":{\"79\":1}}],[\"若需要\",{\"1\":{\"71\":1}}],[\"若节点\",{\"1\":{\"71\":1}}],[\"若是脏页\",{\"1\":{\"64\":1}}],[\"若无则淘汰一个页并且拿到该页\",{\"1\":{\"64\":1}}],[\"额外说明\",{\"1\":{\"64\":1}}],[\"刷新时间\",{\"1\":{\"285\":1}}],[\"刷新\",{\"1\":{\"136\":1}}],[\"刷盘线程\",{\"1\":{\"98\":1}}],[\"刷盘策略\",{\"1\":{\"98\":1}}],[\"刷盘\",{\"1\":{\"98\":1}}],[\"刷盘间隔\",{\"1\":{\"98\":1}}],[\"刷盘次数阈值\",{\"1\":{\"98\":1}}],[\"刷每一页\",{\"1\":{\"64\":1}}],[\"刷数据页\",{\"1\":{\"64\":1}}],[\"证明无法合并\",{\"1\":{\"282\":1}}],[\"证明函数\",{\"1\":{\"225\":1}}],[\"证明快照数据已经存在\",{\"1\":{\"136\":1}}],[\"证明快照数据中的日志\",{\"1\":{\"136\":1}}],[\"证明我已经快照过了\",{\"1\":{\"136\":1}}],[\"证明上一次快照已经包含了本次快照数据\",{\"1\":{\"136\":1}}],[\"证明日志任期无问题\",{\"1\":{\"134\":1}}],[\"证明有人正在使用\",{\"1\":{\"64\":1}}],[\"证明这个operation已经过期了\",{\"1\":{\"28\":1}}],[\"重发后\",{\"1\":{\"284\":1}}],[\"重试失败的时机下调用即可\",{\"1\":{\"285\":1}}],[\"重试发送\",{\"1\":{\"285\":1}}],[\"重试次数超过了默认次数\",{\"1\":{\"285\":1}}],[\"重试次数\",{\"1\":{\"284\":1}}],[\"重试时间\",{\"1\":{\"284\":1}}],[\"重试一次就\",{\"1\":{\"284\":1}}],[\"重载了<\",{\"1\":{\"282\":1}}],[\"重载\",{\"1\":{\"282\":1}}],[\"重传\",{\"1\":{\"278\":1}}],[\"重写\",{\"1\":{\"226\":1}}],[\"重写为\",{\"1\":{\"225\":1}}],[\"重复\",{\"1\":{\"282\":1}}],[\"重复等问题\",{\"1\":{\"273\":1}}],[\"重复步骤\",{\"1\":{\"244\":1}}],[\"重复指令的精简\",{\"1\":{\"218\":1}}],[\"重复这个过程\",{\"1\":{\"73\":2}}],[\"重构再通过测试用例\",{\"1\":{\"168\":1}}],[\"重构方便\",{\"1\":{\"168\":1}}],[\"重构是否过度\",{\"1\":{\"165\":1}}],[\"重构循环\",{\"1\":{\"164\":1}}],[\"重构循环中的重构就是解决架构问题的\",{\"1\":{\"164\":1}}],[\"重构循环来不断推进代码\",{\"1\":{\"164\":1}}],[\"重构要求在功能不变的前提下\",{\"1\":{\"164\":1}}],[\"重构中\",{\"1\":{\"164\":1}}],[\"重构生产代码\",{\"1\":{\"164\":1}}],[\"重新发送\",{\"1\":{\"284\":1}}],[\"重新发送最早的包\",{\"1\":{\"284\":1}}],[\"重新从\",{\"1\":{\"283\":1}}],[\"重新放入池中\",{\"1\":{\"262\":1}}],[\"重新生成新的\",{\"1\":{\"225\":1}}],[\"重新编译\",{\"1\":{\"213\":1}}],[\"重新审视\",{\"1\":{\"192\":1}}],[\"重新请求zk获取地址信息\",{\"1\":{\"148\":1}}],[\"重新订阅\",{\"1\":{\"148\":1}}],[\"重新拥有\",{\"1\":{\"123\":1}}],[\"重新\",{\"1\":{\"98\":1}}],[\"重新建立图\",{\"1\":{\"88\":1}}],[\"重做操作并将数据库恢复到崩溃前的状态\",{\"1\":{\"92\":1}}],[\"重点在于\",{\"1\":{\"272\":1}}],[\"重点在于搜索时根据操作类型来选择锁的方式\",{\"1\":{\"73\":1}}],[\"重点\",{\"1\":{\"200\":2}}],[\"重点阐述如何实现\",{\"1\":{\"8\":1}}],[\"重组器判断报文头字节序号与\",{\"1\":{\"282\":1}}],[\"重组节点\",{\"1\":{\"282\":1}}],[\"重组乱序的报文数据\",{\"1\":{\"282\":1}}],[\"重组报文数据而来\",{\"1\":{\"279\":1}}],[\"重组\",{\"1\":{\"72\":3,\"283\":1}}],[\"重组后为\",{\"1\":{\"72\":1}}],[\"重组过程比较简单\",{\"1\":{\"72\":1}}],[\"重置\",{\"1\":{\"64\":1}}],[\"寻找节点尝试合并数据重复的节点\",{\"1\":{\"282\":1}}],[\"寻找包含\",{\"1\":{\"70\":1}}],[\"寻找新的\",{\"1\":{\"64\":1}}],[\"寻找数据页\",{\"1\":{\"64\":1}}],[\"寻找\",{\"1\":{\"64\":1,\"71\":1}}],[\"查看字节流的前\",{\"1\":{\"281\":1}}],[\"查看其说明\",{\"1\":{\"64\":1}}],[\"查询内核镜像\",{\"1\":{\"291\":1}}],[\"查询到对应的\",{\"1\":{\"241\":1}}],[\"查询条件等\",{\"1\":{\"79\":1}}],[\"查询数据组织方式\",{\"1\":{\"79\":1}}],[\"查询\",{\"1\":{\"77\":1,\"157\":1}}],[\"查询计划\",{\"1\":{\"77\":1,\"78\":1,\"79\":1,\"89\":1}}],[\"查询过程中\",{\"1\":{\"73\":1}}],[\"查找store\",{\"1\":{\"30\":1,\"31\":1,\"32\":1}}],[\"查找等场景的性能要求\",{\"1\":{\"23\":1}}],[\"叫做帧\",{\"1\":{\"64\":1}}],[\"页之间的分裂与合并\",{\"1\":{\"241\":1}}],[\"页堆\",{\"1\":{\"241\":1}}],[\"页内存\",{\"1\":{\"241\":1}}],[\"页中\",{\"1\":{\"69\":1}}],[\"页类型\",{\"1\":{\"69\":1}}],[\"页表\",{\"1\":{\"64\":1,\"241\":1}}],[\"页将其保存在链表头部\",{\"1\":{\"63\":1}}],[\"暂不支持\",{\"1\":{\"219\":2}}],[\"暂不关注\",{\"1\":{\"64\":1}}],[\"暂时不做延伸\",{\"1\":{\"278\":1}}],[\"暂时无法应用在实际场景\",{\"1\":{\"241\":1}}],[\"暂时并未实现\",{\"1\":{\"58\":1}}],[\"暂时没有\",{\"1\":{\"58\":1}}],[\"表明当前没有可用的元素\",{\"1\":{\"261\":1}}],[\"表明当前变量只在自己的文件中生效\",{\"1\":{\"255\":1}}],[\"表格第一行是通用寄存器的真实名称\",{\"1\":{\"250\":1}}],[\"表\",{\"1\":{\"84\":1}}],[\"表迭代器\",{\"1\":{\"79\":1}}],[\"表示需要等待\",{\"1\":{\"285\":1}}],[\"表示输出流已经完全被对端接收且确认\",{\"1\":{\"285\":1}}],[\"表示输入流结束\",{\"1\":{\"285\":1}}],[\"表示字节在数据流中的序号\",{\"1\":{\"283\":1}}],[\"表示字符串长度\",{\"1\":{\"257\":1}}],[\"表示字符串长度为\",{\"1\":{\"257\":1}}],[\"表示该数据流不能存储超过容量的字节数\",{\"1\":{\"281\":1}}],[\"表示该函数跳过堆栈溢出的检查\",{\"1\":{\"256\":1}}],[\"表示仅在当前包可用\",{\"1\":{\"257\":1}}],[\"表示变量偏移\",{\"1\":{\"257\":1}}],[\"表示变量大小\",{\"1\":{\"255\":1}}],[\"表示返回值大小为\",{\"1\":{\"257\":1}}],[\"表示返回值大小\",{\"1\":{\"256\":1}}],[\"表示栈帧大小\",{\"1\":{\"256\":1}}],[\"表示包名\",{\"1\":{\"256\":1}}],[\"表示函数名\",{\"1\":{\"256\":1}}],[\"表示一些标志\",{\"1\":{\"255\":1}}],[\"表示是变量值\",{\"1\":{\"255\":1}}],[\"表示是否脏页\",{\"1\":{\"64\":1}}],[\"表示相对于符号的偏移\",{\"1\":{\"255\":1}}],[\"表示符号\",{\"1\":{\"255\":1}}],[\"表示四个字节\",{\"1\":{\"252\":1}}],[\"表示移动一个字节\",{\"1\":{\"252\":1}}],[\"表示分配堆内存\",{\"1\":{\"237\":1}}],[\"表示存储但未被初始化的全局变量和静态变量\",{\"1\":{\"232\":1}}],[\"表示出栈\",{\"1\":{\"218\":1}}],[\"表示入栈\",{\"1\":{\"218\":1}}],[\"表示第\",{\"1\":{\"218\":1}}],[\"表示使用go内置的链接器\",{\"1\":{\"217\":1}}],[\"表示进程正在运行\",{\"1\":{\"194\":1}}],[\"表示节点的逻辑时钟\",{\"1\":{\"124\":1}}],[\"表示死亡\",{\"1\":{\"123\":1}}],[\"表示\",{\"1\":{\"114\":1,\"129\":1,\"199\":3,\"253\":1,\"255\":1,\"283\":2}}],[\"表示当前数据是\",{\"1\":{\"114\":1}}],[\"表示当前元素在\",{\"1\":{\"114\":1}}],[\"表示当前缓存池还有多少帧是空闲的\",{\"1\":{\"64\":1}}],[\"表示全表扫描查询计划\",{\"1\":{\"79\":1}}],[\"表示内部节点中值上存储页\",{\"1\":{\"69\":1}}],[\"表示树中的每个节点最多只能有\",{\"1\":{\"68\":1}}],[\"表示在1之后插入2\",{\"1\":{\"25\":1}}],[\"表数据\",{\"1\":{\"64\":1}}],[\"加法\",{\"1\":{\"218\":1}}],[\"加法函数\",{\"1\":{\"179\":1}}],[\"加载立即数\",{\"1\":{\"218\":1}}],[\"加工阶段\",{\"0\":{\"184\":1,\"188\":1},\"1\":{\"182\":1}}],[\"加了一层代理服务\",{\"1\":{\"105\":1}}],[\"加上事务隔离级别的判断\",{\"1\":{\"89\":1}}],[\"加入全局链表后即可入栈\",{\"1\":{\"243\":1}}],[\"加入\",{\"1\":{\"138\":1,\"200\":1,\"243\":1}}],[\"加入日志完整度判断\",{\"1\":{\"132\":1}}],[\"加入后等待\",{\"1\":{\"88\":1}}],[\"加入到运行队列中\",{\"1\":{\"200\":1}}],[\"加入到节点头部\",{\"1\":{\"72\":1}}],[\"加入到空闲列表\",{\"1\":{\"64\":1}}],[\"加入到\",{\"1\":{\"63\":1,\"64\":1,\"200\":1}}],[\"加入到第一个operation的succ中\",{\"1\":{\"35\":1}}],[\"加入到最后一个operation的succ中\",{\"1\":{\"32\":1}}],[\"加读锁\",{\"1\":{\"73\":1}}],[\"加独占锁\",{\"1\":{\"73\":5}}],[\"加共享锁\",{\"1\":{\"73\":1}}],[\"加锁后\",{\"1\":{\"86\":1}}],[\"加锁\",{\"1\":{\"63\":3,\"64\":3,\"73\":1,\"86\":2}}],[\"约束\",{\"1\":{\"63\":1}}],[\"约定\",{\"1\":{\"25\":1}}],[\"故是线程\",{\"1\":{\"198\":1,\"203\":1}}],[\"故不能合并\",{\"1\":{\"72\":1}}],[\"故每个函数操作都需加锁\",{\"1\":{\"63\":1}}],[\"故障恢复\",{\"1\":{\"59\":1}}],[\"故障恢复模块\",{\"1\":{\"59\":1}}],[\"返回当前接受者的窗口大小\",{\"1\":{\"283\":1}}],[\"返回确认序号\",{\"1\":{\"283\":1}}],[\"返回池中一个\",{\"1\":{\"262\":1}}],[\"返回该块的地址即可\",{\"1\":{\"240\":1}}],[\"返回值然后生成对应的\",{\"1\":{\"219\":1}}],[\"返回新的切片\",{\"1\":{\"208\":1}}],[\"返回新的stream\",{\"1\":{\"187\":1}}],[\"返回给调用者\",{\"1\":{\"261\":1}}],[\"返回给应用程序\",{\"1\":{\"197\":1}}],[\"返回给领导者\",{\"1\":{\"137\":1}}],[\"返回到中断处理函数\",{\"1\":{\"197\":1}}],[\"返回即可\",{\"1\":{\"187\":1}}],[\"返回一个新的数据流\",{\"1\":{\"177\":1}}],[\"返回固定值\",{\"1\":{\"164\":1}}],[\"返回\",{\"1\":{\"63\":1,\"64\":3,\"79\":2,\"130\":1,\"218\":1,\"238\":1}}],[\"返回最后一个operation的value\",{\"1\":{\"30\":1,\"34\":1}}],[\"淘汰\",{\"1\":{\"64\":1}}],[\"淘汰一个页\",{\"1\":{\"63\":1}}],[\"淘汰策略中删除一个页\",{\"1\":{\"63\":1}}],[\"淘汰策略\",{\"0\":{\"63\":1},\"1\":{\"63\":1}}],[\"淘汰算法lru\",{\"1\":{\"59\":1}}],[\"目标地址在右侧\",{\"1\":{\"252\":1}}],[\"目标很明确\",{\"1\":{\"219\":1}}],[\"目标文件\",{\"1\":{\"217\":1}}],[\"目标与评估\",{\"1\":{\"162\":1}}],[\"目标和路径是什么\",{\"1\":{\"162\":1}}],[\"目标\",{\"0\":{\"102\":1}}],[\"目录下存在新的可执行文件\",{\"1\":{\"294\":1}}],[\"目录获取实现类并加载应用即可\",{\"1\":{\"151\":1}}],[\"目录\",{\"1\":{\"59\":5,\"79\":1}}],[\"目前来说\",{\"1\":{\"294\":1}}],[\"目前最著名的当属\",{\"1\":{\"278\":1}}],[\"目前很多脚本语言都加入了即时编译的新特性\",{\"1\":{\"218\":1}}],[\"目前标准库是没有提供相关的实现\",{\"1\":{\"177\":1}}],[\"目前序列化成熟方案有很多\",{\"1\":{\"147\":1}}],[\"目前是最著名的分布式共识性算法\",{\"1\":{\"121\":1}}],[\"目前\",{\"1\":{\"56\":1}}],[\"目前分布式系统普遍是\",{\"1\":{\"8\":1}}],[\"└──\",{\"1\":{\"59\":2,\"79\":1,\"257\":2,\"280\":1}}],[\"索引元数据\",{\"1\":{\"79\":1}}],[\"索引数据都会通过缓存管理器来管理\",{\"1\":{\"64\":1}}],[\"索引\",{\"1\":{\"59\":1}}],[\"│\",{\"1\":{\"59\":4,\"257\":2}}],[\"├──\",{\"1\":{\"59\":11,\"79\":9,\"257\":3,\"280\":11}}],[\"锁住\",{\"1\":{\"200\":2}}],[\"锁优化等\",{\"1\":{\"151\":1}}],[\"锁升级和解锁等操作\",{\"1\":{\"88\":1}}],[\"锁多的先淘汰\",{\"1\":{\"87\":1}}],[\"锁可分为如下两种类型\",{\"1\":{\"86\":1}}],[\"锁是为了解决不同事务并发操作的隔离性问题\",{\"1\":{\"86\":1}}],[\"锁的\",{\"1\":{\"73\":1}}],[\"锁管理器维护了一个\",{\"1\":{\"88\":1}}],[\"锁管理器会赋予事务锁\",{\"1\":{\"88\":1}}],[\"锁管理器在内部维护一个名为\",{\"1\":{\"87\":1}}],[\"锁管理器在内部维护了事务锁表\",{\"1\":{\"86\":1}}],[\"锁管理器授予事务锁\",{\"1\":{\"86\":1}}],[\"锁管理器的执行机制如下\",{\"1\":{\"86\":1}}],[\"锁管理器负责向事务授予锁\",{\"1\":{\"85\":1}}],[\"锁管理器实现\",{\"1\":{\"59\":1}}],[\"锁管理器\",{\"0\":{\"86\":1},\"1\":{\"59\":1,\"82\":1,\"88\":1}}],[\"锁\",{\"1\":{\"58\":1,\"63\":1,\"64\":1,\"86\":1,\"123\":1}}],[\"日志长度\",{\"1\":{\"136\":1}}],[\"日志经过快照后\",{\"1\":{\"136\":1}}],[\"日志切片序号与日志序号会有不兼容问题\",{\"1\":{\"136\":1}}],[\"日志切片会发生截断\",{\"1\":{\"136\":1}}],[\"日志切片的第一个作为占位使用\",{\"1\":{\"128\":1}}],[\"日志范围就变成为\",{\"1\":{\"136\":1}}],[\"日志进行快照后\",{\"1\":{\"136\":1}}],[\"日志只能以追加方式进行操作\",{\"1\":{\"135\":1}}],[\"日志数据\",{\"1\":{\"133\":1}}],[\"日志数据不变\",{\"1\":{\"127\":1}}],[\"日志序号\",{\"1\":{\"131\":1,\"136\":1}}],[\"日志命令\",{\"1\":{\"131\":1}}],[\"日志应用号通过\",{\"1\":{\"136\":1}}],[\"日志应用\",{\"0\":{\"131\":1}}],[\"日志提交序号\",{\"1\":{\"129\":1}}],[\"日志冲突序号\",{\"1\":{\"134\":1}}],[\"日志冲突任期\",{\"1\":{\"134\":1}}],[\"日志冲突\",{\"1\":{\"129\":1}}],[\"日志内容\",{\"1\":{\"128\":1}}],[\"日志任期\",{\"1\":{\"128\":1}}],[\"日志可以看作是一个不断增加的数组\",{\"1\":{\"127\":1}}],[\"日志压缩\",{\"1\":{\"121\":1}}],[\"日志同步和快照\",{\"1\":{\"139\":1}}],[\"日志同步可能与快照之间相互冲突\",{\"1\":{\"137\":1}}],[\"日志同步均已完成\",{\"1\":{\"132\":1}}],[\"日志同步主要工作可总结如下\",{\"1\":{\"132\":1}}],[\"日志同步是领导者独有的功能\",{\"1\":{\"129\":1}}],[\"日志同步是领导者独有的权利\",{\"1\":{\"126\":1}}],[\"日志同步也需要与其它节点进行沟通\",{\"1\":{\"126\":1}}],[\"日志同步要解决如下两个问题\",{\"1\":{\"126\":1}}],[\"日志同步\",{\"0\":{\"126\":1},\"1\":{\"121\":1,\"123\":1}}],[\"日志和恢复\",{\"0\":{\"91\":1,\"92\":1}}],[\"日志记录\",{\"1\":{\"59\":1}}],[\"日志管理器\",{\"1\":{\"58\":1,\"59\":1,\"64\":1}}],[\"日志\",{\"0\":{\"93\":1,\"127\":1},\"1\":{\"58\":3,\"126\":1,\"129\":1,\"134\":1,\"286\":1}}],[\"负责从输出流中读取数据并打包为\",{\"1\":{\"284\":1}}],[\"负责从输出流中读取数据并打包发送\",{\"1\":{\"284\":1}}],[\"负责接收和缓存\",{\"1\":{\"284\":1}}],[\"负责接收报文工作\",{\"1\":{\"285\":1}}],[\"负责接收报文\",{\"1\":{\"279\":1,\"283\":1}}],[\"负责重组\",{\"1\":{\"279\":1}}],[\"负责发送报文\",{\"1\":{\"279\":1}}],[\"负责实时监控对象数据信息\",{\"1\":{\"243\":1}}],[\"负责管理所有对象\",{\"1\":{\"243\":1}}],[\"负责管理当前\",{\"1\":{\"157\":1}}],[\"负责新建对象\",{\"1\":{\"243\":1}}],[\"负责任的说\",{\"1\":{\"223\":1}}],[\"负责协调多个\",{\"1\":{\"199\":1}}],[\"负责将消耗时间告诉\",{\"1\":{\"285\":1}}],[\"负责将队列中的报文拿出来\",{\"1\":{\"285\":1}}],[\"负责将\",{\"1\":{\"212\":1,\"285\":1}}],[\"负责将不同的序列化技术嵌套在框架中\",{\"1\":{\"143\":1}}],[\"负责将通道中发送日志数据\",{\"1\":{\"139\":1}}],[\"负责请求数据的转码封装等作用\",{\"1\":{\"143\":1}}],[\"负责在集群目标服务中的调用筛选策略\",{\"1\":{\"143\":1}}],[\"负责执行一些自定义的过滤链路\",{\"1\":{\"143\":1}}],[\"负责执行查询\",{\"1\":{\"58\":1}}],[\"负责对报文数据进行重组\",{\"1\":{\"279\":1}}],[\"负责对底层调用细节的封装\",{\"1\":{\"143\":1}}],[\"负责对维护事务与数据表记录之间的锁联系\",{\"1\":{\"88\":1}}],[\"负责维护连接\",{\"1\":{\"279\":1}}],[\"负责维护\",{\"1\":{\"64\":1}}],[\"负责缓存数据页\",{\"1\":{\"64\":1}}],[\"负责分配缓存池的组件被称为缓存管理器\",{\"1\":{\"62\":1}}],[\"负责向磁盘写数据页\",{\"1\":{\"58\":1}}],[\"更换阿里源\",{\"1\":{\"295\":1}}],[\"更深入地了解\",{\"1\":{\"245\":1}}],[\"更直观\",{\"1\":{\"245\":1}}],[\"更棘手的是\",{\"1\":{\"238\":1}}],[\"更像是一种\",{\"1\":{\"219\":1}}],[\"更加适合字符串\",{\"1\":{\"207\":1}}],[\"更加完善\",{\"1\":{\"130\":1}}],[\"更改\",{\"1\":{\"77\":1}}],[\"更改都读写磁盘\",{\"1\":{\"58\":1}}],[\"更新自己的\",{\"1\":{\"129\":1}}],[\"更新了\",{\"1\":{\"86\":1,\"136\":1}}],[\"更新数据的一个基本执行单元\",{\"1\":{\"83\":1}}],[\"更新父节点指针\",{\"1\":{\"72\":1}}],[\"更新doc的length和vector\",{\"1\":{\"26\":1}}],[\"更新和删除操作\",{\"1\":{\"4\":2}}],[\"更新\",{\"1\":{\"4\":1,\"64\":3,\"71\":1,\"73\":1,\"129\":2,\"134\":2,\"281\":1,\"283\":1}}],[\"更新sstable列表\",{\"1\":{\"4\":1}}],[\"解放了我们的双手\",{\"1\":{\"242\":1}}],[\"解析成功\",{\"1\":{\"227\":1}}],[\"解析阶段\",{\"1\":{\"226\":1}}],[\"解析得到表达式\",{\"1\":{\"174\":1}}],[\"解析完成后在sqlsession中解释执行\",{\"1\":{\"174\":1}}],[\"解析器\",{\"1\":{\"58\":2,\"77\":1}}],[\"解锁\",{\"1\":{\"88\":1,\"200\":1}}],[\"解决构建\",{\"1\":{\"295\":1}}],[\"解决丢失\",{\"1\":{\"273\":1}}],[\"解决了基本的内存问题\",{\"1\":{\"235\":1}}],[\"解决了数据持久化和日志冲突问题后\",{\"1\":{\"135\":1}}],[\"解决问题的途径是什么\",{\"1\":{\"162\":1}}],[\"解决日志部分冲突的问题\",{\"1\":{\"129\":1}}],[\"解决死锁的方法有两种\",{\"1\":{\"87\":1}}],[\"解决办法\",{\"1\":{\"86\":1}}],[\"解决方案是检测\",{\"1\":{\"85\":1}}],[\"解决方案是\",{\"1\":{\"85\":1}}],[\"解释一下最复杂的integrate\",{\"1\":{\"26\":1}}],[\"图转化为对应平台的机器码\",{\"1\":{\"227\":1}}],[\"图中底部的菱形图标就是\",{\"1\":{\"243\":1}}],[\"图中划红线的字段暂时不需要\",{\"1\":{\"124\":1}}],[\"图中的节点是事务\",{\"1\":{\"87\":1}}],[\"图\",{\"1\":{\"58\":1,\"64\":2,\"68\":4,\"69\":1,\"71\":5,\"72\":6,\"73\":2,\"79\":1,\"87\":1}}],[\"图数据库\",{\"1\":{\"56\":1}}],[\"究竟有哪些模块\",{\"1\":{\"58\":1}}],[\"整数对象入栈\",{\"1\":{\"243\":1}}],[\"整数转化为字符串的方式有多种\",{\"1\":{\"213\":1}}],[\"整个过程都是在测试驱动下完成的\",{\"1\":{\"165\":1}}],[\"整个框架的每个模块都有调用错误\",{\"1\":{\"150\":1}}],[\"整个insert的核心是integrate\",{\"1\":{\"47\":1}}],[\"整体流程如下图所示\",{\"1\":{\"244\":1}}],[\"整体的翻译代码如下\",{\"1\":{\"218\":1}}],[\"整体代码如下\",{\"1\":{\"218\":1}}],[\"整体把握\",{\"1\":{\"200\":1}}],[\"整体上\",{\"1\":{\"153\":1}}],[\"整体设计\",{\"0\":{\"142\":1}}],[\"整体如下\",{\"1\":{\"103\":1}}],[\"整体架构后\",{\"1\":{\"59\":1}}],[\"整体架构图如下\",{\"1\":{\"58\":1}}],[\"整体架构\",{\"0\":{\"58\":1,\"103\":1}}],[\"代表着\",{\"1\":{\"181\":1}}],[\"代表该item是游离节点\",{\"1\":{\"50\":1}}],[\"代理的仓储服务\",{\"1\":{\"164\":1}}],[\"代理\",{\"1\":{\"151\":1}}],[\"代理层封装方法\",{\"1\":{\"149\":1}}],[\"代理层旨在帮助开发者包装rpc接口调用参数\",{\"1\":{\"144\":1}}],[\"代理层\",{\"0\":{\"144\":1},\"1\":{\"143\":1}}],[\"代理节点开启后台线程定点检查注册信息是否存在和正确\",{\"1\":{\"112\":1}}],[\"代理节点宕机需手动更改地址\",{\"1\":{\"110\":1}}],[\"代理客户端\",{\"0\":{\"111\":1}}],[\"代理服务最大的特点是\",{\"1\":{\"112\":1}}],[\"代理服务是多个\",{\"1\":{\"105\":1}}],[\"代理服务\",{\"0\":{\"105\":1,\"112\":1}}],[\"代码上有详细的注释\",{\"1\":{\"285\":1}}],[\"代码的第\",{\"1\":{\"238\":1}}],[\"代码的时候\",{\"1\":{\"205\":1}}],[\"代码里\",{\"1\":{\"237\":1}}],[\"代码区的指令会自动根据\",{\"1\":{\"232\":1}}],[\"代码区\",{\"1\":{\"232\":1}}],[\"代码易读\",{\"1\":{\"226\":1}}],[\"代码编译为可执行文件即可\",{\"1\":{\"219\":1}}],[\"代码编写一样\",{\"1\":{\"214\":1}}],[\"代码翻译为字节码\",{\"1\":{\"218\":1}}],[\"代码也会被打包进执行文件\",{\"1\":{\"217\":1}}],[\"代码一起编译\",{\"1\":{\"212\":1}}],[\"代码包内以小写字母开头的函数\",{\"1\":{\"206\":1}}],[\"代码如下\",{\"1\":{\"200\":2,\"207\":1}}],[\"代码说明如下\",{\"1\":{\"200\":1}}],[\"代码段\",{\"1\":{\"197\":1}}],[\"代码直接参考这里\",{\"1\":{\"169\":1}}],[\"代码写完了不代表功能完成了\",{\"1\":{\"168\":1}}],[\"代码写完后\",{\"1\":{\"168\":1}}],[\"代码质量\",{\"1\":{\"165\":1}}],[\"代码分层是一种很好的模式\",{\"1\":{\"165\":1}}],[\"代码由少变多\",{\"1\":{\"165\":1}}],[\"代码变更\",{\"1\":{\"164\":1}}],[\"代码实现\",{\"1\":{\"140\":1}}],[\"代码实现如下\",{\"1\":{\"133\":1}}],[\"代码第\",{\"1\":{\"129\":1,\"134\":1,\"136\":2,\"200\":33,\"238\":2,\"257\":4}}],[\"代码\",{\"1\":{\"124\":2,\"129\":8,\"134\":3,\"136\":5,\"197\":1,\"200\":2,\"210\":1,\"223\":1}}],[\"代码结构设计\",{\"1\":{\"168\":1}}],[\"代码结构规整\",{\"1\":{\"164\":1}}],[\"代码结构\",{\"0\":{\"59\":1}}],[\"代码虽然开源\",{\"1\":{\"56\":1}}],[\"开辟新的\",{\"1\":{\"260\":1}}],[\"开辟内存\",{\"1\":{\"234\":1}}],[\"开启几万个乃至十万个都没啥问题\",{\"1\":{\"264\":1}}],[\"开启监控线程\",{\"1\":{\"200\":1}}],[\"开启\",{\"1\":{\"200\":1,\"291\":1}}],[\"开启调度循环\",{\"1\":{\"200\":1}}],[\"开启调度\",{\"1\":{\"200\":1}}],[\"开发者还需抉择内存是在堆上分配\",{\"1\":{\"234\":1}}],[\"开发者必须手动调用\",{\"1\":{\"234\":1}}],[\"开发者在服务端只需定义\",{\"1\":{\"144\":1}}],[\"开发门槛高\",{\"1\":{\"144\":1}}],[\"开源的一款内存分配器\",{\"1\":{\"241\":1}}],[\"开源的一款分布式\",{\"1\":{\"107\":1}}],[\"开源|如何开发一个高性能的\",{\"1\":{\"119\":1}}],[\"开源于\",{\"1\":{\"56\":1}}],[\"开始编译内核\",{\"1\":{\"291\":1}}],[\"开始监听\",{\"1\":{\"286\":1}}],[\"开始标记时\",{\"1\":{\"244\":1}}],[\"开始时\",{\"1\":{\"227\":1}}],[\"开始执行\",{\"1\":{\"200\":1}}],[\"开始工作时\",{\"1\":{\"243\":1}}],[\"开始工作的真正入口点\",{\"1\":{\"200\":1}}],[\"开始工作\",{\"1\":{\"200\":1}}],[\"开始等待空闲\",{\"1\":{\"200\":1}}],[\"开始设置\",{\"1\":{\"200\":1}}],[\"开始一个事务\",{\"1\":{\"85\":1}}],[\"开始一个新的事务\",{\"1\":{\"4\":1}}],[\"开始\",{\"1\":{\"73\":1,\"85\":1,\"127\":1,\"200\":3,\"243\":1,\"283\":3}}],[\"开始加共享锁\",{\"1\":{\"73\":1}}],[\"开始梦游了\",{\"1\":{\"4\":1}}],[\"相等\",{\"1\":{\"254\":2}}],[\"相信入手也很快\",{\"1\":{\"248\":1}}],[\"相信你能从中自己发掘出答案\",{\"1\":{\"56\":1}}],[\"相互协助让\",{\"1\":{\"231\":1}}],[\"相互绑定\",{\"1\":{\"200\":2}}],[\"相对于fset的position\",{\"1\":{\"219\":2}}],[\"相对简单\",{\"1\":{\"165\":1}}],[\"相加后将结果再入栈\",{\"1\":{\"218\":1}}],[\"相应地\",{\"1\":{\"135\":1}}],[\"相较于\",{\"1\":{\"284\":1}}],[\"相较于使用\",{\"1\":{\"190\":1}}],[\"相较于查询\",{\"1\":{\"71\":1}}],[\"相较于磁盘而言\",{\"1\":{\"63\":1}}],[\"相比\",{\"1\":{\"17\":1}}],[\"执行完后再来判断\",{\"1\":{\"227\":1}}],[\"执行完毕后退出\",{\"1\":{\"200\":1}}],[\"执行体等节点\",{\"1\":{\"227\":1}}],[\"执行到\",{\"1\":{\"227\":2}}],[\"执行结果如下\",{\"1\":{\"217\":1}}],[\"执行后\",{\"1\":{\"212\":1}}],[\"执行的上下文\",{\"1\":{\"199\":1}}],[\"执行表达式\",{\"1\":{\"174\":1}}],[\"执行\",{\"1\":{\"79\":1,\"89\":1,\"200\":3}}],[\"执行计划\",{\"0\":{\"79\":1}}],[\"执行上下文\",{\"1\":{\"78\":1}}],[\"执行期实现\",{\"1\":{\"59\":1}}],[\"执行模块\",{\"1\":{\"59\":1}}],[\"执行器运行流程图如图\",{\"1\":{\"79\":1}}],[\"执行器执行时从上下文中获取查询所需的环境\",{\"1\":{\"79\":1}}],[\"执行器需访问数据页\",{\"1\":{\"79\":1}}],[\"执行器上下文上保存了执行器所需的环境\",{\"1\":{\"79\":1}}],[\"执行器可以拥有子执行器\",{\"1\":{\"78\":1}}],[\"执行器都会返回一条数据记录\",{\"1\":{\"78\":1}}],[\"执行器根据执行计划中过滤条件筛选数据返回给应用程序\",{\"1\":{\"58\":1}}],[\"执行器根据执行计划\",{\"1\":{\"58\":1}}],[\"执行器\",{\"0\":{\"76\":1,\"77\":1,\"89\":1},\"1\":{\"58\":1,\"59\":1,\"79\":1}}],[\"执行器究竟是如何实现的\",{\"1\":{\"56\":1}}],[\"执行op即可\",{\"1\":{\"10\":1}}],[\"缓冲池策略\",{\"1\":{\"92\":1}}],[\"缓冲池管理器\",{\"1\":{\"79\":1}}],[\"缓冲池是如何实现的\",{\"1\":{\"56\":1}}],[\"缓存发送但没有被确认的报文\",{\"1\":{\"284\":1}}],[\"缓存了一定\",{\"1\":{\"263\":1}}],[\"缓存等技术\",{\"1\":{\"260\":1}}],[\"缓存\",{\"1\":{\"152\":1}}],[\"缓存集群负责处理\",{\"1\":{\"106\":1}}],[\"缓存服务也需要将自己地址\",{\"1\":{\"113\":1}}],[\"缓存服务主要有如下功能\",{\"1\":{\"113\":1}}],[\"缓存服务通过哈希槽方式来实现分片\",{\"1\":{\"106\":1}}],[\"缓存服务是\",{\"1\":{\"106\":1}}],[\"缓存服务\",{\"0\":{\"106\":1,\"113\":1}}],[\"缓存服务集群\",{\"1\":{\"103\":1}}],[\"缓存分片信息重度冗余在客户端等\",{\"1\":{\"105\":1}}],[\"缓存的淘汰策略就名存实亡了\",{\"1\":{\"64\":1}}],[\"缓存中没有\",{\"1\":{\"64\":1}}],[\"缓存中已有\",{\"1\":{\"64\":1}}],[\"缓存池中的页\",{\"1\":{\"64\":1}}],[\"缓存池中的基本单位是页\",{\"1\":{\"62\":1}}],[\"缓存池大小\",{\"1\":{\"64\":2}}],[\"缓存池\",{\"0\":{\"61\":1,\"62\":1,\"262\":1},\"1\":{\"59\":2,\"62\":1,\"262\":1}}],[\"缓存模块\",{\"1\":{\"59\":1}}],[\"缓存淘汰等操作\",{\"1\":{\"58\":1}}],[\"缓存管理器是内存\",{\"1\":{\"64\":1}}],[\"缓存管理器内存\",{\"1\":{\"64\":1}}],[\"缓存管理器负责将新数据页刷新到磁盘中\",{\"1\":{\"64\":1}}],[\"缓存管理器负责协同内存\",{\"1\":{\"64\":1}}],[\"缓存管理器会调用\",{\"1\":{\"63\":1}}],[\"缓存管理器会将其从缓存池中淘汰\",{\"1\":{\"63\":1}}],[\"缓存管理器判断数据页是否已在缓存中\",{\"1\":{\"58\":1}}],[\"缓存管理器\",{\"0\":{\"64\":1},\"1\":{\"58\":1}}],[\"缓存可以放在内存中\",{\"1\":{\"4\":1}}],[\"缓存操作\",{\"1\":{\"4\":1}}],[\"鲜有去教开发者如何去弄懂数据库系统架构设计\",{\"1\":{\"56\":1}}],[\"书籍\",{\"1\":{\"56\":1}}],[\"关闭连接\",{\"1\":{\"285\":1}}],[\"关闭定时器\",{\"1\":{\"284\":2}}],[\"关闭\",{\"1\":{\"264\":1}}],[\"关注核心竞争力\",{\"1\":{\"162\":1}}],[\"关注服务的上下线\",{\"1\":{\"143\":1}}],[\"关键字来直接开辟协程\",{\"1\":{\"264\":1}}],[\"关键字大量分配内存\",{\"1\":{\"238\":1}}],[\"关键字转化为字符串方便\",{\"1\":{\"227\":1}}],[\"关键字解析\",{\"1\":{\"227\":1}}],[\"关键字是否成功\",{\"1\":{\"227\":1}}],[\"关键字就顺利完成了\",{\"1\":{\"225\":1}}],[\"关键字本身可以视为\",{\"1\":{\"225\":1}}],[\"关键字\",{\"1\":{\"225\":1,\"227\":5}}],[\"关键字开启的一个协程\",{\"1\":{\"131\":1}}],[\"关键字开启的一个死循环\",{\"1\":{\"124\":1}}],[\"关键是日志切片序号与日志序号发生了脱离\",{\"1\":{\"138\":1}}],[\"关系数据库的设计与实现\",{\"1\":{\"56\":1}}],[\"关系数据库\",{\"1\":{\"56\":1}}],[\"关于这二者的细节\",{\"1\":{\"275\":1}}],[\"关于在\",{\"1\":{\"265\":1}}],[\"关于上面代码的说明已经写在了注释中了\",{\"1\":{\"197\":1}}],[\"关于异步生产暂未实现\",{\"1\":{\"159\":1}}],[\"关于\",{\"1\":{\"13\":1,\"52\":1,\"208\":1,\"226\":1,\"227\":1,\"264\":1,\"283\":1,\"285\":1}}],[\"掘金\",{\"1\":{\"53\":1,\"119\":2}}],[\"右孩子节点大于等于当前\",{\"1\":{\"70\":1}}],[\"右边\",{\"1\":{\"68\":1}}],[\"右插入意图相同\",{\"1\":{\"51\":1}}],[\"右链接\",{\"1\":{\"43\":1}}],[\"遵循lww\",{\"1\":{\"50\":1}}],[\"功能之完善\",{\"1\":{\"228\":1}}],[\"功能函数\",{\"1\":{\"164\":1}}],[\"功能是否\",{\"1\":{\"164\":1}}],[\"功能\",{\"1\":{\"49\":1,\"114\":1}}],[\"三次握手全部完成\",{\"1\":{\"286\":1}}],[\"三次握手第三步\",{\"1\":{\"286\":3}}],[\"三次握手第一步\",{\"1\":{\"286\":3}}],[\"三次握手第二步\",{\"1\":{\"286\":3}}],[\"三次握手流程如下\",{\"1\":{\"272\":1}}],[\"三色不变性来实现并发\",{\"1\":{\"245\":1}}],[\"三色标记\",{\"1\":{\"245\":1}}],[\"三色标记法是标记清理法的一个改进算法\",{\"1\":{\"244\":1}}],[\"三色标记法\",{\"0\":{\"244\":1},\"1\":{\"242\":1,\"244\":1,\"245\":1}}],[\"三大模块\",{\"1\":{\"245\":1}}],[\"三方内存管理库\",{\"1\":{\"236\":1}}],[\"三方支付场景\",{\"1\":{\"164\":1}}],[\"三家争霸\",{\"1\":{\"228\":1}}],[\"三个字节\",{\"1\":{\"283\":1}}],[\"三个字段\",{\"1\":{\"133\":1}}],[\"三个标记法将对象抽象为\",{\"1\":{\"244\":1}}],[\"三个结构体\",{\"1\":{\"199\":1}}],[\"三个部分说明如下\",{\"1\":{\"199\":1}}],[\"三个部分的组合\",{\"1\":{\"199\":1}}],[\"三个状态\",{\"1\":{\"125\":1}}],[\"三种状态\",{\"1\":{\"123\":1}}],[\"三种范型参数\",{\"1\":{\"69\":1}}],[\"三种数据类型\",{\"1\":{\"49\":1}}],[\"三条规则\",{\"0\":{\"43\":1}}],[\"纯文本\",{\"1\":{\"49\":1}}],[\"纯文本本质上和\",{\"1\":{\"27\":1}}],[\"支持节点有序化\",{\"1\":{\"282\":1}}],[\"支持计算指令直接在寄存器上进行数据操作\",{\"1\":{\"253\":1}}],[\"支持的汇编语言\",{\"1\":{\"212\":1}}],[\"支持我们将泛型定义为接口再使用\",{\"1\":{\"179\":1}}],[\"支持从xml配置构建sqlsessionfactory\",{\"1\":{\"169\":1}}],[\"支持后\",{\"1\":{\"157\":1}}],[\"支持客户端\",{\"1\":{\"149\":1}}],[\"支持事务等多种特性\",{\"1\":{\"107\":1}}],[\"支持海量数据扩容\",{\"1\":{\"107\":1}}],[\"支持基本\",{\"1\":{\"103\":1}}],[\"支持代理模式自动切换\",{\"1\":{\"102\":1}}],[\"支持脚本事务\",{\"1\":{\"102\":1}}],[\"支持哈希槽分片\",{\"1\":{\"102\":1}}],[\"支持大容量缓存\",{\"1\":{\"102\":1}}],[\"支持\",{\"0\":{\"174\":1},\"1\":{\"69\":1,\"102\":1,\"111\":1,\"227\":2,\"251\":1,\"254\":1}}],[\"支持数据库事务\",{\"1\":{\"58\":1}}],[\"支持ymap\",{\"1\":{\"49\":1}}],[\"支持两种\",{\"1\":{\"27\":1}}],[\"新的\",{\"1\":{\"218\":1}}],[\"新的提交日志序号的任期必须与节点当前任期一致\",{\"1\":{\"134\":1}}],[\"新领导者的日志与现有节点日志有很多冲突\",{\"1\":{\"129\":1}}],[\"新版本会覆盖旧版本的值\",{\"1\":{\"127\":1}}],[\"新建了对象\",{\"1\":{\"244\":1}}],[\"新建了\",{\"1\":{\"243\":1}}],[\"新建对象\",{\"1\":{\"243\":1}}],[\"新建对象都必须通过\",{\"1\":{\"243\":1}}],[\"新建的\",{\"1\":{\"202\":1}}],[\"新建一个\",{\"1\":{\"200\":1,\"207\":1}}],[\"新建一个页\",{\"1\":{\"64\":1}}],[\"新建线程\",{\"1\":{\"198\":1}}],[\"新建协程写数据\",{\"1\":{\"188\":1}}],[\"新建configparser类\",{\"1\":{\"172\":1}}],[\"新建sqlsessionfactory类\",{\"1\":{\"170\":1}}],[\"新建sqlsessionfactorybuilder类\",{\"1\":{\"170\":1}}],[\"新建sqlsessionfactorybuilder解析配置文件\",{\"1\":{\"170\":1}}],[\"新建build方法\",{\"1\":{\"170\":1}}],[\"新建\",{\"1\":{\"71\":1,\"159\":1,\"160\":1,\"200\":2,\"251\":1,\"286\":1,\"291\":1}}],[\"新建数据页\",{\"1\":{\"64\":2}}],[\"新建doc时\",{\"1\":{\"26\":1}}],[\"新访问\",{\"1\":{\"63\":1}}],[\"新增命令\",{\"1\":{\"295\":1}}],[\"新增对\",{\"1\":{\"227\":1}}],[\"新增关键字后再次生成\",{\"1\":{\"227\":1}}],[\"新增关键字\",{\"0\":{\"222\":1}}],[\"新增一个系统调用定义\",{\"1\":{\"294\":1}}],[\"新增一个可用的关键字竟如此简单\",{\"1\":{\"226\":1}}],[\"新增一个\",{\"1\":{\"217\":1}}],[\"新增注册\",{\"1\":{\"151\":1}}],[\"新增spi插件\",{\"1\":{\"151\":1}}],[\"新增了\",{\"1\":{\"136\":1}}],[\"新增\",{\"1\":{\"63\":1,\"227\":5}}],[\"新增的originright\",{\"1\":{\"48\":1}}],[\"双方进入可靠通信阶段\",{\"1\":{\"286\":1}}],[\"双方三次握手的过程\",{\"1\":{\"286\":1}}],[\"双方都全部完成了数据交付和接收\",{\"1\":{\"285\":1}}],[\"双方拥有独立的序号\",{\"1\":{\"275\":1}}],[\"双方达成一致\",{\"1\":{\"48\":1}}],[\"双端过滤器责任链\",{\"1\":{\"149\":1}}],[\"双向链表\",{\"1\":{\"63\":1}}],[\"双向链表显然无法满足大文本编辑\",{\"1\":{\"23\":1}}],[\"且被确认\",{\"1\":{\"286\":1}}],[\"且处于\",{\"1\":{\"286\":1}}],[\"且发送空包\",{\"1\":{\"286\":1}}],[\"且超时时间\",{\"1\":{\"284\":1}}],[\"且还有包未确认\",{\"1\":{\"284\":1}}],[\"且包长度小于窗口大小\",{\"1\":{\"284\":1}}],[\"且流已经\",{\"1\":{\"284\":1}}],[\"且重试次数为\",{\"1\":{\"284\":1}}],[\"且重试时间是依次递增\",{\"1\":{\"284\":1}}],[\"且重置\",{\"1\":{\"123\":1}}],[\"且数据流关闭\",{\"1\":{\"283\":1}}],[\"且数据基本单位是页\",{\"1\":{\"64\":1}}],[\"且本地没有\",{\"1\":{\"283\":1}}],[\"且向数据流中写入\",{\"1\":{\"283\":1}}],[\"且为空\",{\"1\":{\"282\":1}}],[\"且为根节点\",{\"1\":{\"73\":1}}],[\"且颜色变为黑色\",{\"1\":{\"244\":1}}],[\"且其引用对象也已经扫描\",{\"1\":{\"244\":1}}],[\"且其算法是标记清理算法\",{\"1\":{\"242\":1}}],[\"且其兄弟节点\",{\"1\":{\"72\":1}}],[\"且这些页的\",{\"1\":{\"241\":1}}],[\"且都已经被分配\",{\"1\":{\"240\":1}}],[\"且大小不够\",{\"1\":{\"240\":1}}],[\"且未分配的块\",{\"1\":{\"240\":1}}],[\"且不可达\",{\"1\":{\"244\":1}}],[\"且不可被打断\",{\"1\":{\"244\":1}}],[\"且不为空时\",{\"1\":{\"225\":1}}],[\"且不能加读锁\",{\"1\":{\"89\":1}}],[\"且在当前文件夹下有\",{\"1\":{\"219\":1}}],[\"且在进程中的堆上开辟\",{\"1\":{\"194\":1}}],[\"且传入的参数是否正确\",{\"1\":{\"164\":1}}],[\"且\",{\"1\":{\"136\":1,\"283\":1}}],[\"且每个节点都有\",{\"1\":{\"131\":1}}],[\"且日志是只可追加的\",{\"1\":{\"127\":1}}],[\"且拥有选票\",{\"1\":{\"124\":1}}],[\"且任期+1\",{\"1\":{\"123\":1}}],[\"且无\",{\"1\":{\"284\":1}}],[\"且无需被\",{\"1\":{\"238\":1}}],[\"且无法加读锁\",{\"1\":{\"89\":1}}],[\"且无任何子节点\",{\"1\":{\"72\":1}}],[\"且事务处于\",{\"1\":{\"88\":1}}],[\"且多个操作不可分割\",{\"1\":{\"83\":1}}],[\"且共享锁是共享的\",{\"1\":{\"73\":1}}],[\"且所有节点无需变更\",{\"1\":{\"73\":1}}],[\"且已经没有子节点了\",{\"1\":{\"72\":1}}],[\"且有一个孩子节点\",{\"1\":{\"72\":1}}],[\"且也处于半满状态\",{\"1\":{\"72\":1}}],[\"且只有一个子节点\",{\"1\":{\"72\":1}}],[\"且后面不会再变化\",{\"1\":{\"48\":1}}],[\"且3的id大\",{\"1\":{\"48\":1}}],[\"且o1​在左边\",{\"1\":{\"43\":1}}],[\"优秀的设计不止这一点\",{\"1\":{\"241\":1}}],[\"优于\",{\"1\":{\"213\":1}}],[\"优于已有的\",{\"1\":{\"23\":1}}],[\"优先保证质量和速度\",{\"1\":{\"165\":1}}],[\"优先级\",{\"1\":{\"162\":1}}],[\"优点\",{\"1\":{\"144\":1,\"147\":1}}],[\"优化后\",{\"1\":{\"218\":1,\"227\":1}}],[\"优化序列化\",{\"1\":{\"151\":1}}],[\"优化冲突同步\",{\"0\":{\"134\":1}}],[\"优化点\",{\"1\":{\"98\":1}}],[\"优化器\",{\"1\":{\"77\":1}}],[\"优化器等\",{\"1\":{\"58\":1}}],[\"优化并得到该语句的\",{\"1\":{\"77\":1}}],[\"优化版\",{\"0\":{\"48\":1}}],[\"满足查询条件\",{\"1\":{\"79\":1}}],[\"满足则后移\",{\"1\":{\"47\":1}}],[\"满足规则\",{\"1\":{\"44\":3}}],[\"版上\",{\"1\":{\"224\":1}}],[\"版实现了论文原有的插入算法\",{\"1\":{\"48\":1}}],[\"版\",{\"0\":{\"47\":1}}],[\"版本自举后\",{\"1\":{\"228\":1}}],[\"版本\",{\"1\":{\"27\":1}}],[\"介绍为内核线程\",{\"1\":{\"199\":1}}],[\"介绍\",{\"0\":{\"121\":1}}],[\"介绍事务基本概念后\",{\"1\":{\"85\":1}}],[\"介绍完\",{\"1\":{\"45\":1,\"241\":1}}],[\"介绍了其基本原理和实现\",{\"1\":{\"38\":1}}],[\"使代码更易维护和阅读\",{\"1\":{\"279\":1}}],[\"使其支持\",{\"1\":{\"227\":1}}],[\"使其摆脱\",{\"1\":{\"217\":1}}],[\"使其成为一个真正的系统级编程语言呢\",{\"1\":{\"217\":1}}],[\"使其满足规则\",{\"1\":{\"44\":2}}],[\"使我们无法直接操纵内存\",{\"1\":{\"217\":1}}],[\"使\",{\"1\":{\"181\":1}}],[\"使用最广泛的传输层网络协议\",{\"1\":{\"270\":1}}],[\"使用了一个动态大小的\",{\"1\":{\"261\":1}}],[\"使用了状态机来保证相同日志被应用不同节点后\",{\"1\":{\"128\":1}}],[\"使用一个栈专门用来存储灰色对象\",{\"1\":{\"244\":1}}],[\"使用寄存器来传参后\",{\"1\":{\"218\":1}}],[\"使用寄存器来暂存局部变量\",{\"1\":{\"218\":1}}],[\"使用工具\",{\"1\":{\"217\":3}}],[\"使用的也是这种方法\",{\"1\":{\"213\":1}}],[\"使用查表法\",{\"1\":{\"213\":1}}],[\"使用go\",{\"1\":{\"208\":1}}],[\"使用权转交给\",{\"1\":{\"200\":1}}],[\"使用权交给了\",{\"1\":{\"200\":1}}],[\"使用权交给\",{\"1\":{\"200\":1}}],[\"使用反汇编工具来查看一下生成的汇编代码\",{\"1\":{\"180\":1}}],[\"使用\",{\"0\":{\"286\":1,\"290\":1},\"1\":{\"122\":1,\"165\":1,\"177\":1,\"188\":1,\"200\":1,\"207\":1,\"212\":1,\"213\":2,\"217\":5,\"218\":1,\"219\":1,\"252\":1,\"256\":1,\"283\":2}}],[\"使用简单\",{\"1\":{\"102\":1}}],[\"使用锁来保护数据对象\",{\"1\":{\"86\":1}}],[\"使用二分查找从sstable中查询指定键的值\",{\"1\":{\"4\":2}}],[\"左孩子节点小于当前\",{\"1\":{\"70\":1}}],[\"左边\",{\"1\":{\"68\":1}}],[\"左边相邻的操作项oi​\",{\"1\":{\"43\":1}}],[\"左右连线指向当前相邻的字符\",{\"1\":{\"43\":1}}],[\"很可能整个业务的大部分耗时都花在了创建连接上\",{\"1\":{\"260\":1}}],[\"很重的原因\",{\"1\":{\"217\":1}}],[\"很有用的\",{\"1\":{\"204\":1}}],[\"很多人将三次握手\",{\"1\":{\"270\":1}}],[\"很多人都会不知所云\",{\"1\":{\"245\":1}}],[\"很多语言搭上了\",{\"1\":{\"219\":1}}],[\"很多同学会不会疑惑多此一举\",{\"1\":{\"218\":1}}],[\"很多地方将\",{\"1\":{\"199\":1}}],[\"很多时候因为测试的复杂性而选择放弃测试\",{\"1\":{\"165\":1}}],[\"很少有人在一个事务过程中\",{\"1\":{\"84\":1}}],[\"很简单\",{\"1\":{\"69\":1,\"284\":1}}],[\"很好理解\",{\"1\":{\"43\":1}}],[\"很明显由于直接使用寄存器相加\",{\"1\":{\"256\":1}}],[\"很明显\",{\"1\":{\"26\":1,\"220\":1}}],[\"该流由\",{\"1\":{\"279\":1}}],[\"该流负责接收程序写入的数据\",{\"1\":{\"279\":1}}],[\"该类主要维护\",{\"1\":{\"279\":1}}],[\"该元素会从\",{\"1\":{\"261\":1}}],[\"该块是否使用\",{\"1\":{\"240\":1}}],[\"该指令接受两个参数\",{\"1\":{\"207\":1}}],[\"该线程的调用栈分明是在用户地址空间分配的\",{\"1\":{\"199\":1}}],[\"该结构体的定义如下\",{\"1\":{\"194\":1}}],[\"该函数在一次\",{\"1\":{\"262\":1}}],[\"该函数在\",{\"1\":{\"257\":1}}],[\"该函数对应的汇编代码如下\",{\"1\":{\"256\":1}}],[\"该函数有多种实现\",{\"1\":{\"203\":1}}],[\"该函数有一个泛型参数\",{\"1\":{\"181\":1}}],[\"该函数代码如下\",{\"1\":{\"200\":1}}],[\"该函数永远不会返回\",{\"1\":{\"200\":1}}],[\"该函数如下\",{\"1\":{\"200\":1}}],[\"该函数会新建一个\",{\"1\":{\"200\":1}}],[\"该函数会向其它节点发送\",{\"1\":{\"124\":1}}],[\"该函数功能很复杂\",{\"1\":{\"200\":1}}],[\"该函数拥有两个泛型参数\",{\"1\":{\"181\":1}}],[\"该方法接收四个参数\",{\"1\":{\"78\":1}}],[\"该锁确实可以保证树在多线程是数据安全的\",{\"1\":{\"73\":1}}],[\"该页可能会被替换\",{\"1\":{\"64\":1}}],[\"该页\",{\"1\":{\"64\":1}}],[\"该页不再受\",{\"1\":{\"63\":1}}],[\"该论文不仅贡献了\",{\"1\":{\"41\":1}}],[\"该字典的键是事务的标识符\",{\"1\":{\"4\":1}}],[\"富文本实现可参考peritext\",{\"1\":{\"37\":1}}],[\"那\",{\"1\":{\"255\":1}}],[\"那为什么还要再谈\",{\"1\":{\"242\":1}}],[\"那是因为自动内存管理依赖于手动内存管理\",{\"1\":{\"242\":1}}],[\"那是因为如果\",{\"1\":{\"136\":1}}],[\"那些最值得尝试\",{\"1\":{\"162\":1}}],[\"那些\",{\"1\":{\"155\":1}}],[\"那就意味着有\",{\"1\":{\"240\":1}}],[\"那就是缓存\",{\"1\":{\"241\":1}}],[\"那就是直接通过\",{\"1\":{\"238\":1}}],[\"那就是\",{\"1\":{\"225\":1}}],[\"那就是在运行时生成机器码\",{\"1\":{\"218\":1}}],[\"那就是跳转到\",{\"1\":{\"200\":1}}],[\"那就成为\",{\"1\":{\"129\":1,\"133\":1}}],[\"那就没那么简单了\",{\"1\":{\"37\":1}}],[\"那个\",{\"1\":{\"123\":1}}],[\"那么只应该等待\",{\"1\":{\"285\":1}}],[\"那么只需要共享锁\",{\"1\":{\"73\":1}}],[\"那么准备关闭连接\",{\"1\":{\"285\":1}}],[\"那么为什么这里的\",{\"1\":{\"294\":1}}],[\"那么为什么需要发送空包呢\",{\"1\":{\"285\":1}}],[\"那么为什么要说是铺垫呢\",{\"1\":{\"245\":1}}],[\"那么为什么要发送\",{\"1\":{\"126\":1}}],[\"那么填充\",{\"1\":{\"285\":1}}],[\"那么所有\",{\"1\":{\"285\":1}}],[\"那么无法接受\",{\"1\":{\"285\":1}}],[\"那么发送\",{\"1\":{\"285\":2}}],[\"那么调用\",{\"1\":{\"285\":2}}],[\"那么不能对超时时间进行翻倍\",{\"1\":{\"284\":1}}],[\"那么不可能找到另外一个oi​比o1​大\",{\"1\":{\"43\":1}}],[\"那么表示包被确认了\",{\"1\":{\"284\":1}}],[\"那么必须至少回复一个报文\",{\"1\":{\"285\":1}}],[\"那么必须重置超时时间为最初超时时间\",{\"1\":{\"284\":1}}],[\"那么必须为\",{\"1\":{\"284\":1}}],[\"那么必须得拿到数据才能验证\",{\"1\":{\"164\":1}}],[\"那么作为最后一个包发送\",{\"1\":{\"284\":1}}],[\"那么作为\",{\"1\":{\"284\":1}}],[\"那么本次将忽略\",{\"1\":{\"283\":1}}],[\"那么本文可能不适合你\",{\"1\":{\"56\":1}}],[\"那么可能会产生一个问题\",{\"1\":{\"283\":1}}],[\"那么可以尝试这样使用\",{\"1\":{\"210\":1}}],[\"那么依次合并节点\",{\"1\":{\"282\":1}}],[\"那么截取\",{\"1\":{\"282\":1}}],[\"那么接收的为最后一个字符串\",{\"1\":{\"282\":1}}],[\"那么丢弃掉数据\",{\"1\":{\"282\":1}}],[\"那么等于窗口大小\",{\"1\":{\"281\":1}}],[\"那么需要一个同包同文件名且同名的函数来与之对应\",{\"1\":{\"257\":1}}],[\"那么需要依次遍历日志\",{\"1\":{\"129\":1}}],[\"那么它所对应的\",{\"1\":{\"241\":1}}],[\"那么块\",{\"1\":{\"240\":1}}],[\"那么服务就无法服务用户\",{\"1\":{\"238\":1}}],[\"那么会重复执行\",{\"1\":{\"227\":1}}],[\"那么也无法接收\",{\"1\":{\"283\":1}}],[\"那么也能执行\",{\"1\":{\"227\":1}}],[\"那么也必须对兄弟节点加独占锁\",{\"1\":{\"73\":1}}],[\"那么实现起来也就不会难了\",{\"1\":{\"217\":1}}],[\"那么自然就能摆脱掉\",{\"1\":{\"217\":1}}],[\"那么最好的方法肯定是从根源入手\",{\"1\":{\"217\":1}}],[\"那么最后必然会搜索到叶子结点上\",{\"1\":{\"68\":1}}],[\"那么有没有方案能让\",{\"1\":{\"217\":1}}],[\"那么有没有一种方式可以回避掉\",{\"1\":{\"212\":1}}],[\"那么有何关联了\",{\"1\":{\"130\":1}}],[\"那么请随我一起来回顾回顾\",{\"1\":{\"192\":1}}],[\"那么泛型t是如何实现支持多种数据类型的呢\",{\"1\":{\"180\":1}}],[\"那么写在函数上面也不太好看\",{\"1\":{\"179\":1}}],[\"那么测试上下文\",{\"1\":{\"165\":1}}],[\"那么在\",{\"1\":{\"203\":1}}],[\"那么在生产时可以适当重构后即可交付\",{\"1\":{\"165\":1}}],[\"那么在counter这个简单案例中\",{\"1\":{\"10\":1}}],[\"那么我们就可以使用伦敦学派进行\",{\"1\":{\"164\":1}}],[\"那么我们必须引入数据库\",{\"1\":{\"164\":1}}],[\"那么成本再低也是无意义的\",{\"1\":{\"164\":1}}],[\"那么行为测试我们可以这样写\",{\"1\":{\"164\":1}}],[\"那么客户端此时的请求很可能会失败\",{\"1\":{\"150\":1}}],[\"那么是不够快的\",{\"1\":{\"136\":1}}],[\"那么是不是隔离级别越高越好了\",{\"1\":{\"84\":1}}],[\"那么从日志尾部向头部遍历\",{\"1\":{\"134\":1}}],[\"那么设置冲突任期为当前节点序号的任期\",{\"1\":{\"134\":1}}],[\"那么冲突序号就是日志大小\",{\"1\":{\"134\":1}}],[\"那么如何不等待了\",{\"1\":{\"285\":1}}],[\"那么如何定义对象是否为垃圾呢\",{\"1\":{\"243\":1}}],[\"那么如何实现\",{\"1\":{\"225\":1}}],[\"那么如何保证代码质量呢\",{\"1\":{\"165\":1}}],[\"那么如何解决这个问题呢\",{\"1\":{\"135\":1}}],[\"那么如何应用了\",{\"1\":{\"131\":1}}],[\"那么如果某一条数据被修改了很多次\",{\"1\":{\"135\":1}}],[\"那么如果集群中的节点发生了宕机\",{\"1\":{\"132\":1}}],[\"那么如果是删除则复杂一些\",{\"1\":{\"73\":1}}],[\"那么任期号大的日志新\",{\"1\":{\"130\":1}}],[\"那么前面的日志一定是匹配的\",{\"1\":{\"129\":1}}],[\"那么数据的可见性由何种机制来保证了\",{\"1\":{\"128\":1}}],[\"那么日志中存在了该数据的多个版本\",{\"1\":{\"135\":1}}],[\"那么日志比较长的那个就新\",{\"1\":{\"130\":1}}],[\"那么日志\",{\"1\":{\"127\":1}}],[\"那么领导者如何知道追随者日志的同步情况了\",{\"1\":{\"126\":1}}],[\"那么领导者如何向其它节点宣示自己的地位了\",{\"1\":{\"125\":1}}],[\"那么追随者会认为领导者\",{\"1\":{\"126\":1}}],[\"那么立马成为追随者并返回\",{\"1\":{\"124\":1}}],[\"那么仍然可以为请求者投票\",{\"1\":{\"124\":1}}],[\"那么当前节点立马成为追随者\",{\"1\":{\"124\":1}}],[\"那么节点就会自动从追随者切换到协调者\",{\"1\":{\"124\":1}}],[\"那么节点大小必须\",{\"1\":{\"73\":3}}],[\"那么这个序号与绝对\",{\"1\":{\"283\":1}}],[\"那么这个栈在什么地方了\",{\"1\":{\"194\":1}}],[\"那么这个追随者是如何超时成为协调者的呢\",{\"1\":{\"124\":1}}],[\"那么这些\",{\"1\":{\"69\":1}}],[\"那么这些put操作的pred和succ就会形成一个双链表\",{\"1\":{\"28\":1}}],[\"那么直接停止等待\",{\"1\":{\"88\":1}}],[\"那么直接返回\",{\"1\":{\"88\":1,\"129\":1,\"137\":1,\"282\":1,\"283\":1,\"284\":2}}],[\"那么直接\",{\"1\":{\"88\":2}}],[\"那么又该如何保证事务之间不发生数据冲突了\",{\"1\":{\"85\":1}}],[\"那么结束\",{\"1\":{\"79\":1}}],[\"那么继续向下搜索\",{\"1\":{\"73\":1}}],[\"那么释放父节点锁\",{\"1\":{\"73\":1}}],[\"那么性能将是十分的低下\",{\"1\":{\"73\":1}}],[\"那么对父节点仍然递归的执行\",{\"1\":{\"72\":1}}],[\"那么对于这样的节点\",{\"1\":{\"72\":1}}],[\"那么重新申请一个页作为新的根节点\",{\"1\":{\"71\":1}}],[\"那么将关闭计时器\",{\"1\":{\"284\":1}}],[\"那么将不能接受\",{\"1\":{\"136\":1}}],[\"那么将不能接受选票\",{\"1\":{\"124\":1}}],[\"那么将一直持有整条路线上的锁\",{\"1\":{\"73\":1}}],[\"那么将\",{\"1\":{\"71\":1}}],[\"那么将新建一棵\",{\"1\":{\"71\":1}}],[\"那么新建\",{\"1\":{\"71\":1}}],[\"那么向父节点中加入指向\",{\"1\":{\"71\":1}}],[\"那么一定要\",{\"1\":{\"70\":1}}],[\"那么该报文被确认\",{\"1\":{\"284\":1}}],[\"那么该锁可以被其它事务获取\",{\"1\":{\"85\":1}}],[\"那么该查询计划又是如何被执行器执行的呢\",{\"1\":{\"79\":1}}],[\"那么该子节点成为新的根节点\",{\"1\":{\"72\":1}}],[\"那么该内部节点只有\",{\"1\":{\"68\":1}}],[\"那么该页就应该被加入到\",{\"1\":{\"64\":1}}],[\"那么证明有人正在使用该页\",{\"1\":{\"64\":1}}],[\"那么则需要淘汰一个页\",{\"1\":{\"64\":1}}],[\"那么链表尾部自然就成为了最近最少使用的页\",{\"1\":{\"63\":1}}],[\"那么希望你能耐心阅读完本文\",{\"1\":{\"56\":1}}],[\"那么o在this的左边\",{\"1\":{\"51\":1}}],[\"那么origin存在交叉\",{\"1\":{\"44\":1}}],[\"那么插入操作在任意副本都能收敛到全局有序\",{\"1\":{\"43\":1}}],[\"那么意图也就丢失了\",{\"1\":{\"25\":1}}],[\"那么按照siteid排序\",{\"1\":{\"25\":1}}],[\"那么按照counter排序\",{\"1\":{\"25\":1}}],[\"那么就开启计时\",{\"1\":{\"284\":1}}],[\"那么就需要几千万个周期\",{\"1\":{\"231\":1}}],[\"那么就需要淘汰一部分数据页将其刷到磁盘中\",{\"1\":{\"63\":1}}],[\"那么就会进入休眠\",{\"1\":{\"200\":1}}],[\"那么就会造成二者的数据不统一\",{\"1\":{\"136\":1}}],[\"那么就会造成很大的空间浪费\",{\"1\":{\"135\":1}}],[\"那么就只能新写一个函数了\",{\"1\":{\"179\":1}}],[\"那么就只能通过追加覆盖的方式\",{\"1\":{\"127\":1}}],[\"那么就得几百次试探\",{\"1\":{\"134\":1}}],[\"那么就投票给他\",{\"1\":{\"130\":1}}],[\"那么就不能使用这种方式进行动态代理\",{\"1\":{\"144\":1}}],[\"那么就不能产生编辑冲突\",{\"1\":{\"25\":1}}],[\"那么就不需要再次集成了\",{\"1\":{\"26\":1}}],[\"那么就按照字符\",{\"1\":{\"25\":1}}],[\"那么\",{\"1\":{\"16\":1,\"43\":1,\"44\":1,\"72\":1,\"84\":1,\"87\":1,\"94\":1,\"129\":1,\"130\":2,\"134\":1,\"217\":1,\"227\":1,\"231\":1,\"238\":1,\"262\":1,\"282\":1,\"283\":4,\"284\":1,\"285\":1,\"286\":1}}],[\"遍历对象图\",{\"1\":{\"243\":1}}],[\"遍历日志\",{\"1\":{\"129\":1}}],[\"遍历整个有序链表\",{\"1\":{\"43\":1}}],[\"遍历store\",{\"1\":{\"34\":1,\"35\":1,\"36\":1}}],[\"遍历文档树\",{\"1\":{\"26\":1}}],[\"变量仅当前包可用\",{\"1\":{\"257\":1}}],[\"变量名\",{\"1\":{\"257\":1}}],[\"变量存储在\",{\"1\":{\"255\":1}}],[\"变量定义\",{\"0\":{\"255\":1}}],[\"变量也极具攀升\",{\"1\":{\"234\":1}}],[\"变量\",{\"1\":{\"227\":3,\"257\":2}}],[\"变量是私有的\",{\"1\":{\"206\":1}}],[\"变量x在初始化时\",{\"1\":{\"16\":1}}],[\"变更\",{\"1\":{\"28\":1}}],[\"字符串\",{\"1\":{\"281\":1}}],[\"字符串内容\",{\"1\":{\"257\":1}}],[\"字符串长度\",{\"1\":{\"257\":1}}],[\"字符串拷贝到切片\",{\"1\":{\"207\":1}}],[\"字符串之间的数据\",{\"1\":{\"207\":1}}],[\"字符插入后\",{\"1\":{\"43\":1}}],[\"字节流等类将\",{\"1\":{\"279\":1}}],[\"字节等\",{\"1\":{\"241\":1}}],[\"字节\",{\"1\":{\"240\":3,\"241\":4,\"253\":1,\"255\":1}}],[\"字节码执行具有良好的跨平台性\",{\"1\":{\"218\":1}}],[\"字节码生成\",{\"1\":{\"144\":2}}],[\"字节切片\",{\"1\":{\"207\":1,\"262\":1}}],[\"字节处\",{\"1\":{\"200\":2}}],[\"字节对齐\",{\"1\":{\"200\":2}}],[\"字节的内存时被浪费的\",{\"1\":{\"240\":1}}],[\"字节的内存\",{\"1\":{\"240\":1}}],[\"字节的\",{\"1\":{\"114\":1}}],[\"字段用来缓存数据库连接\",{\"1\":{\"263\":1}}],[\"字段用来保存快照数据\",{\"1\":{\"136\":1}}],[\"字段没有设置\",{\"1\":{\"261\":1}}],[\"字段说明都已注明\",{\"1\":{\"243\":1}}],[\"字段被设置为\",{\"1\":{\"202\":1}}],[\"字段中\",{\"1\":{\"200\":1}}],[\"字段与线程局部变量绑定\",{\"1\":{\"200\":1}}],[\"字段地址拷贝到\",{\"1\":{\"200\":1}}],[\"字段地址存储到\",{\"1\":{\"200\":1}}],[\"字段来存储数据流\",{\"1\":{\"183\":1}}],[\"字段来选择序列化框架\",{\"1\":{\"147\":1}}],[\"字段来维护\",{\"1\":{\"69\":1}}],[\"字段需要与快照保持一致\",{\"1\":{\"136\":1}}],[\"字段为请求者\",{\"1\":{\"124\":1}}],[\"字段\",{\"1\":{\"114\":3,\"115\":1,\"116\":1,\"123\":1,\"194\":1,\"200\":2,\"207\":1,\"261\":2,\"279\":2,\"282\":1}}],[\"字段表示\",{\"1\":{\"114\":2,\"115\":1,\"116\":2}}],[\"字段才是真正的物理页数据\",{\"1\":{\"69\":1}}],[\"字段类型\",{\"1\":{\"59\":1}}],[\"字段分别标识操作的前驱\",{\"1\":{\"28\":1}}],[\"字典\",{\"1\":{\"4\":1}}],[\"上分别实现手动\",{\"1\":{\"236\":1}}],[\"上开源了一个名为xmm的\",{\"1\":{\"236\":1}}],[\"上发表了一篇名为go\",{\"1\":{\"236\":1}}],[\"上下载\",{\"1\":{\"224\":1}}],[\"上下文切换的\",{\"1\":{\"200\":1}}],[\"上述的两种方法都被\",{\"1\":{\"214\":1}}],[\"上执行\",{\"1\":{\"200\":1}}],[\"上\",{\"1\":{\"200\":2,\"204\":1,\"243\":1,\"286\":1,\"294\":1}}],[\"上正在运行的\",{\"1\":{\"198\":1}}],[\"上正在运行\",{\"1\":{\"198\":1}}],[\"上面代码已经对节点合并\",{\"1\":{\"282\":1}}],[\"上面的代码会将\",{\"1\":{\"227\":1}}],[\"上面的注释\",{\"1\":{\"48\":1}}],[\"上面这段代码则是在主线程栈中分配一段内存当作\",{\"1\":{\"200\":1}}],[\"上面\",{\"1\":{\"200\":1,\"270\":1}}],[\"上面是一段最基本的\",{\"1\":{\"197\":1}}],[\"上面我们就借助哈希表和环形切片来快速实现了数据去重\",{\"1\":{\"190\":1}}],[\"上线后思考\",{\"1\":{\"162\":1}}],[\"上线后获得了那些收益\",{\"1\":{\"162\":1}}],[\"上线后如何评估变更已生效\",{\"1\":{\"162\":1}}],[\"上线方案\",{\"1\":{\"162\":1}}],[\"上手简单\",{\"1\":{\"144\":1}}],[\"上层应用会调用\",{\"1\":{\"136\":1}}],[\"上层应用通过\",{\"1\":{\"136\":2}}],[\"上层应用发送快照数据给\",{\"1\":{\"136\":1}}],[\"上层服务接收到后\",{\"1\":{\"131\":1}}],[\"上一个包接受距现在时间\",{\"1\":{\"285\":1}}],[\"上一个紧接着\",{\"1\":{\"227\":1}}],[\"上一个\",{\"1\":{\"227\":1}}],[\"上一个应用的++\",{\"1\":{\"131\":1}}],[\"上一个同步日志序号超过了当前节点的日志大小\",{\"1\":{\"129\":1}}],[\"上一次收到\",{\"1\":{\"126\":2}}],[\"上一篇文章探讨了\",{\"1\":{\"41\":1}}],[\"上一篇文章我们介绍了\",{\"1\":{\"22\":1}}],[\"上所有的边\",{\"1\":{\"88\":1}}],[\"上的一个用户态可靠协议\",{\"1\":{\"278\":1}}],[\"上的系统调用通过\",{\"1\":{\"197\":1}}],[\"上的锁\",{\"1\":{\"73\":1,\"88\":1}}],[\"上的操作也需要保证并发安全\",{\"1\":{\"64\":1}}],[\"上图中key1下有两个item\",{\"1\":{\"50\":1}}],[\"上找到了以前的\",{\"1\":{\"27\":1}}],[\"保持对\",{\"1\":{\"192\":1}}],[\"保持一致选择\",{\"1\":{\"155\":1}}],[\"保证了\",{\"1\":{\"282\":1}}],[\"保证了代码质量和可测试性\",{\"1\":{\"165\":1}}],[\"保证每个序号的字节都交付\",{\"1\":{\"273\":1}}],[\"保证外部交互的一致性\",{\"1\":{\"206\":1}}],[\"保证获取到的一定最后n个元素\",{\"1\":{\"188\":1}}],[\"保证正确性的\",{\"1\":{\"164\":1}}],[\"保证鲁棒性\",{\"1\":{\"164\":1}}],[\"保证消息投递可靠性\",{\"1\":{\"159\":1}}],[\"保证数据库的高可用性\",{\"1\":{\"92\":1}}],[\"保证数据操作的原子性\",{\"1\":{\"58\":1}}],[\"保证前后数据的一致性\",{\"1\":{\"92\":1}}],[\"保证线程安全\",{\"1\":{\"64\":1}}],[\"保证文档有序的关键是保证插入操作有序\",{\"1\":{\"43\":1}}],[\"保证id小的在左边\",{\"1\":{\"26\":1}}],[\"保存并退出\",{\"1\":{\"291\":1}}],[\"保存\",{\"1\":{\"200\":1}}],[\"保存就行\",{\"1\":{\"113\":1}}],[\"保存所有变更操作\",{\"1\":{\"16\":1,\"18\":1}}],[\"保存当前减值状态\",{\"1\":{\"14\":1}}],[\"保存当前增值状态\",{\"1\":{\"14\":1}}],[\"找到下一个\",{\"1\":{\"282\":1}}],[\"找到出栈对象的所有引用\",{\"1\":{\"244\":1}}],[\"找到后将该块标记为已用\",{\"1\":{\"240\":1}}],[\"找到第一个\",{\"1\":{\"282\":1}}],[\"找到第一个大小合适\",{\"1\":{\"240\":1}}],[\"找到第index个item\",{\"1\":{\"34\":1,\"35\":1,\"36\":1}}],[\"找到当前运行\",{\"1\":{\"200\":1}}],[\"找到需求输入\",{\"1\":{\"164\":1}}],[\"找到冲突任期所在的最后一个日志序号\",{\"1\":{\"134\":1}}],[\"找到冲突日志\",{\"1\":{\"129\":1}}],[\"找到不冲突的起始序号\",{\"1\":{\"129\":1}}],[\"找到死锁\",{\"1\":{\"87\":1}}],[\"找到pos对应item然后标记isdeleted即可\",{\"1\":{\"47\":1}}],[\"找到pos位置的item\",{\"1\":{\"26\":1}}],[\"找到与prop之相关的所有operation\",{\"1\":{\"32\":1}}],[\"找到与prop相关的所有operation\",{\"1\":{\"30\":1,\"31\":1}}],[\"找到item的parent\",{\"1\":{\"26\":1}}],[\"找到i对应的位置\",{\"1\":{\"23\":1}}],[\"向服务端发送\",{\"1\":{\"286\":1}}],[\"向输出流写数据\",{\"1\":{\"285\":1}}],[\"向后一起合并了\",{\"1\":{\"282\":1}}],[\"向后合并\",{\"1\":{\"282\":1}}],[\"向字节流中写入数据\",{\"1\":{\"281\":1}}],[\"向客户端发送\",{\"1\":{\"272\":1}}],[\"向zk订阅\",{\"1\":{\"148\":1}}],[\"向zk注册\",{\"1\":{\"148\":1}}],[\"向提供者\",{\"1\":{\"148\":1}}],[\"向提供者发起请求\",{\"1\":{\"148\":1}}],[\"向前合并\",{\"1\":{\"282\":1}}],[\"向前\",{\"1\":{\"146\":1,\"282\":1}}],[\"向其它\",{\"1\":{\"136\":1}}],[\"向其它节点发送请求\",{\"1\":{\"124\":1}}],[\"向集群中的其它节点发送投票请求\",{\"1\":{\"123\":1}}],[\"向锁管理器请求\",{\"1\":{\"88\":1}}],[\"向下遍历\",{\"1\":{\"73\":1}}],[\"向叶子节点中插入\",{\"1\":{\"71\":1}}],[\"向根节点中插入数据\",{\"1\":{\"71\":1}}],[\"向\",{\"1\":{\"71\":1,\"239\":1,\"241\":1,\"243\":1}}],[\"向树中插入一个新数据\",{\"1\":{\"71\":1}}],[\"向外提供\",{\"1\":{\"69\":1}}],[\"向1插入了一个3\",{\"1\":{\"48\":1}}],[\"向量\",{\"1\":{\"47\":1}}],[\"向量时钟\",{\"1\":{\"13\":1}}],[\"向store中插入根节点\",{\"1\":{\"26\":1}}],[\"存在于进程地址空间中\",{\"1\":{\"237\":1}}],[\"存在不可解的\",{\"1\":{\"8\":1}}],[\"存储在\",{\"1\":{\"282\":1}}],[\"存储页\",{\"1\":{\"241\":1}}],[\"存储页数据的唯一途径\",{\"1\":{\"69\":1}}],[\"存储只读的机器指令\",{\"1\":{\"232\":1}}],[\"存储执行期间的局部变量\",{\"1\":{\"232\":1}}],[\"存储设备性能很高\",{\"1\":{\"231\":1}}],[\"存储设备类型的不同也会带来存储性能巨大的差异\",{\"1\":{\"231\":1}}],[\"存储到线程局部变量\",{\"1\":{\"200\":1}}],[\"存储了协程栈\",{\"1\":{\"199\":1}}],[\"存储\",{\"1\":{\"146\":1,\"200\":2,\"241\":1}}],[\"存储数据库\",{\"1\":{\"107\":1}}],[\"存储表\",{\"1\":{\"79\":1}}],[\"存储模块\",{\"1\":{\"59\":1}}],[\"存储管理和磁盘存储三大部分\",{\"1\":{\"58\":1}}],[\"存储item的map\",{\"1\":{\"26\":1}}],[\"标志位\",{\"1\":{\"256\":1}}],[\"标记了且出栈的对象才是黑色对象\",{\"1\":{\"244\":1}}],[\"标记了且在灰色栈中的对象是灰色\",{\"1\":{\"244\":1}}],[\"标记对象\",{\"1\":{\"243\":1}}],[\"标记对象是否存活\",{\"1\":{\"243\":1}}],[\"标记所有\",{\"1\":{\"243\":1,\"244\":1}}],[\"标记它们所有可达的对象\",{\"1\":{\"243\":1}}],[\"标记清理法\",{\"0\":{\"243\":1}}],[\"标记完成后\",{\"1\":{\"235\":1,\"243\":2}}],[\"标记出可达对象\",{\"1\":{\"235\":1}}],[\"标记\",{\"1\":{\"235\":1,\"243\":1,\"247\":1}}],[\"标记为灰色\",{\"1\":{\"244\":1}}],[\"标记为\",{\"1\":{\"240\":1}}],[\"标记为不可抢占\",{\"1\":{\"200\":1}}],[\"标记为删除状态\",{\"1\":{\"4\":1}}],[\"标准库中的\",{\"1\":{\"262\":1}}],[\"标准库中提供了一个通用的\",{\"1\":{\"261\":1}}],[\"标准库也用到了\",{\"1\":{\"261\":1}}],[\"标准库和\",{\"1\":{\"219\":1}}],[\"标准库提供的\",{\"1\":{\"207\":1,\"237\":1}}],[\"标准输出的编号\",{\"1\":{\"197\":1}}],[\"标识文档的开始\",{\"1\":{\"26\":1}}],[\"至容器\",{\"1\":{\"291\":1}}],[\"至少申请\",{\"1\":{\"241\":1}}],[\"至少在课程中\",{\"1\":{\"165\":1}}],[\"至于\",{\"1\":{\"218\":1}}],[\"至于删除\",{\"1\":{\"25\":1}}],[\"至此\",{\"1\":{\"13\":1,\"190\":1,\"214\":1,\"219\":1,\"228\":1,\"243\":1,\"244\":1,\"265\":1,\"286\":1}}],[\"第\",{\"1\":{\"136\":1,\"197\":2,\"257\":3}}],[\"第三版\",{\"0\":{\"99\":1}}],[\"第二行是\",{\"1\":{\"250\":1}}],[\"第二版\",{\"0\":{\"98\":1}}],[\"第二次查询却发现有\",{\"1\":{\"84\":1}}],[\"第二次是内部节点\",{\"1\":{\"71\":1}}],[\"第二部分是客户端操作的序号\",{\"1\":{\"25\":1}}],[\"第一次收到\",{\"1\":{\"283\":1}}],[\"第一次是叶子节点\",{\"1\":{\"71\":1}}],[\"第一时间就是初始化\",{\"1\":{\"129\":1}}],[\"第一版\",{\"0\":{\"97\":1}}],[\"第一个包必须携带\",{\"1\":{\"283\":1}}],[\"第一个接收的包一定包含了\",{\"1\":{\"283\":1}}],[\"第一个使用内存自动管理的语言是\",{\"1\":{\"235\":1}}],[\"第一个参数最后入栈\",{\"1\":{\"200\":1,\"251\":1}}],[\"第一个\",{\"1\":{\"200\":1}}],[\"第一个测试用例通过了\",{\"1\":{\"172\":1}}],[\"第一个日志序号应该是\",{\"1\":{\"136\":1}}],[\"第一个序号\",{\"1\":{\"136\":1}}],[\"第一个冲突节点是parent\",{\"1\":{\"51\":1}}],[\"第一个冲突节点是left\",{\"1\":{\"51\":1}}],[\"第一个插入operation的\",{\"1\":{\"37\":1}}],[\"第一部分是客户端的唯一标识符\",{\"1\":{\"25\":1}}],[\"第1项\",{\"1\":{\"34\":1}}],[\"第0项\",{\"1\":{\"34\":1}}],[\"虽然使用方便\",{\"1\":{\"277\":1}}],[\"虽然\",{\"1\":{\"273\":1}}],[\"虽然协程相对轻量\",{\"1\":{\"264\":1}}],[\"虽然它的核心实现是三色标记法\",{\"1\":{\"245\":1}}],[\"虽然它给自己投了\",{\"1\":{\"124\":1}}],[\"虽然目前有很多的\",{\"1\":{\"242\":1}}],[\"虽然好\",{\"1\":{\"242\":1}}],[\"虽然性能强劲\",{\"1\":{\"231\":1}}],[\"虽然这增加了实现的复杂性\",{\"1\":{\"273\":1}}],[\"虽然这一度让我怀疑这是垃圾回收的代码包\",{\"1\":{\"228\":1}}],[\"虽然这样可以传入任意类型的参数\",{\"1\":{\"179\":1}}],[\"虽然简单\",{\"1\":{\"218\":1}}],[\"虽然给了我们一座桥梁\",{\"1\":{\"210\":1}}],[\"虽然只是一个简单的\",{\"1\":{\"200\":1}}],[\"虽然行为验证的主要目的是降低测试成本\",{\"1\":{\"164\":1}}],[\"虽然一个服务会存在多个提供者\",{\"1\":{\"145\":1}}],[\"虽然也是上层应用来调用\",{\"1\":{\"136\":1}}],[\"虽然日志数据没有发生改变\",{\"1\":{\"127\":1}}],[\"虽然节点\",{\"1\":{\"72\":1}}],[\"虽然是物理页数据\",{\"1\":{\"69\":1}}],[\"虽然改成了双向链表\",{\"1\":{\"51\":1}}],[\"虽然携带了插入位置1和插入数据2\",{\"1\":{\"25\":1}}],[\"虽然无法直接用于生产\",{\"1\":{\"5\":1}}],[\"因而也称演进式设计\",{\"1\":{\"164\":1}}],[\"因而实际是一种架构技术\",{\"1\":{\"164\":1}}],[\"因而重构就无法进行\",{\"1\":{\"164\":1}}],[\"因为即使流结束了\",{\"1\":{\"285\":1}}],[\"因为对于远端的包\",{\"1\":{\"285\":1}}],[\"因为如果\",{\"1\":{\"285\":1}}],[\"因为可以同步\",{\"1\":{\"284\":1}}],[\"因为它实际上是一条很长的链路\",{\"1\":{\"241\":1}}],[\"因为或多或少的政治原因\",{\"1\":{\"228\":1}}],[\"因为堆是一段很大的地址空间\",{\"1\":{\"194\":1}}],[\"因为泛型的存在\",{\"1\":{\"181\":1}}],[\"因为代码的设计并没有考虑到测试用例\",{\"1\":{\"168\":1}}],[\"因为测试覆盖率高\",{\"1\":{\"165\":1}}],[\"因为我们把它遗忘了\",{\"1\":{\"131\":1}}],[\"因为他还未与任何节点同步成功过\",{\"1\":{\"129\":1}}],[\"因为领导者需要宣示自己的权利\",{\"1\":{\"126\":1}}],[\"因为再\",{\"1\":{\"85\":1}}],[\"因为字符3的origin是1\",{\"1\":{\"48\":1}}],[\"因为并发冲突都是在origin后发生的\",{\"1\":{\"47\":1}}],[\"因为墓碑机制的存在\",{\"1\":{\"47\":1}}],[\"因为list没有明确的key\",{\"1\":{\"33\":1}}],[\"因为\",{\"1\":{\"28\":1,\"88\":1,\"114\":1,\"136\":1,\"190\":1,\"227\":1,\"245\":1,\"282\":1}}],[\"因为有新的operation插入到了这个operation之后\",{\"1\":{\"28\":1}}],[\"因为两个插入操作的意图是一致的\",{\"1\":{\"25\":1}}],[\"因为1虽然是插入意图\",{\"1\":{\"25\":1}}],[\"因为只有客户端\",{\"1\":{\"25\":1}}],[\"因此这个状态属于被动关闭\",{\"1\":{\"285\":1}}],[\"因此这里选择使用栈来模拟\",{\"1\":{\"243\":1}}],[\"因此这里选择略过\",{\"1\":{\"241\":1}}],[\"因此这里才手动调用了\",{\"1\":{\"238\":1}}],[\"因此这里先将\",{\"1\":{\"225\":1}}],[\"因此这里不做过多介绍\",{\"1\":{\"218\":1}}],[\"因此这里借助一个转换asm2asm\",{\"1\":{\"212\":1}}],[\"因此这里有一步转换工作\",{\"1\":{\"212\":1}}],[\"因此这里没有额外实现\",{\"1\":{\"27\":1}}],[\"因此还可以发送的字节数\",{\"1\":{\"284\":1}}],[\"因此一次可能打包多个报文\",{\"1\":{\"284\":1}}],[\"因此一旦缓存池满了\",{\"1\":{\"63\":1}}],[\"因此为了解决\",{\"1\":{\"282\":1}}],[\"因此常常会有字节流乱序发生\",{\"1\":{\"274\":1}}],[\"因此参考线程池的使用方式\",{\"1\":{\"264\":1}}],[\"因此有很多三方库来解决这些问题\",{\"1\":{\"262\":1}}],[\"因此有不少优化版的\",{\"1\":{\"23\":1}}],[\"因此2\",{\"1\":{\"243\":1}}],[\"因此将其\",{\"1\":{\"243\":1}}],[\"因此将其称为泛型\",{\"1\":{\"179\":1}}],[\"因此对端已经不再接受包了\",{\"1\":{\"285\":1}}],[\"因此对象之间的引用关系\",{\"1\":{\"243\":1}}],[\"因此对于其它层协议不做详细介绍\",{\"1\":{\"270\":1}}],[\"因此对于追随者而言即使快照请求失败也不会有其它影响\",{\"1\":{\"136\":1}}],[\"因此对于领导者\",{\"1\":{\"136\":1}}],[\"因此对于并发连接的数据访问控制\",{\"1\":{\"85\":1}}],[\"因此寄存器\",{\"1\":{\"243\":1}}],[\"因此才写下这篇文章来龙去脉的来谈谈内存管理\",{\"1\":{\"242\":1}}],[\"因此关于它的其它用法\",{\"1\":{\"237\":1}}],[\"因此暂时无需考虑堆越界的问题\",{\"1\":{\"237\":1}}],[\"因此他们引入了纯自动内存管理的编程语言\",{\"1\":{\"234\":1}}],[\"因此他选择了\",{\"1\":{\"129\":1}}],[\"因此几乎所有编程语言都将内存管理内置到了语言中\",{\"1\":{\"233\":1}}],[\"因此笔者铺垫了大量的内存\",{\"1\":{\"245\":1}}],[\"因此笔者\",{\"1\":{\"231\":1}}],[\"因此笔者才没有说丢掉\",{\"1\":{\"217\":1}}],[\"因此新增\",{\"1\":{\"227\":1}}],[\"因此它们联合可以实现如下语句\",{\"1\":{\"227\":1}}],[\"因此判断不成立\",{\"1\":{\"225\":1}}],[\"因此工作线程\",{\"1\":{\"200\":1}}],[\"因此线程创建后会运行\",{\"1\":{\"198\":1,\"203\":1}}],[\"因此调有\",{\"1\":{\"198\":1}}],[\"因此两个\",{\"1\":{\"179\":1}}],[\"因此沉淀了大量的测试用例和测试代码\",{\"1\":{\"165\":1}}],[\"因此测试驱动开发在\",{\"1\":{\"164\":1}}],[\"因此此处\",{\"1\":{\"164\":1}}],[\"因此后面统一小写来表示\",{\"1\":{\"199\":1}}],[\"因此后面还是会统一称作页\",{\"1\":{\"64\":1}}],[\"因此后续代码越写越快\",{\"1\":{\"164\":1}}],[\"因此是无法插入会\",{\"1\":{\"241\":1}}],[\"因此是\",{\"1\":{\"159\":1}}],[\"因此已有成熟稳定的实现\",{\"1\":{\"157\":1}}],[\"因此整个块都是可用内存\",{\"1\":{\"241\":1}}],[\"因此整个\",{\"1\":{\"155\":1}}],[\"因此消费者订阅后\",{\"1\":{\"148\":1}}],[\"因此注册的地址信息存在变更\",{\"1\":{\"148\":1}}],[\"因此追随者的\",{\"1\":{\"136\":1}}],[\"因此上层应用知道状态机数据以及日志应用情况\",{\"1\":{\"136\":1}}],[\"因此如果是在其它语言下\",{\"1\":{\"218\":1}}],[\"因此如果再使用日志序号来从日志切片中获取日志\",{\"1\":{\"136\":1}}],[\"因此如果需要修改\",{\"1\":{\"127\":1}}],[\"因此只需保存最后一个日志序号\",{\"1\":{\"136\":1}}],[\"因此快照机制直接将\",{\"1\":{\"136\":1}}],[\"因此下一次同步序号仍然为冲突序号\",{\"1\":{\"134\":1}}],[\"因此提高同步效率\",{\"1\":{\"134\":1}}],[\"因此选择在堆里面开辟\",{\"1\":{\"194\":1}}],[\"因此选票会向日志完善的节点倾斜\",{\"1\":{\"130\":1}}],[\"因此选举的过程实则就是\",{\"1\":{\"124\":1}}],[\"因此就每个块的首地址除以页大小就能得到对应的页\",{\"1\":{\"241\":1}}],[\"因此就可以用来更新领导者的\",{\"1\":{\"129\":1}}],[\"因此就不会发出下一轮选举\",{\"1\":{\"126\":1}}],[\"因此与其它节点需要同步那么日志\",{\"1\":{\"129\":1}}],[\"因此与其有冲突的节点从item\",{\"1\":{\"51\":1}}],[\"因此在\",{\"1\":{\"194\":1}}],[\"因此在编译器就必须确定\",{\"1\":{\"179\":1}}],[\"因此在取日志数据的时候会发生冲突\",{\"1\":{\"137\":1}}],[\"因此在快照期间的日志同步将需要重新来\",{\"1\":{\"136\":1}}],[\"因此在成为领导者后\",{\"1\":{\"129\":1}}],[\"因此在初始化时\",{\"1\":{\"128\":1}}],[\"因此在具体谈到\",{\"1\":{\"123\":1}}],[\"因此实际可见的数据其实是这样的\",{\"1\":{\"127\":1}}],[\"因此即使日志是空的\",{\"1\":{\"126\":1}}],[\"因此集群领导者并非唯一\",{\"1\":{\"125\":1}}],[\"因此目前\",{\"1\":{\"124\":1}}],[\"因此协调者会与其它节点进行沟通协商\",{\"1\":{\"124\":1}}],[\"因此其实这个日志序号是不存在的\",{\"1\":{\"129\":1}}],[\"因此其中有节点宕机也并无关系\",{\"1\":{\"105\":1}}],[\"因此其它事务可能读到脏数据\",{\"1\":{\"85\":1}}],[\"因此数据库必须预先采取措施以保证即使发生故障\",{\"1\":{\"92\":1}}],[\"因此会尝试不断重试\",{\"1\":{\"150\":1}}],[\"因此会出现环形等待\",{\"1\":{\"87\":1}}],[\"因此会跑到2的后面\",{\"1\":{\"48\":1}}],[\"因此任何一个执行器\",{\"1\":{\"79\":1}}],[\"因此无法快照\",{\"1\":{\"136\":1}}],[\"因此无法释放\",{\"1\":{\"73\":1}}],[\"因此无法确定谁先谁后\",{\"1\":{\"43\":1}}],[\"因此每得到一个锁\",{\"1\":{\"73\":1}}],[\"因此也不会被释放调\",{\"1\":{\"232\":1}}],[\"因此也需要对\",{\"1\":{\"73\":1}}],[\"因此也被称为\",{\"1\":{\"73\":1}}],[\"因此也无需有太强的心理负担\",{\"1\":{\"214\":1}}],[\"因此也无需\",{\"1\":{\"14\":1}}],[\"因此不回分裂\",{\"1\":{\"73\":1}}],[\"因此不同客户端可能在同一个插入意图上工作\",{\"1\":{\"25\":1}}],[\"因此我们会先从\",{\"1\":{\"280\":1}}],[\"因此我们对\",{\"1\":{\"227\":1}}],[\"因此我们只需在\",{\"1\":{\"225\":1}}],[\"因此我们只需更新冲突序号\",{\"1\":{\"134\":1}}],[\"因此我们的\",{\"1\":{\"218\":1}}],[\"因此我们的核心诉求是验证\",{\"1\":{\"164\":1}}],[\"因此我们选择先编译\",{\"1\":{\"217\":1}}],[\"因此我们必须缓存\",{\"1\":{\"282\":1}}],[\"因此我们必须手动地释放\",{\"1\":{\"210\":1}}],[\"因此我们必须得引入数据\",{\"1\":{\"164\":1}}],[\"因此我们不需要\",{\"1\":{\"164\":1}}],[\"因此我们不会谈论如何实现状态机\",{\"1\":{\"131\":1}}],[\"因此我们需要通过锁管理器来完善执行器的事务支持\",{\"1\":{\"89\":1}}],[\"因此我们需要一种算法\",{\"1\":{\"73\":1}}],[\"因此我们可以使用其它的池化方式\",{\"1\":{\"261\":1}}],[\"因此我们可以使用map来存储item\",{\"1\":{\"26\":1}}],[\"因此我们可以通过插入操作来推演\",{\"1\":{\"25\":1}}],[\"因此合并完毕\",{\"1\":{\"72\":1}}],[\"因此节点\",{\"1\":{\"72\":1}}],[\"因此递归情况需分裂到不可分裂为止\",{\"1\":{\"71\":1}}],[\"因此父节点也需要继续分裂\",{\"1\":{\"71\":1}}],[\"因此可将进程当作主线程对待\",{\"1\":{\"199\":1}}],[\"因此可将该字段通过\",{\"1\":{\"69\":1}}],[\"因此可以提前申请一大块内存\",{\"1\":{\"237\":1}}],[\"因此可以使用增量验证的方式来完成测试\",{\"1\":{\"164\":1}}],[\"因此可以作为一个学习\",{\"1\":{\"49\":1}}],[\"因此根节点也是叶子结点\",{\"1\":{\"68\":1}}],[\"因此锁\",{\"1\":{\"64\":1}}],[\"因此需设置\",{\"1\":{\"285\":1}}],[\"因此需要等待\",{\"1\":{\"285\":1}}],[\"因此需要一个空包\",{\"1\":{\"285\":1}}],[\"因此需要新建一个同名的\",{\"1\":{\"212\":1}}],[\"因此需要重组而不是合并\",{\"1\":{\"72\":1}}],[\"因此需要重组或合并\",{\"1\":{\"72\":1}}],[\"因此需要找到pos\",{\"1\":{\"26\":1}}],[\"因此需先调用\",{\"1\":{\"70\":1}}],[\"因此需直接写代码构建执行计划来执行\",{\"1\":{\"58\":1}}],[\"因此开源的只有一部分\",{\"1\":{\"56\":1}}],[\"因此冲突解决需要稍加改变一下\",{\"1\":{\"51\":1}}],[\"因此value是一个小双向链表\",{\"1\":{\"50\":1}}],[\"因此3会插入到2的前面\",{\"1\":{\"48\":1}}],[\"因此destindex的初始值为origin的下标加\",{\"1\":{\"47\":1}}],[\"因此按照id来比较\",{\"1\":{\"43\":1}}],[\"因此未找到item时\",{\"1\":{\"37\":1}}],[\"因此最终文本内容是\",{\"1\":{\"26\":1}}],[\"因此最后的文本内容肯定是一致的\",{\"1\":{\"25\":1}}],[\"因此子节点可能有多个\",{\"1\":{\"26\":1}}],[\"因此\",{\"1\":{\"17\":1,\"23\":1,\"25\":1,\"41\":1,\"43\":1,\"68\":1,\"72\":1,\"73\":1,\"86\":1,\"98\":1,\"122\":1,\"129\":1,\"133\":1,\"136\":1,\"179\":2,\"188\":1,\"200\":4,\"206\":1,\"214\":1,\"218\":1,\"227\":1,\"238\":1,\"241\":1,\"243\":2,\"244\":4,\"270\":1,\"282\":1}}],[\"没错\",{\"1\":{\"194\":1}}],[\"没办法\",{\"1\":{\"24\":1,\"45\":1,\"153\":1}}],[\"没有反应就多按几下\",{\"1\":{\"293\":1}}],[\"没有任何错误产生\",{\"1\":{\"285\":1}}],[\"没有找到\",{\"1\":{\"282\":1}}],[\"没有找到可用的\",{\"1\":{\"240\":1}}],[\"没有找到可运行\",{\"1\":{\"200\":1}}],[\"没有大小限制的\",{\"1\":{\"274\":1}}],[\"没有更多的空闲元素可返回时\",{\"1\":{\"261\":2}}],[\"没有局部变量产生\",{\"1\":{\"256\":1}}],[\"没有元数据浪费\",{\"1\":{\"241\":1}}],[\"没有复杂的函数体\",{\"1\":{\"219\":1}}],[\"没有知道产品和老板会怎么样\",{\"1\":{\"165\":1}}],[\"没有一个整块时间去思考与沉淀\",{\"1\":{\"152\":1}}],[\"没有加读\",{\"1\":{\"89\":2}}],[\"没有加读锁\",{\"1\":{\"89\":2}}],[\"没有加写锁\",{\"1\":{\"89\":1}}],[\"没有则直接返回错误\",{\"1\":{\"240\":1}}],[\"没有则直接返回\",{\"1\":{\"63\":1}}],[\"没有实际的删除数据\",{\"1\":{\"28\":1}}],[\"没有实际意义\",{\"1\":{\"26\":1}}],[\"没有协商并不代表副本数据之间会有差异\",{\"1\":{\"8\":1}}],[\"没有具体的专业领域和技能\",{\"1\":{\"4\":1}}],[\"删\",{\"1\":{\"24\":1,\"45\":1}}],[\"删除已经合并的头节点\",{\"1\":{\"282\":1}}],[\"删除旧数据\",{\"1\":{\"158\":1}}],[\"删除所有\",{\"1\":{\"136\":1}}],[\"删除掉\",{\"1\":{\"136\":1}}],[\"删除冲突日志\",{\"1\":{\"129\":1}}],[\"删除等\",{\"1\":{\"77\":1}}],[\"删除流程图如图\",{\"1\":{\"72\":1}}],[\"删除根节点\",{\"1\":{\"72\":1}}],[\"删除失败\",{\"1\":{\"72\":1}}],[\"删除对应的\",{\"1\":{\"72\":1}}],[\"删除的复杂性大大高于插入\",{\"1\":{\"72\":1}}],[\"删除引发了两次节点合并\",{\"1\":{\"72\":1}}],[\"删除引发了节点重组\",{\"1\":{\"72\":1}}],[\"删除指向\",{\"1\":{\"72\":1}}],[\"删除一个子节点后\",{\"1\":{\"72\":1}}],[\"删除节点\",{\"1\":{\"72\":1}}],[\"删除后\",{\"1\":{\"72\":4,\"73\":2}}],[\"删除\",{\"1\":{\"64\":1,\"69\":1,\"72\":1,\"73\":2}}],[\"删除数据页\",{\"1\":{\"64\":2}}],[\"删除尾部\",{\"1\":{\"63\":1}}],[\"删除这个节点\",{\"1\":{\"63\":1}}],[\"删除时\",{\"1\":{\"43\":1,\"72\":1}}],[\"删除就十分简单了\",{\"1\":{\"26\":1}}],[\"删除item时\",{\"1\":{\"25\":1}}],[\"删除性能\",{\"1\":{\"23\":1}}],[\"删除操作可以被看作是写入一个特殊的标志位来表示该键已被删除\",{\"1\":{\"4\":1}}],[\"删除操作\",{\"1\":{\"4\":1}}],[\"数\",{\"1\":{\"264\":1}}],[\"数和任务数以及关闭\",{\"1\":{\"264\":1}}],[\"数量的\",{\"1\":{\"263\":1}}],[\"数量就翻倍了\",{\"1\":{\"218\":1}}],[\"数量\",{\"1\":{\"69\":1}}],[\"数组字段\",{\"1\":{\"69\":1}}],[\"数组是有限的\",{\"1\":{\"64\":1}}],[\"数组中的每一项被称为帧\",{\"1\":{\"64\":1}}],[\"数组\",{\"1\":{\"64\":1}}],[\"数据容器\",{\"1\":{\"282\":1}}],[\"数据包中的\",{\"1\":{\"279\":1}}],[\"数据写\",{\"1\":{\"274\":1}}],[\"数据传输是基于流的\",{\"1\":{\"274\":1}}],[\"数据在\",{\"1\":{\"260\":1}}],[\"数据在函数之间流转\",{\"1\":{\"177\":1}}],[\"数据计算\",{\"0\":{\"253\":1}}],[\"数据移动\",{\"0\":{\"252\":1}}],[\"数据区的内存由于是全局\",{\"1\":{\"232\":1}}],[\"数据区可以划分为两个部分\",{\"1\":{\"232\":1}}],[\"数据区\",{\"1\":{\"232\":1}}],[\"数据就能从\",{\"1\":{\"207\":1}}],[\"数据段\",{\"1\":{\"194\":1,\"197\":1}}],[\"数据尾项等功能\",{\"1\":{\"190\":1}}],[\"数据排序\",{\"1\":{\"184\":1}}],[\"数据映射\",{\"1\":{\"184\":1}}],[\"数据映射函数\",{\"1\":{\"181\":1}}],[\"数据遍历\",{\"1\":{\"184\":1}}],[\"数据过滤\",{\"1\":{\"184\":1}}],[\"数据去重\",{\"1\":{\"184\":1}}],[\"数据流结束后不等待\",{\"1\":{\"285\":1}}],[\"数据流上达到了\",{\"1\":{\"283\":1}}],[\"数据流很快就会溢出\",{\"1\":{\"283\":1}}],[\"数据流是协议最核心的数据载体\",{\"1\":{\"281\":1}}],[\"数据流重组器\",{\"1\":{\"280\":1,\"283\":1}}],[\"数据流\",{\"1\":{\"280\":1}}],[\"数据流开始\",{\"1\":{\"280\":1}}],[\"数据流过程\",{\"1\":{\"279\":1}}],[\"数据流经处理后\",{\"1\":{\"185\":1}}],[\"数据流的类型\",{\"1\":{\"183\":1}}],[\"数据流进入\",{\"1\":{\"177\":1}}],[\"数据序列化失败\",{\"1\":{\"150\":1}}],[\"数据落盘的编码方式有很多种\",{\"1\":{\"133\":1}}],[\"数据持久化是\",{\"1\":{\"133\":1,\"135\":1}}],[\"数据的可见性是一致的\",{\"1\":{\"128\":1}}],[\"数据是一致的\",{\"1\":{\"128\":1}}],[\"数据是如何转化为叶子结点\",{\"1\":{\"69\":1}}],[\"数据处理函数是实现的一个难点\",{\"1\":{\"188\":1}}],[\"数据处理不会停止流\",{\"1\":{\"184\":1}}],[\"数据处理映射阶段可以定义出非常复杂和丰富的\",{\"1\":{\"184\":1}}],[\"数据处理\",{\"1\":{\"113\":1,\"182\":1}}],[\"数据结构\",{\"1\":{\"261\":1}}],[\"数据结构表示\",{\"1\":{\"199\":1}}],[\"数据结构的\",{\"1\":{\"103\":1}}],[\"数据结构建模\",{\"0\":{\"28\":1}}],[\"数据存储路径\",{\"1\":{\"98\":1}}],[\"数据存储在磁盘上被称为页\",{\"1\":{\"64\":1}}],[\"数据仍然找回\",{\"1\":{\"92\":1}}],[\"数据等信息\",{\"1\":{\"79\":2}}],[\"数据若要插入到叶子节点\",{\"1\":{\"71\":1}}],[\"数据数组\",{\"1\":{\"69\":1}}],[\"数据\",{\"1\":{\"69\":1,\"84\":1,\"97\":1,\"98\":1,\"99\":1,\"200\":1,\"260\":1}}],[\"数据记录容器\",{\"1\":{\"78\":1}}],[\"数据记录\",{\"1\":{\"59\":1}}],[\"数据表记录\",{\"1\":{\"82\":1}}],[\"数据表范式\",{\"1\":{\"79\":2}}],[\"数据表迭代器\",{\"1\":{\"59\":1}}],[\"数据表\",{\"1\":{\"59\":1,\"79\":2}}],[\"数据表页\",{\"1\":{\"59\":1}}],[\"数据表定义\",{\"1\":{\"59\":1}}],[\"数据页\",{\"1\":{\"59\":1}}],[\"数据库连接\",{\"1\":{\"260\":1}}],[\"数据库等\",{\"1\":{\"165\":1}}],[\"数据库\",{\"1\":{\"152\":1,\"164\":1,\"165\":1}}],[\"数据库可以实现多种淘汰算法\",{\"1\":{\"63\":1}}],[\"数据库不可能将所有数据页装在内存中\",{\"1\":{\"63\":1}}],[\"数据库需要在内存中保留尽可能多的数据页\",{\"1\":{\"62\":1}}],[\"数据库目录\",{\"1\":{\"59\":1}}],[\"数据库组开源的一款关系数据库\",{\"1\":{\"56\":1}}],[\"数据库事务隔离级别有哪几个\",{\"1\":{\"56\":1}}],[\"数据库是如何处理并发访问控制的\",{\"1\":{\"56\":1}}],[\"数据库是如何执行\",{\"1\":{\"56\":1}}],[\"数据库是一个老生常谈的话题\",{\"1\":{\"56\":1}}],[\"数据库会预读数据到缓冲池中\",{\"1\":{\"56\":1}}],[\"数据库系统会周期性地检查\",{\"1\":{\"87\":1}}],[\"数据库系统都会为其分配一个事务\",{\"1\":{\"85\":1}}],[\"数据库系统从客户端接收到\",{\"1\":{\"77\":1}}],[\"数据库系统架构是什么样的\",{\"1\":{\"56\":1}}],[\"数据库系统概念\",{\"1\":{\"56\":1}}],[\"数据建模是\",{\"1\":{\"51\":1}}],[\"数据建模\",{\"0\":{\"50\":1}}],[\"数据类型以及其基本操作\",{\"1\":{\"27\":1}}],[\"数据一致性\",{\"1\":{\"4\":3}}],[\"数字文本增\",{\"1\":{\"24\":1,\"45\":1}}],[\"只会重发队首的报文\",{\"1\":{\"284\":1}}],[\"只会查看前\",{\"1\":{\"281\":1}}],[\"只会向其它节点发送投票\",{\"1\":{\"124\":1}}],[\"只不过这些由\",{\"1\":{\"242\":1}}],[\"只不过架构并不是预先设计的\",{\"1\":{\"164\":1}}],[\"只停留在了第\",{\"1\":{\"226\":1}}],[\"只提供了\",{\"1\":{\"208\":1}}],[\"只提供了单值的键值对类型\",{\"1\":{\"113\":1}}],[\"只读\",{\"1\":{\"183\":1,\"255\":2}}],[\"只要朕还在一日\",{\"1\":{\"125\":1}}],[\"只要一个页使用完毕后\",{\"1\":{\"70\":1}}],[\"只支持按照单值键值对的键来排序\",{\"1\":{\"117\":1}}],[\"只支持简单的英文\",{\"1\":{\"24\":1,\"45\":1}}],[\"只剩下根节点了\",{\"1\":{\"72\":1}}],[\"只能增加重试次数\",{\"1\":{\"284\":1}}],[\"只能做到尽最大努力交付\",{\"1\":{\"273\":1}}],[\"只能将其重新插入\",{\"1\":{\"241\":1}}],[\"只能对接口进行代理\",{\"1\":{\"144\":1}}],[\"只能在结束时释放所有的锁\",{\"1\":{\"85\":1}}],[\"只能释放原来获取的锁\",{\"1\":{\"85\":1}}],[\"只能释放锁\",{\"1\":{\"85\":1}}],[\"只能尽可能的将热点数据存储在缓冲池中\",{\"1\":{\"63\":1}}],[\"只能修改已有的item\",{\"1\":{\"37\":1}}],[\"只是它们不再由用户主动调用\",{\"1\":{\"243\":1}}],[\"只是value是一个字符而已\",{\"1\":{\"37\":1}}],[\"只是将上一个operation的succ指向自己\",{\"1\":{\"28\":1}}],[\"只有下次\",{\"1\":{\"262\":1}}],[\"只有输入\",{\"1\":{\"164\":1}}],[\"只有当\",{\"1\":{\"130\":1}}],[\"只有\",{\"1\":{\"34\":1,\"71\":1,\"282\":1}}],[\"只有一个lamport\",{\"1\":{\"32\":1}}],[\"只需要在\",{\"1\":{\"219\":1}}],[\"只需要知道\",{\"1\":{\"124\":1}}],[\"只需一个满足条件的项出现\",{\"1\":{\"189\":1}}],[\"只需遍历\",{\"1\":{\"188\":1}}],[\"只需定义一次\",{\"1\":{\"179\":1}}],[\"只需实现\",{\"1\":{\"157\":1}}],[\"只需掌握持久化时机\",{\"1\":{\"135\":1}}],[\"只需记住任何引起该三个字段发生改变的操作都必须紧接着一次\",{\"1\":{\"133\":1}}],[\"只需将发送的报文推入到两个队列中即\",{\"1\":{\"284\":1}}],[\"只需将日志发送给\",{\"1\":{\"131\":1}}],[\"只需将本地操作op发送给其它节点即可\",{\"1\":{\"10\":1}}],[\"只需指定\",{\"1\":{\"111\":1}}],[\"只需直连代理服务就能访问到不同集群的数据\",{\"1\":{\"105\":1}}],[\"只需判断双方clock大小即可\",{\"1\":{\"17\":1}}],[\"案例\",{\"0\":{\"24\":1,\"45\":1}}],[\"伪代码只为说明过程和原理\",{\"1\":{\"72\":1}}],[\"伪代码实现如下\",{\"1\":{\"64\":1}}],[\"伪代码实现十分简单\",{\"1\":{\"23\":1}}],[\"伪代码\",{\"1\":{\"30\":1,\"31\":1,\"32\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1}}],[\"伪代码如下\",{\"1\":{\"16\":1,\"17\":1,\"70\":1}}],[\"爆发的一年\",{\"1\":{\"23\":1}}],[\"于是写下这篇文章和大家分享一下\",{\"1\":{\"216\":1}}],[\"于是写下这篇\",{\"1\":{\"205\":1}}],[\"于是就有了这篇文章\",{\"1\":{\"177\":1,\"260\":1}}],[\"于\",{\"1\":{\"23\":1,\"41\":1}}],[\"被解析为\",{\"1\":{\"279\":1}}],[\"被\",{\"1\":{\"275\":1}}],[\"被频繁创建然后销毁\",{\"1\":{\"262\":1}}],[\"被回收了\",{\"1\":{\"243\":1}}],[\"被组织为一个单向链表\",{\"1\":{\"241\":1}}],[\"被释放了\",{\"1\":{\"240\":1}}],[\"被置为\",{\"1\":{\"238\":1}}],[\"被分为了两个部分\",{\"1\":{\"257\":1}}],[\"被分配的内存瞬间回到了\",{\"1\":{\"238\":1}}],[\"被分裂为\",{\"1\":{\"71\":1}}],[\"被分裂成\",{\"1\":{\"71\":1}}],[\"被用做主存\",{\"1\":{\"231\":1}}],[\"被用来作为\",{\"1\":{\"231\":1}}],[\"被精简了一半\",{\"1\":{\"218\":1}}],[\"被初始化后\",{\"1\":{\"203\":1}}],[\"被绑定到\",{\"1\":{\"199\":1}}],[\"被称作\",{\"1\":{\"164\":1}}],[\"被称为灰色栈\",{\"1\":{\"244\":1}}],[\"被称为标记清理算法\",{\"1\":{\"235\":1}}],[\"被称为地址空间\",{\"1\":{\"232\":1}}],[\"被称为\",{\"1\":{\"69\":1}}],[\"被视为心跳\",{\"1\":{\"129\":1}}],[\"被应用后\",{\"1\":{\"127\":1}}],[\"被广泛的应用在\",{\"1\":{\"121\":1}}],[\"被广泛应用于生产环境\",{\"1\":{\"22\":1}}],[\"被嵌入到单值键值对的键当中\",{\"1\":{\"116\":1}}],[\"被嵌入到了单值键值对的键当中\",{\"1\":{\"114\":1}}],[\"被调用时可以调用子执行器的\",{\"1\":{\"78\":1}}],[\"被虐的死去活来\",{\"1\":{\"74\":1}}],[\"被删除后\",{\"1\":{\"72\":1}}],[\"被读取转换后才能知道其\",{\"1\":{\"69\":1}}],[\"被修改时\",{\"1\":{\"16\":1}}],[\"所申请的页内存\",{\"1\":{\"241\":1}}],[\"所管理的内存在进程地址空间上\",{\"1\":{\"231\":1}}],[\"所带来的真正收益\",{\"1\":{\"139\":1}}],[\"所支持的\",{\"1\":{\"106\":1}}],[\"所能解决的问题就越多\",{\"1\":{\"84\":1}}],[\"所有数据都被确认了\",{\"1\":{\"284\":1}}],[\"所有数据写请求\",{\"1\":{\"122\":1}}],[\"所有包确认后\",{\"1\":{\"284\":1}}],[\"所有对象都是白色的\",{\"1\":{\"244\":1}}],[\"所有对象由链表连接\",{\"1\":{\"243\":1}}],[\"所有分配对象通过链表连接\",{\"1\":{\"243\":1}}],[\"所有进程的链表\",{\"1\":{\"194\":1}}],[\"所有节点均有\",{\"1\":{\"132\":1}}],[\"所有执行器也有一个公共父类\",{\"1\":{\"79\":1}}],[\"所有项移动到\",{\"1\":{\"72\":1}}],[\"所有叶子节点高\",{\"1\":{\"68\":1}}],[\"所在的叶子节点页\",{\"1\":{\"71\":1}}],[\"所在的叶子结点\",{\"1\":{\"70\":1}}],[\"所示是一棵\",{\"1\":{\"68\":1}}],[\"所示\",{\"1\":{\"64\":1,\"68\":1,\"69\":1,\"71\":3,\"72\":6,\"73\":3,\"79\":1,\"84\":1}}],[\"所采用的算法\",{\"1\":{\"22\":1}}],[\"所以彼端可以直接设置\",{\"1\":{\"285\":1}}],[\"所以无需考虑输出流能否全部交付的问题\",{\"1\":{\"285\":1}}],[\"所以无法释放\",{\"1\":{\"73\":1}}],[\"所以输入流才能关闭\",{\"1\":{\"285\":1}}],[\"所以如果\",{\"1\":{\"284\":1}}],[\"所以就会有大量的大内存切片在队列中\",{\"1\":{\"262\":1}}],[\"所以就开始重复了\",{\"1\":{\"4\":1}}],[\"所以在使用的时候\",{\"1\":{\"261\":1}}],[\"所以栈帧为\",{\"1\":{\"256\":1}}],[\"所以第一个\",{\"1\":{\"255\":1}}],[\"所以会先判断对应\",{\"1\":{\"241\":1}}],[\"所以实现中定义的\",{\"1\":{\"241\":1}}],[\"所以也是学习内存管理必经的一步\",{\"1\":{\"240\":1}}],[\"所以函数继续执行\",{\"1\":{\"225\":1}}],[\"所以很多人用下面这张图来调侃\",{\"1\":{\"223\":1}}],[\"所以线程用户都是在调度循环\",{\"1\":{\"200\":1}}],[\"所以这种说法是不严谨的\",{\"1\":{\"199\":1}}],[\"所以我们需要更改函数名\",{\"1\":{\"179\":1}}],[\"所以测试用例写起来很费劲\",{\"1\":{\"168\":1}}],[\"所以应该删除\",{\"1\":{\"136\":1}}],[\"所以拒绝\",{\"1\":{\"136\":1}}],[\"所以直接为\",{\"1\":{\"129\":1}}],[\"所以直接返回\",{\"1\":{\"124\":1,\"225\":1}}],[\"所以是安全的\",{\"1\":{\"73\":3}}],[\"所以每次\",{\"1\":{\"69\":1}}],[\"所以请切记\",{\"1\":{\"64\":1}}],[\"所以需要先通过findpositionbyindex函数找到pos对应的item的下标i\",{\"1\":{\"47\":1}}],[\"所以pos并不是content的下标\",{\"1\":{\"47\":1}}],[\"所以找到会更加麻烦一点\",{\"1\":{\"33\":1}}],[\"所以\",{\"1\":{\"10\":1,\"114\":1,\"117\":1,\"181\":1,\"198\":1,\"203\":1,\"219\":2,\"261\":1,\"274\":1}}],[\"回应\",{\"1\":{\"285\":1}}],[\"回复\",{\"1\":{\"272\":1}}],[\"回复者接收到这两条信息后\",{\"1\":{\"130\":1}}],[\"回复者任期\",{\"1\":{\"124\":1}}],[\"回收栈内存\",{\"1\":{\"251\":1}}],[\"回收至缓存\",{\"1\":{\"241\":1}}],[\"回收掉垃圾后再恢复\",{\"1\":{\"238\":1}}],[\"回收掉了不需要的垃圾对象\",{\"1\":{\"238\":1}}],[\"回调\",{\"1\":{\"151\":1}}],[\"回到刚才的业务场景上\",{\"1\":{\"262\":1}}],[\"回到\",{\"1\":{\"129\":1,\"277\":1}}],[\"回退一步\",{\"1\":{\"129\":1}}],[\"回滚事务将重新启动或中止\",{\"1\":{\"87\":1}}],[\"回滚事务\",{\"1\":{\"85\":1}}],[\"回滚一个事务\",{\"1\":{\"85\":1}}],[\"回滚\",{\"1\":{\"85\":1}}],[\"回顾一下\",{\"1\":{\"19\":1}}],[\"回答\",{\"1\":{\"4\":2}}],[\"算法简单易理解\",{\"1\":{\"244\":1}}],[\"算法选择合适的时机来调用\",{\"1\":{\"243\":1}}],[\"算法已经实现完毕\",{\"1\":{\"243\":1}}],[\"算法需要找到这些垃圾对象然后才能清理\",{\"1\":{\"243\":1}}],[\"算法来自动调用\",{\"1\":{\"242\":1}}],[\"算法还有很多\",{\"1\":{\"235\":1}}],[\"算法想要应用在工业上\",{\"1\":{\"139\":1}}],[\"算法中一个非常重要的概念\",{\"1\":{\"123\":1}}],[\"算法会选择最近最少使用的页淘汰\",{\"1\":{\"63\":1}}],[\"算法实现的几个重要脉络\",{\"1\":{\"139\":1}}],[\"算法实现是颇具挑战力的\",{\"1\":{\"139\":1}}],[\"算法实现之前\",{\"1\":{\"123\":1}}],[\"算法实现\",{\"1\":{\"59\":1,\"242\":1}}],[\"算法虽然推理起来很麻烦\",{\"1\":{\"44\":1}}],[\"算法的具体实现了\",{\"1\":{\"243\":1}}],[\"算法的必经之路\",{\"1\":{\"235\":1}}],[\"算法的根本目的所在\",{\"1\":{\"128\":1}}],[\"算法的集群中\",{\"1\":{\"122\":1}}],[\"算法的实现上\",{\"1\":{\"121\":1}}],[\"算法的基础上\",{\"1\":{\"46\":1}}],[\"算法的开源\",{\"1\":{\"41\":1}}],[\"算法的原理与实现\",{\"1\":{\"41\":1}}],[\"算法\",{\"1\":{\"20\":1,\"22\":3,\"23\":1,\"41\":3,\"43\":1,\"52\":1,\"63\":1,\"235\":1,\"242\":1,\"243\":2,\"244\":1,\"245\":2}}],[\"算法做铺垫\",{\"1\":{\"19\":1}}],[\"算法是如何实现的\",{\"1\":{\"243\":1}}],[\"算法是目前使用最为广泛的分布式共识性算法\",{\"1\":{\"122\":1}}],[\"算法是\",{\"1\":{\"8\":1}}],[\"为对\",{\"1\":{\"286\":1}}],[\"为最后一个重组的字节序号\",{\"1\":{\"283\":1}}],[\"为全局变量\",{\"1\":{\"257\":1}}],[\"为其实现了一个非常简单的\",{\"1\":{\"235\":1}}],[\"为程序入口\",{\"1\":{\"217\":1}}],[\"为快照数据\",{\"1\":{\"136\":1}}],[\"为此\",{\"1\":{\"134\":1}}],[\"为成功\",{\"1\":{\"126\":1}}],[\"为自己\",{\"1\":{\"123\":1}}],[\"为什么需要看做为\",{\"1\":{\"284\":1}}],[\"为什么会有内存浪费\",{\"1\":{\"262\":1}}],[\"为什么会存在脏读\",{\"1\":{\"85\":1}}],[\"为什么做这个项目\",{\"1\":{\"162\":1}}],[\"为什么选择\",{\"1\":{\"157\":1}}],[\"为什么\",{\"1\":{\"136\":1,\"162\":2}}],[\"为什么我们无需保存快照块的第一个日志序号呢\",{\"1\":{\"136\":1}}],[\"为什么要加上这个条件了\",{\"1\":{\"134\":1}}],[\"为什么要这么设计\",{\"1\":{\"56\":1}}],[\"为例\",{\"1\":{\"79\":1,\"127\":1,\"177\":1,\"188\":1,\"207\":1,\"218\":1,\"237\":1}}],[\"为内部节点\",{\"1\":{\"71\":1}}],[\"为叶子节点\",{\"1\":{\"71\":1}}],[\"为\",{\"1\":{\"64\":1,\"69\":3,\"84\":1,\"124\":2,\"127\":1,\"128\":1,\"130\":3,\"136\":2,\"200\":1,\"243\":2,\"282\":2,\"285\":5}}],[\"为参数调用\",{\"1\":{\"64\":1}}],[\"为避免物理机突然崩溃\",{\"1\":{\"58\":1}}],[\"为空或者为\",{\"1\":{\"130\":1}}],[\"为空\",{\"1\":{\"50\":1,\"126\":1,\"284\":1}}],[\"为切入点\",{\"1\":{\"38\":1}}],[\"为以后深入理解文本\",{\"1\":{\"19\":1}}],[\"为了与其它协议进行区分\",{\"1\":{\"278\":1}}],[\"为了避免引入\",{\"1\":{\"278\":1}}],[\"为了避免二次释放\",{\"1\":{\"241\":1}}],[\"为了避免数据被\",{\"1\":{\"210\":1}}],[\"为了性能考虑\",{\"1\":{\"234\":1}}],[\"为了性能牺牲可靠性\",{\"1\":{\"159\":1}}],[\"为了方便\",{\"1\":{\"227\":1}}],[\"为了方便后续扩展\",{\"1\":{\"155\":1}}],[\"为了屏蔽不同平台架构之间的指令差异性\",{\"1\":{\"219\":1}}],[\"为了改变程序的入口\",{\"1\":{\"217\":1}}],[\"为了帮助大家能够更好的理解\",{\"1\":{\"192\":1}}],[\"为了帮助更多人学习了解\",{\"1\":{\"8\":1}}],[\"为了支持链式调用\",{\"1\":{\"183\":1}}],[\"为了支持多存储引擎\",{\"1\":{\"158\":1}}],[\"为了支持分区\",{\"1\":{\"158\":1}}],[\"为了支持各类查询计划\",{\"1\":{\"79\":1}}],[\"为了更好的支持业务发展\",{\"1\":{\"145\":1}}],[\"为了前后的递进性\",{\"1\":{\"121\":1}}],[\"为了仍然保证\",{\"1\":{\"71\":1}}],[\"为了达到这个目标\",{\"1\":{\"62\":1}}],[\"为了保证数据传输的可靠性\",{\"1\":{\"273\":1}}],[\"为了保证统一\",{\"1\":{\"218\":1}}],[\"为了保证日志\",{\"1\":{\"130\":1}}],[\"为了保持和\",{\"1\":{\"113\":1}}],[\"为了保护课程\",{\"1\":{\"56\":1}}],[\"为了保存所有客户端的数值状态\",{\"1\":{\"14\":1}}],[\"为了解决这些问题\",{\"1\":{\"84\":1,\"282\":1}}],[\"为了解决这个问题\",{\"1\":{\"48\":1,\"136\":1,\"283\":1}}],[\"为了解决数据冲突从而达到最终一致性是十分困难的\",{\"1\":{\"8\":1}}],[\"为了提高读取性能\",{\"1\":{\"4\":1}}],[\"为了进一步减少磁盘空间的使用\",{\"1\":{\"4\":1}}],[\"为了减少磁盘空间的使用和提高查询性能\",{\"1\":{\"4\":1}}],[\"为了设计基于\",{\"1\":{\"4\":1}}],[\"忽略该\",{\"1\":{\"18\":1}}],[\"都应该至少回应一个包\",{\"1\":{\"285\":1}}],[\"都应该\",{\"1\":{\"285\":1}}],[\"都应该忽略\",{\"1\":{\"285\":1}}],[\"都应该准备关闭输入\",{\"1\":{\"285\":1}}],[\"都已经\",{\"1\":{\"284\":1}}],[\"都避免不了在堆中\",{\"1\":{\"260\":1}}],[\"都避免不了从请求体中读取数据\",{\"1\":{\"260\":1}}],[\"都需要掌握\",{\"1\":{\"164\":1}}],[\"都需要检查空闲列表\",{\"1\":{\"64\":1}}],[\"都对应一个\",{\"1\":{\"159\":1}}],[\"都参考了它\",{\"1\":{\"153\":1}}],[\"都太好用了\",{\"1\":{\"152\":1}}],[\"都支持插入用户自定义的中间件对请求处理\",{\"1\":{\"149\":1}}],[\"都有严格的定义\",{\"1\":{\"218\":1}}],[\"都有一个\",{\"1\":{\"200\":1}}],[\"都有\",{\"1\":{\"139\":1}}],[\"都必须由领导者处理\",{\"1\":{\"122\":1}}],[\"都被嵌入到了\",{\"1\":{\"115\":1}}],[\"都被它垄断\",{\"1\":{\"64\":1}}],[\"都插入在字符1右侧\",{\"1\":{\"25\":1}}],[\"都会重置自己\",{\"1\":{\"126\":1}}],[\"都会将页保存在链表头部\",{\"1\":{\"63\":1}}],[\"都会同步到对方\",{\"1\":{\"24\":1,\"45\":1}}],[\"都会递增clock作为timestamp\",{\"1\":{\"16\":1}}],[\"都是学习\",{\"1\":{\"228\":1}}],[\"都是\",{\"1\":{\"164\":1,\"208\":1,\"225\":1,\"283\":1}}],[\"都是安全的\",{\"1\":{\"73\":1}}],[\"都是在链表中排除已删除项\",{\"1\":{\"23\":1}}],[\"都是为了解决分布式环境下数据冲突的问题\",{\"1\":{\"10\":1}}],[\"都能被同步到右侧展示区\",{\"1\":{\"16\":1}}],[\"仍可通过图扫描被找到\",{\"1\":{\"243\":1}}],[\"仍有大量用户请求\",{\"1\":{\"238\":1}}],[\"仍有可能在分配新的对象\",{\"1\":{\"238\":1}}],[\"仍会执行\",{\"1\":{\"227\":1}}],[\"仍以上图为例\",{\"1\":{\"127\":1}}],[\"仍以全表扫描为例\",{\"1\":{\"79\":1}}],[\"仍然将栈\",{\"1\":{\"244\":1}}],[\"仍然沿用\",{\"1\":{\"153\":1}}],[\"仍然沿用上文谈到的\",{\"1\":{\"16\":1}}],[\"仍然恢复到发生前的状态\",{\"1\":{\"92\":1}}],[\"仍然以全表扫描为例\",{\"1\":{\"89\":1}}],[\"仍然会存在\",{\"1\":{\"85\":1}}],[\"仍然满足半满性质\",{\"1\":{\"73\":1}}],[\"仍然是内部节点\",{\"1\":{\"72\":1}}],[\"仍能保证多端的最终一致性\",{\"1\":{\"9\":1}}],[\"|=\",{\"1\":{\"227\":1}}],[\"|pedro\",{\"1\":{\"207\":1}}],[\"||\",{\"1\":{\"47\":2,\"48\":1,\"51\":4,\"63\":1,\"88\":2,\"124\":2,\"129\":3,\"130\":1,\"133\":4,\"136\":3,\"212\":2,\"240\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1}}],[\"|\",{\"1\":{\"16\":2,\"17\":2,\"18\":2,\"25\":4,\"26\":3,\"28\":4,\"47\":1,\"48\":2,\"50\":12,\"51\":1,\"179\":8,\"198\":5,\"207\":11,\"212\":11,\"217\":4,\"218\":1,\"227\":1,\"247\":1,\"291\":3,\"294\":4}}],[\"就通过\",{\"1\":{\"263\":1}}],[\"就比如\",{\"1\":{\"242\":1}}],[\"就没有与之对应的块\",{\"1\":{\"241\":1}}],[\"就应该被返回\",{\"1\":{\"240\":1}}],[\"就被转化为了\",{\"1\":{\"226\":1}}],[\"就目前而言\",{\"1\":{\"226\":1}}],[\"就将其解析为\",{\"1\":{\"225\":1}}],[\"就行了\",{\"1\":{\"218\":1}}],[\"就去全局队列中获取\",{\"1\":{\"200\":1}}],[\"就无需过多关系数据类型的问题\",{\"1\":{\"190\":1}}],[\"就无法复制\",{\"1\":{\"207\":1}}],[\"就无法改变其类型\",{\"1\":{\"179\":1}}],[\"就无法工作\",{\"1\":{\"125\":1}}],[\"就无法直接把集合保存为单值的键值对\",{\"1\":{\"113\":1}}],[\"就不做过多介绍了\",{\"1\":{\"181\":1}}],[\"就需要新的机制来模拟\",{\"1\":{\"243\":1}}],[\"就需要再写一个相同功能的函数\",{\"1\":{\"179\":1}}],[\"就需要调整操作的位置\",{\"1\":{\"44\":1}}],[\"就只能用于\",{\"1\":{\"179\":1}}],[\"就来实现它吧\",{\"1\":{\"177\":1}}],[\"就我个人而言\",{\"1\":{\"165\":1}}],[\"就采用行为测试\",{\"1\":{\"164\":1}}],[\"就必须不停的向其它节点宣示自己的地位\",{\"1\":{\"125\":1}}],[\"就把\",{\"1\":{\"117\":1}}],[\"就可以为其它值了\",{\"1\":{\"255\":1}}],[\"就可以接受两种类型的参数\",{\"1\":{\"179\":1}}],[\"就可以直连\",{\"1\":{\"110\":1}}],[\"就可以释放上一个锁\",{\"1\":{\"73\":1}}],[\"就跟访问普通\",{\"1\":{\"105\":1}}],[\"就有了\",{\"1\":{\"84\":1}}],[\"就很难再对数据结构产生畏惧\",{\"1\":{\"74\":1}}],[\"就证明无人使用该页\",{\"1\":{\"64\":1}}],[\"就会更新\",{\"1\":{\"284\":1}}],[\"就会导致内存泄漏\",{\"1\":{\"262\":1}}],[\"就会浪费大量的内存\",{\"1\":{\"262\":1}}],[\"就会忽略这个值\",{\"1\":{\"261\":1}}],[\"就会从\",{\"1\":{\"261\":1}}],[\"就会调用这个\",{\"1\":{\"261\":1}}],[\"就会创建比较多的\",{\"1\":{\"261\":1}}],[\"就会触发\",{\"1\":{\"243\":1}}],[\"就会造成悬挂指针\",{\"1\":{\"232\":1}}],[\"就会造成内存泄漏\",{\"1\":{\"232\":1}}],[\"就会通过\",{\"1\":{\"136\":1}}],[\"就会将状态机数据\",{\"1\":{\"136\":1}}],[\"就会产生死锁\",{\"1\":{\"87\":1}}],[\"就会产生编辑冲突\",{\"1\":{\"25\":1}}],[\"就会\",{\"1\":{\"64\":1}}],[\"就会有新页来继续使用这个\",{\"1\":{\"64\":1}}],[\"就介绍到这里\",{\"1\":{\"52\":1}}],[\"就能得到容器\",{\"1\":{\"294\":1}}],[\"就能得到最后的\",{\"1\":{\"188\":1}}],[\"就能直接使用\",{\"1\":{\"263\":1}}],[\"就能实现一个非常简单的编译器\",{\"1\":{\"219\":1}}],[\"就能方便的使用\",{\"1\":{\"190\":1}}],[\"就能立马返回\",{\"1\":{\"189\":1}}],[\"就能立马对下一次同步做出调整\",{\"1\":{\"134\":1}}],[\"就能快速锁定是左边节点还是右边节点\",{\"1\":{\"70\":1}}],[\"就能保证只要操作意图origin不变\",{\"1\":{\"43\":1}}],[\"就能推导得出下面两种\",{\"1\":{\"43\":1}}],[\"就是三次握手的第一步\",{\"1\":{\"286\":1}}],[\"就是一种\",{\"1\":{\"263\":1}}],[\"就是为了此刻能够将\",{\"1\":{\"245\":1}}],[\"就是白色对象\",{\"1\":{\"244\":1}}],[\"就是其中的一种方式\",{\"1\":{\"238\":1}}],[\"就是著名的\",{\"1\":{\"237\":1}}],[\"就是编译器的最后一步了\",{\"1\":{\"227\":1}}],[\"就是下一个需要同步的\",{\"1\":{\"134\":1}}],[\"就是上一个已同步的日志序号\",{\"1\":{\"129\":1}}],[\"就是用来存储日志内容的切片\",{\"1\":{\"128\":1}}],[\"就是通过\",{\"1\":{\"79\":1}}],[\"就是\",{\"1\":{\"68\":1,\"241\":1}}],[\"就是插入意图\",{\"1\":{\"25\":1}}],[\"就是列表的\",{\"1\":{\"23\":1}}],[\"就样就能保证此时的值是最新的\",{\"1\":{\"18\":1}}],[\"就像\",{\"1\":{\"15\":1}}],[\"就实现了\",{\"1\":{\"13\":1}}],[\"任务数等查询方法\",{\"1\":{\"264\":1}}],[\"任务的提交是直接往\",{\"1\":{\"264\":1}}],[\"任务更加简单了\",{\"1\":{\"219\":1}}],[\"任务拆解\",{\"1\":{\"162\":1}}],[\"任意\",{\"1\":{\"228\":1}}],[\"任意类型\",{\"1\":{\"128\":1}}],[\"任意客户端都能即时编辑本地副本\",{\"1\":{\"9\":1}}],[\"任期再次同步即可\",{\"1\":{\"134\":1}}],[\"任期和选票均会发生改变\",{\"1\":{\"133\":1}}],[\"任期大的更新话语权\",{\"1\":{\"130\":1}}],[\"任期大的节点对任期小的拥有绝对的话语权\",{\"1\":{\"124\":1}}],[\"任期大\",{\"1\":{\"129\":1}}],[\"任期冲突直接返回\",{\"1\":{\"129\":1,\"134\":1}}],[\"任期高的节点拥有更高的话语权\",{\"1\":{\"124\":1}}],[\"任期在选举过程中究竟有何作用了\",{\"1\":{\"124\":1}}],[\"任期在选举过程中发挥了什么作用了\",{\"1\":{\"123\":1}}],[\"任期为\",{\"1\":{\"123\":1}}],[\"任期\",{\"1\":{\"123\":1,\"124\":1,\"126\":1,\"128\":1}}],[\"任何长度大于\",{\"1\":{\"285\":2}}],[\"任何时候\",{\"1\":{\"285\":1}}],[\"任何时刻只有一个值\",{\"1\":{\"15\":1}}],[\"任何引起\",{\"1\":{\"139\":1}}],[\"任何数据更改在应用到数据库之前\",{\"1\":{\"92\":1}}],[\"任何事务在访问数据记录之前\",{\"1\":{\"88\":1}}],[\"任何一个可执行文件而言\",{\"1\":{\"217\":1}}],[\"任何一个数据项需满足条件后返回结果\",{\"1\":{\"185\":1}}],[\"任何一个节点都可由上层应用通过\",{\"1\":{\"136\":1}}],[\"任何一个字段只要发生了更改\",{\"1\":{\"133\":1}}],[\"任何一个连接建立后\",{\"1\":{\"85\":1}}],[\"任何一个基本操作\",{\"1\":{\"28\":1}}],[\"任何内存与磁盘之间的交互都需要通过它来进行\",{\"1\":{\"64\":1}}],[\"个字节\",{\"1\":{\"281\":5}}],[\"个字段\",{\"1\":{\"243\":1}}],[\"个方法\",{\"1\":{\"281\":1}}],[\"个方向\",{\"1\":{\"151\":1}}],[\"个人观点\",{\"1\":{\"273\":1}}],[\"个人与团队的成长是什么\",{\"1\":{\"162\":1}}],[\"个了\",{\"1\":{\"243\":1}}],[\"个则是引用可达\",{\"1\":{\"243\":1}}],[\"个对象\",{\"1\":{\"243\":2}}],[\"个周期\",{\"1\":{\"231\":1}}],[\"个阶段\",{\"1\":{\"226\":1}}],[\"个大阶段\",{\"1\":{\"226\":1}}],[\"个局部变量\",{\"1\":{\"218\":1}}],[\"个命令分别生成了目标文件\",{\"1\":{\"217\":1}}],[\"个系统线程又负责对这\",{\"1\":{\"199\":1}}],[\"个操作系统线程进行调度\",{\"1\":{\"199\":1}}],[\"个操作系统线程之上\",{\"1\":{\"199\":1}}],[\"个参数\",{\"1\":{\"208\":1,\"257\":3}}],[\"个参数是\",{\"1\":{\"197\":2}}],[\"个参数为\",{\"1\":{\"197\":1}}],[\"个特点\",{\"1\":{\"164\":1}}],[\"个问题\",{\"1\":{\"123\":1,\"136\":2}}],[\"个重要的字段需要说明\",{\"1\":{\"123\":1}}],[\"个模块彼此并不完全独立\",{\"1\":{\"121\":1}}],[\"个功能模块\",{\"1\":{\"121\":1}}],[\"个哈希槽\",{\"1\":{\"106\":1}}],[\"个状态\",{\"1\":{\"85\":1,\"139\":1}}],[\"个数结果恰好是\",{\"1\":{\"294\":1}}],[\"个数据\",{\"1\":{\"188\":1}}],[\"个数加起来\",{\"1\":{\"72\":2}}],[\"个数也\",{\"1\":{\"71\":1}}],[\"个值了\",{\"1\":{\"71\":1}}],[\"个值\",{\"1\":{\"68\":1,\"71\":1}}],[\"个孩子节点\",{\"1\":{\"68\":1}}],[\"个键\",{\"1\":{\"68\":3}}],[\"个子节点的内部叶节点包含\",{\"1\":{\"68\":1}}],[\"个子节点\",{\"1\":{\"68\":4,\"71\":5}}],[\"个基础类型来介绍\",{\"1\":{\"49\":1}}],[\"个operation\",{\"1\":{\"34\":2}}],[\"个\",{\"1\":{\"14\":2,\"125\":2,\"132\":2,\"138\":1,\"139\":2,\"199\":2,\"243\":1,\"264\":1}}],[\"个整数\",{\"1\":{\"14\":2}}],[\"大概的限制了\",{\"1\":{\"294\":1}}],[\"大概有一倍的提升\",{\"1\":{\"213\":1}}],[\"大量使用到了\",{\"1\":{\"260\":1}}],[\"大量的内存都被用于存储元数据了\",{\"1\":{\"240\":1}}],[\"大多数\",{\"1\":{\"243\":1}}],[\"大对象直接放回\",{\"1\":{\"241\":1}}],[\"大对象\",{\"1\":{\"241\":1}}],[\"大对象内存分配策略不同\",{\"1\":{\"241\":1}}],[\"大家都会下意识的想办法去封装和简化\",{\"1\":{\"223\":1}}],[\"大幅提高了程序运行效率\",{\"1\":{\"218\":1}}],[\"大致可分为如下\",{\"1\":{\"226\":1}}],[\"大致可分为两类\",{\"1\":{\"147\":1}}],[\"大致如下\",{\"1\":{\"124\":1,\"212\":1}}],[\"大于\",{\"1\":{\"72\":1,\"131\":2,\"136\":1,\"237\":1}}],[\"大于当前\",{\"1\":{\"18\":1}}],[\"大的字符在右边\",{\"1\":{\"43\":1}}],[\"大的在右边\",{\"1\":{\"26\":1,\"51\":1}}],[\"大者在右边\",{\"1\":{\"25\":2}}],[\"大小总共\",{\"1\":{\"255\":1}}],[\"大小可变\",{\"1\":{\"232\":1}}],[\"大小来重做未完成的事务\",{\"1\":{\"94\":1}}],[\"大小只有\",{\"1\":{\"72\":2}}],[\"大小为\",{\"1\":{\"72\":3,\"73\":1}}],[\"大小计算而来的\",{\"1\":{\"69\":1}}],[\"大小\",{\"1\":{\"17\":1,\"241\":1}}],[\"大不一样\",{\"1\":{\"14\":1}}],[\"大大提升了副本执行效率\",{\"1\":{\"8\":1}}],[\"否则直接拒绝\",{\"1\":{\"283\":1}}],[\"否则还需向进程申请\",{\"1\":{\"241\":1}}],[\"否则\",{\"1\":{\"227\":1}}],[\"否则不做任何事情\",{\"1\":{\"225\":1}}],[\"否则函数返回\",{\"1\":{\"225\":1}}],[\"否则继续向下运行\",{\"1\":{\"225\":1}}],[\"否则数据没有分配\",{\"1\":{\"207\":1}}],[\"否则只能在队列中等待\",{\"1\":{\"199\":1}}],[\"否则前面的goroutine可能阻塞\",{\"1\":{\"189\":1}}],[\"否则删除所有日志\",{\"1\":{\"136\":1}}],[\"否则下一次同步序号为\",{\"1\":{\"134\":1}}],[\"否则下次调用仍会返回相同的\",{\"1\":{\"13\":1}}],[\"否则返回失败\",{\"1\":{\"88\":1}}],[\"否则迭代器继续\",{\"1\":{\"79\":1}}],[\"否则一直持有\",{\"1\":{\"73\":1}}],[\"否则找到含\",{\"1\":{\"72\":1}}],[\"否则页永远不能删除\",{\"1\":{\"64\":1}}],[\"否则无法保证文档的有序性\",{\"1\":{\"43\":1}}],[\"否则会导致重复应用op\",{\"1\":{\"13\":1}}],[\"后需要缓存\",{\"1\":{\"283\":1}}],[\"后才会开启\",{\"1\":{\"284\":1}}],[\"后才有\",{\"1\":{\"283\":1}}],[\"后才能运行\",{\"1\":{\"199\":1}}],[\"后才能到达路由层\",{\"1\":{\"149\":1}}],[\"后才能得到当前所有日志的总大小\",{\"1\":{\"136\":1}}],[\"后然后删除\",{\"1\":{\"282\":1}}],[\"后直接去线程缓存\",{\"1\":{\"241\":1}}],[\"后文我们再来细谈\",{\"1\":{\"235\":1}}],[\"后端平台来编译\",{\"1\":{\"219\":1}}],[\"后退出程序\",{\"1\":{\"217\":1}}],[\"后链接的\",{\"1\":{\"217\":1}}],[\"后赋值给\",{\"1\":{\"187\":1}}],[\"后新加入至标准库的内置类型\",{\"1\":{\"181\":1}}],[\"后写代码\",{\"1\":{\"168\":1}}],[\"后写测试\",{\"1\":{\"168\":1}}],[\"后兼容\",{\"1\":{\"146\":1}}],[\"后面再细说\",{\"1\":{\"282\":1}}],[\"后面有用的部分\",{\"1\":{\"282\":1}}],[\"后面我们再来谈这个\",{\"1\":{\"261\":1}}],[\"后面看了源码以后才恍然大悟\",{\"1\":{\"257\":1}}],[\"后面的\",{\"1\":{\"226\":1}}],[\"后面将不会再说明\",{\"1\":{\"200\":1}}],[\"后面\",{\"1\":{\"114\":1}}],[\"后面增加了\",{\"1\":{\"114\":1}}],[\"后台线程每隔一段时间就会构建出事务之间的依赖图\",{\"1\":{\"88\":1}}],[\"后访问的事务必须等前一个事务执行完成\",{\"1\":{\"84\":1}}],[\"后续文章会对\",{\"1\":{\"52\":1}}],[\"后继操作\",{\"1\":{\"28\":1}}],[\"后\",{\"1\":{\"13\":1,\"25\":1,\"43\":1,\"64\":2,\"71\":4,\"72\":1,\"73\":1,\"136\":1,\"190\":1,\"199\":1,\"218\":2,\"227\":1,\"238\":1,\"240\":1,\"241\":2,\"244\":1,\"279\":1,\"282\":1,\"283\":1}}],[\"污染\",{\"1\":{\"13\":1}}],[\"避免全局队列中的\",{\"1\":{\"200\":1}}],[\"避免饥饿\",{\"1\":{\"200\":1}}],[\"避免每次使用的时候都重新创建\",{\"1\":{\"260\":1}}],[\"避免每次在业务中对切片进行操作\",{\"1\":{\"128\":1}}],[\"避免每次查询\",{\"1\":{\"58\":1}}],[\"避免二次编码\",{\"1\":{\"104\":1}}],[\"避免被垃圾回收掉\",{\"1\":{\"260\":1}}],[\"避免被\",{\"1\":{\"64\":1}}],[\"避免抄袭\",{\"1\":{\"56\":1}}],[\"避免下次重复发送\",{\"1\":{\"13\":1}}],[\"避免\",{\"1\":{\"13\":1}}],[\"避免重复应用\",{\"1\":{\"13\":1}}],[\"需将\",{\"1\":{\"227\":1}}],[\"需求\",{\"0\":{\"169\":1}}],[\"需求都没理解\",{\"1\":{\"168\":1}}],[\"需求评审时思考\",{\"1\":{\"162\":1}}],[\"需调整后续功能点中对于功能上下文以及任务项的划分\",{\"1\":{\"164\":1}}],[\"需携带本次快照请求的快照数据\",{\"1\":{\"136\":1}}],[\"需有一个转换操作\",{\"1\":{\"136\":1}}],[\"需收到\",{\"1\":{\"123\":1}}],[\"需记得对兄弟节点加独占锁\",{\"1\":{\"73\":1}}],[\"需先找到该叶子结点\",{\"1\":{\"71\":1}}],[\"需比较\",{\"1\":{\"44\":1}}],[\"需立即更新vector时钟\",{\"1\":{\"13\":1}}],[\"需要满足一下几个条件\",{\"1\":{\"285\":1}}],[\"需要判断是否超过了窗口\",{\"1\":{\"283\":1}}],[\"需要处理很多边角逻辑\",{\"1\":{\"283\":1}}],[\"需要先从局部出发\",{\"1\":{\"280\":1}}],[\"需要一个重组器组件专门用于流序号的重组工作\",{\"1\":{\"274\":1}}],[\"需要通过三次握手来确认对端状态\",{\"1\":{\"272\":1}}],[\"需要通过其它手段来及时同步地址信息\",{\"1\":{\"148\":1}}],[\"需要三次握手来协商建立连接\",{\"1\":{\"272\":1}}],[\"需要从栈顶弹出两个对象然后再入栈\",{\"1\":{\"243\":1}}],[\"需要对\",{\"1\":{\"219\":1}}],[\"需要对节点\",{\"1\":{\"71\":1}}],[\"需要排空\",{\"1\":{\"189\":1}}],[\"需要你有自己的想法\",{\"1\":{\"164\":1}}],[\"需要重写\",{\"1\":{\"164\":1}}],[\"需要大量实践和打磨\",{\"1\":{\"150\":1}}],[\"需要考虑如下因素\",{\"1\":{\"146\":1}}],[\"需要\",{\"1\":{\"138\":1,\"150\":1}}],[\"需要更新\",{\"1\":{\"136\":1}}],[\"需要更新timestamp\",{\"1\":{\"16\":1}}],[\"需要遍历日志找到冲突任期\",{\"1\":{\"134\":1}}],[\"需要持久化的字段只有三个\",{\"1\":{\"133\":1}}],[\"需要向\",{\"1\":{\"112\":1}}],[\"需要同时支持\",{\"1\":{\"98\":1}}],[\"需要同时指定originleft和originright\",{\"1\":{\"48\":1}}],[\"需要合并\",{\"1\":{\"72\":1,\"73\":1}}],[\"需要注意脏页\",{\"1\":{\"64\":1}}],[\"需要注意\",{\"1\":{\"64\":1,\"285\":1}}],[\"需要注意的是\",{\"1\":{\"4\":1}}],[\"需要携带一个timestamp标识\",{\"1\":{\"16\":1}}],[\"需要状态合并\",{\"1\":{\"14\":1}}],[\"需要防重\",{\"1\":{\"14\":1}}],[\"需要将本地状态同步到其它节点时\",{\"1\":{\"13\":1}}],[\"需要将本地向量n与收到的向量\",{\"1\":{\"10\":1}}],[\"需要读取计数器值时\",{\"1\":{\"13\":1}}],[\"需要保证并发安全\",{\"1\":{\"63\":1}}],[\"需要保证数据的高可用性\",{\"1\":{\"4\":1}}],[\"需要保证数据的完整性和可靠性\",{\"1\":{\"4\":1}}],[\"需要保证返回的是最新的值\",{\"1\":{\"4\":1}}],[\"需要实现并发控制来保证数据的一致性和正确性\",{\"1\":{\"4\":1}}],[\"需要定期合并\",{\"1\":{\"4\":1}}],[\"`package\",{\"1\":{\"219\":2}}],[\"`unsupport\",{\"1\":{\"13\":1,\"16\":1,\"18\":1}}],[\"`\",{\"1\":{\"13\":2,\"16\":1,\"18\":1,\"219\":2}}],[\"`op\",{\"1\":{\"13\":1}}],[\"$buildroot\",{\"1\":{\"293\":2}}],[\"$crosstool\",{\"1\":{\"292\":1}}],[\"$framesize\",{\"1\":{\"256\":1}}],[\"$25\",{\"1\":{\"255\":1}}],[\"$path\",{\"1\":{\"225\":2,\"227\":1}}],[\"$pwd\",{\"1\":{\"224\":2,\"225\":8,\"227\":17}}],[\"$60\",{\"1\":{\"217\":1}}],[\"$33\",{\"1\":{\"217\":2}}],[\"$37\",{\"1\":{\"213\":1}}],[\"$96\",{\"1\":{\"213\":1}}],[\"$runtime\",{\"1\":{\"200\":3,\"251\":1}}],[\"$~15\",{\"1\":{\"200\":1}}],[\"$0\",{\"1\":{\"197\":1,\"200\":10,\"217\":2,\"251\":1,\"256\":2,\"257\":2}}],[\"$0x123\",{\"1\":{\"254\":1}}],[\"$0x10\",{\"1\":{\"180\":4}}],[\"$0x60058d48\",{\"1\":{\"213\":1}}],[\"$0x64\",{\"1\":{\"213\":1}}],[\"$0xc06b\",{\"1\":{\"213\":1}}],[\"$0xe5\",{\"1\":{\"213\":1}}],[\"$0x8948\",{\"1\":{\"213\":1}}],[\"$0x80\",{\"1\":{\"197\":2}}],[\"$0x55\",{\"1\":{\"213\":1}}],[\"$0x00\",{\"1\":{\"213\":1}}],[\"$0x0000\",{\"1\":{\"213\":1}}],[\"$0x0\",{\"1\":{\"180\":1}}],[\"$4\",{\"1\":{\"197\":1,\"255\":1}}],[\"$12\",{\"1\":{\"257\":3}}],[\"$1000\",{\"1\":{\"213\":1}}],[\"$100\",{\"1\":{\"213\":1}}],[\"$16\",{\"1\":{\"200\":1,\"255\":1}}],[\"$1\",{\"1\":{\"197\":2,\"212\":1,\"213\":1,\"252\":1,\"257\":2}}],[\"$1374389535\",{\"1\":{\"213\":1}}],[\"$13\",{\"1\":{\"197\":1,\"212\":1}}],[\"$msg\",{\"1\":{\"197\":1}}],[\"$\",{\"1\":{\"13\":3,\"16\":1,\"18\":1,\"180\":2,\"197\":6,\"200\":4,\"212\":5,\"217\":16,\"219\":1,\"252\":1,\"255\":2,\"257\":6,\"277\":2,\"286\":2,\"290\":3,\"291\":7,\"293\":1}}],[\"+829\",{\"1\":{\"227\":1}}],[\"+82\",{\"1\":{\"227\":1}}],[\"+type\",{\"1\":{\"227\":1}}],[\"+652\",{\"1\":{\"227\":1}}],[\"+60\",{\"1\":{\"225\":1}}],[\"+func\",{\"1\":{\"227\":5}}],[\"+262\",{\"1\":{\"227\":1}}],[\"+2613\",{\"1\":{\"225\":1}}],[\"+223\",{\"1\":{\"227\":1}}],[\"+2269\",{\"1\":{\"227\":1}}],[\"+273\",{\"1\":{\"227\":1}}],[\"+289\",{\"1\":{\"227\":2}}],[\"+2581\",{\"1\":{\"227\":1}}],[\"+39\",{\"1\":{\"227\":1}}],[\"+435\",{\"1\":{\"227\":1}}],[\"+410\",{\"1\":{\"227\":1}}],[\"+49\",{\"1\":{\"225\":1}}],[\"+50\",{\"1\":{\"227\":1}}],[\"+pcquantum\",{\"1\":{\"200\":1,\"202\":1}}],[\"+1821\",{\"1\":{\"227\":1}}],[\"+118\",{\"1\":{\"227\":1}}],[\"+19\",{\"1\":{\"227\":1}}],[\"+1\",{\"1\":{\"71\":1,\"124\":1,\"134\":1,\"283\":1,\"284\":1}}],[\"+++\",{\"1\":{\"197\":2,\"225\":3,\"227\":15,\"257\":2}}],[\"++\",{\"1\":{\"64\":1,\"79\":2,\"89\":1}}],[\"++this\",{\"1\":{\"16\":1,\"18\":1}}],[\"+\",{\"1\":{\"13\":1,\"14\":4,\"26\":2,\"30\":1,\"47\":3,\"48\":3,\"51\":1,\"70\":2,\"72\":1,\"89\":28,\"92\":1,\"97\":1,\"98\":1,\"99\":1,\"126\":6,\"129\":14,\"130\":17,\"131\":5,\"133\":8,\"134\":42,\"136\":29,\"137\":8,\"146\":4,\"177\":2,\"179\":8,\"181\":1,\"190\":1,\"200\":12,\"202\":1,\"213\":2,\"218\":4,\"219\":4,\"225\":52,\"227\":163,\"240\":5,\"241\":1,\"243\":1,\"281\":2,\"282\":1,\"283\":2,\"284\":3,\"286\":5,\"293\":1,\"294\":6}}],[\"+=\",{\"1\":{\"4\":1,\"13\":1,\"26\":1,\"34\":1,\"47\":1,\"48\":1,\"64\":2,\"123\":1,\"200\":1,\"218\":6,\"240\":1,\"253\":1,\"281\":3,\"282\":4,\"283\":2,\"284\":2,\"285\":1}}],[\"增量对象标记\",{\"1\":{\"245\":1}}],[\"增加定时器时间\",{\"1\":{\"284\":1}}],[\"增加\",{\"1\":{\"227\":1,\"285\":1}}],[\"增加理解的难度\",{\"1\":{\"164\":1}}],[\"增加两个字段分别表示冲突任期和序号\",{\"1\":{\"134\":1}}],[\"增加选票数\",{\"1\":{\"124\":1}}],[\"增加读\",{\"1\":{\"98\":1}}],[\"增加计数器\",{\"1\":{\"13\":1,\"14\":1}}],[\"增减时\",{\"1\":{\"10\":1}}],[\"增减只需改变本地状态i即可\",{\"1\":{\"10\":1}}],[\"增减数值\",{\"1\":{\"9\":1}}],[\"由服务器发送\",{\"1\":{\"286\":1}}],[\"由服务发现通知更换\",{\"1\":{\"104\":1}}],[\"由操作系统实现在了内核态\",{\"1\":{\"277\":1}}],[\"由它负责向进程申请内存\",{\"1\":{\"241\":1}}],[\"由一个或多个页组成\",{\"1\":{\"241\":1}}],[\"由用户程序自己管理\",{\"1\":{\"232\":1}}],[\"由汇编实现\",{\"1\":{\"200\":1}}],[\"由编译器实现\",{\"1\":{\"200\":1}}],[\"由内核调度器统一调度\",{\"1\":{\"194\":1}}],[\"由上层应用来处理\",{\"1\":{\"136\":1}}],[\"由事务\",{\"1\":{\"85\":1}}],[\"由磁盘管理器和宿主机操作系统共同完成\",{\"1\":{\"58\":1}}],[\"由\",{\"1\":{\"23\":1,\"43\":1,\"64\":1,\"157\":1,\"232\":1,\"275\":1,\"279\":1}}],[\"由客户端\",{\"1\":{\"13\":1}}],[\"由于我们的环境跑在容器中\",{\"1\":{\"294\":1}}],[\"由于我们没有重新实现一门语言\",{\"1\":{\"243\":1}}],[\"由于网络延迟\",{\"1\":{\"282\":1}}],[\"由于标记阶段占用了\",{\"1\":{\"244\":1}}],[\"由于所有对象都会连接在全局链表\",{\"1\":{\"243\":1}}],[\"由于在\",{\"1\":{\"241\":1}}],[\"由于小内存的块很小\",{\"1\":{\"240\":1}}],[\"由于是分开定义\",{\"1\":{\"255\":1}}],[\"由于是虚拟内存\",{\"1\":{\"237\":1}}],[\"由于是多种数据类型\",{\"1\":{\"51\":1}}],[\"由于平台之间的差异都比较大\",{\"1\":{\"227\":1}}],[\"由于不同语言的调用约定是不一样的\",{\"1\":{\"218\":1}}],[\"由于目前我们支持的字节码比较少\",{\"1\":{\"218\":1}}],[\"由于很多使用\",{\"1\":{\"217\":1}}],[\"由于初期良好的绿灯重构\",{\"1\":{\"164\":1}}],[\"由于继承了\",{\"1\":{\"146\":1}}],[\"由于旧日志不可修改\",{\"1\":{\"127\":1}}],[\"由于操作系统\",{\"1\":{\"69\":1}}],[\"由于每次访问或者新增页时\",{\"1\":{\"63\":1}}],[\"由于originright是2\",{\"1\":{\"48\":1}}],[\"由于id是唯一且确定的\",{\"1\":{\"43\":1}}],[\"由于无法通过origin来比较顺序\",{\"1\":{\"43\":1}}],[\"由于字符3被软删除掉了\",{\"1\":{\"26\":1}}],[\"由于整个文档是一颗树\",{\"1\":{\"26\":1}}],[\"由于value是时间戳大的一方获胜\",{\"1\":{\"17\":1}}],[\"由于传输的数据内容是状态\",{\"1\":{\"14\":1}}],[\"由于\",{\"1\":{\"8\":1,\"14\":1,\"70\":1,\"105\":2,\"129\":1,\"179\":1,\"188\":1,\"208\":1,\"219\":1,\"241\":1,\"246\":1,\"262\":1,\"282\":3}}],[\"由于没有明确的prompt\",{\"1\":{\"4\":1}}],[\"每当调用\",{\"1\":{\"285\":1}}],[\"每当计时\",{\"1\":{\"285\":1}}],[\"每当需要新的类型支持时\",{\"1\":{\"181\":1}}],[\"每小块都有一个头部\",{\"1\":{\"240\":1}}],[\"每调度\",{\"1\":{\"200\":2}}],[\"每秒都在发生系统调用\",{\"1\":{\"198\":1}}],[\"每进行一次回归测试收益就增加一次\",{\"1\":{\"164\":1}}],[\"每访问一个节点都必须先加独占锁\",{\"1\":{\"73\":1}}],[\"每一条日志都可被抽象为\",{\"1\":{\"128\":1}}],[\"每一条数据记录都由\",{\"1\":{\"88\":1}}],[\"每一类查询\",{\"1\":{\"79\":1}}],[\"每一个指令只做一件小事情\",{\"1\":{\"218\":1}}],[\"每一个测试都兼具功能验证和错误定位的功效\",{\"1\":{\"164\":1}}],[\"每一个节点在初始化时\",{\"1\":{\"123\":1}}],[\"每一个节点会有集群元数据\",{\"1\":{\"123\":1}}],[\"每一个\",{\"1\":{\"123\":1,\"200\":1,\"243\":1}}],[\"每一个执行器都实现\",{\"1\":{\"78\":1}}],[\"每一个箭头指向一个孩子节点\",{\"1\":{\"68\":1}}],[\"每一项对应的数组序号称为\",{\"1\":{\"64\":1}}],[\"每一页在磁盘上都有一个副本\",{\"1\":{\"62\":1}}],[\"每执行一次查询\",{\"1\":{\"58\":1}}],[\"每次超时重发\",{\"1\":{\"284\":1}}],[\"每次发送一个包\",{\"1\":{\"284\":1}}],[\"每次服务收到请求调用\",{\"1\":{\"260\":1}}],[\"每次调度都会检查定时器\",{\"1\":{\"200\":1}}],[\"每次调度的时候\",{\"1\":{\"200\":1}}],[\"每次调用\",{\"1\":{\"78\":1}}],[\"每次通知后需重新订阅通知\",{\"1\":{\"148\":1}}],[\"每次\",{\"1\":{\"134\":1,\"238\":1}}],[\"每次插入操作都需要满足上面的\",{\"1\":{\"44\":1}}],[\"每次变更时\",{\"1\":{\"16\":1}}],[\"每次变更都会将当前客户端的状态保存到map中\",{\"1\":{\"14\":1}}],[\"每次变更都会增加clock的值\",{\"1\":{\"13\":2}}],[\"每个报文中的每个字节都有唯一的序号\",{\"1\":{\"279\":1}}],[\"每个报文都有校验和字段\",{\"1\":{\"273\":1}}],[\"每个人都有能力去理解和实现\",{\"1\":{\"278\":1}}],[\"每个小阶段都可以完成一部分标记工作\",{\"1\":{\"244\":1}}],[\"每个小任务都有明确的结果验证再继续推进\",{\"1\":{\"164\":1}}],[\"每个线程都有一定量的内存缓存\",{\"1\":{\"241\":1}}],[\"每个线程都与\",{\"1\":{\"199\":1}}],[\"每个页都装满了相同尺寸的块\",{\"1\":{\"241\":1}}],[\"每个向进程申请内存时\",{\"1\":{\"241\":1}}],[\"每个语言的实现不尽相同\",{\"1\":{\"235\":1}}],[\"每个工作线程一直都在执行\",{\"1\":{\"200\":1}}],[\"每个stream开启一个协程\",{\"1\":{\"187\":1}}],[\"每个数据项均需满足条件后返回结果\",{\"1\":{\"185\":1}}],[\"每个消费者独有自己的消费序号\",{\"1\":{\"153\":1}}],[\"每个服务提供者都有一个唯一且确定的连接\",{\"1\":{\"145\":1}}],[\"每个服务节点中\",{\"1\":{\"106\":1}}],[\"每个节点都有其特有的哈希槽\",{\"1\":{\"106\":1}}],[\"每个节点最多只有\",{\"1\":{\"68\":1}}],[\"每个事务当需要时向锁管理器请求锁\",{\"1\":{\"85\":1}}],[\"每个非叶子节点\",{\"1\":{\"68\":1}}],[\"每个目录后面用注释说明了当前模块的作用和功能\",{\"1\":{\"59\":1}}],[\"每个插入操作被抽象为item\",{\"1\":{\"50\":1}}],[\"每个插入字符操作被抽象为一个item\",{\"1\":{\"26\":1}}],[\"每个\",{\"1\":{\"28\":1,\"158\":1,\"159\":1,\"160\":1,\"217\":1,\"282\":1}}],[\"每个operation都有唯一的id\",{\"1\":{\"28\":1}}],[\"每个字符是其中一个节点\",{\"1\":{\"26\":1}}],[\"每个字符都可能成为多个字符的意图\",{\"1\":{\"26\":1}}],[\"每个元素都是一个操作\",{\"1\":{\"13\":1}}],[\"每个客户端都是向量\",{\"1\":{\"10\":1}}],[\"客户端会关闭输出流\",{\"1\":{\"286\":1}}],[\"客户端会选择其它节点继续使用\",{\"1\":{\"105\":1}}],[\"客户端在收到第一个\",{\"1\":{\"286\":1}}],[\"客户端发起连接\",{\"1\":{\"286\":1}}],[\"客户端发送\",{\"1\":{\"286\":4}}],[\"客户端调用\",{\"1\":{\"286\":1}}],[\"客户端收到\",{\"1\":{\"272\":1,\"286\":1}}],[\"客户端向服务器发送\",{\"1\":{\"272\":1}}],[\"客户端向量\",{\"1\":{\"26\":1}}],[\"客户端连接等\",{\"1\":{\"260\":1}}],[\"客户端需要从其中选择一个最合适的服务提供者并发起请求\",{\"1\":{\"145\":1}}],[\"客户端需感知变更\",{\"1\":{\"105\":1}}],[\"客户端无需过多关注缓存服务集群信息\",{\"1\":{\"105\":1}}],[\"客户端直接访问缓存服务有诸多不便\",{\"1\":{\"105\":1}}],[\"客户端访问模式\",{\"1\":{\"104\":1}}],[\"客户端通过拉取和监听\",{\"1\":{\"105\":1}}],[\"客户端通过\",{\"1\":{\"104\":2}}],[\"客户端可直接使用\",{\"1\":{\"102\":1}}],[\"客户端唯一标识符\",{\"1\":{\"26\":1}}],[\"客户端\",{\"0\":{\"104\":1,\"109\":1},\"1\":{\"13\":1,\"14\":1,\"16\":1,\"18\":1,\"25\":4,\"43\":1,\"47\":1,\"48\":1,\"102\":1,\"103\":1,\"142\":1,\"286\":1}}],[\"客户端只能操作属于自己的项\",{\"1\":{\"10\":1}}],[\"前后任期不一致\",{\"1\":{\"129\":1}}],[\"前面说到大对象是按页来分配的\",{\"1\":{\"241\":1}}],[\"前面在内存分配原理中\",{\"1\":{\"241\":1}}],[\"前面需要一个占位\",{\"1\":{\"136\":1}}],[\"前面我们谈到\",{\"1\":{\"136\":1}}],[\"前面有值\",{\"1\":{\"115\":1}}],[\"前面的执行器是无法支持事务隔离的\",{\"1\":{\"89\":1}}],[\"前面的两个小节中\",{\"1\":{\"77\":1}}],[\"前面实现的\",{\"1\":{\"73\":1}}],[\"前面\",{\"1\":{\"71\":1,\"114\":1}}],[\"前面谈到\",{\"1\":{\"68\":1}}],[\"前面已经介绍了\",{\"1\":{\"12\":1}}],[\"前言\",{\"0\":{\"8\":1,\"22\":1,\"41\":1,\"56\":1,\"167\":1,\"223\":1}}],[\"等适配器将其适配适配到\",{\"1\":{\"286\":1}}],[\"等因素\",{\"1\":{\"274\":1}}],[\"等一些列的分配算法\",{\"1\":{\"240\":1}}],[\"等内置了垃圾回收器\",{\"1\":{\"233\":1}}],[\"等标准库来等\",{\"1\":{\"219\":1}}],[\"等资源\",{\"1\":{\"217\":1}}],[\"等到了生成环境数据库采用了\",{\"1\":{\"164\":1}}],[\"等都非常好用\",{\"1\":{\"152\":1}}],[\"等字段到达对端同步信息\",{\"1\":{\"285\":1}}],[\"等字段\",{\"1\":{\"136\":1}}],[\"等字段来维护这些信息\",{\"1\":{\"126\":1}}],[\"等信息\",{\"1\":{\"123\":1}}],[\"等高级特性\",{\"1\":{\"103\":1}}],[\"等数据\",{\"1\":{\"136\":1}}],[\"等数据结构\",{\"1\":{\"102\":1}}],[\"等数据类型的基类\",{\"1\":{\"50\":1}}],[\"等方法分别用于互斥锁\",{\"1\":{\"88\":1}}],[\"等待超时\",{\"1\":{\"286\":1}}],[\"等待时间为\",{\"1\":{\"285\":1}}],[\"等待被发送\",{\"1\":{\"285\":1}}],[\"等待被唤醒\",{\"1\":{\"200\":1}}],[\"等待重组器中数据为空时再关闭输入流\",{\"1\":{\"282\":1}}],[\"等待回收清理\",{\"1\":{\"244\":1}}],[\"等待响应\",{\"1\":{\"148\":1}}],[\"等待请求\",{\"1\":{\"148\":1}}],[\"等待列表\",{\"1\":{\"88\":1}}],[\"等待\",{\"1\":{\"87\":2}}],[\"等等\",{\"1\":{\"79\":1,\"87\":1,\"149\":1,\"240\":1,\"273\":1}}],[\"等\",{\"1\":{\"11\":1,\"19\":1,\"56\":2,\"63\":1,\"67\":1,\"77\":1,\"79\":1,\"122\":1,\"123\":1,\"147\":1,\"155\":1,\"164\":1,\"190\":1,\"200\":1,\"219\":2,\"237\":1,\"243\":1,\"279\":1,\"284\":1}}],[\"等算法来实现缓存策略\",{\"1\":{\"4\":1}}],[\"库包装好的系统调用函数\",{\"1\":{\"197\":1}}],[\"库是如何实现的\",{\"1\":{\"52\":1}}],[\"库的基础\",{\"1\":{\"23\":1}}],[\"库\",{\"1\":{\"11\":1,\"22\":1,\"27\":1,\"49\":1}}],[\"既可以直接使用\",{\"1\":{\"281\":1}}],[\"既眼馋于\",{\"1\":{\"177\":1}}],[\"既能帮助我们理解\",{\"1\":{\"11\":1}}],[\"既然内存管理如此重要\",{\"1\":{\"233\":1}}],[\"既然常规方法不行\",{\"1\":{\"223\":1}}],[\"既然有了正确的思路\",{\"1\":{\"217\":1}}],[\"既然领导者需要不断地与追随者同步日志\",{\"1\":{\"126\":1}}],[\"既然没有日志需要发送\",{\"1\":{\"126\":1}}],[\"既然是基于\",{\"1\":{\"16\":1}}],[\"既然\",{\"1\":{\"10\":1}}],[\"既然珠玉在前\",{\"1\":{\"8\":1}}],[\"纸上得来终觉浅\",{\"1\":{\"11\":1}}],[\"摘自维基百科\",{\"1\":{\"83\":1}}],[\"摘自\",{\"1\":{\"10\":1}}],[\"函数且没有发生过\",{\"1\":{\"286\":1}}],[\"函数发出连接\",{\"1\":{\"286\":1}}],[\"函数发送快照请求\",{\"1\":{\"136\":1}}],[\"函数发送给\",{\"1\":{\"136\":1}}],[\"函数发送请求\",{\"1\":{\"129\":1}}],[\"函数发送\",{\"1\":{\"124\":1}}],[\"函数多次出现\",{\"1\":{\"285\":1}}],[\"函数都比较简单\",{\"1\":{\"283\":1}}],[\"函数直接找到第一个大于等于当前节点\",{\"1\":{\"282\":1}}],[\"函数poolcleanup来实现回收\",{\"1\":{\"262\":1}}],[\"函数用于返回一个新的\",{\"1\":{\"262\":1}}],[\"函数说明如下\",{\"1\":{\"256\":1}}],[\"函数参数大小\",{\"1\":{\"256\":1}}],[\"函数栈帧大小\",{\"1\":{\"256\":1}}],[\"函数定义在\",{\"1\":{\"256\":1}}],[\"函数定义语法如下\",{\"1\":{\"256\":1}}],[\"函数定义\",{\"0\":{\"256\":1}}],[\"函数清理白色对象\",{\"1\":{\"244\":1}}],[\"函数也会有相应的改造\",{\"1\":{\"244\":1}}],[\"函数也需要加上\",{\"1\":{\"136\":1}}],[\"函数则要简单的多\",{\"1\":{\"240\":1}}],[\"函数则稍微复杂一些\",{\"1\":{\"133\":1}}],[\"函数分配内存\",{\"1\":{\"238\":1}}],[\"函数分别用来开辟\",{\"1\":{\"233\":1}}],[\"函数仅有\",{\"1\":{\"218\":1}}],[\"函数即时编译为机器码\",{\"1\":{\"218\":1}}],[\"函数即可\",{\"1\":{\"133\":2}}],[\"函数对应的字节码\",{\"1\":{\"218\":1}}],[\"函数略有不同\",{\"1\":{\"217\":1}}],[\"函数体定义在一个单独的汇编文件中\",{\"1\":{\"217\":1}}],[\"函数不仅成功运行\",{\"1\":{\"213\":1}}],[\"函数调用辅助文件\",{\"1\":{\"212\":1}}],[\"函数调用来执行快照\",{\"1\":{\"136\":1}}],[\"函数就能顺利的链接上对应的汇编代码\",{\"1\":{\"212\":1}}],[\"函数就能快速的将字符数据从\",{\"1\":{\"207\":1}}],[\"函数就比较简单了\",{\"1\":{\"188\":1}}],[\"函数要更加方便一些\",{\"1\":{\"207\":1}}],[\"函数链接到\",{\"1\":{\"207\":1}}],[\"函数却可以在其它包中\",{\"1\":{\"206\":1}}],[\"函数只能在包内调用\",{\"1\":{\"206\":1}}],[\"函数只需增加数据项的总数返回即可\",{\"1\":{\"189\":1}}],[\"函数并没有新建\",{\"1\":{\"200\":1}}],[\"函数地址\",{\"1\":{\"200\":1}}],[\"函数地址被当作参数\",{\"1\":{\"200\":1}}],[\"函数代码比较长\",{\"1\":{\"200\":1}}],[\"函数通过汇编成功的调用了\",{\"1\":{\"257\":1}}],[\"函数通过栈接受两个参数\",{\"1\":{\"251\":1}}],[\"函数通过\",{\"1\":{\"200\":1}}],[\"函数获取当前\",{\"1\":{\"200\":1}}],[\"函数启动\",{\"1\":{\"200\":1}}],[\"函数新建一个\",{\"1\":{\"200\":1}}],[\"函数继续来处理这两个参数\",{\"1\":{\"200\":1}}],[\"函数将\",{\"1\":{\"200\":2}}],[\"函数将会完成\",{\"1\":{\"200\":1}}],[\"函数有一个\",{\"1\":{\"283\":1}}],[\"函数有些简单\",{\"1\":{\"213\":1}}],[\"函数有如下两个工作\",{\"1\":{\"200\":1}}],[\"函数有且只有一行代码\",{\"1\":{\"200\":1}}],[\"函数是否成功调用了\",{\"1\":{\"257\":1}}],[\"函数是否被成功调用\",{\"1\":{\"164\":1}}],[\"函数是由编译器来实现的\",{\"1\":{\"200\":1}}],[\"函数是\",{\"1\":{\"197\":1}}],[\"函数的参数进行处理\",{\"1\":{\"219\":1}}],[\"函数的定义\",{\"1\":{\"219\":1}}],[\"函数的字节码\",{\"1\":{\"218\":1}}],[\"函数的第一个参数\",{\"1\":{\"208\":1}}],[\"函数的入口地址\",{\"1\":{\"200\":1}}],[\"函数的作用就是将\",{\"1\":{\"200\":1}}],[\"函数的地址\",{\"1\":{\"200\":1,\"251\":1}}],[\"函数的代码\",{\"1\":{\"200\":1}}],[\"函数的核心在于去重\",{\"1\":{\"188\":1}}],[\"函数的泛型是如何实现的\",{\"1\":{\"181\":1}}],[\"函数会不断的判断当前是否有\",{\"1\":{\"200\":1}}],[\"函数会在终端输出一段文本\",{\"1\":{\"197\":1}}],[\"函数会拼接多个流的数据\",{\"1\":{\"187\":1}}],[\"函数会过滤掉>=4\",{\"1\":{\"181\":1}}],[\"函数实际上比较复杂\",{\"1\":{\"200\":1}}],[\"函数实则是一个简单的构造函数\",{\"1\":{\"187\":1}}],[\"函数实现类似\",{\"1\":{\"181\":1}}],[\"函数为例\",{\"1\":{\"187\":1,\"218\":1}}],[\"函数足够简单\",{\"1\":{\"181\":1}}],[\"函数得到最后的\",{\"1\":{\"181\":1}}],[\"函数得到新的元素\",{\"1\":{\"181\":1}}],[\"函数内部使用\",{\"1\":{\"181\":1}}],[\"函数类型后\",{\"1\":{\"181\":1}}],[\"函数被编译成了多个\",{\"1\":{\"180\":1}}],[\"函数重名\",{\"1\":{\"179\":1}}],[\"函数后\",{\"1\":{\"177\":1}}],[\"函数式编程的方式来处理数据\",{\"1\":{\"177\":1}}],[\"函数来向\",{\"1\":{\"238\":1}}],[\"函数来回收垃圾\",{\"1\":{\"238\":1}}],[\"函数来释放\",{\"1\":{\"234\":1}}],[\"函数来开辟内存\",{\"1\":{\"234\":1}}],[\"函数来打印结果\",{\"1\":{\"219\":1}}],[\"函数来对切片进行手动扩容了\",{\"1\":{\"208\":1}}],[\"函数来实现的\",{\"1\":{\"208\":1}}],[\"函数来隐式的扩容\",{\"1\":{\"208\":1}}],[\"函数来真正的应用快照\",{\"1\":{\"136\":1}}],[\"函数来执行快照\",{\"1\":{\"136\":2}}],[\"函数来周期性地向其它节点同步日志\",{\"1\":{\"129\":1}}],[\"函数接受两个参数\",{\"1\":{\"200\":1}}],[\"函数接受\",{\"1\":{\"136\":1,\"208\":1}}],[\"函数负责将字节码翻译为\",{\"1\":{\"218\":1}}],[\"函数负责将当前\",{\"1\":{\"133\":1}}],[\"函数负责从磁盘中读取数据并反序列化为\",{\"1\":{\"133\":1}}],[\"函数负责新建一个\",{\"1\":{\"124\":1}}],[\"函数处理好参数后\",{\"1\":{\"200\":1}}],[\"函数处理请求\",{\"1\":{\"129\":1}}],[\"函数处理然后返回\",{\"1\":{\"124\":1}}],[\"函数向输出流写入数据后\",{\"1\":{\"285\":1}}],[\"函数向其它所有节点\",{\"1\":{\"129\":1}}],[\"函数向某个节点发送\",{\"1\":{\"124\":1}}],[\"函数返回一个默认的\",{\"1\":{\"128\":1}}],[\"函数进行处理\",{\"1\":{\"124\":1,\"136\":1}}],[\"函数休眠一段时间\",{\"1\":{\"124\":1}}],[\"函数时\",{\"1\":{\"123\":1,\"285\":1}}],[\"函数上面也谈到了\",{\"1\":{\"123\":1}}],[\"函数中做好了计算\",{\"1\":{\"283\":1}}],[\"函数中调用\",{\"1\":{\"217\":1}}],[\"函数中真正创建\",{\"1\":{\"200\":1}}],[\"函数中给出了详细的注释\",{\"1\":{\"200\":1}}],[\"函数中来\",{\"1\":{\"129\":1}}],[\"函数中\",{\"1\":{\"89\":1,\"129\":1,\"133\":1,\"136\":1,\"203\":1,\"219\":2}}],[\"函数虽然只有\",{\"1\":{\"44\":1}}],[\"函数作用是将i插入到ops中\",{\"1\":{\"44\":1}}],[\"函数\",{\"1\":{\"10\":1,\"123\":2,\"124\":1,\"133\":2,\"136\":1,\"179\":4,\"180\":1,\"181\":1,\"187\":1,\"188\":1,\"198\":1,\"200\":17,\"202\":1,\"203\":1,\"206\":1,\"207\":1,\"208\":1,\"212\":1,\"213\":2,\"217\":5,\"218\":1,\"219\":2,\"238\":2,\"241\":1,\"243\":1,\"257\":1,\"281\":4}}],[\"其他\",{\"1\":{\"243\":1}}],[\"其他操作\",{\"1\":{\"73\":1}}],[\"其大小\",{\"1\":{\"241\":1}}],[\"其大小为\",{\"1\":{\"72\":1,\"255\":1}}],[\"其接收一个参数\",{\"1\":{\"237\":1}}],[\"其重要性不言而喻\",{\"1\":{\"231\":1}}],[\"其参数是按照\",{\"1\":{\"218\":1}}],[\"其字节码执行都是基于栈来执行的\",{\"1\":{\"218\":1}}],[\"其对应的字节码如下\",{\"1\":{\"218\":1}}],[\"其对应的\",{\"1\":{\"217\":1}}],[\"其对应的功能分别如下\",{\"1\":{\"184\":1}}],[\"其程序的入口是\",{\"1\":{\"217\":1}}],[\"其部分\",{\"1\":{\"185\":1}}],[\"其流程图如下\",{\"1\":{\"160\":1}}],[\"其流程图\",{\"1\":{\"159\":1}}],[\"其日志大幅度落后领导者\",{\"1\":{\"136\":1}}],[\"其有两个字段\",{\"1\":{\"128\":1}}],[\"其架构图如下\",{\"1\":{\"105\":1}}],[\"其变更才能被其它事务看到\",{\"1\":{\"84\":1}}],[\"其变更就能被其它事务看到\",{\"1\":{\"84\":1}}],[\"其定义如下\",{\"1\":{\"78\":1,\"79\":1}}],[\"其核心是引入生产线程\",{\"1\":{\"159\":1}}],[\"其核心字段\",{\"1\":{\"128\":1}}],[\"其核心字段有两个\",{\"1\":{\"79\":1}}],[\"其核心\",{\"1\":{\"79\":1}}],[\"其核心实现如下\",{\"1\":{\"79\":1}}],[\"其核心其实都是\",{\"1\":{\"79\":1}}],[\"其核心思想是充分信任程序员\",{\"1\":{\"234\":1}}],[\"其核心思想是\",{\"1\":{\"78\":1}}],[\"其核心伪代码如下\",{\"1\":{\"73\":1}}],[\"其父节点\",{\"1\":{\"72\":1}}],[\"其兄弟节点\",{\"1\":{\"72\":1}}],[\"其内部的\",{\"1\":{\"69\":1}}],[\"其\",{\"1\":{\"68\":1}}],[\"其本质为一个\",{\"1\":{\"64\":1}}],[\"其着重点在于数据库后端部分\",{\"1\":{\"58\":1}}],[\"其item都会被存储在doc\",{\"1\":{\"50\":1}}],[\"其设计思想和实现优化都非常值得学习\",{\"1\":{\"49\":1}}],[\"其中一个非常著名的改进算法\",{\"1\":{\"244\":1}}],[\"其中偏移\",{\"1\":{\"198\":1}}],[\"其中技术亮点在哪里\",{\"1\":{\"162\":1}}],[\"其中\",{\"1\":{\"69\":1,\"113\":1,\"129\":1,\"139\":2,\"255\":1,\"257\":1,\"284\":1}}],[\"其中key是item\",{\"1\":{\"26\":1}}],[\"其中包含了\",{\"1\":{\"4\":1}}],[\"其它默认\",{\"1\":{\"291\":1}}],[\"其它情况下\",{\"1\":{\"284\":1}}],[\"其它操作寄存器的指令也类似于此\",{\"1\":{\"218\":1}}],[\"其它线程调用栈是在堆里面分配的\",{\"1\":{\"194\":1}}],[\"其它基本类似\",{\"1\":{\"186\":1}}],[\"其它的逻辑却一样\",{\"1\":{\"179\":1}}],[\"其它的路由实现就不赘述了\",{\"1\":{\"145\":1}}],[\"其它待实现特性\",{\"0\":{\"161\":1}}],[\"其它节点都能第一时间感知\",{\"1\":{\"125\":1}}],[\"其它节点受到请求后\",{\"1\":{\"124\":1}}],[\"其它节点接到领导者日志请求后成为其追随者\",{\"1\":{\"123\":1}}],[\"其它节点收到ops数组后\",{\"1\":{\"13\":1}}],[\"其它节点收到op后\",{\"1\":{\"10\":1}}],[\"其它节点收到n后\",{\"1\":{\"10\":1}}],[\"其它事物不可读\",{\"1\":{\"86\":1}}],[\"其它事务可读\",{\"1\":{\"86\":1}}],[\"其它执行器的实现这里就不再赘述了\",{\"1\":{\"79\":1}}],[\"其它\",{\"1\":{\"77\":1}}],[\"其它方法\",{\"1\":{\"64\":1}}],[\"其它部分只会用画图的方式来说明\",{\"1\":{\"56\":1}}],[\"其它客户端处于只读状态\",{\"1\":{\"25\":1}}],[\"其实无实际意义\",{\"1\":{\"255\":1}}],[\"其实很简单\",{\"1\":{\"239\":1,\"285\":1}}],[\"其实就和普通的\",{\"1\":{\"214\":1}}],[\"其实就是字节流还能接收多少字节\",{\"1\":{\"283\":1}}],[\"其实就是\",{\"1\":{\"200\":3}}],[\"其实就是siteid\",{\"1\":{\"28\":1}}],[\"其实在这里已经体现出\",{\"1\":{\"218\":1}}],[\"其实在\",{\"1\":{\"200\":1}}],[\"其实是个空函数\",{\"1\":{\"200\":1}}],[\"其实本质与list大差不差\",{\"1\":{\"37\":1}}],[\"其实\",{\"1\":{\"23\":1,\"218\":1}}],[\"其实一个变量\",{\"1\":{\"15\":1}}],[\"它表示流结束后是否需要等待\",{\"1\":{\"285\":1}}],[\"它接受三个参数\",{\"1\":{\"282\":1}}],[\"它说明\",{\"1\":{\"261\":1}}],[\"它池化的对象可能会被垃圾回收掉\",{\"1\":{\"261\":1}}],[\"它引入了屏障技术\",{\"1\":{\"245\":1}}],[\"它主要由如下功能点\",{\"1\":{\"243\":1}}],[\"它有\",{\"1\":{\"243\":1}}],[\"它有何作用\",{\"1\":{\"56\":1}}],[\"它的作者\",{\"1\":{\"235\":1}}],[\"它的特点是\",{\"1\":{\"15\":1}}],[\"它会产生内存泄漏\",{\"1\":{\"262\":1}}],[\"它会映射堆中的一块内存供程序操纵\",{\"1\":{\"237\":1}}],[\"它会将类似下面的\",{\"1\":{\"218\":1}}],[\"它会选择一个事务回滚以打破循环等待\",{\"1\":{\"87\":1}}],[\"它\",{\"1\":{\"214\":1}}],[\"它才是\",{\"1\":{\"200\":1}}],[\"它由编译器实现\",{\"1\":{\"198\":1}}],[\"它肯定在地址空间里面\",{\"1\":{\"194\":1}}],[\"它只能保存固定n个数据项\",{\"1\":{\"188\":1}}],[\"它既可以为int类型\",{\"1\":{\"179\":1}}],[\"它需要其它节点的选票才能成为领导者\",{\"1\":{\"124\":1}}],[\"它们特性各异\",{\"1\":{\"264\":1}}],[\"它们也就成了垃圾\",{\"1\":{\"243\":1}}],[\"它们将会被回收\",{\"1\":{\"243\":1}}],[\"它们各有优缺点\",{\"1\":{\"237\":1}}],[\"它们之间的对应关系如下\",{\"1\":{\"250\":1}}],[\"它们之间的定义如下\",{\"1\":{\"237\":1}}],[\"它们之间的关系如下所示\",{\"1\":{\"237\":1}}],[\"它们之间的速度差异可以用存储器山来直观的展示\",{\"1\":{\"231\":1}}],[\"它们不约而同地指向了一件事情\",{\"1\":{\"236\":1}}],[\"它们在程序启动的时候就已经被分配了\",{\"1\":{\"232\":1}}],[\"它们都是对多余指令\",{\"1\":{\"218\":1}}],[\"它们分别是\",{\"1\":{\"198\":1}}],[\"它们的集合中的元素是成对的\",{\"1\":{\"113\":1}}],[\"它们的集合中也只有单值\",{\"1\":{\"113\":1}}],[\"它们是如何实现的呢\",{\"1\":{\"10\":1}}],[\"它本身就是单值的键值对\",{\"1\":{\"113\":1}}],[\"它能保证数据库即使在故障发生的情况下\",{\"1\":{\"92\":1}}],[\"它可由多个数据库操作组成\",{\"1\":{\"83\":1}}],[\"它包括如下几类操作\",{\"1\":{\"77\":1}}],[\"它最少只需有\",{\"1\":{\"68\":1}}],[\"它又是如何实现的\",{\"1\":{\"56\":2}}],[\"它是按照笔者个人理解以及\",{\"1\":{\"27\":1}}],[\"它就不知道该说什么了\",{\"1\":{\"4\":1}}],[\"有三个核心函数\",{\"1\":{\"284\":1}}],[\"有三个核心步骤\",{\"1\":{\"26\":1}}],[\"有几个点需要说明一下\",{\"1\":{\"283\":1}}],[\"有什么联系呢\",{\"1\":{\"283\":1}}],[\"有什么区别了\",{\"1\":{\"127\":1}}],[\"有缺别\",{\"1\":{\"282\":1}}],[\"有序排列\",{\"1\":{\"282\":1}}],[\"有问题\",{\"1\":{\"281\":1}}],[\"有两个数据流\",{\"1\":{\"281\":1}}],[\"有两个重要的知识点\",{\"1\":{\"261\":1}}],[\"有两种类型\",{\"1\":{\"10\":1}}],[\"有非常多的改进版本\",{\"1\":{\"244\":1}}],[\"有则返回\",{\"1\":{\"241\":1}}],[\"有没有一种方式能让内存逃开\",{\"1\":{\"238\":1}}],[\"有很大的不同\",{\"1\":{\"237\":1}}],[\"有很多小细节都需要考虑和完善\",{\"1\":{\"74\":1}}],[\"有必要再去管理其内存吗\",{\"1\":{\"236\":1}}],[\"有基本的函数定义\",{\"1\":{\"219\":1}}],[\"有兴趣的同学可以点开链接查看\",{\"1\":{\"218\":1}}],[\"有兴趣的读者可以参考论文\",{\"1\":{\"10\":1}}],[\"有利于写出测试良好的代码\",{\"1\":{\"168\":1}}],[\"有助于理解需求\",{\"1\":{\"168\":1}}],[\"有多种优秀的内存管理实现\",{\"1\":{\"241\":1}}],[\"有多种查询计划\",{\"1\":{\"79\":1}}],[\"有多个缓存服务节点\",{\"1\":{\"105\":1}}],[\"有一定\",{\"1\":{\"227\":1}}],[\"有一些项目就是采用这种做法\",{\"1\":{\"219\":1}}],[\"有一层很重的运行时\",{\"1\":{\"217\":1}}],[\"有一个泛型参数\",{\"1\":{\"183\":1}}],[\"有一个更加深入的理解\",{\"1\":{\"38\":1}}],[\"有一条边指向\",{\"1\":{\"87\":1}}],[\"有且只有一个核心字段\",{\"1\":{\"79\":1}}],[\"有且只有一个客户端进行编辑\",{\"1\":{\"25\":1}}],[\"有如下的处理方式\",{\"1\":{\"72\":1}}],[\"有如下几个核心方法\",{\"1\":{\"64\":1}}],[\"有父节点\",{\"1\":{\"71\":1}}],[\"有同一段文本12\",{\"1\":{\"48\":1}}],[\"有着良好的架构设计\",{\"1\":{\"41\":1}}],[\"有\",{\"1\":{\"34\":1,\"68\":1,\"123\":1}}],[\"有了上面的进程内存管理的铺垫\",{\"1\":{\"238\":1}}],[\"有了关键字\",{\"1\":{\"227\":1}}],[\"有了关键字后\",{\"1\":{\"225\":1}}],[\"有了泛型后\",{\"1\":{\"181\":1}}],[\"有了泛型t后\",{\"1\":{\"179\":1}}],[\"有了过滤器后\",{\"1\":{\"149\":1}}],[\"有了日志冲突任期和序号后\",{\"1\":{\"134\":1}}],[\"有了这些元数据\",{\"1\":{\"69\":1}}],[\"有了originright后\",{\"1\":{\"48\":1}}],[\"有了finditembyindex有\",{\"1\":{\"26\":1}}],[\"有了排序后\",{\"1\":{\"25\":1}}],[\"有了\",{\"1\":{\"25\":1,\"43\":1,\"157\":1,\"168\":1,\"181\":2,\"227\":1}}],[\"有编辑操作\",{\"1\":{\"25\":1}}],[\"分为了三个阶段\",{\"1\":{\"244\":1}}],[\"分为两大类\",{\"1\":{\"10\":1,\"157\":1}}],[\"分成很多小块\",{\"1\":{\"240\":1}}],[\"分页\",{\"1\":{\"231\":1}}],[\"分支等\",{\"1\":{\"219\":1}}],[\"分布在\",{\"1\":{\"199\":1}}],[\"分布式共识性算法的实现\",{\"0\":{\"120\":1}}],[\"分布式环境下\",{\"1\":{\"10\":1}}],[\"分解为功能上下文中可验证的任务项\",{\"1\":{\"164\":1}}],[\"分解为任务项\",{\"1\":{\"164\":1}}],[\"分区分配\",{\"1\":{\"158\":1}}],[\"分区下消费者等\",{\"1\":{\"155\":1}}],[\"分配栈内存\",{\"1\":{\"251\":1}}],[\"分配器\",{\"1\":{\"247\":1}}],[\"分配内存\",{\"1\":{\"234\":1,\"241\":1,\"243\":1}}],[\"分配在不同的\",{\"1\":{\"158\":1}}],[\"分配新的\",{\"1\":{\"64\":1}}],[\"分裂\",{\"1\":{\"71\":4}}],[\"分裂完毕\",{\"1\":{\"71\":1}}],[\"分裂过程与基本情况一致\",{\"1\":{\"71\":1}}],[\"分别为\",{\"1\":{\"243\":1}}],[\"分别用于数据输入和输出\",{\"1\":{\"281\":1}}],[\"分别用于请求投票\",{\"1\":{\"139\":1}}],[\"分别用于表示当前节点最后一个快照块的\",{\"1\":{\"136\":1}}],[\"分别用来保存节点\",{\"1\":{\"129\":1}}],[\"分别用\",{\"1\":{\"115\":1}}],[\"分别表示切片长度\",{\"1\":{\"207\":1}}],[\"分别表示当前数据的版本号和剩余存活时间\",{\"1\":{\"114\":1}}],[\"分别表示当前元素的前一个元素和后一个元素\",{\"1\":{\"114\":1}}],[\"分别表示叶子节点和内部节点能够拥有的最大子节点个数\",{\"1\":{\"69\":1}}],[\"分别介绍了缓存池组件以及支持存储引擎的\",{\"1\":{\"77\":1}}],[\"分别是数据切片a和\",{\"1\":{\"181\":1}}],[\"分别是\",{\"1\":{\"69\":1,\"133\":1,\"200\":1,\"237\":1,\"261\":1}}],[\"分别指向前后两个操作\",{\"1\":{\"50\":1}}],[\"分别对应\",{\"1\":{\"47\":1}}],[\"分别在位置1插入字符2\",{\"1\":{\"25\":2}}],[\"通道中\",{\"1\":{\"131\":1,\"187\":1}}],[\"通知\",{\"1\":{\"88\":1}}],[\"通信依赖\",{\"1\":{\"165\":1}}],[\"通信上\",{\"1\":{\"153\":1}}],[\"通信时\",{\"1\":{\"147\":1}}],[\"通信方式\",{\"1\":{\"14\":1}}],[\"通信内容\",{\"1\":{\"14\":1}}],[\"通信数据不同\",{\"1\":{\"10\":1}}],[\"通过新建\",{\"1\":{\"286\":1}}],[\"通过输出可以清晰的看到\",{\"1\":{\"257\":1}}],[\"通过指针操作\",{\"1\":{\"240\":1}}],[\"通过链表来管理\",{\"1\":{\"240\":1}}],[\"通过这个例子\",{\"1\":{\"238\":1}}],[\"通过此时的输出发现\",{\"1\":{\"238\":1}}],[\"通过脚本生成\",{\"1\":{\"227\":1}}],[\"通过脚本编译出最新的\",{\"1\":{\"224\":1}}],[\"通过流程图分析对代码进行优化\",{\"1\":{\"226\":1}}],[\"通过系统调用\",{\"1\":{\"203\":1}}],[\"通过绑定\",{\"1\":{\"199\":1}}],[\"通过生成函数来初始化\",{\"1\":{\"183\":1}}],[\"通过切片来初始化\",{\"1\":{\"183\":1}}],[\"通过测试用例\",{\"1\":{\"168\":1}}],[\"通过调用\",{\"1\":{\"78\":1}}],[\"通过搜索\",{\"1\":{\"71\":1}}],[\"通过严格的数学公式证明所有插入操作最终有序\",{\"1\":{\"43\":1}}],[\"通过规则\",{\"1\":{\"43\":2}}],[\"通过\",{\"1\":{\"18\":1,\"64\":1,\"69\":1,\"70\":1,\"78\":1,\"79\":1,\"164\":1,\"180\":2,\"183\":2,\"197\":1,\"198\":2,\"199\":1,\"200\":2,\"203\":1,\"207\":1,\"210\":1,\"225\":1,\"234\":1,\"238\":2,\"241\":2,\"243\":1,\"257\":3,\"277\":1,\"283\":1,\"284\":1,\"291\":2,\"294\":1}}],[\"通过数据结构来保证最终一致性\",{\"1\":{\"10\":1}}],[\"通过良好的数据结构设计来使所有副本最终达到一致\",{\"1\":{\"8\":1}}],[\"通过使用该类\",{\"1\":{\"4\":1}}],[\"通过以上改造\",{\"1\":{\"4\":1}}],[\"通过合理的设计和策略选择\",{\"1\":{\"4\":1}}],[\"通过合理的数据结构设计\",{\"1\":{\"4\":1}}],[\"与存储设备之间巨大的速度差异\",{\"1\":{\"231\":1}}],[\"与绝大多数汇编一样\",{\"1\":{\"218\":1}}],[\"与直接运行机器码相比\",{\"1\":{\"218\":1}}],[\"与主线程绑定\",{\"1\":{\"200\":1}}],[\"与当前节点的\",{\"1\":{\"136\":1}}],[\"与查询计划一样\",{\"1\":{\"79\":1}}],[\"与其兄弟节点\",{\"1\":{\"72\":2}}],[\"与其它基于\",{\"1\":{\"18\":1}}],[\"与其它分布式系统不同\",{\"1\":{\"8\":1}}],[\"与它有关的论文\",{\"1\":{\"56\":1}}],[\"与上面保持一致\",{\"1\":{\"50\":1}}],[\"与i有冲突的插入操作列表\",{\"1\":{\"44\":1}}],[\"与\",{\"1\":{\"10\":1,\"15\":1,\"17\":1,\"38\":1,\"64\":2,\"72\":1,\"103\":1,\"127\":1,\"129\":1,\"131\":1,\"136\":4,\"137\":1,\"199\":2,\"200\":1,\"210\":1,\"212\":1,\"241\":1,\"252\":1,\"254\":1,\"257\":1,\"279\":1,\"282\":1,\"283\":6}}],[\"简称数据流\",{\"1\":{\"177\":1}}],[\"简化而来\",{\"1\":{\"51\":1}}],[\"简单测试一下\",{\"1\":{\"243\":1}}],[\"简单而言\",{\"1\":{\"237\":1}}],[\"简单的说\",{\"1\":{\"200\":1}}],[\"简单的理解为工作线程\",{\"1\":{\"199\":1}}],[\"简单来说\",{\"1\":{\"113\":1,\"275\":1}}],[\"简单介绍\",{\"0\":{\"271\":1},\"1\":{\"69\":1,\"226\":1}}],[\"简单说\",{\"1\":{\"10\":1}}],[\"简单案例\",{\"0\":{\"9\":1}}],[\"简介\",{\"0\":{\"10\":1},\"1\":{\"20\":1}}],[\"天然支持离线编辑\",{\"1\":{\"9\":1}}],[\"再运行客户端\",{\"1\":{\"286\":1}}],[\"再没有\",{\"1\":{\"284\":1}}],[\"再来推进\",{\"1\":{\"282\":1}}],[\"再执行\",{\"1\":{\"251\":1}}],[\"再针对\",{\"1\":{\"227\":1}}],[\"再由多变少\",{\"1\":{\"165\":1}}],[\"再通过重构从可工作的软件\",{\"1\":{\"164\":1}}],[\"再将任务转化为测试\",{\"1\":{\"164\":1}}],[\"再次通过\",{\"1\":{\"294\":1}}],[\"再次编译\",{\"1\":{\"227\":1}}],[\"再次选举\",{\"1\":{\"126\":1}}],[\"再次开启网络\",{\"1\":{\"9\":1}}],[\"再\",{\"1\":{\"94\":1}}],[\"再从磁盘读取新的页\",{\"1\":{\"63\":1}}],[\"再看看文档的数据结构\",{\"1\":{\"47\":1}}],[\"再给点提示\",{\"1\":{\"4\":1}}],[\"此处执行程序的\",{\"1\":{\"200\":1}}],[\"此处定义了三个类型\",{\"1\":{\"181\":1}}],[\"此后\",{\"1\":{\"235\":1}}],[\"此后系统线程就与\",{\"1\":{\"203\":1}}],[\"此后可将\",{\"1\":{\"200\":1}}],[\"此后该连接对数据的访问都会以此事务作为基本单位\",{\"1\":{\"85\":1}}],[\"此时已分配\",{\"1\":{\"243\":1}}],[\"此时会创建和初始化所有的\",{\"1\":{\"200\":1}}],[\"此时的\",{\"1\":{\"200\":1,\"227\":1}}],[\"此时如果\",{\"1\":{\"84\":1}}],[\"此时节点\",{\"1\":{\"71\":2}}],[\"此时\",{\"1\":{\"71\":1,\"73\":2,\"117\":1,\"200\":1}}],[\"此时根节点是内部节点\",{\"1\":{\"68\":1}}],[\"此时根节点在树的底部\",{\"1\":{\"68\":1}}],[\"此时客户端\",{\"1\":{\"25\":2,\"43\":1}}],[\"此时增减数值只会在本地生效\",{\"1\":{\"9\":1}}],[\"此外还有\",{\"1\":{\"240\":1}}],[\"此外\",{\"1\":{\"4\":1,\"114\":1}}],[\"按空格选中\",{\"1\":{\"291\":1}}],[\"按需分配\",{\"1\":{\"232\":1}}],[\"按时间清除数据\",{\"1\":{\"98\":1}}],[\"按照输入的尺寸大小来返回合适的\",{\"1\":{\"262\":1}}],[\"按照这些区各自的特点\",{\"1\":{\"232\":1}}],[\"按照这三个阶段来设计\",{\"1\":{\"183\":1}}],[\"按照\",{\"1\":{\"106\":1,\"131\":1,\"147\":1,\"164\":1,\"206\":1,\"228\":1,\"240\":1}}],[\"按照哈希槽分片\",{\"1\":{\"103\":1}}],[\"按照页组织\",{\"1\":{\"98\":1}}],[\"按照执行计划上的表范式\",{\"1\":{\"79\":1}}],[\"按照分裂情况\",{\"1\":{\"71\":2}}],[\"按照排序来\",{\"1\":{\"71\":1}}],[\"按照算法规则\",{\"1\":{\"48\":1}}],[\"按照指定大小拆分键值对列表\",{\"1\":{\"4\":1}}],[\"按钮关闭掉网络\",{\"1\":{\"9\":1}}],[\"多集群访问需要多个不同连接池\",{\"1\":{\"105\":1}}],[\"多消费者\",{\"0\":{\"99\":1}}],[\"多文件持久化队列\",{\"0\":{\"98\":1}}],[\"多次读取同一条记录\",{\"1\":{\"84\":1}}],[\"多事务并发执行的情况下\",{\"1\":{\"84\":1}}],[\"多个\",{\"1\":{\"261\":1}}],[\"多个事务并发执行时\",{\"1\":{\"83\":1}}],[\"多个不同的数据副本分布在不同的客户端上\",{\"1\":{\"9\":1}}],[\"多值存储\",{\"1\":{\"11\":1}}],[\"多副本达成一致\",{\"1\":{\"10\":1}}],[\"多人画图等等\",{\"1\":{\"9\":1}}],[\"多人聊天\",{\"1\":{\"9\":1}}],[\"阅读\",{\"1\":{\"9\":1}}],[\"无数据\",{\"1\":{\"285\":1}}],[\"无条件直接跳转\",{\"1\":{\"254\":1}}],[\"无疑\",{\"1\":{\"238\":1}}],[\"无疑这提升了开发效率\",{\"1\":{\"235\":1}}],[\"无疑是核心\",{\"1\":{\"231\":1}}],[\"无疑更佳\",{\"1\":{\"218\":1}}],[\"无疑更加合适\",{\"1\":{\"190\":1}}],[\"无视类型信息\",{\"1\":{\"207\":1}}],[\"无论怎么调用\",{\"1\":{\"238\":1}}],[\"无论进程和线程都有一个内核栈\",{\"1\":{\"194\":1}}],[\"无论是客户端还是服务端\",{\"1\":{\"285\":1}}],[\"无论是编译器本身\",{\"1\":{\"228\":1}}],[\"无论是伦敦学派\",{\"1\":{\"164\":1}}],[\"无论是模块解耦\",{\"1\":{\"152\":1}}],[\"无论是加锁\",{\"1\":{\"73\":1}}],[\"无论是获取数据页\",{\"1\":{\"64\":1}}],[\"无论是插入还是删除\",{\"1\":{\"23\":1}}],[\"无任何数据项需满足条件后返回结果\",{\"1\":{\"185\":1}}],[\"无状态\",{\"1\":{\"177\":1}}],[\"无冗余字段\",{\"1\":{\"147\":1}}],[\"无实际意义\",{\"1\":{\"136\":1}}],[\"无效则不应用\",{\"1\":{\"131\":1}}],[\"无独有偶\",{\"1\":{\"79\":1}}],[\"无法解决的问题\",{\"1\":{\"228\":1}}],[\"无法编译成功\",{\"1\":{\"227\":1}}],[\"无法完全发挥出汇编的能力\",{\"1\":{\"213\":1}}],[\"无法直接使用高权操作和访问内核数据\",{\"1\":{\"196\":1}}],[\"无法将\",{\"1\":{\"58\":1}}],[\"无法满足\",{\"1\":{\"44\":1}}],[\"无需加入\",{\"1\":{\"285\":1}}],[\"无需加锁\",{\"1\":{\"241\":1}}],[\"无需自定义协议\",{\"1\":{\"153\":1}}],[\"无需再次释放\",{\"1\":{\"241\":1}}],[\"无需再次快照\",{\"1\":{\"136\":1}}],[\"无需再次分裂\",{\"1\":{\"71\":1}}],[\"无需防重\",{\"1\":{\"14\":1}}],[\"无需中心化服务器\",{\"1\":{\"9\":1}}],[\"无需与其它副本协调\",{\"1\":{\"9\":1}}],[\"无冲突可复制数据类型\",{\"1\":{\"9\":1}}],[\"下次还是可以使用\",{\"1\":{\"262\":1}}],[\"下次领导者直接通过冲突序号\",{\"1\":{\"134\":1}}],[\"下移则释放内存\",{\"1\":{\"232\":1}}],[\"下载\",{\"1\":{\"225\":1,\"291\":1,\"292\":1}}],[\"下发起一次系统调用\",{\"1\":{\"197\":1}}],[\"下为\",{\"1\":{\"194\":1}}],[\"下\",{\"1\":{\"194\":1,\"203\":1,\"204\":1,\"217\":2}}],[\"下的消息流\",{\"1\":{\"160\":1}}],[\"下的所有\",{\"1\":{\"157\":1}}],[\"下有那些分区\",{\"1\":{\"155\":1}}],[\"下线则自动删除\",{\"1\":{\"155\":1}}],[\"下一块\",{\"1\":{\"240\":1}}],[\"下一步计划\",{\"0\":{\"151\":1}}],[\"下一次读文件序号\",{\"1\":{\"98\":1}}],[\"下一次读文件偏移\",{\"1\":{\"98\":1}}],[\"下一个待发送日志序号\",{\"1\":{\"126\":1}}],[\"下一个\",{\"1\":{\"79\":1,\"89\":1,\"240\":1}}],[\"下一篇文章我们将介绍\",{\"1\":{\"22\":1}}],[\"下可以有多个\",{\"1\":{\"28\":1,\"158\":1}}],[\"下文再详谈\",{\"1\":{\"26\":1}}],[\"下文会简明其扼要\",{\"1\":{\"8\":1}}],[\"下面会介绍\",{\"1\":{\"285\":1}}],[\"下面会介绍一些\",{\"1\":{\"248\":1}}],[\"下面则是\",{\"1\":{\"243\":1}}],[\"下面的内容\",{\"1\":{\"242\":1}}],[\"下面将介绍\",{\"1\":{\"198\":1}}],[\"下面我们分别简单介绍一下\",{\"1\":{\"271\":1}}],[\"下面我们就来为\",{\"1\":{\"227\":1}}],[\"下面我们来看一个稍微复杂一点的例子\",{\"1\":{\"213\":1}}],[\"下面我们来一一解答\",{\"1\":{\"123\":1}}],[\"下面我们以汇编的形式来看看如何在\",{\"1\":{\"197\":1}}],[\"下面我们以\",{\"1\":{\"197\":1}}],[\"下面让这个测试用例通过\",{\"1\":{\"170\":1}}],[\"下面让我们来总结一下\",{\"1\":{\"139\":1}}],[\"下面分别说明一下\",{\"1\":{\"194\":1}}],[\"下面分别看下每种类型的转换\",{\"1\":{\"113\":1}}],[\"下面分别就这\",{\"1\":{\"49\":1}}],[\"下面分别来实现一下\",{\"1\":{\"12\":1}}],[\"下面笔者尝试用自己的理解来解释这个函数\",{\"1\":{\"44\":1}}],[\"下面\",{\"1\":{\"24\":1,\"25\":1,\"58\":1,\"59\":1,\"177\":1,\"181\":1,\"203\":1,\"209\":1,\"218\":1,\"226\":1,\"243\":1,\"244\":1,\"245\":1,\"278\":1,\"279\":1}}],[\"下面就需要对\",{\"1\":{\"227\":1}}],[\"下面就每个模块\",{\"1\":{\"154\":1}}],[\"下面就每个模块详细阐述其设计\",{\"1\":{\"108\":1}}],[\"下面就\",{\"1\":{\"14\":1,\"27\":1}}],[\"下面就来实践一下一些基础\",{\"1\":{\"11\":1}}],[\"下面就来看看\",{\"1\":{\"10\":1}}],[\"下面就用一个简单的counter样例来看看\",{\"1\":{\"9\":1}}],[\"下面就跟随\",{\"1\":{\"3\":1}}],[\"下面是根据以上改造说明完成的\",{\"1\":{\"4\":1}}],[\"下面是一个简化的伪代码示例\",{\"1\":{\"4\":1}}],[\"名词介绍不是本身重点\",{\"1\":{\"8\":1}}],[\"本着实践加深理解的初衷\",{\"1\":{\"270\":1}}],[\"本着实现了才算理解的初衷\",{\"1\":{\"152\":1}}],[\"本来就有\",{\"1\":{\"242\":1}}],[\"本来也越来越复杂\",{\"1\":{\"152\":1}}],[\"本质是\",{\"1\":{\"208\":1}}],[\"本质上是随机的\",{\"1\":{\"262\":1}}],[\"本质上是引用计数\",{\"1\":{\"234\":1}}],[\"本质上是一个数组\",{\"1\":{\"128\":1}}],[\"本质上都是目标文件被链接后生成的\",{\"1\":{\"217\":1}}],[\"本质上就是拆分为多个小任务\",{\"1\":{\"164\":1}}],[\"本次日志无需同步\",{\"1\":{\"137\":1}}],[\"本身就是线程安全的\",{\"1\":{\"261\":1}}],[\"本身就是汇编的高级抽象\",{\"1\":{\"212\":1}}],[\"本身的复杂性\",{\"1\":{\"246\":1}}],[\"本身也是一个对象\",{\"1\":{\"243\":1}}],[\"本身是一个页\",{\"1\":{\"241\":1}}],[\"本身是不支持函数重载的\",{\"1\":{\"179\":1}}],[\"本身上面\",{\"1\":{\"223\":1}}],[\"本身\",{\"1\":{\"200\":1,\"223\":1}}],[\"本身做过多介绍\",{\"1\":{\"121\":1}}],[\"本身架构就比较复杂\",{\"1\":{\"107\":1}}],[\"本身又比较复杂\",{\"1\":{\"8\":1}}],[\"本节的主角是执行器\",{\"1\":{\"77\":1}}],[\"本篇文章我们将介绍\",{\"1\":{\"22\":1}}],[\"本篇文章简单介绍了\",{\"1\":{\"19\":1}}],[\"本地队列中获取\",{\"1\":{\"200\":1}}],[\"本地时钟\",{\"1\":{\"13\":1}}],[\"本地状态变更有两个核心方法\",{\"1\":{\"13\":1,\"14\":1}}],[\"本地状态\",{\"1\":{\"13\":1,\"14\":1}}],[\"本地状态不再是一个简单的整数i\",{\"1\":{\"10\":1}}],[\"本地向量n发送给其它节点\",{\"1\":{\"10\":1}}],[\"本地仍可编辑\",{\"1\":{\"9\":1}}],[\"本文实现的协议我们统称为\",{\"1\":{\"278\":1}}],[\"本文的重点是简单使用它\",{\"1\":{\"237\":1}}],[\"本文的重点在于实践\",{\"1\":{\"10\":1}}],[\"本文内容与编译器强相关\",{\"1\":{\"220\":1}}],[\"本文基于\",{\"1\":{\"193\":1}}],[\"本文涉及知识点有\",{\"1\":{\"192\":1}}],[\"本文我们将从底层出发\",{\"1\":{\"192\":1}}],[\"本文我们将介绍另一种\",{\"1\":{\"41\":1}}],[\"本文写的稀烂\",{\"1\":{\"169\":1}}],[\"本文聚焦在\",{\"1\":{\"121\":1}}],[\"本文只会贴出部分实现代码进行剖析\",{\"1\":{\"56\":1}}],[\"本文不会去介绍如何写\",{\"1\":{\"56\":1}}],[\"本文以\",{\"1\":{\"38\":1}}],[\"本文旨在介绍一些基础\",{\"1\":{\"19\":1}}],[\"本文会将重点放在\",{\"1\":{\"8\":1}}],[\"本文对\",{\"1\":{\"8\":1}}],[\"同一个\",{\"1\":{\"241\":1}}],[\"同样在\",{\"1\":{\"236\":1}}],[\"同样的通过\",{\"1\":{\"286\":1}}],[\"同样的\",{\"1\":{\"200\":1}}],[\"同样是通过\",{\"1\":{\"131\":1}}],[\"同样是一个死循环\",{\"1\":{\"129\":1}}],[\"同样地\",{\"1\":{\"28\":1,\"71\":1,\"126\":1,\"133\":1,\"208\":1,\"210\":1}}],[\"同步生产\",{\"1\":{\"159\":1}}],[\"同步失败\",{\"1\":{\"129\":1}}],[\"同步成功\",{\"1\":{\"129\":1}}],[\"同步\",{\"0\":{\"129\":1}}],[\"同步日志\",{\"1\":{\"122\":1,\"126\":1}}],[\"同步到对方应用后\",{\"1\":{\"25\":1}}],[\"同步到客户端\",{\"1\":{\"25\":1}}],[\"同理锁管理器还提供了\",{\"1\":{\"88\":1}}],[\"同年发布了另外一篇\",{\"1\":{\"8\":1}}],[\"同时连接拥有两个字节流\",{\"1\":{\"275\":1}}],[\"同时也是\",{\"1\":{\"243\":1}}],[\"同时也是工作\",{\"1\":{\"152\":1}}],[\"同时也能推广到有序列表\",{\"1\":{\"23\":1}}],[\"同时还有\",{\"1\":{\"115\":1}}],[\"同时规定插入的操作排序后必须在originright之前\",{\"1\":{\"48\":1}}],[\"同时比o2​小\",{\"1\":{\"43\":1}}],[\"同时在文本111中的同一位置插入新的字符2\",{\"1\":{\"43\":1}}],[\"同时设置length\",{\"1\":{\"26\":1}}],[\"同时将变更的操作添加到ops数组中\",{\"1\":{\"13\":1}}],[\"同时\",{\"1\":{\"4\":1,\"114\":1,\"115\":1,\"136\":1,\"243\":1}}],[\"论文的说话\",{\"1\":{\"131\":1}}],[\"论文其实并没有给出为什么要引入规则\",{\"1\":{\"43\":1}}],[\"论文中指出\",{\"1\":{\"133\":1}}],[\"论文中的阐述\",{\"1\":{\"128\":1}}],[\"论文中\",{\"1\":{\"23\":1}}],[\"论文中提到\",{\"1\":{\"23\":1}}],[\"论文原话是\",{\"1\":{\"23\":1}}],[\"论文\",{\"1\":{\"8\":1,\"121\":2,\"140\":1}}],[\"论文还对\",{\"1\":{\"8\":1}}],[\"论文作者\",{\"1\":{\"8\":1}}],[\"是比较麻烦\",{\"1\":{\"285\":1}}],[\"是比较简单的\",{\"1\":{\"285\":1}}],[\"是窗口中待确认的字节数量大小\",{\"1\":{\"284\":1}}],[\"是接收者最复杂的函数\",{\"1\":{\"283\":1}}],[\"是发送者随机生成的数字\",{\"1\":{\"283\":1}}],[\"是第一个\",{\"1\":{\"282\":1}}],[\"是第一个用上\",{\"1\":{\"242\":1}}],[\"是按照\",{\"1\":{\"282\":1}}],[\"是三方的一个高性能\",{\"1\":{\"264\":1}}],[\"是函数名\",{\"1\":{\"256\":1}}],[\"是可达的\",{\"1\":{\"244\":1}}],[\"是实现\",{\"1\":{\"243\":1}}],[\"是有的\",{\"1\":{\"238\":1}}],[\"是手动内存管理语言的代表\",{\"1\":{\"234\":1}}],[\"是支持直接将\",{\"1\":{\"219\":1}}],[\"是自举实现的\",{\"1\":{\"219\":1}}],[\"是成功的\",{\"1\":{\"218\":1}}],[\"是的\",{\"1\":{\"218\":1}}],[\"是为了让读者更清晰\",{\"1\":{\"245\":1}}],[\"是为了展示\",{\"1\":{\"238\":1}}],[\"是为了更好的展示入口函数的作用\",{\"1\":{\"217\":1}}],[\"是为数不多将\",{\"1\":{\"27\":1}}],[\"是良药\",{\"1\":{\"217\":1}}],[\"是无法编译的\",{\"1\":{\"212\":1}}],[\"是字符串名称\",{\"1\":{\"257\":1}}],[\"是字符串在内存中的表达形态\",{\"1\":{\"207\":1}}],[\"是字段名称\",{\"1\":{\"79\":1,\"89\":1}}],[\"是字段值\",{\"1\":{\"79\":1,\"89\":1}}],[\"是主线程\",{\"1\":{\"200\":1}}],[\"是全局变量的首地址\",{\"1\":{\"255\":1}}],[\"是全局变量\",{\"1\":{\"200\":1}}],[\"是概念\",{\"1\":{\"199\":1}}],[\"是指\",{\"1\":{\"199\":1}}],[\"是操作系统的基本执行单位\",{\"1\":{\"199\":1}}],[\"是因为\",{\"1\":{\"198\":1}}],[\"是因为这里的实现没有选择双向链表\",{\"1\":{\"47\":1}}],[\"是不够好用的\",{\"1\":{\"262\":1}}],[\"是不需要的\",{\"1\":{\"236\":1}}],[\"是不能编译通过的\",{\"1\":{\"179\":1}}],[\"是不可多得的\",{\"1\":{\"8\":1}}],[\"是int类型后\",{\"1\":{\"179\":1}}],[\"是item数组\",{\"1\":{\"50\":1}}],[\"是强类型语言\",{\"1\":{\"179\":1}}],[\"是流式处理的一种实现\",{\"1\":{\"177\":1}}],[\"是帮助我们从可用代码进化到优质代码的一种优秀的工程实践方法\",{\"1\":{\"164\":1}}],[\"是多端访问元数据的桥梁\",{\"1\":{\"155\":1}}],[\"是每个后端工程师都应深入理解的必备技能\",{\"1\":{\"152\":1}}],[\"是提升整体性能的一个关键点\",{\"1\":{\"147\":1}}],[\"是最简单的一个死循环\",{\"1\":{\"139\":1}}],[\"是当前\",{\"1\":{\"136\":1,\"200\":1}}],[\"是快照数据中最后一个日志序号\",{\"1\":{\"136\":1}}],[\"是应用日志的结构体定义\",{\"1\":{\"131\":1}}],[\"是之前已经同步好的日志\",{\"1\":{\"129\":1,\"133\":1}}],[\"是响应结果\",{\"1\":{\"124\":1}}],[\"是这样定义的\",{\"1\":{\"124\":1}}],[\"是由上层应用直接触发的\",{\"1\":{\"136\":1}}],[\"是由\",{\"1\":{\"124\":1,\"164\":1,\"237\":1}}],[\"是集群的第一步\",{\"1\":{\"122\":1}}],[\"是如何实现这三大模块的\",{\"1\":{\"245\":1}}],[\"是如何管理内存的\",{\"1\":{\"245\":1}}],[\"是如何与系统线程绑定的\",{\"0\":{\"203\":1}}],[\"是如何嵌入到非\",{\"0\":{\"202\":1}}],[\"是如何运行的\",{\"1\":{\"192\":1}}],[\"是如何产生的\",{\"1\":{\"124\":1}}],[\"是如何来支持事务的呢\",{\"1\":{\"89\":1}}],[\"是如何工作的\",{\"1\":{\"24\":1}}],[\"是如何工作且多方协同的\",{\"1\":{\"9\":1}}],[\"是通过\",{\"1\":{\"82\":1,\"85\":1}}],[\"是所有执行计划的父类\",{\"1\":{\"78\":1}}],[\"是叶子结点\",{\"1\":{\"72\":1}}],[\"是根节点\",{\"1\":{\"72\":2}}],[\"是右半部分\",{\"1\":{\"71\":1}}],[\"是内部节点\",{\"1\":{\"69\":1,\"72\":1}}],[\"是对叶子节点和内部节点的抽象\",{\"1\":{\"69\":1}}],[\"是否需要发送空包\",{\"1\":{\"285\":1}}],[\"是否需要合并或者重组\",{\"1\":{\"72\":1}}],[\"是否在数据流结束后等待\",{\"1\":{\"285\":1}}],[\"是否处于激活状态\",{\"1\":{\"285\":1}}],[\"是否收到了\",{\"1\":{\"282\":1}}],[\"是否与\",{\"1\":{\"254\":1}}],[\"是否分配\",{\"1\":{\"240\":1}}],[\"是否还有可用内存\",{\"1\":{\"240\":1}}],[\"是否能真的分配内存\",{\"1\":{\"237\":1}}],[\"是否满足\",{\"1\":{\"227\":1}}],[\"是否有效\",{\"1\":{\"131\":1}}],[\"是否同步成功\",{\"1\":{\"126\":1}}],[\"是否投票\",{\"1\":{\"124\":1}}],[\"是否死亡\",{\"1\":{\"123\":1}}],[\"是否为\",{\"1\":{\"64\":1,\"225\":2}}],[\"是否脏页\",{\"1\":{\"64\":2}}],[\"是否具有冲突的节点\",{\"1\":{\"51\":1}}],[\"是页在内存中暂时的\",{\"1\":{\"64\":1}}],[\"是空闲页列表\",{\"1\":{\"64\":1}}],[\"是数据的通道\",{\"1\":{\"177\":1}}],[\"是数据列\",{\"1\":{\"79\":1,\"89\":1}}],[\"是数据页在磁盘上的标识\",{\"1\":{\"64\":1}}],[\"是数据页在内存中的标识\",{\"1\":{\"64\":1}}],[\"是数据库性能提升的核心组件\",{\"1\":{\"58\":1}}],[\"是目前最常见的页面置换算法\",{\"1\":{\"63\":1}}],[\"是目前生产环境使用最为广泛\",{\"1\":{\"49\":1}}],[\"是目前生产环境使用最广泛的\",{\"1\":{\"41\":1}}],[\"是clientid\",{\"1\":{\"50\":1}}],[\"是abstracttype的实例\",{\"1\":{\"50\":1}}],[\"是abstracttype的名字\",{\"1\":{\"50\":1}}],[\"是笔者实现的一个精简版\",{\"1\":{\"49\":1}}],[\"是学习协同算法的必读论文\",{\"1\":{\"41\":1}}],[\"是学习\",{\"1\":{\"41\":1,\"235\":1,\"270\":1}}],[\"是在第一个operation上加入新的lamport\",{\"1\":{\"35\":1}}],[\"是\",{\"1\":{\"27\":2,\"56\":1,\"69\":1,\"72\":1,\"107\":2,\"123\":1,\"124\":1,\"131\":1,\"139\":1,\"156\":1,\"158\":1,\"180\":1,\"181\":1,\"199\":2,\"200\":4,\"210\":1,\"212\":1,\"255\":1,\"279\":1,\"281\":1,\"282\":1,\"283\":1,\"284\":1}}],[\"是保证多方编辑内容最终一致的\",{\"1\":{\"25\":1}}],[\"是基于\",{\"1\":{\"23\":2}}],[\"是深入\",{\"1\":{\"22\":1}}],[\"是变量值\",{\"1\":{\"18\":1}}],[\"是变量名\",{\"1\":{\"18\":1}}],[\"是一门好课\",{\"1\":{\"287\":1}}],[\"是一门自带\",{\"1\":{\"236\":1}}],[\"是一样大的\",{\"1\":{\"241\":1}}],[\"是一样的\",{\"1\":{\"15\":1,\"27\":1}}],[\"是一个基于内存\",{\"1\":{\"281\":1}}],[\"是一个可读且可写且有容量限制的数据流\",{\"1\":{\"281\":1}}],[\"是一个可靠的\",{\"1\":{\"270\":1}}],[\"是一个可用的rcp玩具\",{\"1\":{\"151\":1}}],[\"是一个特殊符号\",{\"1\":{\"255\":1}}],[\"是一个特殊的\",{\"1\":{\"200\":1}}],[\"是一个简单程序的对象分布图\",{\"1\":{\"243\":1}}],[\"是一个抽象的概念\",{\"1\":{\"199\":1}}],[\"是一个非常庞大的结构体\",{\"1\":{\"194\":1}}],[\"是一个\",{\"1\":{\"164\":1}}],[\"是一个元组\",{\"1\":{\"13\":1}}],[\"是一种并发控制协议\",{\"1\":{\"85\":1}}],[\"是一种优秀的可行解\",{\"1\":{\"8\":1}}],[\"是一条记录\",{\"1\":{\"79\":1,\"89\":1}}],[\"是一棵\",{\"1\":{\"71\":1,\"72\":1}}],[\"是客户端的时钟\",{\"1\":{\"13\":1}}],[\"是客户端\",{\"1\":{\"13\":1}}],[\"是近年来分布式领域的新宠\",{\"1\":{\"8\":1}}],[\"年由\",{\"1\":{\"41\":1}}],[\"年真的是\",{\"1\":{\"23\":1}}],[\"年在论文replicated\",{\"1\":{\"23\":1}}],[\"年\",{\"1\":{\"8\":1,\"236\":3}}],[\"年的一篇论文\",{\"1\":{\"8\":1}}],[\"实时追踪程序变量\",{\"1\":{\"235\":1}}],[\"实在是没有才去偷\",{\"1\":{\"200\":1}}],[\"实在是不应该把精力花在通信层上面\",{\"1\":{\"157\":1}}],[\"实在是国内用的太普遍了\",{\"1\":{\"147\":1}}],[\"实例中\",{\"1\":{\"158\":1}}],[\"实例的基础上\",{\"1\":{\"136\":1}}],[\"实例单独应用了快照\",{\"1\":{\"136\":1}}],[\"实例\",{\"1\":{\"136\":2,\"157\":1,\"158\":1,\"159\":1}}],[\"实例可表示一个\",{\"1\":{\"123\":1}}],[\"实则一直在调度循环\",{\"1\":{\"200\":1}}],[\"实则就是切换寄存器上的值\",{\"1\":{\"200\":1}}],[\"实则就是我们平时所理解的地址空间\",{\"1\":{\"194\":1}}],[\"实则就是对事务的控制\",{\"1\":{\"85\":1}}],[\"实则非常丰富\",{\"1\":{\"190\":1}}],[\"实则是对数据流的一个检查与判断\",{\"1\":{\"189\":1}}],[\"实则也简单\",{\"1\":{\"130\":1}}],[\"实则取的是\",{\"1\":{\"129\":1}}],[\"实则为一对反操作\",{\"1\":{\"64\":1}}],[\"实际为重组确认的当前序号\",{\"1\":{\"283\":1}}],[\"实际还是依靠\",{\"1\":{\"242\":1}}],[\"实际是\",{\"1\":{\"208\":1}}],[\"实际是在寻找i\",{\"1\":{\"44\":1}}],[\"实际就是\",{\"1\":{\"200\":1}}],[\"实际上很多带虚拟机的语言实现基本也是这个思路\",{\"1\":{\"243\":1}}],[\"实际上就是人肉翻译\",{\"1\":{\"218\":1}}],[\"实际上为了调度循环\",{\"1\":{\"200\":1}}],[\"实际上是随机的\",{\"1\":{\"268\":1}}],[\"实际上是\",{\"1\":{\"199\":1}}],[\"实际上\",{\"1\":{\"164\":2,\"214\":1,\"219\":1,\"239\":1,\"242\":1}}],[\"实际上这就是\",{\"1\":{\"18\":1}}],[\"实际的代码实现其实比较复杂\",{\"1\":{\"72\":1}}],[\"实际实现中需要综合考虑以上因素\",{\"1\":{\"4\":2}}],[\"实现是比较简单的\",{\"1\":{\"281\":1}}],[\"实现文件\",{\"1\":{\"280\":6}}],[\"实现分别如下\",{\"1\":{\"244\":1}}],[\"实现都采用可达性分析来判断对象是否存活\",{\"1\":{\"243\":1}}],[\"实现如下\",{\"1\":{\"241\":2}}],[\"实现一个极简编译器\",{\"1\":{\"219\":1}}],[\"实现一个流式处理库\",{\"0\":{\"176\":1}}],[\"实现parse方法\",{\"1\":{\"172\":1}}],[\"实现需求\",{\"1\":{\"165\":1}}],[\"实现方式改变就是功能改变\",{\"1\":{\"164\":1}}],[\"实现这个系统的技术约束是什么\",{\"1\":{\"162\":1}}],[\"实现颇为简单粗暴\",{\"1\":{\"158\":1}}],[\"实现上\",{\"1\":{\"155\":1}}],[\"实现上可以抽象为注册接口\",{\"1\":{\"153\":1}}],[\"实现上也就是几十行代码而已\",{\"1\":{\"44\":1}}],[\"实现上也必须能支持多个值\",{\"1\":{\"18\":1}}],[\"实现后的效果如下\",{\"1\":{\"177\":1}}],[\"实现后\",{\"1\":{\"151\":1}}],[\"实现接口\",{\"1\":{\"144\":1}}],[\"实现中的第三个死循环\",{\"1\":{\"131\":1}}],[\"实现大容量\",{\"1\":{\"119\":1}}],[\"实现参考diskqueue\",{\"1\":{\"99\":1}}],[\"实现参考dqv3\",{\"1\":{\"98\":1}}],[\"实现参考dqv2\",{\"1\":{\"98\":1}}],[\"实现参考dqv1\",{\"1\":{\"97\":1}}],[\"实现过如此复杂的数据结构后\",{\"1\":{\"74\":1}}],[\"实现起来有难度\",{\"1\":{\"73\":1}}],[\"实现并不困难\",{\"1\":{\"63\":1}}],[\"实现数据库数据快照功能\",{\"1\":{\"58\":1}}],[\"实现了两个序号\",{\"1\":{\"283\":1}}],[\"实现了手动内存管理的\",{\"1\":{\"245\":1}}],[\"实现了\",{\"1\":{\"242\":1}}],[\"实现了核心功能和\",{\"1\":{\"161\":1}}],[\"实现了迭代器模型\",{\"1\":{\"78\":1}}],[\"实现了日志记录功能\",{\"1\":{\"58\":1}}],[\"实现了基本的\",{\"1\":{\"49\":1}}],[\"实现做一次解密\",{\"1\":{\"52\":1}}],[\"实现的过程中\",{\"1\":{\"190\":1}}],[\"实现的\",{\"1\":{\"23\":1,\"219\":1,\"237\":1,\"278\":1}}],[\"实现更加简单\",{\"1\":{\"17\":1}}],[\"实现\",{\"0\":{\"26\":1,\"46\":1,\"88\":1,\"186\":1},\"1\":{\"16\":1,\"18\":1,\"19\":1,\"23\":2,\"103\":1,\"118\":1,\"119\":1,\"155\":1,\"157\":1,\"158\":1,\"197\":1,\"200\":1,\"241\":1,\"242\":1,\"262\":1,\"283\":1}}],[\"实现成本\",{\"1\":{\"14\":1}}],[\"实现十分复杂\",{\"1\":{\"8\":1}}],[\"实践总结\",{\"0\":{\"259\":1}}],[\"实践它\",{\"1\":{\"220\":1}}],[\"实践篇\",{\"1\":{\"119\":1}}],[\"实践\",{\"0\":{\"11\":1,\"238\":1}}],[\"实践上充分的吸收网络知识\",{\"1\":{\"287\":1}}],[\"实践上\",{\"1\":{\"8\":1}}],[\"最重要的函数\",{\"1\":{\"282\":1}}],[\"最重要的数据结构\",{\"1\":{\"243\":1}}],[\"最重要的一环上来\",{\"1\":{\"241\":1}}],[\"最重要的关系数据库\",{\"1\":{\"56\":1}}],[\"最新的\",{\"1\":{\"224\":1}}],[\"最小化运行时\",{\"0\":{\"217\":1}}],[\"最近在业务性能优化过程中\",{\"1\":{\"260\":1}}],[\"最近\",{\"1\":{\"205\":1}}],[\"最晚尽责时刻\",{\"1\":{\"164\":1}}],[\"最坏情况是什么\",{\"1\":{\"162\":1}}],[\"最少只需要两个节点\",{\"1\":{\"72\":1}}],[\"最少要拥有\",{\"1\":{\"71\":1}}],[\"最少得有\",{\"1\":{\"68\":1}}],[\"最少两个字\",{\"1\":{\"63\":1}}],[\"最大包长度等\",{\"1\":{\"285\":1}}],[\"最大数量为\",{\"1\":{\"283\":1}}],[\"最大的功能点\",{\"1\":{\"273\":1}}],[\"最大对象个数\",{\"1\":{\"243\":1}}],[\"最大子节点个数和父节点\",{\"1\":{\"69\":1}}],[\"最大子节点个数是根据页大小\",{\"1\":{\"69\":1}}],[\"最大页数量\",{\"1\":{\"63\":1}}],[\"最大限度地提高在内存中处理数据查询的机会\",{\"1\":{\"62\":1}}],[\"最容易想到的是将item直接删除掉\",{\"1\":{\"25\":1}}],[\"最终会实现一个全栈的网络协议栈\",{\"1\":{\"270\":1}}],[\"最终滑向过度设计\",{\"1\":{\"164\":1}}],[\"最终文本变成132\",{\"1\":{\"48\":1}}],[\"最终文本内容就一致了\",{\"1\":{\"25\":1}}],[\"最终保证两个输入框的内容一致\",{\"1\":{\"24\":1,\"45\":1}}],[\"最终一致性进行了严格证明\",{\"1\":{\"8\":1}}],[\"最早可追溯到\",{\"1\":{\"8\":1}}],[\"最后报文接受到现在时间间隔\",{\"1\":{\"285\":1}}],[\"最后一个\",{\"1\":{\"284\":1}}],[\"最后是入口文件\",{\"1\":{\"257\":1}}],[\"最后改变\",{\"1\":{\"243\":1}}],[\"最后回到\",{\"1\":{\"241\":1}}],[\"最后几次迭代编译构建出\",{\"1\":{\"224\":1}}],[\"最后通过函数指针调用\",{\"1\":{\"218\":1}}],[\"最后调用\",{\"1\":{\"218\":1}}],[\"最后我们看看\",{\"1\":{\"200\":1}}],[\"最后将其\",{\"1\":{\"181\":1}}],[\"最后将其集成到文档树中\",{\"1\":{\"26\":1}}],[\"最后汇总得到结果\",{\"1\":{\"177\":1}}],[\"最后新建sqlsession类\",{\"1\":{\"170\":1}}],[\"最后完成全部开发\",{\"1\":{\"164\":1}}],[\"最后任期\",{\"1\":{\"136\":1}}],[\"最后序号\",{\"1\":{\"136\":1}}],[\"最后返回\",{\"1\":{\"129\":1,\"187\":1}}],[\"最后领导者通过\",{\"1\":{\"129\":1}}],[\"最后访问\",{\"1\":{\"86\":1}}],[\"最后找到\",{\"1\":{\"73\":1}}],[\"最后重置页数据\",{\"1\":{\"64\":1}}],[\"最后写入的item会覆盖之前写入的item\",{\"1\":{\"50\":1}}],[\"最后写入的值胜出\",{\"1\":{\"15\":1}}],[\"最后的操作在链表最后端\",{\"1\":{\"28\":1}}],[\"最后使用\",{\"1\":{\"4\":2}}],[\"最后\",{\"1\":{\"4\":1,\"25\":1,\"26\":1,\"47\":1,\"51\":1,\"213\":1,\"227\":1,\"241\":1,\"243\":1,\"244\":1,\"287\":1}}],[\"副本之间可以存在不一致\",{\"1\":{\"10\":1}}],[\"副本\",{\"1\":{\"8\":2,\"161\":1}}],[\"副本执行操作时\",{\"1\":{\"8\":1}}],[\"但有个点很奇怪\",{\"1\":{\"294\":1}}],[\"但必须发送一个空包\",{\"1\":{\"285\":1}}],[\"但必须包含\",{\"1\":{\"283\":1}}],[\"但仍然不能保证完美的可靠性\",{\"1\":{\"273\":1}}],[\"但仍然执行了一次\",{\"1\":{\"227\":1}}],[\"但每次\",{\"1\":{\"264\":1}}],[\"但两次\",{\"1\":{\"262\":1}}],[\"但函数却没有函数体\",{\"1\":{\"257\":1}}],[\"但整体而言相差不大\",{\"1\":{\"248\":1}}],[\"但都不是\",{\"1\":{\"244\":1}}],[\"但其引用对象未被扫描\",{\"1\":{\"244\":1}}],[\"但却是值得的\",{\"1\":{\"273\":1}}],[\"但却是领导者触发的\",{\"1\":{\"136\":1}}],[\"但却没有理解\",{\"1\":{\"270\":1}}],[\"但却有一个很大的问题\",{\"1\":{\"244\":1}}],[\"但栈中只有\",{\"1\":{\"243\":1}}],[\"但它们是\",{\"1\":{\"243\":1}}],[\"但它们仍然占用了内存\",{\"1\":{\"238\":1}}],[\"但或多或少保留着它的影子\",{\"1\":{\"242\":1}}],[\"但只需\",{\"1\":{\"240\":1}}],[\"但好东西都是有代价的\",{\"1\":{\"235\":1}}],[\"但至今仍在使用\",{\"1\":{\"235\":1}}],[\"但更多的人觉得这不够\",{\"1\":{\"234\":1}}],[\"但被释放了\",{\"1\":{\"232\":1}}],[\"但明显这不是\",{\"1\":{\"228\":1}}],[\"但显然这种方式还是不够优雅\",{\"1\":{\"223\":1}}],[\"但效果却很好\",{\"1\":{\"218\":1}}],[\"但翻译为\",{\"1\":{\"218\":1}}],[\"但实现却很复杂\",{\"1\":{\"218\":1}}],[\"但实际上只使用了\",{\"1\":{\"262\":1}}],[\"但实际上这些都是虚拟内存\",{\"1\":{\"237\":1}}],[\"但实际上大部分日志都是可被删除的\",{\"1\":{\"136\":1}}],[\"但实际上最后的算法代码很少\",{\"1\":{\"44\":1}}],[\"但由于\",{\"1\":{\"217\":1}}],[\"但对于存储而言\",{\"1\":{\"231\":1}}],[\"但对于寄存器分配而言\",{\"1\":{\"218\":1}}],[\"但对于一些其它场景\",{\"1\":{\"217\":1}}],[\"但对于了解原理和get\",{\"1\":{\"5\":1}}],[\"但也是最容易忽略的一部分\",{\"1\":{\"281\":1}}],[\"但也大量借鉴了\",{\"1\":{\"245\":1}}],[\"但也未释放\",{\"1\":{\"232\":1}}],[\"但也损耗了一定的性能\",{\"1\":{\"218\":1}}],[\"但也带来了一些问题\",{\"1\":{\"217\":1}}],[\"但也导致了单位时间内只有一个线程能够访问该索引\",{\"1\":{\"73\":1}}],[\"但付出的代价也不小\",{\"1\":{\"210\":1}}],[\"但内部是通过调用\",{\"1\":{\"208\":1}}],[\"但并不是每个人都有这样的能力\",{\"1\":{\"206\":1}}],[\"但在源码中\",{\"1\":{\"199\":1}}],[\"但返回另一个类型的结果\",{\"1\":{\"181\":1}}],[\"但以我之前在腾讯的工作经历来看\",{\"1\":{\"165\":1}}],[\"但架构怎么办\",{\"1\":{\"164\":1}}],[\"但如果\",{\"1\":{\"261\":1}}],[\"但如果丧失了测试的有效性\",{\"1\":{\"164\":1}}],[\"但如果是行为验证\",{\"1\":{\"164\":1}}],[\"但如果是多线程\",{\"1\":{\"73\":1}}],[\"但距离真正可用还有很远的距离\",{\"1\":{\"161\":1}}],[\"但同时也带来了一定量的性能损害\",{\"1\":{\"235\":1}}],[\"但同时也带来了一些问题\",{\"1\":{\"232\":1}}],[\"但同时也带来了麻烦\",{\"1\":{\"157\":1}}],[\"但同样的\",{\"1\":{\"84\":1}}],[\"但各有各的特点与不同\",{\"1\":{\"152\":1}}],[\"但苦于下面的原因所以一直没有实施\",{\"1\":{\"152\":1}}],[\"但我们显然没有这种条件\",{\"1\":{\"146\":1}}],[\"但请求者的日志序号大或者相等\",{\"1\":{\"130\":1}}],[\"但已提交\",{\"1\":{\"127\":1}}],[\"但很显然\",{\"1\":{\"89\":1,\"124\":1}}],[\"但二阶段事务却有\",{\"1\":{\"85\":1}}],[\"但不可能只保存键值对\",{\"1\":{\"69\":1}}],[\"但不可能将所有页都保存在内存中\",{\"1\":{\"62\":1}}],[\"但不保证实时一致\",{\"1\":{\"10\":1}}],[\"但是可能对端没有完全确认\",{\"1\":{\"285\":1}}],[\"但是本端可能没有数据回复\",{\"1\":{\"285\":1}}],[\"但是本文的重点聚焦在\",{\"1\":{\"270\":1}}],[\"但是如果提前判读包的大小\",{\"1\":{\"284\":1}}],[\"但是如果是业务代码就肯定会存在大量的中间件\",{\"1\":{\"165\":1}}],[\"但是前提是内部已经关闭\",{\"1\":{\"283\":1}}],[\"但是不能包括\",{\"1\":{\"283\":1}}],[\"但是在后面的测试中\",{\"1\":{\"281\":1}}],[\"但是一些复杂的特性暂时不支持\",{\"1\":{\"278\":1}}],[\"但是一直没有好的\",{\"1\":{\"167\":1}}],[\"但是普遍集中在\",{\"1\":{\"270\":1}}],[\"但是这不影响我们以此来学习一个简单可靠的类\",{\"1\":{\"278\":1}}],[\"但是这段代码是有问题的\",{\"1\":{\"262\":1}}],[\"但是这也会引出一个问题\",{\"1\":{\"241\":1}}],[\"但是隐藏了太多的内存细节\",{\"1\":{\"242\":1}}],[\"但是回收垃圾也是需要时间的\",{\"1\":{\"238\":1}}],[\"但是旅程绝不仅限于此\",{\"1\":{\"226\":1}}],[\"但是最后的扩容结果却是\",{\"1\":{\"208\":1}}],[\"但是用好了\",{\"1\":{\"207\":1}}],[\"但是会涉及大量知识点\",{\"1\":{\"200\":1}}],[\"但是却屏蔽了大量信息\",{\"1\":{\"277\":1}}],[\"但是却给程序的安全性和可维护性带来了问题\",{\"1\":{\"179\":1}}],[\"但是却经历了好几次的重构而来\",{\"1\":{\"165\":1}}],[\"但是对于一些需要\",{\"1\":{\"164\":1}}],[\"但是对于叶子结点\",{\"1\":{\"68\":1}}],[\"但是只要提供的参数保持不变\",{\"1\":{\"145\":1}}],[\"但是日志序号却是\",{\"1\":{\"136\":1}}],[\"但是日志的应用序号为\",{\"1\":{\"127\":1}}],[\"但是当前节点在该序号的日志任期与领导者任期不同\",{\"1\":{\"134\":1}}],[\"但是领导者独有的\",{\"1\":{\"129\":1}}],[\"但是整体运行效率也越低\",{\"1\":{\"84\":1}}],[\"但是数据库还有更加重要的数据部分\",{\"1\":{\"82\":1}}],[\"但是付出是值得的\",{\"1\":{\"74\":1}}],[\"但是删除元素\",{\"1\":{\"73\":1}}],[\"但是\",{\"1\":{\"72\":1,\"73\":1,\"113\":1,\"127\":1,\"264\":1,\"274\":1,\"283\":1}}],[\"但是被加载到内存\",{\"1\":{\"64\":1}}],[\"但是由于涉及到课程实验作业\",{\"1\":{\"56\":1}}],[\"但是大部分书籍和博文都在教开发者如何去使用一款数据库\",{\"1\":{\"56\":1}}],[\"但是判断逻辑基本一致\",{\"1\":{\"51\":1}}],[\"但是文本中可能存在多个1\",{\"1\":{\"25\":1}}],[\"但没有实现\",{\"1\":{\"49\":1}}],[\"但没有其它约束条件\",{\"1\":{\"25\":1}}],[\"但理解起来不容易\",{\"1\":{\"44\":1}}],[\"但\",{\"1\":{\"37\":1,\"98\":1,\"104\":1,\"110\":1,\"131\":1,\"227\":1,\"238\":3,\"261\":1}}],[\"但这个例子也暴露出\",{\"1\":{\"238\":1}}],[\"但这种做法无疑屏蔽了太多的细节\",{\"1\":{\"217\":1}}],[\"但这些组件本身就占用了一定资源\",{\"1\":{\"217\":1}}],[\"但这两个类型均需实现\",{\"1\":{\"181\":1}}],[\"但这版插入算法其实有一个严重的\",{\"1\":{\"48\":1}}],[\"但这显然不行\",{\"1\":{\"25\":1}}],[\"但这样就能保证最终文本内容一致吗\",{\"1\":{\"25\":1}}],[\"但字符2\",{\"1\":{\"25\":1}}],[\"但最近一段时间笔者分别看到了三篇文章\",{\"1\":{\"236\":1}}],[\"但最终都能达到一致\",{\"1\":{\"10\":1}}],[\"但最后的数据仍然保证一致\",{\"1\":{\"8\":1}}],[\"但前提是任何副本执行的操作都必须通过网络传输并应用到其它副本\",{\"1\":{\"8\":1}}],[\"完成了一系列检查\",{\"1\":{\"227\":1}}],[\"完成扩容工作\",{\"1\":{\"208\":1}}],[\"完成使命时\",{\"1\":{\"202\":1}}],[\"完成\",{\"1\":{\"190\":1}}],[\"完成功能不代表做完了需求\",{\"1\":{\"165\":1}}],[\"完备的测试用例保证了重构后代码的正确性\",{\"1\":{\"168\":1}}],[\"完全可以自主实现\",{\"1\":{\"278\":1}}],[\"完全可以在new的时候预分配\",{\"1\":{\"262\":1}}],[\"完全可以对\",{\"1\":{\"164\":1}}],[\"完全无需与其它副本进行协商\",{\"1\":{\"8\":1}}],[\"完善日志同步\",{\"0\":{\"137\":1},\"1\":{\"138\":1}}],[\"完善选举\",{\"0\":{\"130\":1},\"1\":{\"132\":1}}],[\"完整代码见\",{\"1\":{\"5\":1}}],[\"基础知识\",{\"1\":{\"165\":1}}],[\"基础篇\",{\"0\":{\"7\":1}}],[\"基于字节流\",{\"0\":{\"274\":1},\"1\":{\"270\":1}}],[\"基于双向链表实现的部分伪代码\",{\"1\":{\"23\":1}}],[\"基于\",{\"1\":{\"15\":1,\"103\":1,\"279\":1}}],[\"基于此\",{\"1\":{\"8\":1,\"105\":1,\"145\":1}}],[\"基本覆盖了网络知识的方方面面\",{\"1\":{\"287\":1}}],[\"基本覆盖了我们生活的方方面面\",{\"1\":{\"287\":1}}],[\"基本覆盖了flush和merge等全部操作\",{\"1\":{\"5\":1}}],[\"基本语法如下\",{\"1\":{\"255\":1}}],[\"基本介绍\",{\"0\":{\"249\":1}}],[\"基本已经接近人类理解的程序执行流程图了\",{\"1\":{\"227\":1}}],[\"基本使用\",{\"0\":{\"197\":1}}],[\"基本工程方法论\",{\"1\":{\"165\":1}}],[\"基本情况\",{\"1\":{\"71\":1}}],[\"基本与insert类似\",{\"1\":{\"37\":1}}],[\"基本些许更改就能\",{\"1\":{\"5\":1}}],[\"了好久才察觉是\",{\"1\":{\"281\":1}}],[\"了解了\",{\"1\":{\"59\":1}}],[\"了解了基本数据结构后\",{\"1\":{\"29\":1}}],[\"了\",{\"1\":{\"5\":1,\"43\":1,\"69\":1,\"124\":1,\"126\":1,\"200\":2,\"224\":1,\"225\":1,\"243\":1,\"284\":3}}],[\"zone\",{\"1\":{\"212\":1}}],[\"zookeeperregistryservice\",{\"1\":{\"155\":1}}],[\"zookeeper\",{\"1\":{\"153\":1,\"155\":1}}],[\"zyedidia\",{\"1\":{\"191\":1}}],[\"zero\",{\"1\":{\"191\":1,\"219\":4}}],[\"zeromicro\",{\"1\":{\"191\":1}}],[\"zk\",{\"1\":{\"153\":1,\"155\":4}}],[\"zk通知只有一次\",{\"1\":{\"148\":1}}],[\"zk通知\",{\"1\":{\"148\":1}}],[\"zhihu\",{\"1\":{\"90\":1,\"295\":1}}],[\"zhuanlan\",{\"1\":{\"90\":1,\"295\":1}}],[\"z\",{\"1\":{\"5\":1}}],[\"zip\",{\"1\":{\"4\":2}}],[\"yes\",{\"1\":{\"255\":1,\"293\":2}}],[\"yet\",{\"1\":{\"41\":1,\"200\":1,\"283\":1,\"284\":1}}],[\"yongman\",{\"1\":{\"119\":1}}],[\"your\",{\"1\":{\"130\":1,\"283\":1}}],[\"you\",{\"1\":{\"88\":1,\"283\":1,\"292\":1}}],[\"yrs\",{\"1\":{\"53\":1}}],[\"ymap\",{\"1\":{\"49\":1,\"50\":2,\"51\":1}}],[\"ytext\",{\"1\":{\"49\":2,\"50\":5,\"51\":1}}],[\"yarray\",{\"1\":{\"49\":2,\"50\":5,\"51\":1}}],[\"yata篇\",{\"0\":{\"40\":1}}],[\"yata\",{\"0\":{\"42\":1,\"47\":1},\"1\":{\"22\":2,\"41\":5,\"43\":5,\"44\":1,\"45\":2,\"46\":2,\"47\":3,\"48\":1,\"52\":1,\"53\":1}}],[\"yjs\",{\"0\":{\"48\":1},\"1\":{\"11\":1,\"22\":1,\"41\":2,\"44\":1,\"48\":2,\"49\":4,\"51\":2,\"52\":1,\"53\":1}}],[\"y\",{\"1\":{\"5\":1,\"127\":1,\"136\":1,\"218\":11,\"219\":8,\"225\":2,\"227\":1,\"291\":1}}],[\"qemu\",{\"1\":{\"290\":5,\"291\":7,\"293\":1,\"294\":2}}],[\"qcrao\",{\"1\":{\"266\":1}}],[\"quic\",{\"1\":{\"278\":4}}],[\"quick\",{\"1\":{\"258\":1}}],[\"queryonebyid\",{\"1\":{\"164\":5}}],[\"query\",{\"1\":{\"80\":3,\"164\":1}}],[\"queue<tcpsegment>\",{\"1\":{\"284\":2,\"285\":1}}],[\"queuemap\",{\"1\":{\"157\":1}}],[\"queuemanager\",{\"1\":{\"157\":3}}],[\"queuename\",{\"1\":{\"157\":4}}],[\"queueserviceimplbase\",{\"1\":{\"157\":1}}],[\"queueservicegrpc\",{\"1\":{\"157\":1}}],[\"queueservice\",{\"1\":{\"157\":2}}],[\"queueinfo\",{\"1\":{\"155\":3}}],[\"queueid\",{\"1\":{\"155\":6}}],[\"queue\",{\"1\":{\"26\":11,\"88\":9,\"150\":1,\"155\":1,\"157\":6,\"158\":3,\"159\":1,\"160\":1,\"161\":1,\"284\":1,\"285\":1}}],[\"qq\",{\"1\":{\"119\":1,\"164\":1,\"191\":2}}],[\"q\",{\"1\":{\"5\":1,\"252\":1,\"253\":1}}],[\"ov\",{\"1\":{\"291\":1,\"294\":1}}],[\"overlay\",{\"1\":{\"293\":3}}],[\"overall\",{\"1\":{\"238\":8}}],[\"over\",{\"1\":{\"164\":1}}],[\"override\",{\"1\":{\"63\":4,\"79\":1,\"144\":2,\"145\":2,\"146\":2,\"147\":2,\"149\":1,\"157\":1,\"164\":1}}],[\"occupied\",{\"1\":{\"285\":1}}],[\"oci6twgi9f5c11uakbumew\",{\"1\":{\"191\":1}}],[\"oh\",{\"1\":{\"255\":1}}],[\"our\",{\"1\":{\"227\":1,\"283\":1,\"284\":2}}],[\"outgoing\",{\"1\":{\"284\":1}}],[\"outbound\",{\"1\":{\"284\":1,\"285\":6,\"286\":4}}],[\"out\",{\"1\":{\"146\":8,\"213\":11,\"217\":7,\"219\":2,\"227\":4,\"281\":2,\"283\":4,\"284\":4,\"285\":10}}],[\"output\",{\"1\":{\"5\":1,\"79\":8,\"181\":1,\"190\":1,\"212\":1,\"234\":1,\"279\":2,\"281\":5,\"282\":4}}],[\"oif\",{\"1\":{\"227\":1}}],[\"oid\",{\"1\":{\"79\":9}}],[\"odowhile\",{\"1\":{\"227\":10}}],[\"o3\",{\"1\":{\"212\":1}}],[\"oselect\",{\"1\":{\"227\":1}}],[\"oset\",{\"1\":{\"203\":3}}],[\"oswitch\",{\"1\":{\"227\":1}}],[\"osstack\",{\"1\":{\"200\":2}}],[\"os\",{\"0\":{\"304\":1},\"1\":{\"200\":1,\"203\":1,\"221\":1,\"238\":2}}],[\"osinit\",{\"1\":{\"200\":1}}],[\"okay\",{\"1\":{\"198\":1}}],[\"ok\",{\"1\":{\"71\":2,\"72\":2,\"89\":1,\"124\":4,\"129\":4,\"136\":4,\"177\":2,\"188\":2,\"190\":2,\"200\":2,\"219\":4,\"225\":2}}],[\"ok​右边操作项\",{\"1\":{\"43\":1}}],[\"ok​左边操作项\",{\"1\":{\"43\":1}}],[\"ok​\",{\"1\":{\"43\":1,\"48\":1}}],[\"oorigin\",{\"1\":{\"47\":4}}],[\"oleft\",{\"1\":{\"47\":3,\"48\":4}}],[\"oldest\",{\"1\":{\"263\":1}}],[\"old\",{\"1\":{\"13\":1,\"14\":4,\"16\":1,\"18\":1,\"71\":7,\"72\":5,\"208\":3}}],[\"o的origin\",{\"1\":{\"44\":1}}],[\"o<i需要满足上面的\",{\"1\":{\"44\":1}}],[\"o<i\",{\"1\":{\"44\":1}}],[\"o1​在origin2​的左边\",{\"1\":{\"43\":1}}],[\"o1​<rule1​o2​⇔o1​<origin2​∨origin2​≤origin1​\",{\"1\":{\"43\":1}}],[\"online\",{\"1\":{\"294\":6}}],[\"only\",{\"1\":{\"127\":1,\"263\":1}}],[\"oncompleted\",{\"1\":{\"157\":1}}],[\"onnext\",{\"1\":{\"157\":2}}],[\"onerror\",{\"1\":{\"157\":1}}],[\"one\",{\"1\":{\"134\":1,\"164\":1,\"285\":1}}],[\"on\",{\"1\":{\"39\":1,\"41\":2,\"53\":1,\"88\":11,\"161\":1,\"164\":1,\"165\":1,\"200\":2,\"238\":1,\"263\":2,\"264\":1,\"277\":2,\"285\":1}}],[\"objsiz\",{\"1\":{\"243\":1}}],[\"objpair\",{\"1\":{\"243\":4,\"244\":1}}],[\"objint\",{\"1\":{\"243\":3,\"244\":1}}],[\"objid\",{\"1\":{\"28\":1,\"31\":1}}],[\"obj包\",{\"1\":{\"227\":1}}],[\"objdump\",{\"1\":{\"180\":1,\"218\":1}}],[\"objecttype\",{\"1\":{\"243\":6}}],[\"objectclass\",{\"1\":{\"241\":1}}],[\"object>\",{\"1\":{\"164\":1,\"174\":1}}],[\"object\",{\"1\":{\"150\":1,\"164\":4,\"174\":3,\"241\":1,\"243\":16,\"244\":7,\"247\":1}}],[\"objects\",{\"1\":{\"150\":1,\"243\":1}}],[\"obj\",{\"1\":{\"31\":1,\"36\":2,\"37\":1,\"147\":3,\"241\":3,\"243\":21,\"244\":8}}],[\"objtype标识是map还是list\",{\"1\":{\"28\":1}}],[\"objtype\",{\"1\":{\"28\":2}}],[\"oblwwregister\",{\"1\":{\"16\":1}}],[\"oblwwregister<t>\",{\"1\":{\"16\":1}}],[\"obcounter\",{\"1\":{\"13\":5,\"14\":3}}],[\"opname\",{\"1\":{\"227\":3}}],[\"opcode\",{\"1\":{\"218\":1}}],[\"opcodes\",{\"1\":{\"218\":3}}],[\"op3\",{\"1\":{\"218\":2}}],[\"op2\",{\"1\":{\"218\":7}}],[\"op1\",{\"1\":{\"218\":8}}],[\"openstmt\",{\"1\":{\"263\":1}}],[\"openscope\",{\"1\":{\"227\":1}}],[\"opensession\",{\"1\":{\"170\":1}}],[\"open\",{\"1\":{\"98\":2}}],[\"operator<\",{\"1\":{\"282\":1}}],[\"operationtype\",{\"1\":{\"73\":2}}],[\"operations\",{\"1\":{\"30\":2,\"31\":2,\"32\":2,\"34\":4,\"35\":2,\"36\":2,\"37\":3}}],[\"operation<t>\",{\"1\":{\"28\":1}}],[\"operation\",{\"0\":{\"16\":1},\"1\":{\"8\":1,\"10\":4,\"16\":1,\"28\":1,\"34\":6,\"53\":1,\"225\":2,\"227\":1}}],[\"operand\",{\"1\":{\"227\":1}}],[\"opertaions\",{\"1\":{\"30\":1,\"31\":1,\"32\":1}}],[\"opt\",{\"1\":{\"293\":1}}],[\"optimization\",{\"1\":{\"229\":1}}],[\"optimize\",{\"1\":{\"218\":3}}],[\"options\",{\"1\":{\"278\":1,\"291\":2,\"292\":1}}],[\"optional<uint16\",{\"1\":{\"284\":1}}],[\"optional<wrappingint32>\",{\"1\":{\"283\":2}}],[\"optional<student>\",{\"1\":{\"164\":3}}],[\"optional\",{\"1\":{\"164\":1,\"283\":2,\"284\":1}}],[\"option\",{\"1\":{\"164\":2,\"184\":3}}],[\"optionparsers\",{\"1\":{\"164\":2}}],[\"opts\",{\"1\":{\"184\":3}}],[\"optree\",{\"1\":{\"28\":3}}],[\"optree<t>>\",{\"1\":{\"28\":1}}],[\"optree<t>\",{\"1\":{\"28\":1}}],[\"optype\",{\"1\":{\"13\":6,\"16\":2,\"18\":2}}],[\"opid\",{\"1\":{\"28\":4}}],[\"op应用完成后\",{\"1\":{\"13\":1}}],[\"op<string>\",{\"1\":{\"18\":4}}],[\"op<t>\",{\"1\":{\"13\":1,\"16\":4}}],[\"op<number>\",{\"1\":{\"13\":5}}],[\"op类型定义如下\",{\"1\":{\"13\":1}}],[\"opset\",{\"1\":{\"28\":1}}],[\"opset<t>\",{\"1\":{\"28\":2}}],[\"ops\",{\"1\":{\"13\":11,\"16\":8,\"18\":8,\"28\":1,\"44\":1}}],[\"op\",{\"0\":{\"13\":1},\"1\":{\"10\":4,\"12\":1,\"13\":19,\"14\":3,\"15\":1,\"16\":10,\"18\":12,\"25\":3,\"28\":2,\"31\":5,\"36\":5,\"37\":5,\"73\":4,\"212\":23,\"213\":5,\"218\":6,\"225\":8,\"227\":12}}],[\"off\",{\"1\":{\"237\":1,\"284\":1}}],[\"offset\",{\"1\":{\"77\":1,\"94\":1,\"136\":1,\"237\":1,\"255\":4,\"282\":3}}],[\"oforuntil\",{\"1\":{\"227\":1}}],[\"of\",{\"1\":{\"8\":1,\"10\":1,\"14\":2,\"19\":1,\"20\":1,\"23\":1,\"26\":4,\"28\":1,\"30\":1,\"47\":4,\"48\":2,\"51\":5,\"87\":1,\"134\":1,\"164\":1,\"177\":1,\"181\":1,\"200\":3,\"221\":1,\"227\":1,\"263\":4,\"264\":1,\"266\":1,\"268\":3,\"282\":1,\"283\":2,\"284\":2,\"285\":3,\"286\":1,\"291\":1,\"294\":2}}],[\"other\",{\"1\":{\"14\":3}}],[\"ot\",{\"1\":{\"8\":2,\"10\":1,\"23\":1,\"43\":1}}],[\"oriented\",{\"1\":{\"270\":1}}],[\"oright\",{\"1\":{\"48\":2}}],[\"originright\",{\"1\":{\"48\":6,\"50\":5,\"51\":2}}],[\"originrightk​\",{\"1\":{\"48\":1}}],[\"originleft\",{\"1\":{\"48\":6,\"50\":5,\"51\":6}}],[\"origin是创建时的左侧item节点\",{\"1\":{\"47\":1}}],[\"origin四个属性\",{\"1\":{\"47\":1}}],[\"origin2​与origin1​是同一个操作\",{\"1\":{\"43\":1}}],[\"origin2​在origin1​的左边\",{\"1\":{\"43\":1}}],[\"origin连接不会交叉\",{\"1\":{\"43\":1}}],[\"origin连线是这样的\",{\"1\":{\"43\":1}}],[\"origin的存在是为了解决并发插入问题\",{\"1\":{\"43\":1}}],[\"origink​\",{\"1\":{\"43\":2,\"44\":1,\"47\":1,\"48\":1}}],[\"origin\",{\"1\":{\"28\":1,\"47\":13,\"48\":1,\"51\":1,\"293\":1}}],[\"orange\",{\"1\":{\"227\":2}}],[\"oracle\",{\"1\":{\"191\":1}}],[\"org\",{\"1\":{\"170\":3,\"225\":1,\"238\":1,\"277\":1,\"291\":1,\"292\":1,\"293\":1,\"295\":1}}],[\"or​=ir​<o<i\",{\"1\":{\"44\":1}}],[\"or​<o<ir​<i\",{\"1\":{\"44\":1}}],[\"or​<ir​<o<i\",{\"1\":{\"44\":1}}],[\"or​\",{\"1\":{\"44\":1}}],[\"ordered\",{\"1\":{\"263\":1}}],[\"orderblock\",{\"1\":{\"227\":1}}],[\"orderstate\",{\"1\":{\"227\":1}}],[\"order\",{\"1\":{\"13\":1,\"218\":3,\"227\":2,\"282\":1}}],[\"or\",{\"1\":{\"8\":1,\"23\":1,\"26\":1,\"28\":3,\"47\":5,\"89\":1,\"237\":2,\"284\":1}}],[\"o\",{\"1\":{\"5\":1,\"13\":2,\"16\":2,\"18\":2,\"43\":1,\"44\":1,\"47\":15,\"48\":3,\"51\":29,\"180\":1,\"197\":5,\"200\":1,\"217\":18,\"227\":12,\"243\":5,\"244\":7,\"294\":1}}],[\"kb\",{\"1\":{\"231\":1,\"238\":1}}],[\"karthikkaranth\",{\"1\":{\"215\":1}}],[\"kafka\",{\"1\":{\"152\":2,\"153\":1,\"155\":1}}],[\"know\",{\"1\":{\"200\":1,\"285\":1}}],[\"kindflags\",{\"1\":{\"208\":1}}],[\"kind\",{\"1\":{\"179\":1,\"227\":2}}],[\"kills\",{\"1\":{\"285\":1}}],[\"kill\",{\"1\":{\"125\":1}}],[\"killed\",{\"1\":{\"124\":1,\"129\":1,\"131\":1,\"133\":1,\"136\":1}}],[\"k8s\",{\"1\":{\"121\":1}}],[\"keep\",{\"1\":{\"285\":1}}],[\"keepalive\",{\"1\":{\"238\":2}}],[\"kernel\",{\"1\":{\"247\":2,\"291\":8,\"293\":3,\"294\":2}}],[\"keil\",{\"1\":{\"215\":1}}],[\"kevin\",{\"1\":{\"41\":1}}],[\"keyword\",{\"1\":{\"227\":2}}],[\"keyfunc\",{\"1\":{\"184\":2,\"188\":3}}],[\"keytype\",{\"1\":{\"69\":3}}],[\"keycomparator\",{\"1\":{\"69\":4}}],[\"keycomparator>\",{\"1\":{\"69\":3}}],[\"key=lambda\",{\"1\":{\"4\":1}}],[\"keys\",{\"1\":{\"4\":34,\"188\":3}}],[\"key\",{\"1\":{\"4\":63,\"13\":1,\"18\":8,\"27\":3,\"49\":4,\"50\":3,\"51\":2,\"69\":3,\"70\":14,\"71\":10,\"72\":5,\"73\":4,\"106\":1,\"114\":6,\"115\":4,\"116\":3,\"117\":1,\"119\":1,\"188\":5,\"227\":1}}],[\"kv\",{\"0\":{\"100\":1},\"1\":{\"11\":1,\"18\":2,\"69\":1,\"71\":3,\"73\":1,\"103\":2,\"104\":1,\"105\":3,\"106\":3,\"107\":2,\"118\":1,\"119\":1,\"127\":1}}],[\"k\",{\"1\":{\"5\":1,\"14\":6,\"68\":6,\"69\":7}}],[\"jian\",{\"1\":{\"295\":1}}],[\"jiangjiang\",{\"1\":{\"295\":1}}],[\"jianshu\",{\"1\":{\"295\":1}}],[\"jit\",{\"0\":{\"218\":1},\"1\":{\"218\":5,\"221\":1}}],[\"j8\",{\"1\":{\"291\":2,\"294\":1}}],[\"john\",{\"1\":{\"235\":1}}],[\"join\",{\"1\":{\"77\":1,\"79\":2}}],[\"jul\",{\"1\":{\"294\":1}}],[\"juejin\",{\"1\":{\"215\":1,\"295\":1}}],[\"just\",{\"0\":{\"218\":1},\"1\":{\"177\":2,\"183\":3,\"190\":2}}],[\"jb\",{\"1\":{\"213\":1}}],[\"jeq\",{\"1\":{\"254\":2}}],[\"jemalloc和tcmalloc\",{\"1\":{\"237\":1}}],[\"je\",{\"1\":{\"212\":1}}],[\"jmp\",{\"1\":{\"200\":5,\"213\":1,\"217\":2,\"254\":2}}],[\"jdbc\",{\"1\":{\"170\":2}}],[\"jdkclientinvocationhandler\",{\"1\":{\"150\":1}}],[\"jdk原生\",{\"1\":{\"144\":1}}],[\"jdk代理\",{\"1\":{\"144\":1}}],[\"jparepository<student\",{\"1\":{\"164\":1}}],[\"jpa\",{\"1\":{\"164\":2}}],[\"javase\",{\"1\":{\"191\":1}}],[\"javassist\",{\"1\":{\"144\":1}}],[\"java中实现接口代理的方式有两种\",{\"1\":{\"144\":1}}],[\"java\",{\"1\":{\"23\":1,\"175\":1,\"177\":2,\"191\":1,\"233\":1,\"242\":1}}],[\"jsj3\",{\"1\":{\"119\":1}}],[\"jsonserializer\",{\"1\":{\"147\":1}}],[\"json\",{\"1\":{\"18\":2,\"147\":4,\"260\":2}}],[\"js\",{\"1\":{\"15\":1}}],[\"j\",{\"1\":{\"5\":1,\"210\":2}}],[\"9090\",{\"1\":{\"277\":5}}],[\"998\",{\"1\":{\"243\":1,\"294\":2}}],[\"9999\",{\"1\":{\"213\":2}}],[\"9\",{\"1\":{\"5\":2,\"71\":2,\"72\":3,\"134\":2,\"177\":1,\"190\":1,\"200\":5,\"213\":21,\"219\":2,\"225\":1,\"227\":2,\"291\":6,\"292\":1,\"294\":3}}],[\"829\",{\"1\":{\"227\":1}}],[\"82\",{\"1\":{\"227\":1}}],[\"824\",{\"1\":{\"140\":1}}],[\"8+7\",{\"1\":{\"200\":1}}],[\"80h\",{\"1\":{\"197\":1}}],[\"8080\",{\"1\":{\"164\":4}}],[\"8~12\",{\"1\":{\"136\":1}}],[\"8\",{\"1\":{\"5\":1,\"65\":1,\"71\":2,\"134\":1,\"170\":1,\"191\":1,\"194\":1,\"200\":10,\"213\":20,\"217\":3,\"218\":2,\"219\":1,\"227\":1,\"238\":8,\"241\":3,\"243\":3,\"255\":3,\"256\":3,\"257\":1}}],[\"huaweicloud\",{\"1\":{\"295\":1}}],[\"hub\",{\"1\":{\"292\":1}}],[\"hh\",{\"1\":{\"280\":6}}],[\"hdr\",{\"1\":{\"238\":2,\"240\":3}}],[\"hdt3213\",{\"1\":{\"119\":1}}],[\"hostname\",{\"1\":{\"293\":1}}],[\"hover\",{\"1\":{\"291\":1}}],[\"home\",{\"1\":{\"291\":1,\"293\":2}}],[\"how\",{\"1\":{\"236\":1,\"238\":1,\"266\":1}}],[\"hook\",{\"1\":{\"227\":1}}],[\"holding\",{\"1\":{\"200\":1}}],[\"high\",{\"1\":{\"266\":1}}],[\"hi\",{\"1\":{\"200\":3,\"203\":1}}],[\"h>\",{\"1\":{\"197\":1,\"210\":3,\"237\":4,\"294\":3}}],[\"h2\",{\"1\":{\"164\":2,\"170\":2}}],[\"http\",{\"1\":{\"260\":4,\"262\":1,\"263\":2,\"277\":1,\"291\":11,\"292\":1,\"295\":2}}],[\"https\",{\"1\":{\"90\":2,\"119\":12,\"140\":1,\"170\":1,\"191\":8,\"212\":1,\"215\":6,\"224\":1,\"238\":1,\"266\":6,\"290\":1,\"291\":2,\"292\":1,\"293\":1,\"295\":9}}],[\"htm\",{\"1\":{\"215\":1}}],[\"html\",{\"1\":{\"140\":1,\"191\":1,\"215\":1,\"266\":1,\"295\":2}}],[\"heiyeluren\",{\"1\":{\"236\":1}}],[\"help2man\",{\"1\":{\"292\":1}}],[\"help\",{\"1\":{\"200\":1,\"292\":1}}],[\"helloworld\",{\"1\":{\"197\":11,\"200\":2,\"257\":12}}],[\"hello\",{\"0\":{\"192\":1},\"1\":{\"144\":1,\"192\":3,\"197\":8,\"200\":8,\"217\":4,\"225\":3,\"257\":7,\"286\":23}}],[\"heap这文章的作者要提出\",{\"1\":{\"238\":1}}],[\"heap的文章\",{\"1\":{\"236\":1}}],[\"heap\",{\"1\":{\"232\":1,\"237\":1}}],[\"heapfile\",{\"1\":{\"98\":1}}],[\"head\",{\"1\":{\"184\":2,\"188\":1,\"194\":1,\"243\":3,\"244\":1,\"282\":16,\"283\":4}}],[\"headers\",{\"1\":{\"293\":1}}],[\"headersize\",{\"1\":{\"238\":1,\"240\":6}}],[\"header\",{\"1\":{\"69\":2,\"227\":2,\"238\":1,\"240\":9,\"241\":1,\"282\":1,\"283\":7,\"284\":5,\"285\":14,\"286\":5}}],[\"heartbeatinterval\",{\"1\":{\"129\":1}}],[\"here\",{\"1\":{\"51\":1,\"130\":1,\"255\":1}}],[\"hacking\",{\"1\":{\"291\":1}}],[\"have\",{\"1\":{\"227\":1,\"284\":1,\"285\":1}}],[\"hard\",{\"1\":{\"191\":1}}],[\"handlev1函数\",{\"1\":{\"260\":1}}],[\"handlev1\",{\"1\":{\"260\":1}}],[\"handler\",{\"1\":{\"198\":1}}],[\"handle\",{\"1\":{\"149\":2,\"282\":3}}],[\"hands\",{\"1\":{\"5\":1}}],[\"happens\",{\"1\":{\"72\":1}}],[\"hasn\",{\"1\":{\"283\":1}}],[\"hasbreak\",{\"1\":{\"227\":1}}],[\"hasprefix\",{\"1\":{\"225\":2}}],[\"hascycle\",{\"1\":{\"88\":1}}],[\"hashcode\",{\"1\":{\"145\":3}}],[\"hashrouter\",{\"1\":{\"145\":1}}],[\"hashicorp\",{\"1\":{\"139\":1}}],[\"hash\",{\"0\":{\"116\":1},\"1\":{\"26\":7,\"102\":1,\"113\":2,\"116\":4,\"208\":1}}],[\"has\",{\"1\":{\"26\":2,\"28\":1,\"49\":1,\"50\":2,\"51\":2,\"262\":1,\"263\":1,\"283\":1,\"284\":2,\"285\":7,\"286\":2,\"293\":1}}],[\"hyun\",{\"1\":{\"23\":1}}],[\"h\",{\"1\":{\"5\":1,\"200\":1,\"212\":6,\"213\":1,\"240\":15,\"257\":1,\"294\":4}}],[\"75\",{\"1\":{\"231\":1}}],[\"777\",{\"1\":{\"225\":1}}],[\"78830772\",{\"1\":{\"215\":1}}],[\"72\",{\"1\":{\"207\":1}}],[\"70\",{\"1\":{\"207\":1}}],[\"712\",{\"1\":{\"200\":1}}],[\"7\",{\"1\":{\"5\":1,\"71\":2,\"72\":1,\"124\":1,\"129\":1,\"200\":6,\"213\":20,\"218\":1,\"219\":1,\"225\":1,\"227\":1,\"257\":1}}],[\"gnu\",{\"1\":{\"292\":1,\"293\":2}}],[\"gzip\",{\"1\":{\"291\":1,\"293\":1,\"294\":1}}],[\"gz\",{\"1\":{\"291\":7,\"293\":2,\"294\":4}}],[\"gdb\",{\"1\":{\"291\":2}}],[\"gdead\",{\"1\":{\"200\":3}}],[\"gbit\",{\"1\":{\"286\":2}}],[\"gbuf\",{\"1\":{\"200\":1}}],[\"gawk\",{\"1\":{\"292\":1}}],[\"gammazero\",{\"1\":{\"264\":1}}],[\"garbage\",{\"1\":{\"200\":1,\"235\":1,\"245\":1,\"247\":2}}],[\"guintptr\",{\"1\":{\"200\":1,\"202\":1}}],[\"guide\",{\"1\":{\"140\":1,\"247\":1,\"258\":1}}],[\"gist\",{\"1\":{\"295\":1}}],[\"git\",{\"1\":{\"212\":1,\"224\":3,\"290\":1,\"291\":1}}],[\"github\",{\"1\":{\"27\":1,\"56\":1,\"119\":11,\"161\":1,\"174\":1,\"191\":5,\"212\":1,\"215\":1,\"224\":2,\"236\":2,\"266\":2,\"290\":1,\"295\":1}}],[\"gid\",{\"1\":{\"200\":1}}],[\"gidle\",{\"1\":{\"200\":1}}],[\"gfget\",{\"1\":{\"200\":1}}],[\"gp\",{\"1\":{\"200\":27}}],[\"gc2\",{\"1\":{\"244\":1}}],[\"gc4\",{\"1\":{\"243\":1}}],[\"gc编译器\",{\"1\":{\"228\":1}}],[\"gcdata\",{\"1\":{\"208\":1}}],[\"gcenable\",{\"1\":{\"200\":1}}],[\"gc\",{\"0\":{\"238\":1},\"1\":{\"200\":3,\"210\":2,\"217\":2,\"233\":1,\"235\":3,\"236\":4,\"238\":16,\"242\":9,\"243\":36,\"244\":12,\"245\":3,\"246\":1,\"247\":1,\"261\":1,\"262\":7,\"268\":2}}],[\"gcinit\",{\"1\":{\"200\":1}}],[\"gccgo\",{\"1\":{\"212\":1}}],[\"gcc\",{\"1\":{\"197\":1,\"228\":1,\"291\":2,\"293\":1,\"294\":1}}],[\"g0\",{\"1\":{\"198\":2,\"200\":41,\"203\":3}}],[\"globl\",{\"1\":{\"212\":1,\"255\":3,\"257\":2}}],[\"globrunqget\",{\"1\":{\"200\":1}}],[\"globalpagemap\",{\"1\":{\"241\":1}}],[\"globalpageheap\",{\"1\":{\"241\":3}}],[\"globallock\",{\"1\":{\"241\":4}}],[\"global\",{\"1\":{\"197\":1,\"219\":1,\"255\":1}}],[\"glibc\",{\"1\":{\"197\":1,\"237\":1,\"293\":1}}],[\"gmp\",{\"0\":{\"199\":1},\"1\":{\"192\":1,\"199\":3}}],[\"gen\",{\"1\":{\"227\":2}}],[\"gendecl\",{\"1\":{\"219\":1}}],[\"gensymabis\",{\"1\":{\"217\":1}}],[\"gensuccessresult\",{\"1\":{\"157\":1}}],[\"generated\",{\"1\":{\"294\":2}}],[\"generatefunc\",{\"1\":{\"183\":1}}],[\"generate\",{\"1\":{\"183\":1,\"225\":4,\"227\":3}}],[\"generating\",{\"1\":{\"175\":1}}],[\"generic\",{\"1\":{\"191\":1}}],[\"generics\",{\"1\":{\"191\":2}}],[\"genericcomparator<8>\",{\"1\":{\"69\":1}}],[\"genericcomparator<8>>\",{\"1\":{\"69\":1}}],[\"generickey<8>\",{\"1\":{\"69\":1}}],[\"genqueuenotfoundresult\",{\"1\":{\"157\":1}}],[\"getbuffer\",{\"1\":{\"262\":2}}],[\"getbroker\",{\"1\":{\"155\":1}}],[\"getobject\",{\"1\":{\"241\":2}}],[\"getoutputschema\",{\"1\":{\"79\":1}}],[\"getconns\",{\"1\":{\"263\":1}}],[\"getcontentlength\",{\"1\":{\"146\":1}}],[\"getcontent\",{\"1\":{\"26\":1,\"146\":1}}],[\"getcallersp\",{\"1\":{\"200\":1}}],[\"getcallerpc\",{\"1\":{\"200\":2}}],[\"getg\",{\"1\":{\"198\":1,\"200\":11}}],[\"getifnodes\",{\"1\":{\"174\":1}}],[\"getitemcleanend\",{\"1\":{\"51\":1}}],[\"getitem\",{\"1\":{\"51\":5}}],[\"getname\",{\"1\":{\"158\":1,\"164\":1,\"172\":1,\"173\":1}}],[\"getnextlsn\",{\"1\":{\"93\":1}}],[\"getqueuename\",{\"1\":{\"157\":1}}],[\"getqueuesizeresponse\",{\"1\":{\"157\":1}}],[\"getqueuesizerequest\",{\"1\":{\"157\":1}}],[\"getqueuesize\",{\"1\":{\"157\":1}}],[\"getqueuesbytopic\",{\"1\":{\"155\":1}}],[\"getqueueconsumer\",{\"1\":{\"155\":1}}],[\"getqueue\",{\"1\":{\"155\":1}}],[\"getuuid\",{\"1\":{\"150\":1}}],[\"getsockopt\",{\"1\":{\"294\":2}}],[\"getspan\",{\"1\":{\"241\":1}}],[\"getsubsql\",{\"1\":{\"174\":1}}],[\"getsql\",{\"1\":{\"174\":1}}],[\"getserialization\",{\"1\":{\"146\":1}}],[\"getsize\",{\"1\":{\"70\":1,\"72\":4}}],[\"getversion\",{\"1\":{\"146\":1}}],[\"getvalue\",{\"1\":{\"70\":3,\"172\":1}}],[\"getlogger\",{\"1\":{\"149\":1}}],[\"getlogbuffer\",{\"1\":{\"93\":1}}],[\"getlist\",{\"1\":{\"144\":2}}],[\"getelementptr\",{\"1\":{\"219\":1}}],[\"getentries\",{\"1\":{\"129\":1}}],[\"getexpr\",{\"1\":{\"79\":1,\"89\":1}}],[\"getexecutorcontext\",{\"1\":{\"79\":1}}],[\"getrootelement\",{\"1\":{\"172\":1,\"173\":1}}],[\"getrootpage\",{\"1\":{\"73\":1}}],[\"getresource\",{\"1\":{\"172\":1}}],[\"getresourceasstream\",{\"1\":{\"170\":1,\"172\":1}}],[\"getresponse\",{\"1\":{\"150\":1}}],[\"getrandelecttimeout\",{\"1\":{\"124\":1}}],[\"getrid\",{\"1\":{\"79\":1,\"89\":8}}],[\"getallqueues\",{\"1\":{\"155\":1}}],[\"getalltopics\",{\"1\":{\"155\":1}}],[\"getallbrokers\",{\"1\":{\"155\":1}}],[\"getas<bool>\",{\"1\":{\"79\":1,\"89\":1}}],[\"getarray\",{\"1\":{\"50\":1}}],[\"getty\",{\"1\":{\"293\":1}}],[\"gettype\",{\"1\":{\"79\":1}}],[\"gettokens\",{\"1\":{\"174\":1}}],[\"gettopic\",{\"1\":{\"155\":1}}],[\"gettargetmethod\",{\"1\":{\"149\":1}}],[\"gettargetservicename\",{\"1\":{\"149\":1}}],[\"gettableoid\",{\"1\":{\"79\":1}}],[\"gettransaction\",{\"1\":{\"88\":2}}],[\"gettext\",{\"1\":{\"50\":1}}],[\"getmagicnumber\",{\"1\":{\"146\":1}}],[\"getmajorindex\",{\"1\":{\"129\":2,\"134\":1}}],[\"getmaxsize\",{\"1\":{\"72\":1}}],[\"getminsize\",{\"1\":{\"72\":1}}],[\"getdata\",{\"1\":{\"71\":4,\"72\":1}}],[\"getpid\",{\"1\":{\"238\":2}}],[\"getpayload\",{\"1\":{\"157\":1}}],[\"getpageid\",{\"1\":{\"71\":2}}],[\"getpages\",{\"1\":{\"64\":1}}],[\"getpersistentlsn\",{\"1\":{\"93\":1}}],[\"getpredicate\",{\"1\":{\"79\":1}}],[\"getpoolsize\",{\"1\":{\"64\":1}}],[\"get都可以被抽象为一个operation\",{\"1\":{\"28\":1}}],[\"get\",{\"0\":{\"30\":1,\"34\":1},\"1\":{\"4\":23,\"5\":9,\"13\":2,\"14\":5,\"16\":1,\"17\":1,\"18\":3,\"26\":5,\"27\":2,\"30\":2,\"34\":2,\"49\":3,\"50\":2,\"51\":3,\"144\":1,\"145\":1,\"150\":1,\"157\":1,\"158\":1,\"164\":1,\"174\":1,\"200\":4,\"241\":1,\"254\":1,\"261\":5,\"262\":6,\"268\":2,\"291\":1,\"292\":1,\"294\":12}}],[\"goworkers\",{\"1\":{\"264\":1}}],[\"google\",{\"1\":{\"241\":1,\"262\":1}}],[\"go文件\",{\"1\":{\"227\":2}}],[\"goroot=$pwd\",{\"1\":{\"224\":1}}],[\"goroot\",{\"1\":{\"224\":1}}],[\"goroutinepool\",{\"0\":{\"264\":1}}],[\"goroutine\",{\"0\":{\"202\":1},\"1\":{\"124\":1,\"131\":1,\"199\":5,\"200\":5,\"202\":1,\"204\":2,\"217\":1,\"261\":2,\"264\":8,\"266\":1}}],[\"go黑魔法\",{\"0\":{\"222\":1}}],[\"gopath=$pwd\",{\"1\":{\"224\":1}}],[\"gopath\",{\"1\":{\"224\":1}}],[\"gopher\",{\"1\":{\"221\":1}}],[\"gopc\",{\"1\":{\"200\":1}}],[\"gollvm\",{\"1\":{\"219\":1}}],[\"gollvm和\",{\"1\":{\"219\":1}}],[\"goland\",{\"1\":{\"207\":1,\"208\":1,\"212\":1,\"213\":1}}],[\"golang\",{\"1\":{\"119\":1,\"191\":1,\"204\":4,\"224\":1,\"225\":1,\"229\":1,\"238\":1,\"247\":3}}],[\"goitab\",{\"1\":{\"208\":1}}],[\"goiface\",{\"1\":{\"208\":1}}],[\"goidcache++\",{\"1\":{\"200\":1}}],[\"goidcache\",{\"1\":{\"200\":1}}],[\"goid\",{\"1\":{\"200\":1}}],[\"got\",{\"1\":{\"213\":2}}],[\"gotret\",{\"1\":{\"212\":3}}],[\"gotype\",{\"1\":{\"208\":10}}],[\"goto\",{\"1\":{\"200\":1}}],[\"gounusedparameter\",{\"1\":{\"207\":1,\"208\":1,\"212\":1,\"213\":1}}],[\"goarch\",{\"1\":{\"200\":1}}],[\"goargs\",{\"1\":{\"200\":1}}],[\"gogo\",{\"1\":{\"200\":5,\"204\":1}}],[\"gogetenv\",{\"1\":{\"200\":1}}],[\"gostring\",{\"1\":{\"207\":3}}],[\"gostartcallfn\",{\"1\":{\"200\":1,\"202\":1}}],[\"goslice\",{\"1\":{\"207\":5,\"208\":3}}],[\"gosafe\",{\"1\":{\"188\":1}}],[\"goeface\",{\"1\":{\"208\":5}}],[\"goexit0\",{\"0\":{\"202\":1}}],[\"goexit\",{\"1\":{\"200\":2,\"202\":4}}],[\"goenvs\",{\"1\":{\"200\":1}}],[\"gomaxprocs\",{\"1\":{\"200\":2}}],[\"go<abiinternal>\",{\"1\":{\"200\":4}}],[\"gofile\",{\"1\":{\"180\":2}}],[\"go1\",{\"1\":{\"177\":1,\"179\":2,\"181\":1,\"224\":11,\"225\":3,\"227\":2}}],[\"gobuf\",{\"1\":{\"200\":12}}],[\"gob\",{\"1\":{\"133\":1}}],[\"godis\",{\"1\":{\"119\":1}}],[\"go\",{\"0\":{\"176\":1,\"192\":1,\"198\":1,\"205\":1,\"216\":1,\"226\":1,\"230\":1,\"245\":1,\"248\":1,\"259\":1,\"261\":1,\"302\":1},\"1\":{\"53\":1,\"123\":2,\"124\":5,\"126\":1,\"128\":1,\"129\":2,\"131\":3,\"136\":3,\"177\":4,\"178\":3,\"179\":5,\"180\":37,\"181\":1,\"182\":1,\"186\":1,\"187\":1,\"188\":1,\"189\":1,\"190\":1,\"191\":4,\"192\":3,\"193\":1,\"198\":8,\"199\":6,\"200\":22,\"202\":1,\"203\":1,\"204\":2,\"205\":1,\"206\":3,\"207\":10,\"208\":11,\"209\":1,\"210\":5,\"212\":13,\"213\":7,\"214\":5,\"215\":2,\"216\":2,\"217\":32,\"218\":2,\"219\":11,\"221\":2,\"223\":8,\"224\":22,\"225\":38,\"226\":8,\"227\":56,\"228\":10,\"229\":4,\"233\":1,\"236\":9,\"238\":4,\"241\":2,\"242\":2,\"244\":1,\"245\":6,\"246\":1,\"247\":4,\"248\":2,\"257\":17,\"258\":5,\"261\":4,\"262\":1,\"263\":2,\"264\":2,\"265\":1,\"266\":1,\"268\":2,\"291\":1}}],[\"grep\",{\"1\":{\"291\":1,\"294\":2}}],[\"greater\",{\"1\":{\"188\":1}}],[\"grpool\",{\"1\":{\"264\":1}}],[\"grpc\",{\"1\":{\"153\":1,\"157\":2}}],[\"grunning\",{\"1\":{\"200\":1}}],[\"grunnable\",{\"1\":{\"200\":2}}],[\"group\",{\"1\":{\"187\":4,\"197\":1,\"257\":1}}],[\"grow\",{\"1\":{\"268\":1}}],[\"growslice\",{\"0\":{\"208\":1},\"1\":{\"208\":16}}],[\"growing\",{\"1\":{\"85\":2}}],[\"growable\",{\"1\":{\"23\":2}}],[\"gravity\",{\"1\":{\"247\":1}}],[\"graycount++\",{\"1\":{\"244\":1}}],[\"graycount\",{\"1\":{\"244\":5}}],[\"graymax\",{\"1\":{\"244\":1}}],[\"graystack\",{\"1\":{\"244\":4}}],[\"granted\",{\"1\":{\"88\":2}}],[\"graph\",{\"1\":{\"19\":1,\"88\":1,\"227\":1}}],[\"gérald\",{\"1\":{\"8\":2}}],[\"g\",{\"1\":{\"5\":1,\"10\":1,\"23\":1,\"198\":5,\"199\":15,\"200\":93,\"202\":4,\"227\":16,\"251\":1,\"286\":1}}],[\"6856591451418329101\",{\"1\":{\"295\":1}}],[\"60\",{\"1\":{\"225\":1,\"238\":1}}],[\"60740782\",{\"1\":{\"213\":1}}],[\"6974581261192921095\",{\"1\":{\"215\":1}}],[\"6f\",{\"1\":{\"207\":1}}],[\"652\",{\"1\":{\"227\":1}}],[\"65\",{\"1\":{\"207\":1}}],[\"61\",{\"1\":{\"200\":3}}],[\"64\",{\"1\":{\"198\":1,\"200\":5,\"207\":1,\"219\":1,\"221\":1,\"250\":1,\"291\":5,\"292\":1,\"293\":2,\"294\":5}}],[\"6th\",{\"1\":{\"60\":1}}],[\"6\",{\"0\":{\"91\":1},\"1\":{\"5\":1,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"26\":1,\"47\":1,\"50\":1,\"68\":5,\"69\":2,\"71\":3,\"72\":4,\"119\":1,\"134\":1,\"140\":1,\"177\":1,\"179\":1,\"181\":1,\"190\":1,\"200\":4,\"207\":3,\"213\":20,\"218\":4,\"219\":1,\"225\":2,\"227\":14,\"243\":3,\"257\":6,\"258\":1,\"277\":1}}],[\"547\",{\"1\":{\"294\":1}}],[\"546\",{\"1\":{\"294\":1}}],[\"545\",{\"1\":{\"294\":1}}],[\"544\",{\"1\":{\"294\":1}}],[\"543\",{\"1\":{\"294\":1}}],[\"542\",{\"1\":{\"294\":1}}],[\"541\",{\"1\":{\"294\":1}}],[\"540\",{\"1\":{\"294\":1}}],[\"58\",{\"1\":{\"286\":1}}],[\"5840\",{\"1\":{\"119\":1}}],[\"56\",{\"1\":{\"225\":1}}],[\"52\",{\"1\":{\"213\":1}}],[\"51\",{\"1\":{\"136\":1}}],[\"539\",{\"1\":{\"294\":1}}],[\"538\",{\"1\":{\"294\":1}}],[\"537\",{\"1\":{\"294\":1}}],[\"536\",{\"1\":{\"294\":1}}],[\"53\",{\"1\":{\"129\":1}}],[\"500\",{\"1\":{\"268\":1}}],[\"50m\",{\"1\":{\"238\":1}}],[\"50\",{\"1\":{\"129\":1,\"136\":1,\"227\":1,\"238\":4,\"240\":1}}],[\"5ios4\",{\"1\":{\"119\":1}}],[\"5\",{\"0\":{\"81\":1},\"1\":{\"5\":1,\"8\":1,\"68\":2,\"71\":2,\"72\":3,\"103\":1,\"106\":1,\"122\":1,\"130\":3,\"136\":3,\"150\":1,\"177\":2,\"181\":1,\"190\":1,\"200\":1,\"207\":3,\"213\":20,\"218\":2,\"219\":1,\"238\":1,\"257\":1,\"281\":1,\"293\":1}}],[\"48983798\",{\"1\":{\"295\":1}}],[\"48~49\",{\"1\":{\"129\":1}}],[\"4k8k\",{\"1\":{\"295\":1}}],[\"4m\",{\"1\":{\"294\":1}}],[\"4就变成了垃圾\",{\"1\":{\"243\":1}}],[\"45\",{\"1\":{\"227\":1}}],[\"455\",{\"1\":{\"213\":1}}],[\"44\",{\"1\":{\"227\":1}}],[\"4395\",{\"1\":{\"295\":1}}],[\"435\",{\"1\":{\"227\":1}}],[\"43\",{\"1\":{\"227\":1}}],[\"42\",{\"1\":{\"225\":1,\"227\":1}}],[\"49\",{\"1\":{\"225\":1}}],[\"40\",{\"1\":{\"225\":1,\"227\":1,\"240\":1,\"268\":1,\"277\":1}}],[\"4096\",{\"1\":{\"218\":2}}],[\"4066\",{\"1\":{\"202\":1}}],[\"47\",{\"1\":{\"129\":1}}],[\"410\",{\"1\":{\"227\":1}}],[\"41\",{\"1\":{\"129\":1,\"225\":1,\"227\":1}}],[\"46\",{\"1\":{\"73\":2,\"197\":1}}],[\"4\",{\"0\":{\"76\":1},\"1\":{\"5\":1,\"26\":1,\"68\":5,\"75\":1,\"85\":1,\"90\":1,\"95\":1,\"119\":1,\"121\":2,\"129\":1,\"130\":1,\"134\":1,\"146\":1,\"177\":2,\"181\":2,\"190\":1,\"197\":1,\"200\":3,\"207\":2,\"212\":1,\"213\":22,\"218\":4,\"219\":1,\"226\":3,\"227\":11,\"228\":1,\"231\":1,\"238\":3,\"243\":8,\"252\":1,\"253\":1,\"255\":2,\"257\":1,\"283\":1,\"285\":2,\"291\":5,\"292\":1,\"293\":1,\"294\":2}}],[\"38\",{\"1\":{\"227\":1}}],[\"37731\",{\"1\":{\"277\":1}}],[\"37\",{\"1\":{\"227\":1}}],[\"37~38\",{\"1\":{\"200\":1}}],[\"36\",{\"1\":{\"227\":1}}],[\"362061406\",{\"1\":{\"90\":1}}],[\"3~8\",{\"1\":{\"200\":1}}],[\"3~11\",{\"1\":{\"75\":1}}],[\"35\",{\"1\":{\"200\":1,\"227\":2,\"286\":1}}],[\"39239info\",{\"1\":{\"286\":1}}],[\"39239\",{\"1\":{\"286\":3}}],[\"39\",{\"1\":{\"200\":1,\"225\":1,\"227\":2}}],[\"333\",{\"1\":{\"225\":1}}],[\"33\",{\"1\":{\"136\":1,\"200\":2,\"217\":3}}],[\"32\",{\"1\":{\"134\":1,\"136\":1,\"213\":2,\"227\":1,\"241\":1,\"263\":1,\"283\":2,\"291\":4}}],[\"348654\",{\"1\":{\"295\":1}}],[\"34\",{\"1\":{\"129\":1,\"136\":1,\"227\":1}}],[\"3的\",{\"1\":{\"25\":1}}],[\"3之间位置暂时不知如何排列\",{\"1\":{\"25\":1}}],[\"31\",{\"1\":{\"5\":1,\"129\":1,\"227\":1}}],[\"301\",{\"1\":{\"291\":5,\"292\":1,\"294\":2}}],[\"3000\",{\"1\":{\"286\":10}}],[\"300\",{\"1\":{\"165\":1}}],[\"30\",{\"1\":{\"5\":1,\"124\":1,\"227\":1}}],[\"3\",{\"0\":{\"66\":1,\"219\":1},\"1\":{\"5\":2,\"8\":1,\"25\":6,\"26\":1,\"34\":1,\"43\":5,\"44\":5,\"47\":1,\"48\":2,\"49\":1,\"51\":1,\"64\":2,\"68\":1,\"71\":1,\"72\":3,\"73\":1,\"80\":1,\"89\":2,\"122\":1,\"123\":3,\"124\":1,\"127\":1,\"129\":1,\"136\":3,\"139\":3,\"151\":1,\"164\":1,\"170\":2,\"174\":1,\"177\":2,\"181\":1,\"190\":1,\"197\":1,\"200\":2,\"207\":2,\"208\":1,\"212\":1,\"213\":21,\"217\":1,\"218\":4,\"219\":7,\"224\":4,\"225\":3,\"226\":1,\"227\":7,\"236\":1,\"238\":1,\"243\":1,\"244\":2,\"257\":2,\"258\":1,\"283\":1,\"285\":2,\"293\":5}}],[\"2^64\",{\"1\":{\"283\":1}}],[\"2^32−1\",{\"1\":{\"283\":1}}],[\"2^32−2\",{\"1\":{\"283\":2}}],[\"2^32\",{\"1\":{\"283\":1}}],[\"2~4\",{\"1\":{\"200\":1}}],[\"2d\",{\"1\":{\"136\":1}}],[\"2auto\",{\"1\":{\"200\":1}}],[\"2args\",{\"1\":{\"200\":1}}],[\"2a\",{\"1\":{\"130\":1}}],[\"2b\",{\"1\":{\"126\":1,\"130\":2,\"131\":1}}],[\"2pl\",{\"1\":{\"85\":4}}],[\"2等等\",{\"1\":{\"13\":1}}],[\"29\",{\"1\":{\"5\":1,\"227\":2,\"294\":1}}],[\"289\",{\"1\":{\"227\":2}}],[\"28\",{\"1\":{\"5\":1,\"200\":1,\"227\":1,\"268\":1}}],[\"273\",{\"1\":{\"227\":1}}],[\"27\",{\"1\":{\"5\":2}}],[\"260\",{\"1\":{\"227\":1}}],[\"2613\",{\"1\":{\"225\":1}}],[\"26\",{\"1\":{\"5\":1}}],[\"256mib\",{\"1\":{\"268\":1}}],[\"256mb\",{\"1\":{\"262\":2}}],[\"2567\",{\"1\":{\"227\":1}}],[\"250000000\",{\"1\":{\"200\":1}}],[\"25~46\",{\"1\":{\"129\":1}}],[\"25\",{\"1\":{\"5\":1,\"136\":1,\"227\":1,\"255\":1,\"292\":3}}],[\"24\",{\"1\":{\"5\":1,\"200\":3}}],[\"23\",{\"1\":{\"5\":1,\"200\":1}}],[\"223\",{\"1\":{\"227\":1,\"238\":2}}],[\"2269\",{\"1\":{\"227\":1}}],[\"222\",{\"1\":{\"225\":3,\"238\":1}}],[\"22\",{\"1\":{\"5\":1,\"129\":1,\"136\":1,\"200\":1}}],[\"21\",{\"1\":{\"5\":1,\"227\":1}}],[\"2020\",{\"1\":{\"288\":1}}],[\"2021\",{\"1\":{\"266\":1}}],[\"2022\",{\"1\":{\"210\":1,\"236\":2,\"293\":4}}],[\"20kb\",{\"1\":{\"262\":1}}],[\"2040\",{\"1\":{\"210\":1}}],[\"20763\",{\"1\":{\"198\":1}}],[\"20~29\",{\"1\":{\"136\":1}}],[\"200m\",{\"1\":{\"238\":4}}],[\"200\",{\"1\":{\"84\":1,\"165\":1,\"213\":1,\"238\":6}}],[\"2006\",{\"1\":{\"8\":1}}],[\"2018\",{\"1\":{\"266\":1}}],[\"2019\",{\"1\":{\"236\":1,\"266\":1}}],[\"2016\",{\"1\":{\"41\":1}}],[\"2011\",{\"1\":{\"8\":2,\"23\":2}}],[\"20\",{\"1\":{\"5\":1,\"79\":2,\"134\":1,\"136\":1,\"200\":1,\"227\":1,\"240\":1,\"247\":1,\"262\":1,\"291\":3,\"295\":1}}],[\"2\",{\"0\":{\"61\":1,\"181\":1,\"209\":1,\"218\":1},\"1\":{\"5\":2,\"13\":3,\"14\":2,\"25\":12,\"26\":2,\"43\":5,\"44\":2,\"48\":5,\"51\":1,\"64\":2,\"68\":3,\"70\":1,\"71\":2,\"72\":4,\"73\":1,\"75\":1,\"84\":2,\"89\":2,\"123\":2,\"124\":1,\"127\":3,\"129\":1,\"130\":3,\"132\":1,\"134\":1,\"136\":2,\"139\":1,\"146\":3,\"174\":1,\"177\":2,\"181\":1,\"190\":1,\"197\":1,\"200\":2,\"207\":3,\"210\":1,\"213\":21,\"218\":11,\"219\":6,\"226\":1,\"227\":3,\"236\":2,\"237\":1,\"238\":3,\"240\":1,\"243\":6,\"244\":2,\"254\":2,\"257\":1,\"262\":1,\"283\":3,\"284\":2,\"285\":3,\"286\":1,\"291\":1}}],[\"1u\",{\"1\":{\"294\":4}}],[\"1s\",{\"1\":{\"286\":1}}],[\"1kib\",{\"1\":{\"268\":1}}],[\"1kb\",{\"1\":{\"262\":1}}],[\"1ba85cc8d9\",{\"1\":{\"227\":1}}],[\"1l\",{\"1\":{\"150\":1,\"164\":4}}],[\"1是2的origin\",{\"1\":{\"48\":1}}],[\"1位置的item作为其插入意图\",{\"1\":{\"26\":1}}],[\"19282\",{\"1\":{\"238\":1}}],[\"19\",{\"1\":{\"5\":1,\"73\":3,\"129\":1,\"200\":1,\"213\":1,\"224\":6,\"225\":1,\"227\":4}}],[\"1855\",{\"1\":{\"238\":1}}],[\"1821\",{\"1\":{\"227\":1}}],[\"18\",{\"1\":{\"5\":1,\"73\":4,\"177\":1,\"179\":2,\"181\":1,\"200\":1,\"210\":1,\"224\":5,\"225\":4}}],[\"17\",{\"1\":{\"5\":1,\"72\":2,\"200\":3,\"218\":1,\"221\":1,\"225\":1}}],[\"168\",{\"1\":{\"238\":1}}],[\"16\",{\"1\":{\"5\":1,\"72\":2,\"95\":1,\"124\":1,\"134\":1,\"200\":7,\"241\":1,\"243\":1,\"255\":1}}],[\"150\",{\"1\":{\"238\":2}}],[\"15\",{\"1\":{\"5\":1,\"71\":4,\"72\":5,\"75\":1,\"90\":1,\"129\":1,\"134\":1,\"200\":2,\"227\":4,\"238\":1}}],[\"144\",{\"1\":{\"288\":1}}],[\"14\",{\"1\":{\"5\":1,\"72\":2,\"129\":1,\"134\":1,\"200\":3,\"218\":1,\"227\":1,\"294\":1}}],[\"13hello\",{\"1\":{\"197\":1}}],[\"1312342604\",{\"1\":{\"164\":1}}],[\"13\",{\"1\":{\"5\":1,\"72\":2,\"136\":2,\"197\":2,\"200\":1,\"227\":1,\"238\":1,\"257\":1,\"266\":1}}],[\"12125736\",{\"1\":{\"295\":1}}],[\"1216\",{\"1\":{\"238\":1}}],[\"127\",{\"1\":{\"277\":2,\"286\":11,\"291\":1}}],[\"12736031\",{\"1\":{\"266\":1}}],[\"12hello\",{\"1\":{\"257\":1}}],[\"123\",{\"1\":{\"225\":2}}],[\"1234\",{\"1\":{\"213\":2,\"291\":2}}],[\"122945924\",{\"1\":{\"213\":1}}],[\"12\",{\"1\":{\"5\":1,\"72\":2,\"80\":1,\"136\":1,\"180\":12,\"200\":3,\"213\":2,\"218\":1,\"219\":1,\"227\":1,\"257\":1}}],[\"114\",{\"1\":{\"238\":1}}],[\"118\",{\"1\":{\"227\":1}}],[\"111\",{\"1\":{\"225\":1}}],[\"112\",{\"1\":{\"208\":2}}],[\"11\",{\"1\":{\"5\":1,\"71\":2,\"75\":1,\"136\":1,\"180\":15,\"200\":1,\"212\":1}}],[\"107547837\",{\"1\":{\"295\":1}}],[\"109442115\",{\"1\":{\"295\":1}}],[\"104\",{\"1\":{\"200\":4}}],[\"103\",{\"1\":{\"181\":1}}],[\"101\",{\"1\":{\"181\":1}}],[\"105\",{\"1\":{\"177\":2,\"190\":2}}],[\"102\",{\"1\":{\"177\":2,\"181\":1}}],[\"1024+104\",{\"1\":{\"200\":1}}],[\"1024\",{\"1\":{\"106\":1,\"200\":4,\"238\":8,\"262\":3,\"268\":2,\"294\":3}}],[\"100731400\",{\"1\":{\"295\":1}}],[\"100644\",{\"1\":{\"227\":1}}],[\"100\",{\"1\":{\"32\":1,\"84\":1,\"136\":2,\"144\":1,\"177\":2,\"181\":1,\"190\":1,\"208\":2,\"210\":1,\"213\":4,\"218\":2,\"231\":1,\"237\":1,\"238\":2,\"241\":1}}],[\"1000000000\",{\"1\":{\"200\":1}}],[\"10000\",{\"1\":{\"200\":2,\"213\":4,\"264\":3}}],[\"1000\",{\"1\":{\"4\":1,\"213\":2,\"241\":3,\"286\":1}}],[\"10\",{\"1\":{\"5\":1,\"44\":1,\"65\":1,\"71\":2,\"72\":4,\"75\":1,\"134\":1,\"177\":1,\"190\":1,\"200\":4,\"207\":6,\"208\":2,\"213\":2,\"218\":1,\"219\":5,\"227\":2,\"240\":2,\"252\":1,\"266\":1,\"268\":3,\"285\":4,\"286\":2}}],[\"1\",{\"0\":{\"55\":1,\"179\":1,\"206\":1,\"217\":1},\"1\":{\"5\":8,\"13\":12,\"14\":4,\"16\":3,\"17\":3,\"18\":3,\"25\":20,\"26\":10,\"30\":2,\"31\":1,\"32\":1,\"34\":3,\"43\":8,\"44\":3,\"47\":10,\"48\":12,\"51\":1,\"53\":1,\"58\":3,\"64\":3,\"65\":1,\"68\":2,\"70\":5,\"71\":1,\"72\":2,\"73\":1,\"79\":1,\"84\":4,\"89\":2,\"114\":1,\"123\":4,\"124\":9,\"125\":2,\"127\":3,\"128\":1,\"129\":12,\"130\":2,\"132\":1,\"133\":2,\"134\":11,\"136\":8,\"137\":2,\"138\":1,\"164\":1,\"170\":1,\"174\":1,\"177\":2,\"181\":1,\"188\":2,\"190\":1,\"197\":4,\"200\":7,\"207\":3,\"210\":2,\"212\":1,\"213\":26,\"217\":1,\"218\":10,\"219\":12,\"221\":1,\"225\":1,\"226\":1,\"227\":4,\"228\":1,\"234\":2,\"237\":2,\"238\":4,\"240\":3,\"241\":3,\"243\":2,\"244\":3,\"257\":5,\"266\":1,\"268\":3,\"277\":2,\"283\":12,\"284\":5,\"285\":4,\"286\":14,\"291\":9,\"292\":3,\"294\":8}}],[\"给错误调试和定位带来了很大困难\",{\"1\":{\"277\":1}}],[\"给干掉\",{\"1\":{\"261\":1}}],[\"给\",{\"1\":{\"223\":1}}],[\"给函数使用带来的麻烦\",{\"1\":{\"179\":1}}],[\"给领导者\",{\"1\":{\"129\":1}}],[\"给自己投票后迫切地想成为领导者\",{\"1\":{\"124\":1}}],[\"给谁投过票\",{\"1\":{\"123\":1,\"126\":1,\"133\":1}}],[\"给出类型定义\",{\"1\":{\"181\":1}}],[\"给出了\",{\"1\":{\"23\":1,\"38\":1}}],[\"给出了明确定义\",{\"1\":{\"8\":1}}],[\"给出了主流协同算法\",{\"1\":{\"8\":1}}],[\"给出的lsmtree稍加修饰\",{\"1\":{\"5\":1}}],[\"给一个明确的方向\",{\"1\":{\"4\":1}}],[\"测试成功\",{\"1\":{\"213\":1}}],[\"测试用例\",{\"0\":{\"170\":1}}],[\"测试用例反推代码结构\",{\"1\":{\"168\":1}}],[\"测试用例是对功能的需求的描述\",{\"1\":{\"168\":1}}],[\"测试用例写起来很麻烦\",{\"1\":{\"168\":1}}],[\"测试驱动开发的主要关注点在于功能在单元\",{\"1\":{\"164\":1}}],[\"测试步骤\",{\"1\":{\"164\":1}}],[\"测试方案\",{\"1\":{\"162\":1}}],[\"测试通过\",{\"1\":{\"5\":1,\"170\":1}}],[\"测试\",{\"0\":{\"5\":1},\"1\":{\"165\":1}}],[\"磁盘读比\",{\"1\":{\"231\":1}}],[\"磁盘之间的数据通道\",{\"1\":{\"64\":1}}],[\"磁盘之间的数据交换\",{\"1\":{\"64\":1}}],[\"磁盘\",{\"1\":{\"64\":1}}],[\"磁盘上的副本可能是老数据\",{\"1\":{\"62\":1}}],[\"磁盘上保存的数据实则是缓存池数据的副本\",{\"1\":{\"62\":1}}],[\"磁盘存储\",{\"1\":{\"58\":1,\"59\":1}}],[\"磁盘管理器\",{\"1\":{\"58\":1,\"59\":1,\"64\":1}}],[\"磁盘表\",{\"1\":{\"4\":1}}],[\"磁盘使用和内存占用等\",{\"1\":{\"4\":1}}],[\"uapi\",{\"1\":{\"294\":1}}],[\"ubuntu\",{\"1\":{\"291\":11,\"295\":1}}],[\"ubuntu20\",{\"1\":{\"291\":2}}],[\"udpsocket\",{\"1\":{\"286\":5}}],[\"udp\",{\"1\":{\"278\":2,\"279\":4,\"286\":8}}],[\"u32toa\",{\"0\":{\"213\":1},\"1\":{\"213\":13}}],[\"uint16\",{\"1\":{\"284\":1}}],[\"uint32\",{\"1\":{\"208\":1,\"213\":6}}],[\"uint8\",{\"1\":{\"207\":6,\"208\":4}}],[\"uint64\",{\"1\":{\"200\":1,\"238\":2,\"263\":2,\"283\":4,\"284\":4}}],[\"uintptr\",{\"1\":{\"200\":4,\"207\":2,\"208\":2,\"218\":1,\"238\":2,\"240\":7,\"241\":4,\"243\":1,\"244\":1}}],[\"util\",{\"1\":{\"191\":1}}],[\"utf\",{\"1\":{\"170\":1}}],[\"url\",{\"1\":{\"170\":1}}],[\"uml\",{\"1\":{\"97\":1}}],[\"uptime\",{\"1\":{\"291\":1}}],[\"uptodate\",{\"1\":{\"130\":8,\"133\":1}}],[\"upper\",{\"1\":{\"285\":1}}],[\"upfront\",{\"1\":{\"164\":1}}],[\"upon\",{\"1\":{\"134\":1}}],[\"up\",{\"1\":{\"88\":1,\"136\":1,\"227\":1}}],[\"updates\",{\"1\":{\"291\":2}}],[\"updaterootpageid\",{\"1\":{\"72\":1}}],[\"update\",{\"1\":{\"26\":1,\"51\":1,\"79\":1,\"285\":1,\"291\":1}}],[\"updated\",{\"1\":{\"26\":1}}],[\"usr\",{\"1\":{\"291\":2,\"294\":4}}],[\"using\",{\"1\":{\"69\":2,\"224\":5,\"225\":5,\"247\":1}}],[\"user\",{\"1\":{\"263\":1,\"292\":1}}],[\"username\",{\"1\":{\"170\":1}}],[\"uses\",{\"1\":{\"200\":2}}],[\"use\",{\"1\":{\"51\":1,\"283\":1,\"291\":1,\"293\":1}}],[\"used\",{\"1\":{\"4\":2,\"63\":1,\"200\":1,\"263\":1}}],[\"unzip\",{\"1\":{\"292\":1}}],[\"unclean\",{\"1\":{\"285\":5}}],[\"uncommitted\",{\"1\":{\"88\":2,\"89\":1}}],[\"unwrap\",{\"1\":{\"283\":1,\"284\":2}}],[\"unwind\",{\"1\":{\"212\":1}}],[\"unacceptable\",{\"1\":{\"283\":1}}],[\"unassembled\",{\"1\":{\"282\":4,\"283\":1}}],[\"unary\",{\"1\":{\"164\":2,\"218\":1}}],[\"un\",{\"1\":{\"268\":1}}],[\"unusable\",{\"1\":{\"263\":1}}],[\"unused\",{\"1\":{\"64\":2,\"69\":6}}],[\"unmarshal\",{\"1\":{\"260\":1}}],[\"unmap\",{\"1\":{\"237\":1}}],[\"unreached\",{\"1\":{\"243\":3,\"244\":3}}],[\"unregisterqueue\",{\"1\":{\"155\":1}}],[\"unregistertopic\",{\"1\":{\"155\":1}}],[\"unregisterbroker\",{\"1\":{\"155\":1}}],[\"unpacktype\",{\"1\":{\"208\":2}}],[\"unpinpage\",{\"1\":{\"64\":4,\"70\":1}}],[\"unpinpageimpl\",{\"1\":{\"64\":2}}],[\"unpin\",{\"1\":{\"63\":3,\"64\":3,\"70\":1}}],[\"until\",{\"1\":{\"200\":1,\"286\":2}}],[\"unistd\",{\"1\":{\"294\":1}}],[\"universe\",{\"1\":{\"291\":10}}],[\"uninitialized\",{\"1\":{\"200\":1}}],[\"unique\",{\"1\":{\"88\":3}}],[\"unique<tableiterator>\",{\"1\":{\"79\":1}}],[\"unknown\",{\"1\":{\"200\":1,\"292\":1,\"293\":2}}],[\"unsafeprintfunc\",{\"1\":{\"218\":2}}],[\"unsafe\",{\"1\":{\"198\":3,\"200\":4,\"202\":3,\"203\":4,\"207\":11,\"208\":4,\"214\":2,\"218\":2,\"238\":1,\"240\":7,\"241\":3,\"243\":3,\"244\":1}}],[\"unsigned\",{\"1\":{\"198\":2,\"237\":2,\"284\":4,\"294\":4}}],[\"unsetqueueconsumer\",{\"1\":{\"155\":1}}],[\"undo\",{\"1\":{\"94\":3,\"198\":1}}],[\"unlockosthread\",{\"1\":{\"200\":2}}],[\"unlock\",{\"1\":{\"88\":2,\"124\":5,\"129\":5,\"130\":1,\"131\":1,\"136\":5,\"137\":1,\"200\":2,\"241\":2}}],[\"unordered\",{\"1\":{\"63\":1,\"64\":1,\"88\":1}}],[\"u\",{\"1\":{\"5\":1}}],[\"uuid4\",{\"1\":{\"4\":1}}],[\"uuid\",{\"1\":{\"4\":2}}],[\"强领导者\",{\"1\":{\"122\":1}}],[\"强二阶段锁规定\",{\"1\":{\"85\":1}}],[\"强二阶段锁定协议示意图如下\",{\"1\":{\"85\":1}}],[\"强调的是状态\",{\"1\":{\"10\":1}}],[\"强调的是操作\",{\"1\":{\"10\":1}}],[\"强\",{\"1\":{\"4\":1}}],[\"修改源代码\",{\"0\":{\"294\":1}}],[\"修改完毕后\",{\"1\":{\"225\":1}}],[\"修改代码时\",{\"1\":{\"164\":1}}],[\"修改rpc调用参数\",{\"1\":{\"149\":1}}],[\"修改\",{\"1\":{\"4\":1,\"225\":1}}],[\"提一点\",{\"1\":{\"243\":1}}],[\"提一下\",{\"1\":{\"242\":1}}],[\"提案的简单实现方式了\",{\"1\":{\"239\":1}}],[\"提出了一种\",{\"1\":{\"236\":1}}],[\"提出了一种名为\",{\"1\":{\"8\":1}}],[\"提升内存的应用效率\",{\"1\":{\"261\":1}}],[\"提升了分配性能\",{\"1\":{\"241\":1}}],[\"提升业务开发效率\",{\"1\":{\"151\":1}}],[\"提升扩展性\",{\"1\":{\"151\":1}}],[\"提升性能\",{\"1\":{\"151\":1}}],[\"提升容错\",{\"1\":{\"150\":1}}],[\"提升整个框架稳定性是容错层必须解决的问题\",{\"1\":{\"150\":1}}],[\"提升带宽利用率\",{\"1\":{\"146\":1}}],[\"提高主\",{\"1\":{\"121\":1}}],[\"提高访问性能\",{\"1\":{\"64\":1}}],[\"提供的函数\",{\"1\":{\"285\":1}}],[\"提供的\",{\"1\":{\"238\":1}}],[\"提供了更便利的\",{\"1\":{\"264\":2}}],[\"提供了简单易用的\",{\"1\":{\"264\":1}}],[\"提供了多层级的\",{\"1\":{\"262\":1}}],[\"提供了\",{\"1\":{\"183\":1,\"243\":1}}],[\"提供两种客户端访问模式\",{\"1\":{\"104\":1}}],[\"提供\",{\"1\":{\"103\":1,\"264\":1}}],[\"提交阶段\",{\"1\":{\"85\":1}}],[\"提交\",{\"1\":{\"85\":1}}],[\"提交一个事务\",{\"1\":{\"4\":1,\"85\":2}}],[\"提示缺少\",{\"1\":{\"225\":1}}],[\"提示一下\",{\"1\":{\"218\":1}}],[\"提示\",{\"1\":{\"72\":1}}],[\"提问\",{\"1\":{\"4\":1}}],[\"列表的最后一个元素是否为\",{\"1\":{\"225\":1}}],[\"列表\",{\"1\":{\"4\":2,\"105\":1}}],[\"列表为新生成的\",{\"1\":{\"4\":1}}],[\"列表中\",{\"1\":{\"4\":1}}],[\"然后开始愉快的调试\",{\"1\":{\"291\":1}}],[\"然后开启调度循环\",{\"1\":{\"198\":1,\"203\":1}}],[\"然后编译\",{\"1\":{\"291\":1}}],[\"然后干净地关闭连接\",{\"1\":{\"286\":2}}],[\"然后向\",{\"1\":{\"286\":1}}],[\"然后适配到\",{\"1\":{\"286\":1}}],[\"然后新建客户端连接\",{\"1\":{\"286\":1}}],[\"然后从\",{\"1\":{\"286\":1}}],[\"然后从磁盘上读取新的数据页\",{\"1\":{\"63\":1}}],[\"然后设置\",{\"1\":{\"285\":2}}],[\"然后设置目录变量\",{\"1\":{\"224\":1}}],[\"然后发送报文\",{\"1\":{\"284\":1}}],[\"然后尝试去合并二者\",{\"1\":{\"282\":1}}],[\"然后搜索连接对象\",{\"1\":{\"244\":1}}],[\"然后返回\",{\"1\":{\"241\":1,\"243\":1}}],[\"然后去页中拿到空间块返回\",{\"1\":{\"241\":1}}],[\"然后去学习\",{\"1\":{\"220\":1}}],[\"然后需要内存时\",{\"1\":{\"239\":1}}],[\"然后用这块内存来用于程序其它数据的分配\",{\"1\":{\"237\":1}}],[\"然后自己来解决\",{\"1\":{\"228\":1}}],[\"然后生成对应的解析程序部分\",{\"1\":{\"225\":1}}],[\"然后生成新的item\",{\"1\":{\"26\":1}}],[\"然后推入栈\",{\"1\":{\"218\":1}}],[\"然后写入内存并执行\",{\"1\":{\"218\":1}}],[\"然后执行了\",{\"1\":{\"218\":1}}],[\"然后执行\",{\"1\":{\"218\":1}}],[\"然后运行\",{\"1\":{\"212\":1}}],[\"然后调度\",{\"1\":{\"200\":1}}],[\"然后调用该函数\",{\"1\":{\"200\":1}}],[\"然后调用\",{\"1\":{\"70\":1,\"94\":1,\"200\":1,\"208\":1,\"218\":1,\"238\":1}}],[\"然后看\",{\"1\":{\"200\":1}}],[\"然后拿到\",{\"1\":{\"198\":1,\"240\":1}}],[\"然后通过\",{\"1\":{\"200\":1,\"225\":1,\"286\":1}}],[\"然后通过中断调用使系统进入内核态\",{\"1\":{\"197\":1}}],[\"然后通过谓词判断记录是否符合查询条件\",{\"1\":{\"79\":1}}],[\"然后汇总到\",{\"1\":{\"187\":1}}],[\"然后vi会通过\",{\"1\":{\"181\":1}}],[\"然后驱动其开发\",{\"1\":{\"164\":1}}],[\"然后交给网络层进行传输\",{\"1\":{\"147\":1}}],[\"然后持久化快照数据\",{\"1\":{\"136\":1}}],[\"然后截断日志切片\",{\"1\":{\"136\":1}}],[\"然后更新\",{\"1\":{\"136\":1,\"281\":1}}],[\"然后判断重试次数\",{\"1\":{\"285\":1}}],[\"然后判断\",{\"1\":{\"225\":1,\"240\":1}}],[\"然后判断该序号是否小于\",{\"1\":{\"134\":1}}],[\"然后判断事务之间是否存在循环依赖\",{\"1\":{\"88\":1}}],[\"然后继续同步\",{\"1\":{\"129\":1}}],[\"然后转发到对应的缓存节点中\",{\"1\":{\"106\":1}}],[\"然后再\",{\"1\":{\"285\":1}}],[\"然后再用\",{\"1\":{\"224\":1}}],[\"然后再次运行\",{\"1\":{\"212\":1,\"225\":1}}],[\"然后再转化成\",{\"1\":{\"212\":1}}],[\"然后再将栈顶的值推出\",{\"1\":{\"218\":1}}],[\"然后再将\",{\"1\":{\"200\":1,\"218\":1}}],[\"然后再将其与\",{\"1\":{\"198\":1}}],[\"然后再查询现有数据数量\",{\"1\":{\"164\":1}}],[\"然后再插入一条数据\",{\"1\":{\"164\":1}}],[\"然后再完善文档\",{\"1\":{\"118\":1}}],[\"然后再向访问单节点\",{\"1\":{\"105\":1}}],[\"然后再更改\",{\"1\":{\"86\":1}}],[\"然后再更新本地向量\",{\"1\":{\"10\":1}}],[\"然后初始化该执行器\",{\"1\":{\"78\":1}}],[\"然后获取节点\",{\"1\":{\"73\":4}}],[\"然后升级为独占锁\",{\"1\":{\"73\":1}}],[\"然后在容器中安装\",{\"1\":{\"291\":1}}],[\"然后在另一个窗口中连接该端口\",{\"1\":{\"277\":1}}],[\"然后在合适的时机自动\",{\"1\":{\"238\":1}}],[\"然后在\",{\"1\":{\"213\":2}}],[\"然后在生产代码再写一遍\",{\"1\":{\"164\":1}}],[\"然后在框架启动时\",{\"1\":{\"151\":1}}],[\"然后在判断子节点安全后\",{\"1\":{\"73\":1}}],[\"然后在事务中使用\",{\"1\":{\"4\":1}}],[\"然后移动另外一条\",{\"1\":{\"73\":1}}],[\"然后删除旧的根节点\",{\"1\":{\"72\":1}}],[\"然后以事务的方式请求缓存管理器获取数据页\",{\"1\":{\"58\":1}}],[\"然后将数据加入到\",{\"1\":{\"281\":1}}],[\"然后将出栈对象标记为黑色\",{\"1\":{\"244\":1}}],[\"然后将内存拿到后放入\",{\"1\":{\"241\":1}}],[\"然后将其编译为一个本地镜像\",{\"1\":{\"291\":1}}],[\"然后将其编译为汇编代码供\",{\"1\":{\"213\":1}}],[\"然后将其解析为\",{\"1\":{\"260\":1}}],[\"然后将其引用对象入栈\",{\"1\":{\"244\":1}}],[\"然后将其清理掉\",{\"1\":{\"243\":1}}],[\"然后将其通过指针强转为函数指针\",{\"1\":{\"218\":1}}],[\"然后将其复制到了飞书文档\",{\"1\":{\"27\":1}}],[\"然后将\",{\"1\":{\"200\":1}}],[\"然后将这些信息包装为参数发送给节点\",{\"1\":{\"129\":1}}],[\"然后将页数据视为叶子\",{\"1\":{\"71\":1}}],[\"然后将i插入到o后面\",{\"1\":{\"44\":1}}],[\"然后将item插入到parent\",{\"1\":{\"26\":1}}],[\"然后将集成\",{\"1\":{\"26\":1}}],[\"然后插入或删除即可\",{\"1\":{\"23\":1}}],[\"然后是\",{\"1\":{\"10\":1}}],[\"然后\",{\"1\":{\"4\":1,\"47\":2,\"84\":2,\"200\":1,\"212\":1,\"217\":1,\"219\":1,\"257\":1}}],[\"wget\",{\"1\":{\"291\":3,\"292\":1,\"293\":1}}],[\"wrap\",{\"1\":{\"283\":2,\"285\":1}}],[\"wrappingint32\",{\"1\":{\"283\":4,\"284\":2}}],[\"wrappingintegers\",{\"1\":{\"280\":2}}],[\"wrapping\",{\"1\":{\"280\":2}}],[\"wrapper\",{\"1\":{\"263\":1}}],[\"written\",{\"1\":{\"281\":2,\"282\":3}}],[\"writev\",{\"1\":{\"294\":2}}],[\"writes\",{\"1\":{\"268\":2}}],[\"writeshort\",{\"1\":{\"146\":3}}],[\"writer\",{\"1\":{\"260\":1}}],[\"writefile\",{\"1\":{\"219\":1}}],[\"writefilenum\",{\"1\":{\"98\":1}}],[\"write|syscall\",{\"1\":{\"218\":1}}],[\"writebytes\",{\"1\":{\"146\":1}}],[\"writeint\",{\"1\":{\"146\":1}}],[\"writeone\",{\"1\":{\"98\":2}}],[\"writemetadata\",{\"1\":{\"98\":2}}],[\"writepos\",{\"1\":{\"98\":1}}],[\"writepage\",{\"1\":{\"64\":4}}],[\"write\",{\"1\":{\"4\":3,\"15\":1,\"50\":1,\"197\":6,\"238\":1,\"247\":1,\"257\":5,\"281\":2,\"282\":1,\"285\":4,\"286\":1}}],[\"www\",{\"1\":{\"90\":1,\"215\":1,\"266\":1,\"295\":5}}],[\"wasm\",{\"1\":{\"200\":2}}],[\"wakep\",{\"1\":{\"200\":2}}],[\"wakes\",{\"1\":{\"88\":1}}],[\"way\",{\"1\":{\"191\":1}}],[\"walker\",{\"1\":{\"227\":2}}],[\"walkfunc\",{\"1\":{\"184\":1}}],[\"walk\",{\"1\":{\"184\":2,\"227\":6}}],[\"wal\",{\"1\":{\"92\":1}}],[\"waited\",{\"1\":{\"263\":1}}],[\"waitduration\",{\"1\":{\"263\":1}}],[\"waitsince\",{\"1\":{\"200\":1}}],[\"waitstrategies\",{\"1\":{\"150\":1}}],[\"waits\",{\"1\":{\"88\":4}}],[\"waiting\",{\"1\":{\"88\":1,\"263\":1,\"286\":3}}],[\"wait\",{\"1\":{\"87\":2,\"88\":8,\"187\":1,\"286\":2}}],[\"wants\",{\"1\":{\"284\":1,\"285\":1}}],[\"wantconnqueue\",{\"1\":{\"263\":1}}],[\"wantret\",{\"1\":{\"212\":5,\"213\":5}}],[\"want\",{\"1\":{\"51\":1,\"212\":1,\"227\":1}}],[\"whole\",{\"1\":{\"285\":1}}],[\"whose\",{\"1\":{\"181\":1}}],[\"whatever\",{\"1\":{\"164\":2}}],[\"what\",{\"0\":{\"118\":1},\"1\":{\"286\":2}}],[\"when\",{\"1\":{\"88\":1,\"164\":1,\"200\":1,\"284\":1}}],[\"where\",{\"1\":{\"79\":1,\"174\":1}}],[\"which\",{\"1\":{\"47\":1,\"51\":1,\"262\":1,\"263\":1}}],[\"while\",{\"1\":{\"4\":1,\"26\":2,\"51\":3,\"70\":2,\"73\":1,\"78\":1,\"79\":2,\"88\":2,\"89\":1,\"227\":6,\"282\":3,\"284\":2,\"285\":1,\"286\":1}}],[\"wlatch\",{\"1\":{\"73\":1}}],[\"wite\",{\"1\":{\"286\":11}}],[\"withstopstrategy\",{\"1\":{\"150\":1}}],[\"withwaitstrategy\",{\"1\":{\"150\":1}}],[\"with\",{\"1\":{\"47\":2,\"51\":2,\"134\":2,\"197\":1,\"200\":1,\"257\":1,\"262\":1,\"285\":2,\"286\":1,\"291\":1,\"293\":1}}],[\"without\",{\"1\":{\"8\":1}}],[\"win\",{\"1\":{\"284\":4,\"285\":3,\"286\":1}}],[\"windows\",{\"1\":{\"283\":1}}],[\"window\",{\"1\":{\"279\":3,\"283\":5,\"284\":21,\"285\":6}}],[\"width\",{\"1\":{\"255\":3}}],[\"will\",{\"1\":{\"51\":1,\"262\":1}}],[\"weight\",{\"1\":{\"294\":4}}],[\"weixin\",{\"1\":{\"119\":1,\"191\":2,\"295\":1}}],[\"welcome\",{\"1\":{\"293\":1}}],[\"we\",{\"1\":{\"51\":3,\"283\":1,\"285\":1}}],[\"wowotech\",{\"1\":{\"295\":1}}],[\"worrying\",{\"1\":{\"236\":1,\"238\":1}}],[\"word\",{\"1\":{\"213\":3}}],[\"worldstarted\",{\"1\":{\"200\":1}}],[\"world\",{\"0\":{\"192\":1},\"1\":{\"192\":3,\"197\":9,\"200\":9,\"235\":1,\"257\":7}}],[\"worker\",{\"1\":{\"264\":3}}],[\"workerpool\",{\"1\":{\"264\":1}}],[\"worker线程池\",{\"1\":{\"151\":1}}],[\"workspacefolder\",{\"1\":{\"291\":2}}],[\"workspace\",{\"1\":{\"225\":2}}],[\"working\",{\"1\":{\"164\":1}}],[\"work\",{\"1\":{\"5\":1,\"164\":1,\"200\":1}}],[\"won\",{\"1\":{\"15\":1,\"50\":1}}],[\"woot\",{\"1\":{\"8\":2}}],[\"w\",{\"1\":{\"5\":1,\"133\":3,\"227\":11}}],[\"09\",{\"1\":{\"266\":1}}],[\"0m\",{\"1\":{\"238\":1}}],[\"0a\",{\"1\":{\"219\":1}}],[\"00s\",{\"1\":{\"208\":1,\"212\":3,\"227\":1}}],[\"00\",{\"1\":{\"207\":29}}],[\"00000000\",{\"1\":{\"207\":6}}],[\"0666\",{\"1\":{\"219\":1}}],[\"06\",{\"1\":{\"207\":3}}],[\"05\",{\"1\":{\"207\":3}}],[\"04\",{\"1\":{\"207\":3,\"291\":3,\"295\":1}}],[\"03\",{\"1\":{\"207\":3,\"215\":1}}],[\"02e165a0004be33734ac2334f215380e\",{\"1\":{\"295\":1}}],[\"02\",{\"1\":{\"207\":3,\"266\":1,\"293\":4}}],[\"02c\",{\"1\":{\"198\":2}}],[\"01\",{\"1\":{\"181\":4,\"207\":3,\"294\":1}}],[\"0x00\",{\"1\":{\"257\":1}}],[\"0x123\",{\"1\":{\"254\":2}}],[\"0x18\",{\"1\":{\"180\":2}}],[\"0xc0|as\",{\"1\":{\"218\":1}}],[\"0x48\",{\"1\":{\"218\":1}}],[\"0x90\",{\"1\":{\"212\":1}}],[\"0xba00000\",{\"1\":{\"210\":1,\"237\":1}}],[\"0x7ffe88f6ce40\",{\"1\":{\"197\":1}}],[\"0x28\",{\"1\":{\"180\":4}}],[\"0x2000000+1\",{\"1\":{\"217\":1}}],[\"0x20\",{\"1\":{\"180\":4}}],[\"0x89\",{\"1\":{\"218\":1}}],[\"0x8\",{\"1\":{\"180\":6}}],[\"08\",{\"1\":{\"119\":1,\"266\":1}}],[\"0\",{\"1\":{\"4\":2,\"13\":4,\"14\":6,\"16\":2,\"17\":2,\"18\":2,\"26\":14,\"34\":4,\"35\":1,\"36\":1,\"37\":2,\"47\":12,\"48\":7,\"51\":2,\"64\":11,\"69\":2,\"72\":1,\"79\":3,\"93\":1,\"94\":1,\"123\":2,\"124\":2,\"127\":2,\"128\":4,\"129\":15,\"131\":3,\"133\":1,\"134\":3,\"136\":12,\"137\":5,\"170\":2,\"180\":8,\"197\":5,\"200\":16,\"202\":1,\"207\":2,\"208\":5,\"210\":2,\"212\":7,\"213\":29,\"217\":3,\"218\":16,\"219\":16,\"225\":1,\"227\":9,\"234\":1,\"237\":2,\"238\":30,\"241\":11,\"243\":3,\"244\":4,\"251\":1,\"255\":2,\"256\":2,\"257\":4,\"262\":1,\"268\":3,\"277\":8,\"282\":9,\"283\":9,\"284\":19,\"285\":10,\"286\":23,\"291\":4,\"292\":3,\"294\":5}}],[\"x32\",{\"1\":{\"294\":12}}],[\"xz\",{\"1\":{\"292\":2}}],[\"xzf\",{\"1\":{\"291\":1,\"293\":1}}],[\"xf\",{\"1\":{\"291\":1,\"292\":1}}],[\"xyz\",{\"1\":{\"266\":1,\"295\":1}}],[\"xpos\",{\"1\":{\"227\":1}}],[\"x2\",{\"1\":{\"217\":4}}],[\"x86\",{\"1\":{\"197\":1,\"200\":1,\"221\":1,\"291\":8,\"292\":1,\"293\":2,\"294\":8}}],[\"xxx\",{\"1\":{\"180\":1,\"224\":4}}],[\"xorps\",{\"1\":{\"180\":1}}],[\"x1\",{\"1\":{\"180\":4,\"217\":4}}],[\"x0\",{\"1\":{\"180\":4}}],[\"xmm\",{\"1\":{\"180\":5,\"247\":1}}],[\"xml配置文件\",{\"1\":{\"170\":1,\"172\":1}}],[\"xml\",{\"0\":{\"172\":1,\"173\":1},\"1\":{\"147\":1,\"170\":3,\"172\":2,\"175\":1}}],[\"xunit\",{\"1\":{\"164\":1}}],[\"x=5\",{\"1\":{\"127\":3}}],[\"x=1\",{\"1\":{\"127\":1}}],[\"xcodis\",{\"1\":{\"119\":1}}],[\"x\",{\"1\":{\"4\":2,\"5\":1,\"16\":2,\"86\":1,\"127\":6,\"136\":1,\"200\":2,\"217\":3,\"218\":14,\"219\":12,\"225\":7,\"227\":10,\"240\":1,\"291\":1,\"293\":3,\"295\":1}}],[\"nr\",{\"1\":{\"294\":1}}],[\"ng\",{\"0\":{\"292\":1},\"1\":{\"292\":10}}],[\"n2\",{\"1\":{\"282\":1}}],[\"n1\",{\"1\":{\"282\":1}}],[\"nmap\",{\"1\":{\"277\":1}}],[\"ncat\",{\"1\":{\"277\":6}}],[\"nc\",{\"1\":{\"277\":4}}],[\"ncpu\",{\"1\":{\"200\":1}}],[\"nbody\",{\"1\":{\"227\":1}}],[\"ns\",{\"1\":{\"213\":2}}],[\"nsjqlmdpew\",{\"1\":{\"191\":1}}],[\"n++\",{\"1\":{\"213\":6}}],[\"narg\",{\"1\":{\"200\":4}}],[\"nanotime\",{\"1\":{\"200\":1}}],[\"names\",{\"1\":{\"219\":1}}],[\"namespace\",{\"1\":{\"173\":1}}],[\"namepos\",{\"1\":{\"219\":1}}],[\"name=\",{\"1\":{\"170\":4}}],[\"name\",{\"1\":{\"5\":1,\"28\":1,\"50\":8,\"69\":2,\"98\":1,\"212\":4,\"213\":6,\"218\":2,\"219\":17,\"225\":2,\"237\":2,\"291\":1,\"293\":1}}],[\"nil\",{\"1\":{\"128\":2,\"133\":4,\"136\":4,\"179\":1,\"200\":9,\"203\":1,\"218\":24,\"219\":5,\"223\":2,\"225\":13,\"227\":12,\"238\":7,\"240\":5,\"241\":4,\"243\":1,\"244\":1,\"260\":1,\"261\":3,\"262\":1}}],[\"nth\",{\"1\":{\"34\":2,\"35\":1,\"36\":1,\"37\":1}}],[\"numclosed\",{\"1\":{\"263\":2}}],[\"numobjects++\",{\"1\":{\"243\":1}}],[\"numobjects\",{\"1\":{\"243\":13,\"244\":3}}],[\"numpages\",{\"1\":{\"241\":2}}],[\"numgc\",{\"1\":{\"238\":14}}],[\"num\",{\"1\":{\"63\":2,\"294\":10}}],[\"numbers\",{\"1\":{\"181\":1,\"285\":1}}],[\"number>\",{\"1\":{\"13\":1,\"14\":4}}],[\"number\",{\"1\":{\"13\":5,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"25\":1,\"26\":4,\"28\":2,\"47\":3,\"48\":1,\"69\":1,\"87\":1,\"146\":2,\"263\":1,\"282\":1,\"283\":2,\"284\":3,\"285\":1,\"294\":4}}],[\"nullopt\",{\"1\":{\"283\":2,\"284\":2}}],[\"nullptr\",{\"1\":{\"78\":1,\"79\":1,\"89\":2,\"93\":2,\"94\":1}}],[\"null>\",{\"1\":{\"18\":1}}],[\"null\",{\"1\":{\"16\":3,\"17\":3,\"18\":2,\"25\":4,\"26\":9,\"28\":4,\"36\":1,\"37\":1,\"47\":3,\"48\":6,\"50\":14,\"51\":18,\"70\":2,\"150\":1,\"157\":1,\"174\":3,\"210\":1,\"237\":1,\"291\":6,\"294\":1}}],[\"neq\",{\"1\":{\"225\":2}}],[\"neg\",{\"1\":{\"218\":3}}],[\"negative\",{\"1\":{\"218\":1}}],[\"net\",{\"1\":{\"215\":1,\"263\":3,\"291\":1,\"295\":2}}],[\"netty处理器中不阻塞流程\",{\"1\":{\"151\":1}}],[\"networking\",{\"1\":{\"288\":1}}],[\"network\",{\"0\":{\"303\":1},\"1\":{\"9\":1,\"293\":1}}],[\"nemo\",{\"1\":{\"117\":1}}],[\"nested\",{\"1\":{\"79\":2}}],[\"neighbor\",{\"1\":{\"72\":8}}],[\"neo4j\",{\"1\":{\"56\":1}}],[\"necessary\",{\"1\":{\"51\":1,\"285\":1}}],[\"needs\",{\"1\":{\"285\":1}}],[\"needunlock\",{\"1\":{\"200\":3}}],[\"need\",{\"1\":{\"51\":1,\"179\":1}}],[\"near\",{\"1\":{\"39\":1,\"41\":2,\"53\":1}}],[\"nextp\",{\"1\":{\"200\":2}}],[\"nextindex\",{\"1\":{\"126\":3,\"129\":25,\"134\":8,\"136\":6,\"137\":5}}],[\"nextreadfilenum\",{\"1\":{\"98\":1}}],[\"nextreadpos\",{\"1\":{\"98\":1}}],[\"next\",{\"0\":{\"118\":1},\"1\":{\"26\":1,\"51\":1,\"78\":5,\"79\":6,\"89\":2,\"93\":2,\"114\":1,\"225\":1,\"240\":6,\"243\":9,\"244\":2,\"282\":14,\"284\":9,\"285\":1}}],[\"newest\",{\"1\":{\"263\":1}}],[\"newencoder\",{\"1\":{\"133\":1}}],[\"newvm\",{\"1\":{\"243\":1,\"244\":1}}],[\"newobject\",{\"1\":{\"243\":5}}],[\"newosproc\",{\"1\":{\"203\":2}}],[\"newdowhilestmt\",{\"1\":{\"227\":2}}],[\"newdecoder\",{\"1\":{\"133\":1}}],[\"newname\",{\"1\":{\"225\":2}}],[\"newchararrayfromstring\",{\"1\":{\"219\":1}}],[\"newcall\",{\"1\":{\"219\":2}}],[\"newcompiler\",{\"1\":{\"218\":1}}],[\"newcommitindex\",{\"1\":{\"129\":3,\"134\":5}}],[\"newint\",{\"1\":{\"219\":2}}],[\"newitem\",{\"1\":{\"26\":2,\"47\":2}}],[\"newarray\",{\"1\":{\"219\":1}}],[\"newadd\",{\"1\":{\"219\":1}}],[\"newassembler\",{\"1\":{\"218\":1}}],[\"newblock\",{\"1\":{\"219\":2,\"227\":3}}],[\"newbuilder\",{\"1\":{\"150\":1,\"157\":2}}],[\"newbuffer\",{\"1\":{\"133\":1,\"262\":1}}],[\"newforstmt\",{\"1\":{\"227\":1}}],[\"newfunc\",{\"1\":{\"219\":4}}],[\"newfileset\",{\"1\":{\"219\":2}}],[\"newmodule\",{\"1\":{\"219\":1}}],[\"newm\",{\"1\":{\"200\":1}}],[\"newgetelementptr\",{\"1\":{\"219\":1}}],[\"newglobaldef\",{\"1\":{\"219\":1}}],[\"newg\",{\"1\":{\"200\":30,\"202\":9}}],[\"newpool\",{\"1\":{\"264\":1}}],[\"newpointer\",{\"1\":{\"219\":2}}],[\"newparam\",{\"1\":{\"219\":3}}],[\"newpage\",{\"1\":{\"64\":3,\"71\":2}}],[\"newpageimpl\",{\"1\":{\"64\":2}}],[\"newproc1\",{\"1\":{\"200\":3,\"202\":1}}],[\"newproc\",{\"1\":{\"200\":7,\"251\":2}}],[\"newret\",{\"1\":{\"219\":2}}],[\"newring\",{\"1\":{\"188\":1}}],[\"newroutinegroup\",{\"1\":{\"187\":1}}],[\"newrootnode\",{\"1\":{\"72\":1}}],[\"new\",{\"1\":{\"4\":3,\"13\":4,\"14\":2,\"16\":1,\"18\":2,\"26\":7,\"32\":2,\"35\":2,\"47\":2,\"48\":1,\"50\":4,\"51\":2,\"71\":18,\"72\":2,\"93\":2,\"94\":1,\"133\":1,\"146\":2,\"150\":1,\"164\":5,\"170\":3,\"172\":9,\"173\":3,\"174\":4,\"200\":1,\"208\":1,\"225\":5,\"227\":2,\"234\":1,\"236\":1,\"239\":1,\"241\":1,\"243\":1,\"244\":1,\"261\":6,\"262\":4,\"263\":1,\"268\":2,\"286\":1}}],[\"n\",{\"1\":{\"5\":1,\"10\":3,\"180\":1,\"181\":8,\"184\":2,\"188\":6,\"197\":4,\"199\":5,\"200\":3,\"207\":2,\"212\":2,\"213\":8,\"218\":5,\"219\":1,\"227\":60,\"234\":1,\"238\":3,\"241\":1,\"243\":3,\"257\":3,\"263\":2,\"268\":3,\"286\":2,\"291\":9,\"294\":1}}],[\"norandmaps\",{\"1\":{\"291\":1}}],[\"noapic\",{\"1\":{\"291\":1}}],[\"nographic\",{\"1\":{\"291\":3,\"294\":1}}],[\"nokaslr\",{\"1\":{\"291\":2,\"294\":1}}],[\"nocopy\",{\"1\":{\"261\":1}}],[\"noptr\",{\"1\":{\"257\":2}}],[\"nostdlib\",{\"1\":{\"212\":1}}],[\"nosplit\",{\"1\":{\"200\":9,\"212\":1,\"213\":1,\"217\":3,\"256\":2,\"257\":2}}],[\"noinspection\",{\"1\":{\"207\":1,\"208\":1,\"212\":1,\"213\":1}}],[\"noescape\",{\"1\":{\"207\":1,\"212\":1,\"213\":1,\"217\":1}}],[\"now\",{\"1\":{\"129\":1,\"131\":1,\"136\":1,\"137\":1,\"198\":1,\"200\":1}}],[\"non\",{\"1\":{\"84\":1,\"227\":2}}],[\"nonematch\",{\"1\":{\"185\":2}}],[\"none\",{\"1\":{\"4\":15,\"5\":3,\"218\":27,\"291\":2}}],[\"noder\",{\"1\":{\"227\":3}}],[\"nodes\",{\"1\":{\"227\":3}}],[\"node\",{\"1\":{\"69\":2,\"70\":2,\"71\":33,\"72\":42,\"73\":4,\"227\":30,\"282\":9}}],[\"no\",{\"1\":{\"26\":1,\"72\":1,\"92\":1,\"200\":2,\"227\":1,\"262\":1,\"293\":1}}],[\"notify\",{\"1\":{\"88\":1}}],[\"notequal\",{\"1\":{\"241\":1}}],[\"note\",{\"1\":{\"51\":1}}],[\"not\",{\"1\":{\"4\":5,\"13\":1,\"26\":6,\"37\":1,\"47\":2,\"48\":1,\"64\":3,\"70\":1,\"88\":1,\"134\":1,\"157\":1,\"174\":1,\"200\":2,\"218\":1,\"219\":1,\"225\":1,\"284\":1}}],[\">>\",{\"1\":{\"293\":1}}],[\">>>\",{\"1\":{\"218\":3}}],[\">data\",{\"1\":{\"282\":1}}],[\">deallocatepage\",{\"1\":{\"64\":1}}],[\">m\",{\"1\":{\"200\":1}}],[\">g0\",{\"1\":{\"200\":1}}],[\">getlockmanager\",{\"1\":{\"89\":3}}],[\">getexclusivelockset\",{\"1\":{\"88\":2}}],[\">getsharedlockset\",{\"1\":{\"88\":3}}],[\">getstate\",{\"1\":{\"88\":3}}],[\">getsize\",{\"1\":{\"72\":1}}],[\">getisolationlevel\",{\"1\":{\"88\":2,\"89\":1}}],[\">getcolumns\",{\"1\":{\"79\":2,\"89\":2}}],[\">getcatalog\",{\"1\":{\"79\":1}}],[\">getpredicate\",{\"1\":{\"79\":2,\"89\":2}}],[\">getparentpage\",{\"1\":{\"71\":1}}],[\">gettransactionid\",{\"1\":{\"88\":1}}],[\">gettransaction\",{\"1\":{\"79\":1,\"89\":8}}],[\">gettableoid\",{\"1\":{\"79\":1}}],[\">gettable\",{\"1\":{\"79\":1}}],[\">getdata\",{\"1\":{\"69\":2,\"70\":1}}],[\">unlock\",{\"1\":{\"89\":1}}],[\">lockshared\",{\"1\":{\"89\":2}}],[\">status\",{\"1\":{\"200\":1}}],[\">setstate\",{\"1\":{\"88\":1}}],[\">schema\",{\"1\":{\"79\":2,\"89\":2}}],[\">outputschema\",{\"1\":{\"79\":3,\"89\":3}}],[\">emplace\",{\"1\":{\"88\":1}}],[\">evaluate\",{\"1\":{\"79\":2,\"89\":2}}],[\">end\",{\"1\":{\"79\":1,\"88\":2,\"89\":1}}],[\">begin\",{\"1\":{\"79\":1,\"88\":2,\"282\":1}}],[\">table\",{\"1\":{\"79\":2,\"89\":1}}],[\">push\",{\"1\":{\"78\":1}}],[\">pin\",{\"1\":{\"64\":1}}],[\">next\",{\"1\":{\"78\":1}}],[\">isexclusivelocked\",{\"1\":{\"88\":1,\"89\":2}}],[\">issharedlocked\",{\"1\":{\"88\":1,\"89\":2}}],[\">isleafpage\",{\"1\":{\"72\":1}}],[\">init\",{\"1\":{\"78\":1}}],[\">wlatch\",{\"1\":{\"73\":1}}],[\">runlatch\",{\"1\":{\"73\":1}}],[\">removeanddeleterecord\",{\"1\":{\"72\":1}}],[\">reset\",{\"1\":{\"64\":1}}],[\">\",{\"1\":{\"4\":1,\"16\":2,\"17\":2,\"18\":2,\"26\":2,\"34\":1,\"50\":1,\"64\":5,\"69\":2,\"72\":2,\"73\":2,\"79\":3,\"124\":2,\"129\":4,\"130\":1,\"131\":1,\"133\":4,\"134\":2,\"136\":4,\"150\":1,\"164\":8,\"170\":11,\"174\":2,\"177\":8,\"190\":3,\"200\":5,\"225\":1,\"227\":4,\"240\":1,\"244\":1,\"262\":1,\"281\":3,\"282\":1,\"283\":2,\"284\":3,\"285\":3,\"291\":6,\"293\":36,\"294\":2}}],[\">=\",{\"1\":{\"4\":4,\"13\":1,\"26\":1,\"63\":1,\"71\":3,\"72\":1,\"124\":1,\"129\":3,\"130\":1,\"131\":1,\"134\":2,\"213\":3,\"262\":1,\"282\":3,\"283\":1,\"284\":1,\"285\":1}}],[\"操作系统还提供另外的一种系统调用\",{\"1\":{\"237\":1}}],[\"操作系统为例\",{\"1\":{\"237\":1}}],[\"操作系统会为其分配一片巨大的虚拟内存\",{\"1\":{\"232\":1}}],[\"操作系统对内存的抽象和管理是很复杂的\",{\"1\":{\"231\":1}}],[\"操作系统实现系统调用的基本过程是\",{\"1\":{\"197\":1}}],[\"操作系统\",{\"0\":{\"193\":1},\"1\":{\"165\":1,\"200\":1}}],[\"操作成功后\",{\"1\":{\"73\":1}}],[\"操作完成后\",{\"1\":{\"64\":1}}],[\"操作o1​如果在操作o2​的左边\",{\"1\":{\"43\":1}}],[\"操作是否被删除\",{\"1\":{\"43\":1}}],[\"操作创建时\",{\"1\":{\"43\":1}}],[\"操作的唯一标识\",{\"1\":{\"43\":1}}],[\"操作意图origin与操作o这样就能得到如下的性质\",{\"1\":{\"43\":1}}],[\"操作意图\",{\"1\":{\"28\":1,\"43\":1}}],[\"操作同步数据就变成了\",{\"1\":{\"25\":1}}],[\"操作同步的数据\",{\"1\":{\"25\":1}}],[\"操作值\",{\"1\":{\"13\":1}}],[\"操作类型\",{\"1\":{\"13\":1}}],[\"操作数组\",{\"1\":{\"13\":1}}],[\"操作和提高查询效率\",{\"1\":{\"4\":1}}],[\"操作\",{\"1\":{\"4\":1,\"13\":1,\"28\":1,\"72\":1,\"88\":1,\"106\":1,\"157\":1,\"197\":1}}],[\"操作加入其中\",{\"1\":{\"4\":1}}],[\"要从发现问题和定位问题的角度\",{\"1\":{\"164\":1}}],[\"要么都不执行\",{\"1\":{\"83\":1}}],[\"要么全部失败\",{\"1\":{\"83\":1}}],[\"要么全部成功\",{\"1\":{\"83\":1}}],[\"要在上面的\",{\"1\":{\"4\":1}}],[\"要在\",{\"1\":{\"4\":1}}],[\"要求给出详细的设计思路和伪代码\",{\"1\":{\"4\":1}}],[\"这表示远端已经发送了\",{\"1\":{\"285\":1}}],[\"这才是\",{\"1\":{\"283\":1}}],[\"这才是从头实现一个\",{\"1\":{\"139\":1}}],[\"这几乎是不可能达成的目标\",{\"1\":{\"283\":1}}],[\"这几乎不可能\",{\"1\":{\"165\":1}}],[\"这代表\",{\"1\":{\"283\":1}}],[\"这主要取决于滑动窗口大下\",{\"1\":{\"274\":1}}],[\"这门课\",{\"1\":{\"270\":1}}],[\"这对于数据库长连接等场景是不合适的\",{\"1\":{\"261\":1}}],[\"这篇文章写的实在是不容易\",{\"1\":{\"246\":1}}],[\"这篇论文详细的阐述了\",{\"1\":{\"8\":1}}],[\"这一步是可以多批次进行的\",{\"1\":{\"244\":1}}],[\"这一步就够了\",{\"1\":{\"227\":1}}],[\"这一层\",{\"1\":{\"238\":2}}],[\"这不难想到\",{\"1\":{\"238\":1}}],[\"这不就是汇编吗\",{\"1\":{\"218\":1}}],[\"这块内存大小由参数控制\",{\"1\":{\"237\":1}}],[\"这说明\",{\"1\":{\"237\":1}}],[\"这三篇文章分别是\",{\"1\":{\"236\":1}}],[\"这三部分又包含了数据库很多模块\",{\"1\":{\"58\":1}}],[\"这其中就有最臭名昭举的\",{\"1\":{\"235\":1}}],[\"这类语法\",{\"1\":{\"227\":1}}],[\"这类线性数据结构而言\",{\"1\":{\"50\":1}}],[\"这使得\",{\"1\":{\"223\":1}}],[\"这明显重复了\",{\"1\":{\"218\":1}}],[\"这还不够\",{\"1\":{\"210\":1}}],[\"这很正常\",{\"1\":{\"200\":1}}],[\"这次就用\",{\"1\":{\"167\":1}}],[\"这次删除操作才能释放所有节点上的锁\",{\"1\":{\"73\":1}}],[\"这或许没问题\",{\"1\":{\"164\":1}}],[\"这与\",{\"1\":{\"164\":1}}],[\"这与其它\",{\"1\":{\"136\":1}}],[\"这被称为\",{\"1\":{\"130\":1}}],[\"这部分将在后面一一完成\",{\"1\":{\"124\":1}}],[\"这段代码展示了\",{\"1\":{\"281\":1}}],[\"这段代码中\",{\"1\":{\"200\":1}}],[\"这段内存\",{\"1\":{\"238\":1}}],[\"这段内存是存活的\",{\"1\":{\"238\":1}}],[\"这段时间就是节点的心跳超时时间\",{\"1\":{\"124\":1}}],[\"这段冲突解决代码几乎与\",{\"1\":{\"51\":1}}],[\"这\",{\"1\":{\"121\":1,\"217\":1}}],[\"这两个函数都与连接关闭有直接关系\",{\"1\":{\"285\":1}}],[\"这两个工具\",{\"1\":{\"277\":1}}],[\"这两个字\",{\"1\":{\"261\":1}}],[\"这两个字段\",{\"1\":{\"114\":1}}],[\"这两个阶段必须先后进行\",{\"1\":{\"244\":1}}],[\"这两个关键字\",{\"1\":{\"227\":1}}],[\"这两个操作明显可以直接优化成一个操作\",{\"1\":{\"218\":1}}],[\"这两种算法分别是知名\",{\"1\":{\"22\":1}}],[\"这取决于具体情况\",{\"1\":{\"87\":1}}],[\"这条规则被称为半满\",{\"1\":{\"68\":1}}],[\"这棵\",{\"1\":{\"68\":1}}],[\"这也导致了\",{\"1\":{\"270\":1}}],[\"这也映证了刚才谈到的\",{\"1\":{\"238\":1}}],[\"这也直接导致了\",{\"1\":{\"228\":1}}],[\"这也直接导致二者在设计上十分不同\",{\"1\":{\"10\":1}}],[\"这也是一种协程资源的浪费\",{\"1\":{\"264\":1}}],[\"这也是为什么go\",{\"1\":{\"238\":1}}],[\"这也是其\",{\"1\":{\"217\":1}}],[\"这也是\",{\"1\":{\"128\":1,\"214\":1,\"219\":1}}],[\"这也有今天的主角\",{\"1\":{\"56\":1}}],[\"这就需要三方库的支持了\",{\"1\":{\"263\":1}}],[\"这就待我们后续去实践和完善了\",{\"1\":{\"190\":1}}],[\"这就导致了双方最终内容不一致\",{\"1\":{\"48\":1}}],[\"这就是持久化模块的功能了\",{\"1\":{\"132\":1}}],[\"这就是日志同步这个模块要解决的问题\",{\"1\":{\"125\":1}}],[\"这就是\",{\"1\":{\"9\":1}}],[\"这里额外说明几点\",{\"1\":{\"284\":1}}],[\"这里额外说明一下\",{\"1\":{\"283\":1,\"285\":1}}],[\"这里摘出\",{\"1\":{\"281\":1}}],[\"这里摘取了其中的主干部分\",{\"1\":{\"200\":1}}],[\"这里先给出\",{\"1\":{\"280\":1}}],[\"这里是\",{\"1\":{\"257\":1}}],[\"这里定义了一个全局变量\",{\"1\":{\"255\":1}}],[\"这里通过\",{\"1\":{\"251\":1}}],[\"这里选择将触发时机放在\",{\"1\":{\"243\":1}}],[\"这里选择最简单的数量阈值触发\",{\"1\":{\"243\":1}}],[\"这里仍需简单说一下\",{\"1\":{\"243\":1}}],[\"这里麻烦的是\",{\"1\":{\"241\":1}}],[\"这里说明\",{\"1\":{\"241\":1}}],[\"这里又引入了两个新的概念\",{\"1\":{\"241\":1}}],[\"这里笔者会简单介绍它的核心概念以及实现\",{\"1\":{\"241\":1}}],[\"这里笔者仅简单的翻译上面的例子\",{\"1\":{\"219\":1}}],[\"这里之所以调用\",{\"1\":{\"238\":1}}],[\"这里运用了一个小技巧\",{\"1\":{\"225\":1}}],[\"这里使用\",{\"1\":{\"218\":1}}],[\"这里直接将\",{\"1\":{\"218\":1}}],[\"这里不做过多介绍\",{\"1\":{\"255\":1}}],[\"这里不会涉及到太复杂的优化算法\",{\"1\":{\"218\":1}}],[\"这里不再赘述\",{\"1\":{\"158\":1}}],[\"这里将栈顶的值推出后\",{\"1\":{\"218\":1}}],[\"这里将一段内存看作一个栈来操作\",{\"1\":{\"218\":1}}],[\"这里会将\",{\"1\":{\"218\":1}}],[\"这里会先介绍一些前置知识\",{\"1\":{\"192\":1}}],[\"这里会先介绍一下\",{\"1\":{\"178\":1}}],[\"这里引入了\",{\"1\":{\"208\":1}}],[\"这里只做了简单说明\",{\"1\":{\"218\":1}}],[\"这里只贴出了主干部分\",{\"1\":{\"200\":1}}],[\"这里只摘出了有用的部分\",{\"1\":{\"194\":1}}],[\"这里只给出部分\",{\"1\":{\"186\":1}}],[\"这里只给出部分的定义\",{\"1\":{\"184\":1}}],[\"这里和\",{\"1\":{\"155\":1}}],[\"这里原理很简单\",{\"1\":{\"129\":1}}],[\"这里抛出\",{\"1\":{\"123\":1}}],[\"这里也不做介绍\",{\"1\":{\"77\":1}}],[\"这里的内容很多\",{\"1\":{\"208\":1}}],[\"这里的len不能为0\",{\"1\":{\"207\":1}}],[\"这里的\",{\"1\":{\"199\":1,\"283\":1}}],[\"这里的栈实则就是进程在用户态的调用栈\",{\"1\":{\"194\":1}}],[\"这里的key类型是r\",{\"1\":{\"188\":1}}],[\"这里的查询操作\",{\"1\":{\"77\":1}}],[\"这里的opid其实也是\",{\"1\":{\"28\":1}}],[\"这里就不展开讲了\",{\"1\":{\"287\":1}}],[\"这里就不展示相关的伪代码了\",{\"1\":{\"73\":1}}],[\"这里就不做过多介绍了\",{\"1\":{\"188\":1}}],[\"这里就不赘述了\",{\"1\":{\"149\":1}}],[\"这里就不赘述\",{\"1\":{\"107\":1}}],[\"这里就不再赘述了\",{\"1\":{\"64\":1}}],[\"这里利用了\",{\"1\":{\"69\":1}}],[\"这里我们引入了元祖\",{\"1\":{\"243\":1}}],[\"这里我们需要先引入几个概念\",{\"1\":{\"243\":1}}],[\"这里我们指定\",{\"1\":{\"217\":1}}],[\"这里我们借助\",{\"1\":{\"188\":1}}],[\"这里我们提出了一种名为\",{\"1\":{\"146\":1}}],[\"这里我们选择比较简单的\",{\"1\":{\"133\":1}}],[\"这里我们先简单的来介绍一下\",{\"1\":{\"67\":1}}],[\"这里我们来详细介绍\",{\"1\":{\"63\":1}}],[\"这里贴出笔者实现的伪代码\",{\"1\":{\"64\":1}}],[\"这里需要额外说明一点\",{\"1\":{\"283\":1}}],[\"这里需要额外说明的是\",{\"1\":{\"64\":1}}],[\"这里需要说明几个点\",{\"1\":{\"200\":1}}],[\"这里需要注意的是\",{\"1\":{\"26\":1}}],[\"这里简单解释一下\",{\"1\":{\"51\":1}}],[\"这里与\",{\"1\":{\"35\":1}}],[\"这里\",{\"1\":{\"25\":1,\"43\":1,\"63\":1,\"64\":1,\"124\":1,\"129\":1,\"213\":1,\"217\":1,\"218\":2,\"238\":1,\"243\":1,\"244\":1}}],[\"这里可以通过ack来确认\",{\"1\":{\"13\":1}}],[\"这样使用的时候就不必重新创建\",{\"1\":{\"260\":1}}],[\"这样灰色对象由栈来管理\",{\"1\":{\"244\":1}}],[\"这样扫描完毕后\",{\"1\":{\"243\":1}}],[\"这样对象不仅可以通过链表被找到\",{\"1\":{\"243\":1}}],[\"这样每个新建的对象都有类型\",{\"1\":{\"243\":1}}],[\"这样减少了数据竞争\",{\"1\":{\"241\":1}}],[\"这样会显得头重脚轻\",{\"1\":{\"240\":1}}],[\"这样边回收边开辟会非常复杂\",{\"1\":{\"238\":1}}],[\"这样内存资源就被浪费了\",{\"1\":{\"238\":1}}],[\"这样内存不仅能够得到完善的管理\",{\"1\":{\"234\":1}}],[\"这样无效的复制指令\",{\"1\":{\"218\":1}}],[\"这样链接生成的文件就不会再走原来的执行流\",{\"1\":{\"217\":1}}],[\"这样也能达到一样的效果\",{\"1\":{\"207\":1}}],[\"这样既能促进系统运行的可靠性\",{\"1\":{\"206\":1}}],[\"这样既能保证操作\",{\"1\":{\"13\":1}}],[\"这样在\",{\"1\":{\"200\":1,\"202\":1}}],[\"这样的指令形式被称为\",{\"1\":{\"218\":1}}],[\"这样的操作在\",{\"1\":{\"207\":1}}],[\"这样的规定对设计\",{\"1\":{\"206\":1}}],[\"这样的一句话需求肯定是让人难受的\",{\"1\":{\"170\":1}}],[\"这样的数据结构导致文本内容是一个树\",{\"1\":{\"26\":1}}],[\"这样编程会带来几个很麻烦的问题\",{\"1\":{\"168\":1}}],[\"这样测试的上下文就会复杂很多\",{\"1\":{\"165\":1}}],[\"这样访问\",{\"1\":{\"105\":1}}],[\"这样\",{\"1\":{\"69\":1,\"164\":1,\"179\":1,\"207\":1,\"208\":1,\"217\":1,\"227\":1,\"238\":2,\"241\":1,\"243\":1}}],[\"这样doc就能支持多数据类型\",{\"1\":{\"50\":1}}],[\"这样客户端\",{\"1\":{\"48\":1}}],[\"这样可以保证文档在任何客户端都能最终收敛到一致\",{\"1\":{\"43\":1}}],[\"这样就不会因为容器过度使用\",{\"1\":{\"294\":1}}],[\"这样就不用在\",{\"1\":{\"241\":1}}],[\"这样就有一个装有\",{\"1\":{\"291\":1}}],[\"这样就达到了对象重复利用的效果\",{\"1\":{\"262\":1}}],[\"这样就省去了重复多次的\",{\"1\":{\"225\":1}}],[\"这样就通过已有的\",{\"1\":{\"224\":1}}],[\"这样就展示了一个程序编译\",{\"1\":{\"217\":1}}],[\"这样就减少了依赖的复杂度\",{\"1\":{\"164\":1}}],[\"这样就避免了选举时会发生脑裂\",{\"1\":{\"122\":1}}],[\"这样就保证了插入的顺序\",{\"1\":{\"48\":1}}],[\"这样就解决了这个问题\",{\"1\":{\"48\":1}}],[\"这样就能显著地降低标记\",{\"1\":{\"244\":1}}],[\"这样就能拿到对应的页\",{\"1\":{\"241\":1}}],[\"这样就能轻松获取\",{\"1\":{\"198\":1}}],[\"这样就能最大程度的利用缓存\",{\"1\":{\"64\":1}}],[\"这样就能得出插入算法\",{\"1\":{\"44\":1}}],[\"这样就能保证消息链路全可控\",{\"1\":{\"157\":1}}],[\"这样就能保证集群数据的一致性\",{\"1\":{\"128\":1}}],[\"这样就能保证一个叶子节点数据刚好能够存储在一个页中\",{\"1\":{\"69\":1}}],[\"这样就能保证每个字符都有唯一的\",{\"1\":{\"25\":1}}],[\"这样就能保留插入意图\",{\"1\":{\"25\":1}}],[\"这样就可以将operation从链表中软移除了\",{\"1\":{\"28\":1,\"32\":1}}],[\"这样能够保证最终文本内容一致了吗\",{\"1\":{\"25\":1}}],[\"这样才能保证最后写入的值胜出\",{\"1\":{\"16\":1}}],[\"这种简单的内存管理方式被称为\",{\"1\":{\"240\":1}}],[\"这种懒加载的机制被称为缺页中断\",{\"1\":{\"237\":1}}],[\"这种机制彻底解放了开发者们\",{\"1\":{\"235\":1}}],[\"这种技巧解决了\",{\"1\":{\"223\":1}}],[\"这种汇编\",{\"1\":{\"212\":1}}],[\"这种方式几乎就是\",{\"1\":{\"239\":1}}],[\"这种方式也被\",{\"1\":{\"238\":1}}],[\"这种方式也被称作\",{\"1\":{\"164\":1}}],[\"这种方式虽然不会初始化\",{\"1\":{\"217\":1}}],[\"这种方式不仅回避了\",{\"1\":{\"212\":1}}],[\"这种变量仅当前线程可见\",{\"1\":{\"200\":1}}],[\"这种情况\",{\"1\":{\"150\":1}}],[\"这种特殊的场景被称为\",{\"1\":{\"126\":1}}],[\"这种特性天然适合多人协作场景\",{\"1\":{\"9\":1}}],[\"这种设计思想其实是lamport\",{\"1\":{\"13\":1}}],[\"这些细节后面会在实现中详细介绍\",{\"1\":{\"272\":1}}],[\"这些连接在创建的时候是一个非常耗时的操作\",{\"1\":{\"260\":1}}],[\"这些内容比较多\",{\"1\":{\"241\":1}}],[\"这些内存问题也一直困扰着\",{\"1\":{\"232\":1}}],[\"这些编译器前端知识感兴趣的同学可以自行去查阅词法分析\",{\"1\":{\"218\":1}}],[\"这些组件极大地方便了应用程序的开发和迭代\",{\"1\":{\"217\":1}}],[\"这些调试指令\",{\"1\":{\"200\":1}}],[\"这些\",{\"1\":{\"199\":1}}],[\"这些字段\",{\"1\":{\"124\":1}}],[\"这些东西先不管\",{\"1\":{\"124\":1}}],[\"这些节点可能分布在不同集群\",{\"1\":{\"105\":1}}],[\"这些节点都有可能是冲突节点\",{\"1\":{\"51\":1}}],[\"这些本文不做讨论\",{\"1\":{\"73\":1}}],[\"这些元数据被抽象为了\",{\"1\":{\"69\":1}}],[\"这些模块将按照如下顺序依次介绍\",{\"1\":{\"59\":1}}],[\"这些模块负责哪些功能\",{\"1\":{\"58\":1}}],[\"这些将在后面详细介绍\",{\"1\":{\"58\":1}}],[\"这些基础\",{\"1\":{\"11\":1}}],[\"这些都是\",{\"1\":{\"10\":1}}],[\"这是三次握手的第一步\",{\"1\":{\"286\":1}}],[\"这是因为\",{\"1\":{\"231\":1}}],[\"这是否会导致大量时间都用在了产出不大的重构上\",{\"1\":{\"165\":1}}],[\"这是墨守成规的\",{\"1\":{\"164\":1}}],[\"这是\",{\"1\":{\"10\":1,\"251\":1}}],[\"这意味着我们不仅可以直接使用前端部分\",{\"1\":{\"219\":1}}],[\"这意味着\",{\"1\":{\"10\":1}}],[\"这意味着一个\",{\"1\":{\"8\":1}}],[\"这个变量需要额外说明一下\",{\"1\":{\"285\":1}}],[\"这个包可能为空包\",{\"1\":{\"285\":1}}],[\"这个例子中\",{\"1\":{\"254\":1}}],[\"这个局布到这里\",{\"1\":{\"245\":1}}],[\"这个起点就被称作\",{\"1\":{\"243\":1}}],[\"这个地址指针\",{\"1\":{\"237\":1}}],[\"这个地方的\",{\"1\":{\"283\":1}}],[\"这个地方的翻译是比较枯燥的\",{\"1\":{\"218\":1}}],[\"这个地方的序号已经被大部分节点同步到了\",{\"1\":{\"129\":1}}],[\"这个地方比较粗暴\",{\"1\":{\"129\":1,\"134\":1}}],[\"这个地方\",{\"1\":{\"124\":1}}],[\"这个堆非常大\",{\"1\":{\"237\":1}}],[\"这个提案希望\",{\"1\":{\"236\":1}}],[\"这个算法思路虽然简单\",{\"1\":{\"235\":1}}],[\"这个算法管理内存的思路很简单\",{\"1\":{\"235\":1}}],[\"这个过程也称\",{\"1\":{\"227\":1}}],[\"这个过程被称为\",{\"1\":{\"88\":1}}],[\"这个方式其实很容易想到\",{\"1\":{\"212\":1}}],[\"这个方法\",{\"1\":{\"164\":1}}],[\"这个是因为\",{\"1\":{\"208\":1}}],[\"这个\",{\"1\":{\"200\":1,\"241\":1}}],[\"这个线程栈在用户空间分配\",{\"1\":{\"200\":1}}],[\"这个系统调用\",{\"1\":{\"198\":1}}],[\"这个最基本例子来看看\",{\"1\":{\"192\":1}}],[\"这个目标一直都在\",{\"1\":{\"152\":1}}],[\"这个结构体和其方法\",{\"1\":{\"136\":1}}],[\"这个操作也很简单\",{\"1\":{\"136\":1}}],[\"这个通道即可\",{\"1\":{\"131\":1}}],[\"这个重要的字段\",{\"1\":{\"131\":1}}],[\"这个很好理解\",{\"1\":{\"129\":1}}],[\"这个字段的类型是函数\",{\"1\":{\"261\":1}}],[\"这个字段\",{\"1\":{\"128\":1,\"131\":1}}],[\"这个函数会进行简单的四则运算\",{\"1\":{\"218\":1}}],[\"这个函数是否被调用\",{\"1\":{\"164\":1}}],[\"这个函数上来\",{\"1\":{\"124\":1}}],[\"这个函数中\",{\"1\":{\"124\":2}}],[\"这个概念\",{\"1\":{\"84\":1,\"241\":1}}],[\"这个精巧的关系数据库来告诉你\",{\"1\":{\"56\":1}}],[\"这个数量还能成倍增加\",{\"1\":{\"8\":1}}],[\"这个时候领导者可以选择将快照发给追随者\",{\"1\":{\"136\":1}}],[\"这个时候\",{\"1\":{\"4\":1}}],[\"这只是一个简单的示例\",{\"1\":{\"4\":1}}],[\"值拷贝到\",{\"1\":{\"200\":2}}],[\"值有多条日志\",{\"1\":{\"136\":1}}],[\"值推到与\",{\"1\":{\"131\":1}}],[\"值就会被更改\",{\"1\":{\"127\":1}}],[\"值为\",{\"1\":{\"127\":1,\"255\":1}}],[\"值都嵌入到了单值键值对的键当中\",{\"1\":{\"117\":1}}],[\"值排序的\",{\"1\":{\"117\":1}}],[\"值\",{\"1\":{\"72\":2,\"115\":1,\"136\":3,\"200\":2,\"261\":1}}],[\"值则是插入到\",{\"1\":{\"68\":1}}],[\"值是对应的\",{\"1\":{\"4\":1}}],[\"值得注意的是\",{\"1\":{\"4\":1}}],[\"值对\",{\"1\":{\"4\":1}}],[\"对报文数据进行重组\",{\"1\":{\"279\":1}}],[\"对超时未确认的报文进行重发\",{\"1\":{\"279\":1}}],[\"对这种机械式的内存管理方式\",{\"1\":{\"242\":1}}],[\"对内存块进行了分类\",{\"1\":{\"241\":1}}],[\"对内存以页为基本单位\",{\"1\":{\"241\":1}}],[\"对生成的语法树做语法检查\",{\"1\":{\"226\":1}}],[\"对所有类型的一个抽象数据结构\",{\"1\":{\"208\":1}}],[\"对系统线程的一个包装\",{\"1\":{\"199\":1}}],[\"对数据进行裁剪\",{\"1\":{\"282\":1}}],[\"对数据进行处理与检查\",{\"1\":{\"190\":1}}],[\"对数据流中的每一项都执行操作\",{\"1\":{\"185\":1}}],[\"对数据结果不关心的情况下\",{\"1\":{\"164\":1}}],[\"对整个数据流执行操作\",{\"1\":{\"185\":1}}],[\"对某个模块用\",{\"1\":{\"164\":1}}],[\"对外提供了三个方法\",{\"1\":{\"261\":1}}],[\"对外暴露的\",{\"1\":{\"157\":1}}],[\"对外暴露主题操作\",{\"1\":{\"156\":1}}],[\"对外只暴露一个\",{\"1\":{\"78\":1}}],[\"对范围为\",{\"1\":{\"136\":1}}],[\"对队列加锁\",{\"1\":{\"88\":1}}],[\"对语句解析\",{\"1\":{\"77\":1}}],[\"对子节点加独占锁后\",{\"1\":{\"73\":1}}],[\"对其初始化\",{\"1\":{\"71\":1}}],[\"对的最大数量\",{\"1\":{\"69\":1}}],[\"对的数量\",{\"1\":{\"69\":1}}],[\"对\",{\"1\":{\"69\":1,\"73\":2,\"210\":1,\"278\":1}}],[\"对项目整体有一个基本认识\",{\"1\":{\"59\":1}}],[\"对推理过程感兴趣的可以直接看论文\",{\"1\":{\"43\":1}}],[\"对应序号\",{\"1\":{\"218\":1}}],[\"对应链接的函数的路径\",{\"1\":{\"207\":1}}],[\"对应系统调用\",{\"1\":{\"197\":1}}],[\"对应论文中的\",{\"1\":{\"126\":1}}],[\"对应图中节点里面的数字\",{\"1\":{\"68\":1}}],[\"对应图中的箭头\",{\"1\":{\"68\":1}}],[\"对应图中的for\",{\"1\":{\"44\":1}}],[\"对应操作系统\",{\"1\":{\"62\":1}}],[\"对应的代码如下\",{\"1\":{\"218\":1}}],[\"对应的优化代码如下\",{\"1\":{\"218\":1}}],[\"对应的\",{\"1\":{\"200\":1,\"241\":1,\"283\":1}}],[\"对应的着不同的指令实现\",{\"1\":{\"180\":1}}],[\"对应的汇编代码如下\",{\"1\":{\"180\":1}}],[\"对应的队列\",{\"1\":{\"88\":1}}],[\"对应的锁队列\",{\"1\":{\"88\":1}}],[\"对应的值\",{\"1\":{\"70\":1}}],[\"对应的页数据到\",{\"1\":{\"64\":1}}],[\"对应的最左边节点\",{\"1\":{\"51\":1}}],[\"对应的operation\",{\"1\":{\"28\":1}}],[\"对应上面的origin\",{\"1\":{\"48\":1}}],[\"对应\",{\"1\":{\"47\":1,\"64\":1,\"227\":1,\"250\":1,\"256\":1,\"257\":1}}],[\"对应到\",{\"1\":{\"44\":1}}],[\"对应算法中的breaking\",{\"1\":{\"44\":1}}],[\"对应一个map或者list\",{\"1\":{\"28\":1}}],[\"对于发送但位确认的报文\",{\"1\":{\"284\":1}}],[\"对于可靠性的细节\",{\"1\":{\"273\":1}}],[\"对于超时未能确认的豹纹\",{\"1\":{\"273\":1}}],[\"对于连接池而言\",{\"1\":{\"263\":1}}],[\"对于已经定义的函数\",{\"1\":{\"256\":1}}],[\"对于大对象\",{\"1\":{\"241\":1}}],[\"对于大内存\",{\"1\":{\"241\":2}}],[\"对于内存释放\",{\"1\":{\"241\":1}}],[\"对于内存开辟\",{\"1\":{\"241\":1}}],[\"对于小内存\",{\"1\":{\"241\":1}}],[\"对于少量的变量\",{\"1\":{\"234\":1}}],[\"对于计算而言\",{\"1\":{\"231\":1}}],[\"对于循环执行也只提供了\",{\"1\":{\"227\":1}}],[\"对于下面的\",{\"1\":{\"225\":1}}],[\"对于应用程序而言\",{\"1\":{\"217\":1}}],[\"对于切片扩容\",{\"1\":{\"208\":1}}],[\"对于切片之间的数据拷贝\",{\"1\":{\"207\":1}}],[\"对于稍微复杂一点的\",{\"1\":{\"187\":1}}],[\"对于这些重复的逻辑\",{\"1\":{\"179\":1}}],[\"对于这类并发冲突\",{\"1\":{\"43\":1}}],[\"对于一个程序而言\",{\"1\":{\"232\":1}}],[\"对于一个加法函数\",{\"1\":{\"179\":1}}],[\"对于一些特殊的函数\",{\"1\":{\"206\":1}}],[\"对于一些功能的实现\",{\"1\":{\"121\":1}}],[\"对于代码测试和工程质量的重视程度不够\",{\"1\":{\"165\":1}}],[\"对于状态验证\",{\"1\":{\"164\":1}}],[\"对于第\",{\"1\":{\"136\":1}}],[\"对于日志持久化也会带来很大的性能影响\",{\"1\":{\"135\":1}}],[\"对于领导者而言\",{\"1\":{\"125\":1}}],[\"对于集合类型来说\",{\"1\":{\"113\":1}}],[\"对于三个事务隔离级别的处理方式如下\",{\"1\":{\"89\":1}}],[\"对于重组\",{\"1\":{\"73\":1}}],[\"对于条件\",{\"1\":{\"68\":1}}],[\"对于关系数据库\",{\"1\":{\"56\":1}}],[\"对于\",{\"1\":{\"50\":2,\"51\":1,\"73\":1,\"113\":1,\"116\":1,\"133\":2,\"134\":1,\"164\":1,\"181\":1,\"188\":1,\"206\":1,\"212\":1,\"219\":1,\"237\":1,\"240\":2,\"241\":1,\"243\":2,\"262\":1}}],[\"对于text\",{\"1\":{\"37\":1}}],[\"对于map和list的操作一般需要两步\",{\"1\":{\"28\":1}}],[\"对于map来说\",{\"1\":{\"28\":1}}],[\"对于list来说\",{\"1\":{\"28\":1}}],[\"对于传输而来的远端状态\",{\"1\":{\"14\":1}}],[\"对核心原理不做过多阐述\",{\"1\":{\"10\":1}}],[\"对键值对列表按照键排序\",{\"1\":{\"4\":1}}],[\"对象个数为\",{\"1\":{\"244\":1}}],[\"对象为黑色\",{\"1\":{\"244\":1}}],[\"对象未被扫描\",{\"1\":{\"244\":1}}],[\"对象已经扫描\",{\"1\":{\"244\":2}}],[\"对象就剩\",{\"1\":{\"243\":1}}],[\"对象则还需标记它的两个头\",{\"1\":{\"243\":1}}],[\"对象则相对麻烦一点\",{\"1\":{\"243\":1}}],[\"对象入栈\",{\"1\":{\"243\":1}}],[\"对象会引用另外两个对象\",{\"1\":{\"243\":1}}],[\"对象链表\",{\"1\":{\"243\":1}}],[\"对象图之间的连接不是\",{\"1\":{\"243\":1}}],[\"对象类型\",{\"1\":{\"243\":2}}],[\"对象分配有两种情况\",{\"1\":{\"241\":1}}],[\"对象的删除列表中\",{\"1\":{\"4\":1}}],[\"对象中的头\",{\"1\":{\"243\":1}}],[\"对象中\",{\"1\":{\"4\":1}}],[\"对象\",{\"1\":{\"4\":6,\"243\":7}}],[\"对软件社区最大的负面影响就是\",{\"1\":{\"0\":1}}],[\"<>\",{\"1\":{\"255\":1,\"257\":2}}],[\"<body>\",{\"1\":{\"227\":1}}],[\"<cond>\",{\"1\":{\"227\":1}}],[\"<configuration>\",{\"1\":{\"170\":1,\"172\":1}}],[\"<init>\",{\"1\":{\"227\":1}}],[\"<if\",{\"1\":{\"174\":1}}],[\"<<\",{\"1\":{\"213\":2,\"268\":2,\"286\":16}}],[\"<unistd\",{\"1\":{\"210\":1,\"237\":2,\"294\":1}}],[\"<sys\",{\"1\":{\"237\":1,\"294\":1}}],[\"<stdio\",{\"1\":{\"197\":1,\"210\":2,\"237\":1,\"294\":1}}],[\"<select\",{\"1\":{\"174\":1}}],[\"<mapper>\",{\"1\":{\"173\":1}}],[\"<mapper\",{\"1\":{\"170\":1}}],[\"<mappers>\",{\"1\":{\"170\":1}}],[\"<property\",{\"1\":{\"170\":4}}],[\"<datasource\",{\"1\":{\"170\":1}}],[\"<environment\",{\"1\":{\"170\":1}}],[\"<environments\",{\"1\":{\"170\":1}}],[\"<transactionmanager\",{\"1\":{\"170\":1}}],[\"<t>\",{\"1\":{\"147\":4}}],[\"<typename\",{\"1\":{\"69\":1}}],[\"<=\",{\"1\":{\"26\":1,\"47\":4,\"48\":2,\"70\":2,\"72\":1,\"129\":1,\"136\":4,\"137\":1,\"241\":2,\"283\":1,\"284\":4}}],[\"<\",{\"1\":{\"4\":3,\"13\":3,\"26\":1,\"47\":15,\"48\":1,\"51\":1,\"64\":2,\"71\":2,\"72\":1,\"73\":1,\"124\":1,\"129\":4,\"130\":1,\"131\":1,\"133\":2,\"134\":2,\"136\":4,\"137\":2,\"146\":2,\"170\":7,\"174\":2,\"181\":1,\"183\":2,\"187\":3,\"188\":3,\"213\":4,\"218\":3,\"238\":2,\"240\":1,\"241\":2,\"243\":1,\"244\":1,\"268\":2,\"282\":9,\"284\":1,\"286\":1}}],[\"会占有\",{\"1\":{\"283\":1}}],[\"会消费流数据\",{\"1\":{\"281\":1}}],[\"会发送到队列中\",{\"1\":{\"285\":1}}],[\"会发现多出了如下日志\",{\"1\":{\"277\":1}}],[\"会发生意图交叉\",{\"1\":{\"51\":1}}],[\"会重传这些包\",{\"1\":{\"273\":1}}],[\"会头到尾实现了一个用户态简易版\",{\"1\":{\"270\":1}}],[\"会释放掉一批\",{\"1\":{\"264\":1}}],[\"会把这个元素保存到池中\",{\"1\":{\"261\":1}}],[\"会跳到\",{\"1\":{\"254\":1}}],[\"会产生大量的垃圾对象\",{\"1\":{\"243\":1}}],[\"会先判断缓存中是否有可用的块内存\",{\"1\":{\"241\":1}}],[\"会先从内存表中查询\",{\"1\":{\"4\":1}}],[\"会优先从页堆中拿出空闲页返回\",{\"1\":{\"241\":1}}],[\"会优先去缓存\",{\"1\":{\"241\":1}}],[\"会按照参数计算合适的块大小\",{\"1\":{\"241\":1}}],[\"会一直认为\",{\"1\":{\"238\":1}}],[\"会一直运行\",{\"1\":{\"125\":1}}],[\"会预先分配一大块内存\",{\"1\":{\"238\":1}}],[\"会选择暂停程序运行\",{\"1\":{\"238\":1}}],[\"会为程序接管进程内存\",{\"1\":{\"238\":1}}],[\"会得到以下输出\",{\"1\":{\"237\":1}}],[\"会得到如下输出\",{\"1\":{\"210\":1,\"238\":1}}],[\"会严重破坏其核心资源管理能力\",{\"1\":{\"217\":1}}],[\"会生成两个文件\",{\"1\":{\"212\":1}}],[\"会报错\",{\"1\":{\"212\":1}}],[\"会在\",{\"1\":{\"212\":1}}],[\"会在节点内部存储集群元数据\",{\"1\":{\"124\":1}}],[\"会直接向\",{\"1\":{\"210\":1}}],[\"会直接将\",{\"1\":{\"137\":1}}],[\"会做一个\",{\"1\":{\"208\":1}}],[\"会调用\",{\"1\":{\"202\":1}}],[\"会链接到程序的\",{\"1\":{\"200\":1}}],[\"会执行调度时找到的\",{\"1\":{\"200\":1}}],[\"会使用这个栈\",{\"1\":{\"194\":1}}],[\"会引入不断增长的数据\",{\"1\":{\"164\":1}}],[\"会给你带来新的体验与收获\",{\"1\":{\"139\":1}}],[\"会判断\",{\"1\":{\"136\":1}}],[\"会被设置一个\",{\"1\":{\"281\":1}}],[\"会被回收掉\",{\"1\":{\"243\":1}}],[\"会被自动回收掉\",{\"1\":{\"238\":1}}],[\"会被发送到\",{\"1\":{\"131\":1}}],[\"会被垃圾回收掉\",{\"1\":{\"50\":1}}],[\"会不断的更新\",{\"1\":{\"131\":1}}],[\"会不断的扩容节点\",{\"1\":{\"71\":1}}],[\"会附带上自己日志的最后序号和任期\",{\"1\":{\"130\":1}}],[\"会自发的进行下一轮选举\",{\"1\":{\"126\":1}}],[\"会自动监测内存使用情况\",{\"1\":{\"238\":1}}],[\"会自动解析\",{\"1\":{\"225\":1}}],[\"会自动判断\",{\"1\":{\"225\":1}}],[\"会自动调用\",{\"1\":{\"124\":1,\"129\":1}}],[\"会自动成为协调者\",{\"1\":{\"123\":1}}],[\"会向集群中的其它节点发送投票\",{\"1\":{\"124\":1}}],[\"会休眠一段后\",{\"1\":{\"124\":1}}],[\"会更新\",{\"1\":{\"98\":1}}],[\"会扫描全部的日志文件\",{\"1\":{\"94\":1}}],[\"会读到脏数据\",{\"1\":{\"86\":1}}],[\"会从缓冲池中获取一个新页作为根节点页\",{\"1\":{\"71\":1}}],[\"会尝试从树中搜索\",{\"1\":{\"70\":1}}],[\"会减少\",{\"1\":{\"64\":1}}],[\"会增加页的\",{\"1\":{\"64\":1}}],[\"会有哪些不同\",{\"1\":{\"10\":1}}],[\"会将语法树转化为\",{\"1\":{\"227\":1}}],[\"会将两个寄存器的值相加后再置入第一个寄存器中\",{\"1\":{\"218\":1}}],[\"会将工作线程\",{\"1\":{\"198\":1}}],[\"会将功能需求的上下文打散到一组细碎的对象群落中\",{\"1\":{\"164\":1}}],[\"会将其与自己的任期和日志进行比较\",{\"1\":{\"130\":1}}],[\"会将当前节点切换为领导者状态\",{\"1\":{\"123\":1}}],[\"会将内存表中的数据写入磁盘\",{\"1\":{\"4\":1}}],[\"会将数据先写入内存表\",{\"1\":{\"4\":1}}],[\"时检查\",{\"1\":{\"261\":1}}],[\"时间\",{\"1\":{\"244\":1}}],[\"时间戳\",{\"1\":{\"16\":1,\"18\":1,\"98\":1}}],[\"时延的原因\",{\"1\":{\"238\":1}}],[\"时的状态称为自旋状态\",{\"1\":{\"199\":1}}],[\"时会将线程局部变量地址设置到\",{\"1\":{\"198\":1}}],[\"时刻感知认知提升\",{\"1\":{\"164\":1}}],[\"时也需要注意脏页\",{\"1\":{\"64\":1}}],[\"时序数据库\",{\"1\":{\"56\":1}}],[\"时钟实现\",{\"1\":{\"43\":1}}],[\"时钟\",{\"1\":{\"16\":1,\"28\":1}}],[\"时钟的\",{\"1\":{\"13\":1}}],[\"时\",{\"1\":{\"4\":4,\"17\":1,\"18\":1,\"69\":1,\"73\":2,\"86\":1,\"130\":1,\"136\":3,\"137\":1,\"200\":1,\"237\":2,\"238\":1,\"240\":2,\"241\":1,\"243\":1,\"262\":1,\"282\":1}}],[\"包就丢失了\",{\"1\":{\"284\":1}}],[\"包可能没有任何数组\",{\"1\":{\"284\":1}}],[\"包可能先于其它数据包达到\",{\"1\":{\"282\":1}}],[\"包发送\",{\"1\":{\"284\":1}}],[\"包也占有一个序号\",{\"1\":{\"283\":1}}],[\"包数据\",{\"1\":{\"282\":1}}],[\"包重发达到后\",{\"1\":{\"282\":1}}],[\"包到达后也不可直接写入字节流\",{\"1\":{\"282\":1}}],[\"包到达时\",{\"1\":{\"282\":1}}],[\"包达到\",{\"1\":{\"282\":1}}],[\"包丢了\",{\"1\":{\"282\":1}}],[\"包更早到达\",{\"1\":{\"282\":1}}],[\"包比\",{\"1\":{\"282\":1}}],[\"包装32位seqno\",{\"1\":{\"280\":1}}],[\"包装为表记录\",{\"1\":{\"79\":1}}],[\"包的交互\",{\"1\":{\"272\":1}}],[\"包至客户端\",{\"1\":{\"272\":1}}],[\"包后等待\",{\"1\":{\"284\":1}}],[\"包后\",{\"1\":{\"272\":2,\"285\":1,\"286\":1}}],[\"包\",{\"1\":{\"257\":1,\"272\":2,\"282\":2,\"283\":3,\"284\":3,\"285\":8,\"286\":14}}],[\"包下\",{\"1\":{\"256\":1}}],[\"包下有对各个平台的机器码支持\",{\"1\":{\"227\":1}}],[\"包下的\",{\"1\":{\"200\":3}}],[\"包中的\",{\"1\":{\"217\":1}}],[\"包中的全局变量\",{\"1\":{\"200\":1}}],[\"包中\",{\"1\":{\"206\":1,\"261\":1,\"262\":1}}],[\"包含数据\",{\"1\":{\"285\":1}}],[\"包含数据链路层\",{\"1\":{\"270\":1}}],[\"包含在其中的对数据库的操作要么全部被执行\",{\"1\":{\"83\":1}}],[\"包含了数据\",{\"1\":{\"282\":1}}],[\"包含了一个\",{\"1\":{\"261\":1}}],[\"包含了键和值的列表\",{\"1\":{\"4\":1}}],[\"包含了写操作\",{\"1\":{\"4\":1}}],[\"包括内存管理\",{\"1\":{\"217\":1}}],[\"包括栈\",{\"1\":{\"194\":1}}],[\"包括insert\",{\"1\":{\"28\":1}}],[\"包括两部分\",{\"1\":{\"25\":1}}],[\"包括\",{\"1\":{\"4\":1,\"11\":1,\"19\":1,\"117\":1,\"242\":1}}],[\"类都能代理\",{\"1\":{\"144\":1}}],[\"类图如下\",{\"1\":{\"279\":1}}],[\"类图\",{\"1\":{\"97\":1}}],[\"类定义如下\",{\"1\":{\"93\":1,\"284\":1}}],[\"类有两个重要字段\",{\"1\":{\"79\":1}}],[\"类实例来执行查询计划\",{\"1\":{\"78\":1}}],[\"类中定义一把锁\",{\"1\":{\"73\":1}}],[\"类中添加以下方法来支持事务操作\",{\"1\":{\"4\":1}}],[\"类中添加一个字典属性来存储所有进行中的事务\",{\"1\":{\"4\":1}}],[\"类别众多\",{\"1\":{\"56\":1}}],[\"类似的情况还有\",{\"1\":{\"260\":1}}],[\"类似于\",{\"1\":{\"255\":1}}],[\"类似这样的\",{\"1\":{\"218\":1}}],[\"类似地\",{\"1\":{\"207\":1}}],[\"类似\",{\"1\":{\"15\":1,\"64\":1,\"129\":1,\"136\":2,\"252\":1}}],[\"类型大小\",{\"1\":{\"256\":1}}],[\"类型提供对应的新建\",{\"1\":{\"243\":1}}],[\"类型定义数据结构\",{\"1\":{\"208\":1}}],[\"类型链接初始化\",{\"1\":{\"200\":1}}],[\"类型为t\",{\"1\":{\"179\":1}}],[\"类型数据的加法\",{\"1\":{\"179\":1}}],[\"类型需要能够按照集合元素的\",{\"1\":{\"117\":1}}],[\"类型来说\",{\"1\":{\"113\":1,\"116\":1}}],[\"类型来生成对应的执行器\",{\"1\":{\"78\":1}}],[\"类型\",{\"0\":{\"114\":1,\"117\":1},\"1\":{\"11\":2,\"19\":1,\"69\":2,\"113\":4,\"114\":1,\"115\":1,\"181\":1,\"243\":2,\"283\":1}}],[\"类型的伪代码实现\",{\"1\":{\"8\":1}}],[\"类就具备了事务支持能力\",{\"1\":{\"4\":1}}],[\"类的值类型为\",{\"1\":{\"69\":1}}],[\"类的完整代码\",{\"1\":{\"4\":1}}],[\"类的代码\",{\"1\":{\"4\":1}}],[\"类的相应方法\",{\"1\":{\"4\":1}}],[\"类的示例代码\",{\"1\":{\"4\":1}}],[\"类可以包含以下属性\",{\"1\":{\"4\":1}}],[\"类代码中加入事务支持\",{\"1\":{\"4\":1}}],[\"类代码\",{\"1\":{\"4\":1}}],[\"类是对数据页的代码抽象\",{\"1\":{\"69\":1}}],[\"类是\",{\"1\":{\"4\":2}}],[\"类\",{\"1\":{\"4\":1,\"64\":1,\"69\":1}}],[\"类和\",{\"1\":{\"4\":1}}],[\"bz2\",{\"1\":{\"291\":2}}],[\"bzimage\",{\"1\":{\"291\":4,\"294\":3}}],[\"bc\",{\"1\":{\"291\":1}}],[\"bcond\",{\"1\":{\"227\":3}}],[\"blacken\",{\"1\":{\"244\":2}}],[\"blogs\",{\"1\":{\"295\":1}}],[\"blog\",{\"1\":{\"174\":2,\"215\":2,\"295\":1}}],[\"blogmapper\",{\"1\":{\"170\":1}}],[\"blockplain\",{\"1\":{\"227\":4}}],[\"block\",{\"1\":{\"225\":1,\"227\":3,\"240\":1}}],[\"blocked\",{\"1\":{\"88\":1}}],[\"blocks++\",{\"1\":{\"240\":1}}],[\"blockstmt\",{\"1\":{\"225\":1,\"227\":4}}],[\"blocks\",{\"1\":{\"23\":1,\"39\":1,\"200\":1,\"238\":2,\"240\":1}}],[\"bloomfilter\",{\"1\":{\"4\":1}}],[\"bloom\",{\"1\":{\"4\":4}}],[\"b的引用\",{\"1\":{\"243\":1}}],[\"btomb\",{\"1\":{\"238\":4}}],[\"bss\",{\"1\":{\"232\":2}}],[\"b2\",{\"1\":{\"218\":3}}],[\"bison\",{\"1\":{\"292\":1}}],[\"bisect\",{\"1\":{\"4\":7}}],[\"big\",{\"1\":{\"238\":4}}],[\"bind\",{\"1\":{\"286\":1}}],[\"bin\",{\"1\":{\"224\":2,\"225\":6,\"227\":8,\"290\":1,\"291\":4,\"292\":1,\"294\":4}}],[\"binary\",{\"1\":{\"218\":9,\"291\":1}}],[\"bit\",{\"1\":{\"198\":1,\"263\":1}}],[\"bi\",{\"1\":{\"181\":2}}],[\"bx\",{\"1\":{\"180\":1,\"200\":28,\"250\":1,\"253\":6,\"256\":3}}],[\"bp\",{\"1\":{\"180\":6,\"200\":3,\"250\":1}}],[\"bplustreepage\",{\"1\":{\"69\":3}}],[\"bplustreeinternalpage\",{\"1\":{\"69\":3}}],[\"bplustreeinternalpage<keytype\",{\"1\":{\"69\":1}}],[\"bplustreeleafpage\",{\"1\":{\"69\":2}}],[\"bplustreeleafpage<keytype\",{\"1\":{\"69\":1}}],[\"bplustree<generickey<8>\",{\"1\":{\"69\":1}}],[\"bplustree\",{\"1\":{\"69\":11,\"73\":1}}],[\"bdd\",{\"1\":{\"165\":1}}],[\"bdwms\",{\"1\":{\"90\":1}}],[\"b1\",{\"1\":{\"71\":2,\"218\":5,\"225\":5}}],[\"bound\",{\"1\":{\"282\":4}}],[\"body\",{\"1\":{\"219\":1,\"227\":34,\"260\":1}}],[\"boot\",{\"1\":{\"291\":5,\"293\":1,\"294\":3}}],[\"bootstrap\",{\"0\":{\"219\":1},\"1\":{\"200\":1,\"224\":5,\"225\":4}}],[\"book\",{\"1\":{\"215\":1}}],[\"bool\",{\"1\":{\"63\":2,\"64\":8,\"71\":2,\"78\":1,\"79\":3,\"88\":1,\"89\":1,\"93\":1,\"94\":1,\"124\":2,\"126\":1,\"129\":1,\"131\":1,\"134\":1,\"136\":4,\"177\":3,\"181\":2,\"185\":4,\"189\":1,\"190\":3,\"200\":3,\"227\":1,\"240\":1,\"243\":1,\"263\":2,\"282\":2,\"283\":1,\"284\":1,\"285\":6}}],[\"bool类型等\",{\"1\":{\"59\":1}}],[\"booleans\",{\"1\":{\"181\":1}}],[\"boolean\",{\"1\":{\"25\":1,\"26\":1,\"28\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":2,\"149\":2,\"158\":1,\"174\":1,\"177\":1,\"227\":1}}],[\"boss\",{\"1\":{\"165\":1}}],[\"both\",{\"1\":{\"69\":1,\"227\":1,\"285\":2}}],[\"b+tree\",{\"1\":{\"75\":1}}],[\"b+操作中最复杂的一部分\",{\"1\":{\"72\":1}}],[\"b+的一条性质\",{\"1\":{\"68\":1}}],[\"b+\",{\"1\":{\"68\":2,\"75\":1}}],[\"b+树可用于存储索引\",{\"1\":{\"82\":1}}],[\"b+树可以满足单线程下任意读写\",{\"1\":{\"73\":1}}],[\"b+树可以拥有多个子节点\",{\"1\":{\"68\":1}}],[\"b+树这一节中\",{\"1\":{\"82\":1}}],[\"b+树支持多线程并发访问\",{\"1\":{\"73\":1}}],[\"b+树该如何支持并发访问了\",{\"1\":{\"73\":1}}],[\"b+树已被清空\",{\"1\":{\"72\":1}}],[\"b+树删除是\",{\"1\":{\"72\":1}}],[\"b+树删除\",{\"0\":{\"72\":1}}],[\"b+树性质\",{\"1\":{\"71\":1}}],[\"b+树节点最多只能拥有\",{\"1\":{\"71\":1}}],[\"b+树节点可分为内部节点\",{\"1\":{\"69\":1}}],[\"b+树插入对外暴露\",{\"1\":{\"71\":1}}],[\"b+树插入伪代码如下\",{\"1\":{\"71\":1}}],[\"b+树插入会复杂一些\",{\"1\":{\"71\":1}}],[\"b+树插入\",{\"0\":{\"71\":1}}],[\"b+树将所有值存储在了叶子结点中\",{\"1\":{\"70\":1}}],[\"b+树中查询\",{\"1\":{\"73\":1}}],[\"b+树中插入数据\",{\"1\":{\"71\":1}}],[\"b+树中搜索函数\",{\"1\":{\"70\":1}}],[\"b+树中最简单的部分\",{\"1\":{\"70\":1}}],[\"b+树中只有叶子结点才会存储真正的数据\",{\"1\":{\"68\":1}}],[\"b+树一番介绍后\",{\"1\":{\"70\":1}}],[\"b+树一个节点究竟能存储多少项\",{\"1\":{\"56\":1}}],[\"b+树搜索是如何实现的\",{\"1\":{\"70\":1}}],[\"b+树搜索\",{\"0\":{\"70\":1}}],[\"b+树类图\",{\"1\":{\"69\":1}}],[\"b+树结构类图如图\",{\"1\":{\"69\":1}}],[\"b+树在插入数据时\",{\"1\":{\"71\":1}}],[\"b+树在搜索时\",{\"1\":{\"70\":1}}],[\"b+树在代码中被抽象定义为\",{\"1\":{\"69\":1}}],[\"b+树在关系数据库上的重要性不言而喻\",{\"1\":{\"67\":1}}],[\"b+树的搜索\",{\"1\":{\"69\":1}}],[\"b+树的抽象非常优美\",{\"1\":{\"69\":1}}],[\"b+树的实现\",{\"1\":{\"69\":1}}],[\"b+树后\",{\"1\":{\"69\":1}}],[\"b+树设计\",{\"0\":{\"69\":1}}],[\"b+树查询数据\",{\"1\":{\"68\":1}}],[\"b+树包括根节点\",{\"1\":{\"68\":1}}],[\"b+树是一种多路自平衡树\",{\"1\":{\"68\":1}}],[\"b+树定义\",{\"0\":{\"68\":1}}],[\"b+树或其变种\",{\"1\":{\"67\":1}}],[\"b+树实现之前\",{\"1\":{\"69\":1}}],[\"b+树实现花了大量篇幅\",{\"1\":{\"69\":1}}],[\"b+树实现及并发\",{\"1\":{\"59\":1}}],[\"b+树实现的\",{\"1\":{\"23\":1}}],[\"b+树\",{\"0\":{\"67\":1},\"1\":{\"59\":2,\"67\":1,\"68\":4,\"71\":2,\"72\":1,\"74\":2,\"77\":1,\"82\":1}}],[\"b+树又是如何支持并发访问的\",{\"1\":{\"56\":1}}],[\"b+树似乎是数据库组织数据的最常用数据结构\",{\"1\":{\"56\":1}}],[\"banner\",{\"1\":{\"293\":1}}],[\"ballast\",{\"1\":{\"236\":2,\"238\":4}}],[\"bash\",{\"1\":{\"224\":1,\"225\":1,\"227\":2,\"290\":1,\"291\":1}}],[\"basiclit\",{\"1\":{\"219\":1,\"227\":1}}],[\"base\",{\"1\":{\"48\":1,\"146\":2,\"198\":1,\"250\":1}}],[\"based\",{\"0\":{\"13\":1,\"14\":1,\"16\":1,\"17\":1},\"1\":{\"10\":15,\"12\":2,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"53\":1}}],[\"bad\",{\"1\":{\"179\":2,\"227\":1}}],[\"badger\",{\"1\":{\"119\":1}}],[\"batch\",{\"1\":{\"78\":1}}],[\"backports\",{\"1\":{\"291\":2}}],[\"backendqueue\",{\"1\":{\"157\":1,\"158\":2}}],[\"back\",{\"1\":{\"63\":1,\"64\":1,\"78\":1,\"79\":1,\"88\":2,\"89\":1,\"284\":1}}],[\"busybox\",{\"1\":{\"291\":8,\"295\":2}}],[\"bustub\",{\"1\":{\"56\":4,\"58\":8,\"59\":1,\"63\":1,\"64\":1,\"69\":1,\"77\":1,\"78\":2,\"79\":4,\"82\":1,\"85\":2,\"89\":1,\"93\":1,\"94\":3}}],[\"bucket\",{\"1\":{\"262\":1}}],[\"buf\",{\"1\":{\"213\":6,\"262\":11}}],[\"buf+0\",{\"1\":{\"200\":1}}],[\"bufferlist\",{\"1\":{\"281\":3}}],[\"buffers\",{\"1\":{\"262\":1}}],[\"bufferpool\",{\"0\":{\"262\":1},\"1\":{\"262\":6}}],[\"bufferpoolmanager\",{\"1\":{\"64\":12,\"69\":3,\"79\":1,\"94\":1}}],[\"buffer\",{\"1\":{\"58\":1,\"59\":2,\"62\":1,\"65\":2,\"69\":1,\"70\":2,\"71\":2,\"93\":9,\"94\":7,\"133\":1,\"261\":2,\"262\":8,\"268\":4,\"281\":13,\"283\":2,\"284\":1}}],[\"but\",{\"1\":{\"136\":1,\"284\":1}}],[\"build=\",{\"1\":{\"293\":1}}],[\"buildroot=\",{\"1\":{\"293\":1}}],[\"buildroot\",{\"0\":{\"293\":1},\"1\":{\"293\":10,\"295\":1}}],[\"build\",{\"1\":{\"150\":1,\"157\":2,\"170\":2,\"172\":1,\"200\":1,\"212\":1,\"217\":1,\"257\":1,\"290\":1,\"291\":3,\"292\":1,\"293\":3}}],[\"buildwaitsforgraph\",{\"1\":{\"88\":2}}],[\"building\",{\"1\":{\"23\":1,\"39\":1,\"224\":6,\"225\":6,\"292\":1}}],[\"builtin\",{\"1\":{\"212\":1,\"219\":2}}],[\"built\",{\"1\":{\"88\":1}}],[\"bug\",{\"1\":{\"74\":1,\"164\":1}}],[\"br2\",{\"1\":{\"293\":1}}],[\"brk\",{\"1\":{\"237\":14}}],[\"branches\",{\"1\":{\"227\":1}}],[\"brokerinfo\",{\"1\":{\"155\":3}}],[\"brokerid\",{\"1\":{\"155\":3}}],[\"broker\",{\"0\":{\"156\":1},\"1\":{\"153\":2,\"155\":4,\"156\":1,\"157\":2,\"158\":2,\"159\":5,\"160\":6}}],[\"brrr\",{\"1\":{\"53\":1}}],[\"breakok\",{\"1\":{\"227\":1}}],[\"break\",{\"1\":{\"4\":1,\"26\":1,\"44\":1,\"47\":5,\"48\":3,\"51\":3,\"88\":1,\"89\":6,\"129\":4,\"131\":2,\"134\":2,\"227\":4,\"282\":4,\"284\":1}}],[\"bytedance\",{\"1\":{\"215\":1}}],[\"bytetomessagedecoder\",{\"1\":{\"146\":2}}],[\"bytebuf\",{\"1\":{\"146\":12}}],[\"byte\",{\"1\":{\"133\":1,\"136\":5,\"146\":2,\"147\":4,\"158\":4,\"207\":8,\"208\":3,\"212\":4,\"213\":8,\"218\":3,\"219\":1,\"238\":4,\"252\":2,\"260\":2,\"262\":7,\"270\":1,\"280\":2,\"282\":1,\"283\":2,\"284\":1,\"285\":1,\"286\":2}}],[\"bytestream\",{\"0\":{\"281\":1},\"1\":{\"279\":2,\"280\":3,\"281\":15,\"282\":2,\"284\":1}}],[\"bytestring\",{\"1\":{\"157\":1}}],[\"bytes\",{\"1\":{\"133\":3,\"262\":7,\"268\":3,\"281\":4,\"282\":5,\"283\":2,\"284\":3,\"285\":2}}],[\"by\",{\"1\":{\"28\":1,\"87\":2,\"164\":1,\"181\":1,\"218\":2,\"227\":1,\"263\":1,\"285\":2,\"286\":1}}],[\"behavior\",{\"1\":{\"263\":1}}],[\"best\",{\"1\":{\"240\":1}}],[\"bensuperpc\",{\"1\":{\"292\":1}}],[\"bend\",{\"1\":{\"227\":4}}],[\"bench\",{\"1\":{\"213\":1}}],[\"benchmark\",{\"1\":{\"286\":2}}],[\"benchmarkfastconv\",{\"1\":{\"213\":3}}],[\"benchmarkgoconv\",{\"1\":{\"213\":3}}],[\"bean\",{\"1\":{\"144\":1}}],[\"beyond\",{\"1\":{\"134\":1,\"200\":1}}],[\"becomefollower\",{\"1\":{\"123\":2,\"124\":2,\"129\":3,\"133\":5,\"136\":3}}],[\"becomeleader\",{\"1\":{\"123\":2,\"124\":1,\"129\":1}}],[\"becomecandidate\",{\"1\":{\"123\":3,\"124\":1,\"133\":1}}],[\"because\",{\"1\":{\"51\":1,\"200\":1}}],[\"between\",{\"1\":{\"48\":1,\"283\":1}}],[\"beforeeach\",{\"1\":{\"164\":1}}],[\"before\",{\"1\":{\"47\":1,\"51\":1,\"131\":1,\"133\":1,\"164\":1,\"200\":4,\"263\":1,\"285\":1}}],[\"below\",{\"1\":{\"47\":1}}],[\"been\",{\"1\":{\"26\":1,\"227\":1,\"283\":1,\"284\":1,\"285\":3,\"286\":2}}],[\"be\",{\"1\":{\"26\":1,\"47\":2,\"51\":1,\"88\":3,\"134\":1,\"172\":1,\"173\":1,\"179\":1,\"188\":1,\"200\":3,\"262\":1,\"284\":1,\"285\":3}}],[\"beginning\",{\"1\":{\"26\":1,\"227\":1}}],[\"begin\",{\"1\":{\"4\":4,\"5\":1,\"47\":1,\"48\":1,\"50\":1,\"79\":1,\"85\":2,\"89\":1,\"212\":1,\"281\":4,\"282\":14}}],[\"bbs\",{\"1\":{\"295\":1}}],[\"bbody\",{\"1\":{\"227\":6}}],[\"bbbb\",{\"1\":{\"51\":1}}],[\"bb\",{\"1\":{\"5\":1,\"212\":1}}],[\"b\",{\"1\":{\"5\":3,\"14\":4,\"51\":3,\"71\":7,\"72\":9,\"73\":8,\"79\":1,\"84\":3,\"144\":1,\"164\":4,\"165\":1,\"177\":2,\"179\":19,\"190\":2,\"213\":8,\"218\":15,\"219\":2,\"224\":1,\"225\":3,\"227\":22,\"238\":2,\"243\":4,\"252\":1,\"256\":1,\"268\":6,\"282\":6,\"285\":1}}],[\"从原理到实战\",{\"1\":{\"288\":1}}],[\"从终端输出中可以看到\",{\"1\":{\"286\":1}}],[\"从中来看看三次握手是如何发生的\",{\"1\":{\"286\":1}}],[\"从输出流中读取数据并包装为报文\",{\"1\":{\"284\":1}}],[\"从这个图中可以总结出\",{\"1\":{\"279\":1}}],[\"从这里就可以得出\",{\"1\":{\"28\":1}}],[\"从队列里面拿\",{\"1\":{\"268\":1}}],[\"从每个\",{\"1\":{\"243\":1}}],[\"从所有\",{\"1\":{\"243\":1}}],[\"从内存起始地址依次沿链表寻找\",{\"1\":{\"240\":1}}],[\"从内存表中查询\",{\"1\":{\"4\":3}}],[\"从此\",{\"1\":{\"238\":1}}],[\"从高地址向地址增长\",{\"1\":{\"232\":1}}],[\"从一个基本的\",{\"1\":{\"227\":1}}],[\"从构建输出可以看出\",{\"1\":{\"224\":1}}],[\"从结果可以发现\",{\"1\":{\"218\":1}}],[\"从结果中\",{\"1\":{\"213\":1}}],[\"从运行结果来看\",{\"1\":{\"217\":1}}],[\"从源码角度看\",{\"1\":{\"204\":2}}],[\"从进程堆内存上给其分配栈\",{\"1\":{\"200\":1}}],[\"从进行中的事务字典中移除该事务\",{\"1\":{\"4\":4}}],[\"从寄存器拷贝回栈中\",{\"1\":{\"200\":1}}],[\"从其它本地队列中偷\",{\"1\":{\"200\":1}}],[\"从其它\",{\"1\":{\"199\":1,\"200\":1}}],[\"从参数读取\",{\"1\":{\"187\":1}}],[\"从汇编代码上可以看到\",{\"1\":{\"180\":1}}],[\"从入口测试用例反推代码结构\",{\"1\":{\"168\":1}}],[\"从零写一个简单的mybatis\",{\"0\":{\"166\":1}}],[\"从功能测试出发\",{\"1\":{\"164\":1}}],[\"从理解到实现需要走很长的一段路\",{\"1\":{\"139\":1}}],[\"从节点日志冲突解决的性能\",{\"1\":{\"121\":1}}],[\"从根节点\",{\"1\":{\"73\":2}}],[\"从树级别下降到了页级别\",{\"1\":{\"73\":1}}],[\"从叶子结点上寻找值\",{\"1\":{\"70\":1}}],[\"从伪代码中\",{\"1\":{\"64\":1}}],[\"从空闲列表中拿到\",{\"1\":{\"64\":1}}],[\"从空闲列表中获取\",{\"1\":{\"64\":1}}],[\"从磁盘中读取数据并解码\",{\"1\":{\"133\":1}}],[\"从磁盘中读取\",{\"1\":{\"64\":1}}],[\"从磁盘中读取页数据并缓存在内存中\",{\"1\":{\"58\":1}}],[\"从缓存中删除一个页\",{\"1\":{\"64\":1}}],[\"从\",{\"0\":{\"192\":1},\"1\":{\"63\":1,\"64\":1,\"72\":1,\"96\":1,\"127\":1,\"159\":1,\"160\":1,\"192\":1,\"200\":3,\"224\":1,\"225\":1,\"241\":1,\"243\":2,\"279\":2,\"283\":2,\"285\":2}}],[\"从链表尾部得到淘汰页\",{\"1\":{\"63\":1}}],[\"从本篇文章开始\",{\"1\":{\"22\":1}}],[\"从而无法开启新的内存接受新的请求\",{\"1\":{\"260\":1}}],[\"从而就不再是\",{\"1\":{\"243\":1}}],[\"从而减少\",{\"1\":{\"238\":2}}],[\"从而减少磁盘读取次数\",{\"1\":{\"4\":1}}],[\"从而提升代码质量\",{\"1\":{\"223\":1}}],[\"从而获取\",{\"1\":{\"200\":1}}],[\"从而导致代码越来越难以维护\",{\"1\":{\"165\":1}}],[\"从而导致最终文本内容不一致\",{\"1\":{\"25\":1}}],[\"从而发起rpc请求\",{\"1\":{\"148\":1}}],[\"从而保证二者的数据一致性\",{\"1\":{\"138\":1}}],[\"从而保证原来任期的日志不会被覆盖\",{\"1\":{\"134\":1}}],[\"从而保证最终文本内容一致\",{\"1\":{\"25\":1}}],[\"从而维持集群的正常运行\",{\"1\":{\"125\":1}}],[\"从而可能引发父节点再次分裂\",{\"1\":{\"71\":1}}],[\"从而达到规避\",{\"1\":{\"217\":1}}],[\"从而达到去重的效果\",{\"1\":{\"188\":1}}],[\"从而达到删除age的效果\",{\"1\":{\"32\":1}}],[\"从而达到最终一致性\",{\"1\":{\"10\":1}}],[\"从lsm树中删除事务中删除的键\",{\"1\":{\"4\":1}}],[\"从后往前遍历\",{\"1\":{\"4\":3}}],[\"从sstable中查询指定键的值\",{\"1\":{\"4\":1}}],[\"从sstable中查询\",{\"1\":{\"4\":3}}],[\"读日志需要将日志序号减去\",{\"1\":{\"136\":1}}],[\"读一条消息\",{\"1\":{\"98\":1}}],[\"读元数据\",{\"1\":{\"98\":1}}],[\"读文件序号\",{\"1\":{\"98\":1}}],[\"读偏移\",{\"1\":{\"98\":1}}],[\"读已提交\",{\"1\":{\"89\":2}}],[\"读提交\",{\"1\":{\"84\":3}}],[\"读未提交无法解决脏读\",{\"1\":{\"84\":1}}],[\"读未提交\",{\"1\":{\"84\":2,\"89\":2}}],[\"读\",{\"1\":{\"73\":1,\"97\":1,\"274\":1}}],[\"读写分离\",{\"1\":{\"111\":1}}],[\"读写相对麻烦一点\",{\"1\":{\"14\":1}}],[\"读写简单\",{\"1\":{\"14\":1}}],[\"读操作\",{\"1\":{\"4\":3}}],[\"读取后会移除前\",{\"1\":{\"281\":1}}],[\"读取字节流中的前\",{\"1\":{\"281\":1}}],[\"读取全部元素\",{\"1\":{\"188\":1}}],[\"读取mybatis\",{\"1\":{\"170\":1,\"172\":1}}],[\"读取\",{\"0\":{\"172\":1,\"173\":1},\"1\":{\"69\":1,\"98\":1}}],[\"读取值\",{\"1\":{\"18\":1}}],[\"读取值十分简单\",{\"1\":{\"16\":1}}],[\"读取计数时\",{\"1\":{\"14\":1}}],[\"读取性能\",{\"1\":{\"4\":1}}],[\"读取操作\",{\"1\":{\"4\":1}}],[\"用容量减去当前的缓冲区大小即可\",{\"1\":{\"283\":1}}],[\"用绝对序号来表示数据流上字节的数量\",{\"1\":{\"283\":1}}],[\"用户可编译\",{\"1\":{\"292\":1}}],[\"用户态协议\",{\"0\":{\"278\":1}}],[\"用户态程序需要通过系统调用这个桥梁向内核发起申请\",{\"1\":{\"197\":1}}],[\"用户程序\",{\"1\":{\"245\":1}}],[\"用栈来模拟\",{\"1\":{\"243\":1}}],[\"用完后释放\",{\"1\":{\"234\":1}}],[\"用一个例子看看效果\",{\"1\":{\"225\":1}}],[\"用一种新的方式来学习\",{\"1\":{\"2\":1}}],[\"用在了生产环境上\",{\"1\":{\"214\":1,\"238\":1}}],[\"用在生产环境上的\",{\"1\":{\"27\":1}}],[\"用系统调用号来区分入口函数\",{\"1\":{\"197\":1}}],[\"用思考找到技术价值再动手做事\",{\"1\":{\"162\":1}}],[\"用\",{\"1\":{\"114\":2,\"116\":2,\"119\":1,\"236\":1}}],[\"用来保存一组可独立访问的临时对象\",{\"1\":{\"261\":1}}],[\"用来保护\",{\"1\":{\"88\":1}}],[\"用来访问函数的参数\",{\"1\":{\"250\":1}}],[\"用来设置架构特定的线程状态\",{\"1\":{\"198\":1}}],[\"用来表示变量\",{\"1\":{\"257\":1}}],[\"用来表示\",{\"1\":{\"115\":1}}],[\"用来表示数据是\",{\"1\":{\"115\":1}}],[\"用来支持过期\",{\"1\":{\"114\":1}}],[\"用来记录事务正在等待获取的锁\",{\"1\":{\"87\":1}}],[\"用来唯一标识一张表\",{\"1\":{\"79\":1}}],[\"用来说明\",{\"1\":{\"4\":1}}],[\"用于序列重组\",{\"1\":{\"282\":1}}],[\"用于初始化一个字节流\",{\"1\":{\"281\":1}}],[\"用于自动实现\",{\"1\":{\"227\":1}}],[\"用于将\",{\"1\":{\"227\":1}}],[\"用于解析新的关键字\",{\"1\":{\"227\":1}}],[\"用于任意数据之间的内存拷贝\",{\"1\":{\"207\":1}}],[\"用于新建子进程或者线程\",{\"1\":{\"198\":1}}],[\"用于对每一个数据项处理\",{\"1\":{\"189\":1}}],[\"用于编译时指定\",{\"1\":{\"183\":1}}],[\"用于返回\",{\"1\":{\"160\":1}}],[\"用于客户端发起请求时选择提供者连接\",{\"1\":{\"145\":1}}],[\"用于超时后发起选举\",{\"1\":{\"139\":1}}],[\"用于快照\",{\"1\":{\"138\":1}}],[\"用于日志同步和快照\",{\"1\":{\"139\":1}}],[\"用于日志同步\",{\"1\":{\"132\":1}}],[\"用于投票\",{\"1\":{\"125\":1}}],[\"用于故障后数据恢复\",{\"1\":{\"58\":1}}],[\"用于\",{\"1\":{\"56\":1,\"69\":1,\"200\":1,\"282\":1,\"283\":1}}],[\"用于保存多个变量\",{\"1\":{\"18\":1}}],[\"用于表示任意对象\",{\"1\":{\"243\":1}}],[\"用于表示一个变量\",{\"1\":{\"18\":1}}],[\"用于表示事务\",{\"1\":{\"4\":1}}],[\"用于标识当前值的声明周期\",{\"1\":{\"16\":1}}],[\"用于标识操作\",{\"1\":{\"13\":1}}],[\"用于标识客户端\",{\"1\":{\"13\":1,\"14\":1,\"16\":1,\"18\":1}}],[\"用于生成操作\",{\"1\":{\"13\":1}}],[\"用于存储其它客户端的时钟\",{\"1\":{\"13\":1}}],[\"用于存储操作\",{\"1\":{\"13\":1}}],[\"用于存储删除的键\",{\"1\":{\"4\":1}}],[\"用于存储插入或更新的键值对\",{\"1\":{\"4\":1}}],[\"用于存储所有进行中的事务\",{\"1\":{\"4\":1}}],[\"用于存储已经稳定的键值对\",{\"1\":{\"4\":1}}],[\"用于暂时存储插入或更新的键值对\",{\"1\":{\"4\":1}}],[\"光有理论不行\",{\"1\":{\"4\":1}}],[\"可通过\",{\"1\":{\"282\":1}}],[\"可通过下面的\",{\"1\":{\"16\":1,\"18\":1}}],[\"可靠的数据流实现类\",{\"1\":{\"281\":1}}],[\"可靠性是\",{\"1\":{\"273\":1}}],[\"可靠性\",{\"0\":{\"273\":1}}],[\"可靠\",{\"1\":{\"270\":1}}],[\"可靠和可扩展的存储引擎\",{\"1\":{\"4\":1}}],[\"可直接通过\",{\"1\":{\"256\":1}}],[\"可直接通过二分查找找到对应的值\",{\"1\":{\"70\":1}}],[\"可达的\",{\"1\":{\"243\":1}}],[\"可达性\",{\"1\":{\"243\":1}}],[\"可达到下面的效果\",{\"1\":{\"227\":1}}],[\"可是一旦代码量急剧攀升\",{\"1\":{\"234\":1}}],[\"可是如果你还有疑惑\",{\"1\":{\"56\":1}}],[\"可按块分配大内存\",{\"1\":{\"232\":1}}],[\"可点击此处了解\",{\"1\":{\"226\":1}}],[\"可根据实际的情况\",{\"1\":{\"218\":1}}],[\"可执行文件\",{\"1\":{\"217\":1,\"219\":1}}],[\"可用于表示任意类型\",{\"1\":{\"208\":1}}],[\"可用来表示所有类型的执行计划\",{\"1\":{\"78\":1}}],[\"可运行\",{\"1\":{\"200\":1}}],[\"可在用户态是没有\",{\"1\":{\"197\":1}}],[\"可由汇总函数得到最后的处理结果\",{\"1\":{\"185\":1}}],[\"可灰度的\",{\"1\":{\"162\":1}}],[\"可量化的目标是什么\",{\"1\":{\"162\":1}}],[\"可参考\",{\"1\":{\"158\":1}}],[\"可参考这里\",{\"1\":{\"107\":1}}],[\"可优化的\",{\"1\":{\"151\":1}}],[\"可读\",{\"1\":{\"146\":1}}],[\"可见值却发生了改变\",{\"1\":{\"127\":1}}],[\"可见数据会变\",{\"1\":{\"127\":1}}],[\"可将\",{\"1\":{\"121\":1}}],[\"可重读读\",{\"1\":{\"89\":1}}],[\"可重复读\",{\"1\":{\"84\":3,\"89\":1}}],[\"可一旦操作同步到客户端\",{\"1\":{\"48\":1}}],[\"可一旦有多个客户端同时进行编辑\",{\"1\":{\"25\":1}}],[\"可能得不到\",{\"1\":{\"279\":1}}],[\"可能需要判断\",{\"1\":{\"261\":1}}],[\"可能需要对读写操作进行锁定以防止数据被修改\",{\"1\":{\"4\":1}}],[\"可能在栈中\",{\"1\":{\"260\":1}}],[\"可能为\",{\"1\":{\"243\":1}}],[\"可能为空\",{\"1\":{\"36\":1}}],[\"可能有大量的垃圾没有及时回收\",{\"1\":{\"238\":1}}],[\"可能不久的将来\",{\"1\":{\"228\":1}}],[\"可能不是立马执行\",{\"1\":{\"198\":1,\"203\":1}}],[\"可能会存在\",{\"1\":{\"129\":1,\"137\":1}}],[\"可能会对多个数据页加锁并读取数据\",{\"1\":{\"85\":1}}],[\"可能会出现改动和优化\",{\"1\":{\"121\":1}}],[\"可能会出现如下几个问题\",{\"1\":{\"84\":1}}],[\"可能会出现\",{\"1\":{\"72\":1}}],[\"可复制增长数组\",{\"1\":{\"23\":1}}],[\"可以传输无限量的字节\",{\"1\":{\"274\":1}}],[\"可以无限制地提交任务\",{\"1\":{\"264\":1}}],[\"可以选择适合自己业务的来使用\",{\"1\":{\"264\":1}}],[\"可以自行\",{\"1\":{\"262\":1}}],[\"可以并发地调用它的方法存取对象\",{\"1\":{\"261\":1}}],[\"可以采用对象池的方式\",{\"1\":{\"260\":1}}],[\"可以查看一下\",{\"1\":{\"257\":1}}],[\"可以不理会\",{\"1\":{\"257\":1}}],[\"可以不予理会\",{\"1\":{\"200\":1,\"257\":1}}],[\"可以分开定义同一个变量\",{\"1\":{\"257\":1}}],[\"可以作为垃圾清理掉\",{\"1\":{\"235\":1}}],[\"可以点击这里回顾一下\",{\"1\":{\"231\":1}}],[\"可以明显看出\",{\"1\":{\"213\":1}}],[\"可以得到如下的输出\",{\"1\":{\"218\":1}}],[\"可以得到如下输出\",{\"1\":{\"210\":1}}],[\"可以得出\",{\"1\":{\"68\":1}}],[\"可以享受\",{\"1\":{\"210\":1}}],[\"可以表示\",{\"1\":{\"208\":1}}],[\"可以发现\",{\"1\":{\"200\":1,\"227\":1}}],[\"可以发现生产代码非常少\",{\"1\":{\"165\":1}}],[\"可以看作是系统线程的包装\",{\"1\":{\"199\":1}}],[\"可以看到在\",{\"1\":{\"294\":1}}],[\"可以看到\",{\"1\":{\"218\":1,\"227\":1,\"277\":1}}],[\"可以看到通过汇编系统调用同样实现了与\",{\"1\":{\"197\":1}}],[\"可以看到删除操作加锁比查询加锁要复杂的多\",{\"1\":{\"73\":1}}],[\"可以将\",{\"1\":{\"199\":1}}],[\"可以将其理解为主线程\",{\"1\":{\"194\":1}}],[\"可以将日志序号理解为版本\",{\"1\":{\"127\":1}}],[\"可以\",{\"1\":{\"182\":1}}],[\"可以清晰的看到泛型的作用\",{\"1\":{\"181\":1}}],[\"可以接受一个类型的参数\",{\"1\":{\"181\":1}}],[\"可以接受一切实现了\",{\"1\":{\"181\":1}}],[\"可以跳过\",{\"1\":{\"178\":1}}],[\"可以有效地减少新对象的申请\",{\"1\":{\"261\":1}}],[\"可以有\",{\"1\":{\"198\":1,\"203\":1}}],[\"可以有如下实现\",{\"1\":{\"177\":1}}],[\"可以有多个消费者\",{\"1\":{\"153\":1}}],[\"可以尽早开始实现功能\",{\"1\":{\"164\":1}}],[\"可以帮助减小改进的成本\",{\"1\":{\"164\":1}}],[\"可以帮助我们更好的理解\",{\"1\":{\"27\":1}}],[\"可以及时通过测试来回归\",{\"1\":{\"164\":1}}],[\"可以从多个\",{\"1\":{\"160\":1}}],[\"可以从故障中恢复\",{\"1\":{\"92\":1}}],[\"可以向多个\",{\"1\":{\"159\":1}}],[\"可以由生产者\",{\"1\":{\"157\":1}}],[\"可以更换\",{\"1\":{\"155\":1}}],[\"可以供后期二次扩展\",{\"1\":{\"143\":1}}],[\"可以进行投票\",{\"1\":{\"123\":1}}],[\"可以进行以下改造\",{\"1\":{\"4\":1}}],[\"可以把\",{\"1\":{\"113\":1}}],[\"可以先加共享锁\",{\"1\":{\"73\":1}}],[\"可以被淘汰\",{\"1\":{\"64\":1}}],[\"可以用于缓存页数据\",{\"1\":{\"64\":1}}],[\"可以体验一下\",{\"1\":{\"45\":1}}],[\"可以参考这里\",{\"1\":{\"13\":1}}],[\"可以直接将副本数量提升几个量级\",{\"1\":{\"8\":1}}],[\"可以创建一个\",{\"1\":{\"4\":1}}],[\"可以通过上面counterdemo\",{\"1\":{\"13\":1}}],[\"可以通过\",{\"1\":{\"4\":1,\"199\":1}}],[\"可以在\",{\"1\":{\"4\":1}}],[\"可以实现高效\",{\"1\":{\"4\":1}}],[\"可以实现高效的存储引擎\",{\"1\":{\"4\":1}}],[\"可以添加压缩机制\",{\"1\":{\"4\":1}}],[\"可以使用主备份\",{\"1\":{\"4\":1}}],[\"可以使用故障检测和恢复机制来自动检测和修复故障\",{\"1\":{\"4\":1}}],[\"可以使用备份和复制等机制来保证数据的容错性\",{\"1\":{\"4\":1}}],[\"可以使用日志\",{\"1\":{\"4\":1}}],[\"可以使用读写锁\",{\"1\":{\"4\":1}}],[\"可以使用锁机制来保证对数据的原子性访问和操作\",{\"1\":{\"4\":1}}],[\"可以使用缓存来存储最常访问的数据项\",{\"1\":{\"4\":1}}],[\"可以使用压缩算法对\",{\"1\":{\"4\":1}}],[\"可以使用类似归并排序的方式来合并多个\",{\"1\":{\"4\":1}}],[\"可以使用一种合并策略\",{\"1\":{\"4\":1}}],[\"可以使用\",{\"1\":{\"4\":2}}],[\"即终端输出的\",{\"1\":{\"286\":1}}],[\"即三次握手第二步\",{\"1\":{\"286\":1}}],[\"即子条件\",{\"1\":{\"285\":1}}],[\"即报文均被确认\",{\"1\":{\"284\":1}}],[\"即剩下可以接受且重组的字节数才是窗口大小\",{\"1\":{\"283\":1}}],[\"即是否要关闭输入数据流\",{\"1\":{\"282\":1}}],[\"即是否更改了该页数据\",{\"1\":{\"64\":1}}],[\"即没有字节被重组\",{\"1\":{\"282\":1}}],[\"即调用\",{\"1\":{\"279\":3,\"285\":1}}],[\"即调度循环\",{\"1\":{\"200\":1}}],[\"即代表运行成功\",{\"1\":{\"257\":1}}],[\"即字符串\",{\"1\":{\"257\":1}}],[\"即字段的定义\",{\"1\":{\"79\":1,\"89\":1}}],[\"即与变量首地址的偏移值\",{\"1\":{\"255\":1}}],[\"即变量名称\",{\"1\":{\"255\":1}}],[\"即局部变量的首地址\",{\"1\":{\"250\":1}}],[\"即伪寄存器\",{\"1\":{\"250\":1}}],[\"即对象图中的路径连接\",{\"1\":{\"243\":1}}],[\"即对哪张表进行全表扫描\",{\"1\":{\"79\":1}}],[\"即核心思想就在于线程缓存\",{\"1\":{\"241\":1}}],[\"即分配内存的大小\",{\"1\":{\"240\":1}}],[\"即手动管理\",{\"1\":{\"239\":1}}],[\"即解析阶段的时候\",{\"1\":{\"226\":1}}],[\"即最后的可执行代码\",{\"1\":{\"226\":1}}],[\"即在栈上的变量都是\",{\"1\":{\"243\":1}}],[\"即在\",{\"1\":{\"225\":1}}],[\"即编译器\",{\"1\":{\"219\":1}}],[\"即后面的\",{\"1\":{\"218\":1}}],[\"即先将字节码翻译为\",{\"1\":{\"218\":1}}],[\"即时编译原理虽然简单明了\",{\"1\":{\"218\":1}}],[\"即时编译的原理很简单\",{\"1\":{\"218\":1}}],[\"即时编译\",{\"0\":{\"218\":1}}],[\"即时网络断开\",{\"1\":{\"9\":1}}],[\"即上面谈到的\",{\"1\":{\"200\":1}}],[\"即上图\",{\"1\":{\"58\":1}}],[\"即栈顶\",{\"1\":{\"200\":1}}],[\"即获得了执行资源后\",{\"1\":{\"199\":1}}],[\"即一个进程\",{\"1\":{\"199\":1}}],[\"即独立的\",{\"1\":{\"194\":1}}],[\"即t和r\",{\"1\":{\"181\":1}}],[\"即视作对于架构的重构与梳理\",{\"1\":{\"164\":1}}],[\"即提取\",{\"1\":{\"164\":1}}],[\"即状态验证\",{\"1\":{\"164\":1}}],[\"即行为验证\",{\"1\":{\"164\":1}}],[\"即每个\",{\"1\":{\"158\":1}}],[\"即已经发生了快照的情况下\",{\"1\":{\"137\":1}}],[\"即已找到插入位置\",{\"1\":{\"47\":1}}],[\"即图中的\",{\"1\":{\"136\":2}}],[\"即图中公式的downstream\",{\"1\":{\"10\":1}}],[\"即更新超时心跳时间\",{\"1\":{\"129\":1}}],[\"即领导者最后一个日志序号+1\",{\"1\":{\"129\":1}}],[\"即序号为\",{\"1\":{\"127\":1}}],[\"即将\",{\"1\":{\"127\":1,\"218\":1,\"227\":1}}],[\"即将数据持久地写入磁盘\",{\"1\":{\"4\":1}}],[\"即无日志同步\",{\"1\":{\"126\":1}}],[\"即节点被创建后会一直运行\",{\"1\":{\"124\":1}}],[\"即当前请求共享锁的事务实例\",{\"1\":{\"88\":1}}],[\"即当前插入位置字符的\",{\"1\":{\"25\":1}}],[\"即死锁\",{\"1\":{\"87\":1}}],[\"即事务本身觉得是序列化执行的\",{\"1\":{\"86\":1}}],[\"即执行器上下文\",{\"1\":{\"79\":1}}],[\"即根节点\",{\"1\":{\"68\":1}}],[\"即必须在originleft和originright之间\",{\"1\":{\"48\":1}}],[\"即item的插入位置\",{\"1\":{\"47\":1}}],[\"即item列表\",{\"1\":{\"47\":1}}],[\"即文档内容是一致的\",{\"1\":{\"43\":1}}],[\"即ok​\",{\"1\":{\"44\":1}}],[\"即origin2​≤origin1​\",{\"1\":{\"43\":1}}],[\"即o1​<origin2​\",{\"1\":{\"43\":1}}],[\"即operations\",{\"1\":{\"35\":1}}],[\"即opset\",{\"1\":{\"28\":1}}],[\"即op类型\",{\"1\":{\"13\":1}}],[\"即不会出现这样的情况\",{\"1\":{\"43\":1}}],[\"即不可能存在o1​<c​oi​<c​o2​\",{\"1\":{\"43\":1}}],[\"即满足o1​<c​o2​\",{\"1\":{\"43\":1}}],[\"即可以通过\",{\"1\":{\"206\":1}}],[\"即可完成整个rpc调用链路\",{\"1\":{\"144\":1}}],[\"即可\",{\"1\":{\"105\":1,\"164\":1,\"219\":2,\"238\":1,\"240\":1,\"243\":1,\"283\":1}}],[\"即可得到有序的文档内容\",{\"1\":{\"43\":1}}],[\"即可实现多端协同\",{\"1\":{\"9\":1}}],[\"即插入origin\",{\"1\":{\"51\":1}}],[\"即插入一个新的item\",{\"1\":{\"36\":1}}],[\"即插入位置前一项\",{\"1\":{\"28\":1}}],[\"即multilwwregister\",{\"1\":{\"18\":1}}],[\"即client1\",{\"1\":{\"13\":1}}],[\"即clientid\",{\"1\":{\"13\":1}}],[\"即增加或减少的值\",{\"1\":{\"13\":1}}],[\"即增加或减少\",{\"1\":{\"13\":1}}],[\"即计数器的值\",{\"1\":{\"13\":1}}],[\"即\",{\"1\":{\"11\":1,\"25\":3,\"43\":1,\"44\":1,\"48\":1,\"79\":1,\"122\":1,\"124\":2,\"127\":2,\"136\":2,\"181\":1,\"183\":1,\"194\":1,\"197\":1,\"198\":1,\"200\":7,\"203\":1,\"208\":1,\"227\":1,\"252\":2,\"256\":1,\"257\":1,\"262\":1,\"283\":3,\"285\":3,\"286\":1}}],[\"即n\",{\"1\":{\"10\":1}}],[\"即数据的状态\",{\"1\":{\"10\":1}}],[\"即用户对数据的操作\",{\"1\":{\"10\":1}}],[\"即任意副本最终都能达到一致\",{\"1\":{\"10\":1}}],[\"即使是虚拟机也不多见\",{\"1\":{\"294\":1}}],[\"即使二者不在栈中\",{\"1\":{\"243\":1}}],[\"即使手动去调用\",{\"1\":{\"238\":1}}],[\"即使速度差距如此之大\",{\"1\":{\"231\":1}}],[\"即使\",{\"1\":{\"227\":1,\"238\":1}}],[\"即使测试环境下\",{\"1\":{\"164\":1}}],[\"即使编辑从双端扩展到多端\",{\"1\":{\"9\":1}}],[\"即使这些操作到达时是乱序的\",{\"1\":{\"8\":1}}],[\"即系统能够持续地提供服务\",{\"1\":{\"4\":1}}],[\"即需要通过\",{\"1\":{\"4\":1}}],[\"不应该\",{\"1\":{\"285\":1}}],[\"不填充\",{\"1\":{\"284\":1}}],[\"不算\",{\"1\":{\"283\":2}}],[\"不含\",{\"1\":{\"282\":1}}],[\"不稳定\",{\"1\":{\"236\":1}}],[\"不熟悉的同学\",{\"1\":{\"231\":1}}],[\"不为\",{\"1\":{\"225\":2}}],[\"不为空\",{\"1\":{\"28\":1}}],[\"不一样的认识\",{\"1\":{\"214\":1}}],[\"不要受到语言本身的限制\",{\"1\":{\"214\":1}}],[\"不提倡的\",{\"1\":{\"214\":1}}],[\"不使用\",{\"1\":{\"212\":1}}],[\"不影响对流程的学习\",{\"1\":{\"200\":1}}],[\"不用再确认\",{\"1\":{\"284\":1}}],[\"不用发送\",{\"1\":{\"284\":1}}],[\"不用去兼容老的代码逻辑\",{\"1\":{\"181\":1}}],[\"不用分裂\",{\"1\":{\"71\":1}}],[\"不是灰色栈\",{\"1\":{\"244\":1}}],[\"不是\",{\"1\":{\"241\":1}}],[\"不是一种写代码方法\",{\"1\":{\"164\":1}}],[\"不是根节点\",{\"1\":{\"71\":1}}],[\"不符合预期\",{\"1\":{\"162\":1}}],[\"不上升高级功能\",{\"1\":{\"152\":1}}],[\"不推荐造轮子\",{\"1\":{\"139\":1}}],[\"不再\",{\"1\":{\"262\":1}}],[\"不再引用\",{\"1\":{\"243\":1}}],[\"不再指向\",{\"1\":{\"243\":1}}],[\"不再指望一次性完成需求\",{\"1\":{\"164\":1}}],[\"不再是\",{\"1\":{\"243\":1}}],[\"不再进入\",{\"1\":{\"217\":1}}],[\"不再适合作为一个原型产品进行学习与实践\",{\"1\":{\"152\":1}}],[\"不再靠领导者一点点试探\",{\"1\":{\"134\":1}}],[\"不再使用\",{\"1\":{\"64\":1,\"219\":1}}],[\"不断的试探\",{\"1\":{\"129\":1,\"134\":1}}],[\"不断地向集群其它节点发号施令\",{\"1\":{\"123\":1}}],[\"不断地向追随者发送号令\",{\"1\":{\"122\":1}}],[\"不对\",{\"1\":{\"121\":1}}],[\"不够熟练的情况下\",{\"1\":{\"96\":1}}],[\"不可直接写入字节流\",{\"1\":{\"282\":1}}],[\"不可在使用之后再复制使用\",{\"1\":{\"261\":1}}],[\"不可抢占等\",{\"1\":{\"200\":1}}],[\"不可抢占\",{\"1\":{\"200\":1}}],[\"不可写\",{\"1\":{\"86\":1}}],[\"不可重复读\",{\"1\":{\"84\":3}}],[\"不可能为负\",{\"1\":{\"64\":1}}],[\"不安全\",{\"1\":{\"73\":1}}],[\"不满足循环条件\",{\"1\":{\"227\":1}}],[\"不满足条件为止\",{\"1\":{\"227\":2}}],[\"不满足\",{\"1\":{\"227\":2}}],[\"不满足于自己现在状态\",{\"1\":{\"124\":1}}],[\"不满足半满性质\",{\"1\":{\"72\":2}}],[\"不满足则跳出循环\",{\"1\":{\"47\":1}}],[\"不能立马关闭\",{\"1\":{\"282\":1}}],[\"不能超过\",{\"1\":{\"281\":1}}],[\"不能写\",{\"1\":{\"183\":1}}],[\"不能对类进行代理\",{\"1\":{\"144\":1}}],[\"不能提交其它任期日志\",{\"1\":{\"134\":1}}],[\"不能加读锁后\",{\"1\":{\"89\":1}}],[\"不能访问\",{\"1\":{\"86\":1}}],[\"不能删除\",{\"1\":{\"64\":2}}],[\"不能插入新的item\",{\"1\":{\"37\":1}}],[\"不存在\",{\"1\":{\"64\":1}}],[\"不存在则调用文件管理器读取对应页然后再返回\",{\"1\":{\"58\":1}}],[\"不受淘汰约束\",{\"1\":{\"63\":1}}],[\"不支持消费者组\",{\"1\":{\"153\":1}}],[\"不支持代理集群自动切换等高级功能\",{\"1\":{\"110\":1}}],[\"不支持除5\",{\"1\":{\"110\":1}}],[\"不支持\",{\"1\":{\"103\":1}}],[\"不支持富文本\",{\"1\":{\"49\":1}}],[\"不支持中文\",{\"1\":{\"24\":1,\"45\":1}}],[\"不好理解\",{\"1\":{\"43\":1}}],[\"不会重发所有报文\",{\"1\":{\"284\":1}}],[\"不会将对象直接\",{\"1\":{\"262\":1}}],[\"不会尝试去回收它\",{\"1\":{\"238\":1}}],[\"不会介绍地址空间之下的内容\",{\"1\":{\"231\":1}}],[\"不会初始化\",{\"1\":{\"217\":1}}],[\"不会涉及到任何中间件\",{\"1\":{\"165\":1}}],[\"不会从日志切片中间截断\",{\"1\":{\"136\":1}}],[\"不会更新\",{\"1\":{\"98\":1}}],[\"不会发生重组\",{\"1\":{\"73\":1}}],[\"不会再淘汰\",{\"1\":{\"64\":1}}],[\"不会改变\",{\"1\":{\"43\":1}}],[\"不会生成新的operation\",{\"1\":{\"32\":1}}],[\"不同于上面提到的汇编方言\",{\"1\":{\"219\":1}}],[\"不同于二叉树\",{\"1\":{\"68\":1}}],[\"不同类型\",{\"1\":{\"180\":1}}],[\"不同任期的选票不能使用\",{\"1\":{\"124\":1}}],[\"不同级别又是如何实现\",{\"1\":{\"56\":1}}],[\"不同\",{\"1\":{\"35\":1}}],[\"不同的场景下有不同的分配算法实现\",{\"1\":{\"237\":1}}],[\"不同的是进程独有自己的资源和地址空间\",{\"1\":{\"199\":1}}],[\"不同的查询计划对应不同的执行器\",{\"1\":{\"79\":1}}],[\"不同的\",{\"1\":{\"4\":1,\"158\":1}}],[\"不包括根节点\",{\"1\":{\"26\":1}}],[\"不过它的实现略有不同\",{\"1\":{\"263\":1}}],[\"不过这些算法都不够好用\",{\"1\":{\"240\":1}}],[\"不过快照最终都是由上层应用来触发\",{\"1\":{\"138\":1}}],[\"不过只需记住一条黄金铁律即可\",{\"1\":{\"133\":1}}],[\"不过需要注意以下两点\",{\"1\":{\"63\":1}}],[\"不过\",{\"1\":{\"23\":1,\"261\":1}}],[\"不过达成一致的方式不同\",{\"1\":{\"10\":1}}],[\"不仅可以减少业务的耗时\",{\"1\":{\"260\":1}}],[\"不仅仅只在内核态运行\",{\"1\":{\"199\":1}}],[\"不仅能兼容支持\",{\"1\":{\"117\":1}}],[\"不仅适用于有序文本\",{\"1\":{\"23\":1}}],[\"不仅如此\",{\"1\":{\"9\":1,\"219\":1}}],[\"不利于在分布式环境下扩展\",{\"1\":{\"8\":1}}],[\"不吃这一套\",{\"1\":{\"4\":1}}],[\"树后\",{\"1\":{\"219\":1}}],[\"树翻译为\",{\"1\":{\"219\":1}}],[\"树为空\",{\"1\":{\"70\":1}}],[\"树就可以用于存储\",{\"1\":{\"69\":1}}],[\"树可以拥有多个子节点\",{\"1\":{\"68\":1}}],[\"树有三个节点\",{\"1\":{\"68\":1}}],[\"树有且只有一个节点\",{\"1\":{\"68\":1}}],[\"树\",{\"1\":{\"4\":1,\"219\":1,\"227\":1}}],[\"树实现\",{\"1\":{\"4\":1}}],[\"树中值的类型\",{\"1\":{\"69\":1}}],[\"树中键的类型\",{\"1\":{\"69\":1}}],[\"树中的数据\",{\"1\":{\"68\":1}}],[\"树中检索\",{\"1\":{\"4\":2}}],[\"树中删除\",{\"1\":{\"4\":2}}],[\"树中添加合并\",{\"1\":{\"4\":1}}],[\"树中\",{\"1\":{\"4\":3}}],[\"树的内部是内部节点\",{\"1\":{\"68\":1}}],[\"树的底部是叶子结点\",{\"1\":{\"68\":1}}],[\"树的基本读写伪代码的完整示例\",{\"1\":{\"4\":1}}],[\"树的基本思想和操作\",{\"1\":{\"4\":1}}],[\"树的主要实现\",{\"1\":{\"4\":1}}],[\"树的设计和实现需要综合考虑以上各种因素\",{\"1\":{\"4\":1}}],[\"树的存储引擎需要综合考虑各种因素\",{\"1\":{\"4\":1}}],[\"树的存储引擎原型\",{\"1\":{\"4\":1}}],[\"树的数据结构\",{\"1\":{\"4\":1}}],[\"写个简单的程序来调用一下\",{\"1\":{\"294\":1}}],[\"写代码时无需关注内存的回收问题\",{\"1\":{\"238\":1}}],[\"写出测试良好的代码\",{\"1\":{\"168\":1}}],[\"写起来很容易卡壳\",{\"1\":{\"168\":1}}],[\"写完代码后自测思考\",{\"1\":{\"162\":1}}],[\"写技术方案时思考\",{\"1\":{\"162\":1}}],[\"写命中率\",{\"1\":{\"98\":1}}],[\"写文件\",{\"1\":{\"98\":1}}],[\"写文件序号\",{\"1\":{\"98\":1}}],[\"写一条消息\",{\"1\":{\"98\":1}}],[\"写元数据\",{\"1\":{\"98\":1}}],[\"写偏移\",{\"1\":{\"98\":1}}],[\"写\",{\"1\":{\"97\":1}}],[\"写消费指针\",{\"1\":{\"97\":1,\"98\":1,\"99\":1}}],[\"写锁\",{\"1\":{\"89\":2}}],[\"写到这里\",{\"1\":{\"246\":1}}],[\"写到\",{\"1\":{\"64\":1}}],[\"写操作\",{\"1\":{\"4\":3}}],[\"写操作需要保证数据的持久性\",{\"1\":{\"4\":1}}],[\"写入策略\",{\"1\":{\"4\":1}}],[\"写入磁盘\",{\"1\":{\"4\":1}}],[\"写入操作\",{\"1\":{\"4\":1}}],[\"直面上感受不到系统调用的发生\",{\"1\":{\"197\":1}}],[\"直观上\",{\"1\":{\"238\":1}}],[\"直观\",{\"1\":{\"147\":1}}],[\"直连代理节点\",{\"1\":{\"102\":1}}],[\"直至试出匹配值\",{\"1\":{\"129\":1,\"134\":1}}],[\"直至寻找到包含\",{\"1\":{\"73\":1}}],[\"直至无需分裂后返回\",{\"1\":{\"71\":1}}],[\"直至找到item的插入位置\",{\"1\":{\"47\":1}}],[\"直至找到满足规则\",{\"1\":{\"44\":1}}],[\"直到无包可发送\",{\"1\":{\"284\":1}}],[\"直到栈中再无灰色对象\",{\"1\":{\"244\":1}}],[\"直到不满足为止\",{\"1\":{\"227\":1}}],[\"直到所有功能完成\",{\"1\":{\"164\":1}}],[\"直到重试次数超过了阈值\",{\"1\":{\"150\":1}}],[\"直到节点被\",{\"1\":{\"125\":1}}],[\"直到满足半满为止\",{\"1\":{\"72\":1}}],[\"直到item\",{\"1\":{\"51\":1}}],[\"直到找到对应的值或遍历完为止\",{\"1\":{\"4\":1}}],[\"直到找到为止\",{\"1\":{\"4\":3}}],[\"直到找到或者找完所有文件为止\",{\"1\":{\"4\":1}}],[\"直接通过\",{\"1\":{\"292\":1}}],[\"直接抵消了\",{\"1\":{\"283\":1}}],[\"直接丢弃\",{\"1\":{\"262\":1}}],[\"直接运行\",{\"1\":{\"257\":1}}],[\"直接跳过\",{\"1\":{\"254\":1}}],[\"直接设置\",{\"1\":{\"243\":1}}],[\"直接插入回\",{\"1\":{\"241\":1}}],[\"直接分配的\",{\"1\":{\"241\":1}}],[\"直接向进程要内存\",{\"1\":{\"238\":1}}],[\"直接向bytebuf中写入5个字段即可\",{\"1\":{\"146\":1}}],[\"直接置为\",{\"1\":{\"238\":1}}],[\"直接新建对象即可\",{\"1\":{\"238\":1}}],[\"直接进入\",{\"1\":{\"227\":1}}],[\"直接操作\",{\"1\":{\"207\":1}}],[\"直接影响测试编写难度和测试维护成本\",{\"1\":{\"165\":1}}],[\"直接集成了\",{\"1\":{\"153\":1}}],[\"直接拒绝即可\",{\"1\":{\"136\":1}}],[\"直接回退\",{\"1\":{\"129\":1,\"134\":1}}],[\"直接退出\",{\"1\":{\"129\":1}}],[\"直接使用\",{\"1\":{\"110\":1}}],[\"直接将链表尾部页淘汰即可\",{\"1\":{\"63\":1}}],[\"直接break\",{\"1\":{\"51\":1}}],[\"直接\",{\"1\":{\"44\":1,\"89\":2,\"282\":1,\"283\":1}}],[\"直接返回\",{\"1\":{\"37\":1,\"64\":2,\"70\":1,\"71\":2,\"72\":1,\"79\":1,\"88\":1,\"89\":1,\"129\":1,\"284\":1}}],[\"直接传输状态即可\",{\"1\":{\"14\":1}}],[\"直接继续\",{\"1\":{\"4\":1}}],[\"直接干翻很多垃圾资料书\",{\"1\":{\"4\":1}}],[\"也应该调用\",{\"1\":{\"285\":1}}],[\"也无需确认\",{\"1\":{\"285\":1}}],[\"也无法满足半满性质\",{\"1\":{\"72\":1}}],[\"也懒得重构\",{\"1\":{\"283\":1}}],[\"也伴随着数据\",{\"1\":{\"283\":1}}],[\"也使功能迭代和完善更加方便\",{\"1\":{\"279\":1}}],[\"也使用了类似方案\",{\"1\":{\"117\":1}}],[\"也提供了一个通用的数据库连接池\",{\"1\":{\"263\":1}}],[\"也在大量使用\",{\"1\":{\"263\":1}}],[\"也踩了这个坑\",{\"1\":{\"262\":1}}],[\"也没法通过扫描找到的对象\",{\"1\":{\"243\":1}}],[\"也没有\",{\"1\":{\"283\":1}}],[\"也没有选择\",{\"1\":{\"248\":1}}],[\"也没有真正的发生\",{\"1\":{\"238\":1}}],[\"也没有加写锁\",{\"1\":{\"89\":1}}],[\"也因此\",{\"1\":{\"231\":1}}],[\"也称主存\",{\"1\":{\"231\":1}}],[\"也对应了两次\",{\"1\":{\"218\":1}}],[\"也能找到对应的\",{\"1\":{\"241\":1}}],[\"也能让程序员朝九晚五的工作\",{\"1\":{\"238\":1}}],[\"也能达到申请堆内存的效果\",{\"1\":{\"237\":1}}],[\"也能减少使用者的信息负载\",{\"1\":{\"206\":1}}],[\"也能保证不同客户端的操作\",{\"1\":{\"13\":1}}],[\"也只需给t添加一个新的类型约束即可\",{\"1\":{\"179\":1}}],[\"也就不会初始化\",{\"1\":{\"217\":1}}],[\"也就\",{\"1\":{\"165\":1}}],[\"也就是本文后面所实现的\",{\"1\":{\"278\":1}}],[\"也就是上面谈到的\",{\"1\":{\"242\":1}}],[\"也就是\",{\"1\":{\"200\":1,\"212\":1,\"218\":1,\"261\":1}}],[\"也就是进程\",{\"1\":{\"200\":1}}],[\"也就是进一步将可验证的里程碑点\",{\"1\":{\"164\":1}}],[\"也就是常说的\",{\"1\":{\"199\":1}}],[\"也就是我们通常意义上理解的协程\",{\"1\":{\"199\":1}}],[\"也就是将需求转化为一系列可验证的里程碑点\",{\"1\":{\"164\":1}}],[\"也就是说\",{\"1\":{\"164\":1}}],[\"也正因如此才能收获颇丰\",{\"1\":{\"139\":1}}],[\"也拒绝还未提交的\",{\"1\":{\"136\":1}}],[\"也要发送\",{\"1\":{\"126\":1}}],[\"也直接返回\",{\"1\":{\"124\":1}}],[\"也被嵌入到单值键值对的键当中\",{\"1\":{\"116\":1}}],[\"也可按字节分配小内存\",{\"1\":{\"232\":1}}],[\"也可理解为心跳\",{\"1\":{\"124\":1}}],[\"也可理解为查询条件\",{\"1\":{\"79\":1}}],[\"也可以使用\",{\"1\":{\"281\":1}}],[\"也可以使用专用的缓存服务器\",{\"1\":{\"4\":1}}],[\"也可以建立在\",{\"1\":{\"278\":1}}],[\"也可以是\",{\"1\":{\"275\":1}}],[\"也可以调整\",{\"1\":{\"200\":1}}],[\"也可以理解为主线程\",{\"1\":{\"199\":1}}],[\"也可以为float64类型\",{\"1\":{\"179\":1}}],[\"也可以将序列化\",{\"1\":{\"151\":1}}],[\"也可以通过\",{\"1\":{\"85\":1}}],[\"也可以看作索引的名称\",{\"1\":{\"69\":1}}],[\"也可以作为叶子节点\",{\"1\":{\"68\":1}}],[\"也不会产生内存的安全问题\",{\"1\":{\"238\":1}}],[\"也不会造成内存安全问题\",{\"1\":{\"234\":1}}],[\"也不会更新\",{\"1\":{\"98\":1}}],[\"也不一定能保证测试通过\",{\"1\":{\"164\":1}}],[\"也不能升级\",{\"1\":{\"85\":1}}],[\"也不安全\",{\"1\":{\"73\":1}}],[\"也不满足半满的性质\",{\"1\":{\"72\":1}}],[\"也不复杂\",{\"1\":{\"63\":1}}],[\"也作为\",{\"1\":{\"71\":1}}],[\"也必须分裂\",{\"1\":{\"71\":1}}],[\"也谈到了\",{\"1\":{\"71\":1}}],[\"也有不适合的场景\",{\"1\":{\"261\":1}}],[\"也有\",{\"1\":{\"68\":1}}],[\"也有两种实现方式\",{\"1\":{\"15\":1}}],[\"也会有一个固定的\",{\"1\":{\"241\":1}}],[\"也会造成内存浪费\",{\"1\":{\"240\":1}}],[\"也会从磁盘中读取数据页到内存\",{\"1\":{\"64\":1}}],[\"也会调用\",{\"1\":{\"63\":1}}],[\"也增加了originright的判断条件\",{\"1\":{\"48\":1}}],[\"也即是\",{\"1\":{\"28\":1}}],[\"也是一个基于字节流的网络协议\",{\"1\":{\"281\":1}}],[\"也是需要占内存的\",{\"1\":{\"240\":1}}],[\"也是内存管理的主战场\",{\"1\":{\"232\":1}}],[\"也是可以直接优化的\",{\"1\":{\"218\":1}}],[\"也是工程师素养的重中之重\",{\"1\":{\"150\":1}}],[\"也是必须的\",{\"1\":{\"64\":1}}],[\"也是数据设计的主要目标\",{\"1\":{\"62\":1}}],[\"也是\",{\"1\":{\"23\":1,\"244\":1}}],[\"也是以后工业级\",{\"1\":{\"11\":1}}],[\"也需要支持如下功能\",{\"1\":{\"145\":1}}],[\"也需要\",{\"1\":{\"18\":1}}],[\"也别忘记在set变更值时\",{\"1\":{\"17\":1}}],[\"也基本一致\",{\"1\":{\"16\":1}}],[\"也更加符合工程师视角\",{\"1\":{\"3\":1}}],[\"压缩算法可以选择一种高效的压缩方法\",{\"1\":{\"4\":1}}],[\"压缩操作可以在合并操作中进行\",{\"1\":{\"4\":1}}],[\"压缩操作\",{\"1\":{\"4\":1}}],[\"或芝加哥学派\",{\"1\":{\"164\":1}}],[\"或心跳\",{\"1\":{\"129\":1}}],[\"或更新\",{\"1\":{\"58\":1}}],[\"或者调试内核\",{\"1\":{\"291\":1}}],[\"或者被析构\",{\"1\":{\"285\":1}}],[\"或者实现机制可以参考这里\",{\"1\":{\"237\":1}}],[\"或者几\",{\"1\":{\"231\":1}}],[\"或者直接去阅读\",{\"1\":{\"218\":1}}],[\"或者激进一点\",{\"1\":{\"165\":1}}],[\"或者突然宕机\",{\"1\":{\"150\":1}}],[\"或者其它触发情况\",{\"1\":{\"136\":1}}],[\"或者任期不一致\",{\"1\":{\"129\":1}}],[\"或者已经\",{\"1\":{\"284\":1}}],[\"或者已经给请求者投过票\",{\"1\":{\"124\":1}}],[\"或者已经包含了\",{\"1\":{\"63\":1}}],[\"或者当前锁请求与队列中的其它锁兼容\",{\"1\":{\"88\":1}}],[\"或者当前表记录\",{\"1\":{\"79\":1}}],[\"或者阻塞事务执行\",{\"1\":{\"86\":1}}],[\"或者阻塞事物\",{\"1\":{\"85\":1}}],[\"或者升级\",{\"1\":{\"86\":1}}],[\"或者协议\",{\"1\":{\"73\":1}}],[\"或者将\",{\"1\":{\"72\":1}}],[\"或者从磁盘读数据页\",{\"1\":{\"58\":1}}],[\"或者\",{\"1\":{\"43\":1,\"44\":1,\"69\":1,\"72\":1,\"227\":2,\"231\":1,\"234\":2,\"243\":1,\"282\":1,\"284\":1,\"291\":1}}],[\"或者时间戳相等但\",{\"1\":{\"18\":1}}],[\"或者使用\",{\"1\":{\"4\":2,\"217\":1}}],[\"或者可以单独执行\",{\"1\":{\"4\":1}}],[\"或分布式复制等机制来提高系统的可用性\",{\"1\":{\"4\":1}}],[\"或\",{\"1\":{\"4\":2}}],[\"或根据\",{\"1\":{\"4\":1}}],[\"并添加如下内容\",{\"1\":{\"291\":1}}],[\"并关闭连接\",{\"1\":{\"285\":1}}],[\"并填充到报文中\",{\"1\":{\"285\":1}}],[\"并放入自己的队列\",{\"1\":{\"285\":1}}],[\"并做如下处理\",{\"1\":{\"285\":1}}],[\"并设置到\",{\"1\":{\"284\":1}}],[\"并设置为\",{\"1\":{\"134\":1}}],[\"并与\",{\"1\":{\"283\":1}}],[\"并重组后交给应用程序\",{\"1\":{\"279\":1}}],[\"并领略它的风采\",{\"1\":{\"277\":1}}],[\"并能在新的地方使用合适的池化方案\",{\"1\":{\"265\":1}}],[\"并能解锁\",{\"1\":{\"89\":1}}],[\"并入栈\",{\"1\":{\"244\":1}}],[\"并加入\",{\"1\":{\"294\":1}}],[\"并加入全局链表\",{\"1\":{\"243\":1}}],[\"并加上如下内容\",{\"1\":{\"207\":1}}],[\"并赋值给\",{\"1\":{\"218\":1}}],[\"并生成\",{\"1\":{\"217\":1}}],[\"并生成新的\",{\"1\":{\"4\":1}}],[\"并生成新的sstable对象\",{\"1\":{\"4\":1}}],[\"并自带\",{\"1\":{\"217\":1}}],[\"并深入地看看了它的源码\",{\"1\":{\"216\":1}}],[\"并用\",{\"1\":{\"213\":1}}],[\"并看看二者之间的性能差异\",{\"1\":{\"213\":1}}],[\"并运行\",{\"1\":{\"212\":1,\"232\":1}}],[\"并新建\",{\"1\":{\"200\":1}}],[\"并同时运行多个\",{\"1\":{\"198\":1}}],[\"并对外暴露\",{\"1\":{\"277\":1}}],[\"并对每一个数据项进行处理\",{\"1\":{\"189\":1}}],[\"并对子节点加上共享锁后\",{\"1\":{\"73\":1}}],[\"并向服务器发送\",{\"1\":{\"286\":1}}],[\"并向\",{\"1\":{\"188\":1}}],[\"并得到\",{\"1\":{\"174\":1}}],[\"并作为查询数据库数据的代理\",{\"1\":{\"164\":1}}],[\"并以测试来驱动子任务实现\",{\"1\":{\"164\":1}}],[\"并以此支持多数据类型\",{\"1\":{\"51\":1}}],[\"并返回退出码\",{\"1\":{\"217\":1}}],[\"并返回消息列表\",{\"1\":{\"160\":1}}],[\"并返回成功\",{\"1\":{\"159\":1}}],[\"并调用\",{\"1\":{\"159\":1,\"219\":1}}],[\"并调用integrate函数将其插入到content中\",{\"1\":{\"47\":1}}],[\"并融入spring的庞大生态\",{\"1\":{\"151\":1}}],[\"并没有什么高深莫测的技术\",{\"1\":{\"278\":1}}],[\"并没有立即回收\",{\"1\":{\"238\":1}}],[\"并没有立即更新\",{\"1\":{\"136\":1}}],[\"并没有考虑并发控制\",{\"1\":{\"4\":2}}],[\"并切截断日志切片\",{\"1\":{\"136\":1}}],[\"并持久化快照\",{\"1\":{\"136\":1}}],[\"并遍历日志找到第一个有任期冲突的日志序号\",{\"1\":{\"134\":1}}],[\"并\",{\"1\":{\"131\":1,\"200\":1}}],[\"并迅速做出重新选举的反应\",{\"1\":{\"125\":1}}],[\"并在超时后重新发送\",{\"1\":{\"284\":1}}],[\"并在程序编译的时候将\",{\"1\":{\"225\":1}}],[\"并在\",{\"1\":{\"217\":1}}],[\"并在成功后回调\",{\"1\":{\"159\":1}}],[\"并在函数中对请求结果进行处理\",{\"1\":{\"124\":1}}],[\"并在需要时执行合并操作\",{\"1\":{\"4\":1}}],[\"并给自己投票\",{\"1\":{\"123\":2}}],[\"并给出了诸多基础\",{\"1\":{\"8\":1}}],[\"并开始选举操作\",{\"1\":{\"123\":1}}],[\"并实时同步\",{\"1\":{\"123\":1}}],[\"并存\",{\"1\":{\"103\":1}}],[\"并提供\",{\"1\":{\"277\":1}}],[\"并提供了\",{\"1\":{\"264\":1}}],[\"并提供兼容\",{\"1\":{\"103\":1}}],[\"并提交了\",{\"1\":{\"86\":1}}],[\"并通过重组器\",{\"1\":{\"279\":1}}],[\"并通过了单测\",{\"1\":{\"212\":1}}],[\"并通过\",{\"1\":{\"94\":1,\"124\":2,\"136\":1,\"218\":1,\"283\":1}}],[\"并通过判断节点是否安全来决定是否释放祖先节点上的锁\",{\"1\":{\"73\":1}}],[\"并启动一个后台线程专门用于检查事务之间的依赖关系\",{\"1\":{\"88\":1}}],[\"并决定如何打破它\",{\"1\":{\"87\":1}}],[\"并包装为表记录返回给执行引擎\",{\"1\":{\"79\":1}}],[\"并不会发包\",{\"1\":{\"285\":1}}],[\"并不会直接回收\",{\"1\":{\"262\":1}}],[\"并不会真正的去解析\",{\"1\":{\"164\":1}}],[\"并不断调用\",{\"1\":{\"78\":1}}],[\"并不单单指数据查询\",{\"1\":{\"77\":1}}],[\"并获取查询结果\",{\"1\":{\"78\":1}}],[\"并释放锁\",{\"1\":{\"73\":1}}],[\"并插入\",{\"1\":{\"71\":1}}],[\"并刷回磁盘\",{\"1\":{\"64\":1}}],[\"并刷到磁盘中\",{\"1\":{\"63\":1}}],[\"并从中删除\",{\"1\":{\"72\":1}}],[\"并从磁盘中读取新页\",{\"1\":{\"64\":1}}],[\"并从哈希表中删除\",{\"1\":{\"63\":1}}],[\"并增加\",{\"1\":{\"64\":1}}],[\"并写入哈希表供快速查询\",{\"1\":{\"63\":1}}],[\"并写入磁盘\",{\"1\":{\"4\":1}}],[\"并发送给远端\",{\"1\":{\"279\":1}}],[\"并发输出的时候\",{\"1\":{\"261\":1}}],[\"并发起请求\",{\"1\":{\"145\":1}}],[\"并发访问控制和数据库事务的\",{\"1\":{\"82\":1}}],[\"并发访问索引是极其常见的\",{\"1\":{\"73\":1}}],[\"并发的\",{\"1\":{\"74\":1}}],[\"并发b+树\",{\"0\":{\"66\":1}}],[\"并发\",{\"0\":{\"67\":1},\"1\":{\"59\":1}}],[\"并发控制\",{\"0\":{\"81\":1,\"82\":1},\"1\":{\"4\":1,\"59\":2}}],[\"并参考\",{\"1\":{\"38\":1}}],[\"并应用后\",{\"1\":{\"25\":1}}],[\"并且已经全部发送到对端\",{\"1\":{\"285\":1}}],[\"并且涉及到不同的连接关闭方式\",{\"1\":{\"285\":1}}],[\"并且关闭连接\",{\"1\":{\"285\":1}}],[\"并且调用\",{\"1\":{\"285\":1}}],[\"并且永久关闭连接\",{\"1\":{\"285\":1}}],[\"并且推出队列\",{\"1\":{\"284\":1}}],[\"并且打包后直接发送\",{\"1\":{\"284\":1}}],[\"并且查询字节数量不能超过当前缓冲区字节的数量\",{\"1\":{\"281\":1}}],[\"并且可以复用\",{\"1\":{\"261\":1}}],[\"并且在不需要的时候回收掉\",{\"1\":{\"261\":1}}],[\"并且头部中还有一个\",{\"1\":{\"240\":1}}],[\"并且按需使用\",{\"1\":{\"238\":1}}],[\"并且让普通人开始着手写代码\",{\"1\":{\"235\":1}}],[\"并且适合程序进行分析和优化\",{\"1\":{\"218\":1}}],[\"并且通过反射的机制来拿到字节切片中的\",{\"1\":{\"208\":1}}],[\"并且完成加法\",{\"1\":{\"179\":1}}],[\"并且每次都需要类型断言\",{\"1\":{\"179\":1}}],[\"并且传入参数为\",{\"1\":{\"164\":1}}],[\"并且候选人的日志至少和自己一样新\",{\"1\":{\"130\":1}}],[\"并且根据\",{\"1\":{\"129\":1}}],[\"并且开始日志同步\",{\"1\":{\"129\":1}}],[\"并且任期为\",{\"1\":{\"124\":1}}],[\"并且设置\",{\"1\":{\"123\":1}}],[\"并且设置指向子节点的指针\",{\"1\":{\"71\":1}}],[\"并且也带有版本信息和剩余存活时间\",{\"1\":{\"116\":1}}],[\"并且发生了环等待\",{\"1\":{\"87\":1}}],[\"并且尽可能的提高并发性能\",{\"1\":{\"73\":1}}],[\"并且更新\",{\"1\":{\"72\":1,\"129\":1,\"136\":1,\"281\":1}}],[\"并且更新父节点\",{\"1\":{\"72\":1}}],[\"并且能够一直保持完美的自平衡\",{\"1\":{\"68\":1}}],[\"并且页最后能否被删除取决于\",{\"1\":{\"64\":1}}],[\"并且不会改变\",{\"1\":{\"43\":1}}],[\"并且保证最后的结果不会存在冲突\",{\"1\":{\"9\":1}}],[\"并且\",{\"1\":{\"8\":1,\"71\":1,\"264\":1}}],[\"并且它们可能具有不同的值\",{\"1\":{\"4\":1}}],[\"并使用\",{\"1\":{\"4\":1}}],[\"并按照键的顺序进行排序\",{\"1\":{\"4\":1}}],[\"并按照键的顺序排序\",{\"1\":{\"4\":1}}],[\"并将报文数据\",{\"1\":{\"283\":1}}],[\"并将报文中的\",{\"1\":{\"279\":2}}],[\"并将流数据交付给应用程序\",{\"1\":{\"279\":1}}],[\"并将字节流写入到\",{\"1\":{\"279\":1}}],[\"并将接收到的报文交给\",{\"1\":{\"279\":1}}],[\"并将结果返回\",{\"1\":{\"218\":1}}],[\"并将结果写入新的更大的\",{\"1\":{\"4\":1}}],[\"并将\",{\"1\":{\"200\":1,\"240\":1}}],[\"并将其包装成报文并发送\",{\"1\":{\"279\":1}}],[\"并将其切到\",{\"1\":{\"224\":1}}],[\"并将其加入到哈希表中方便后续查找\",{\"1\":{\"219\":1}}],[\"并将其翻译为\",{\"1\":{\"219\":1}}],[\"并将其转化为\",{\"1\":{\"106\":1}}],[\"并将其添加到进行中的事务字典中\",{\"1\":{\"4\":1}}],[\"并将其添加到\",{\"1\":{\"4\":1}}],[\"并将淘汰页的\",{\"1\":{\"63\":1}}],[\"并将执行计划交给执行器\",{\"1\":{\"58\":1}}],[\"并将插入操作\",{\"1\":{\"25\":2}}],[\"并将变更操作保存到ops中\",{\"1\":{\"16\":1,\"18\":1}}],[\"并将查询结果返回\",{\"1\":{\"4\":1}}],[\"并根据具体需求进行优化和扩展\",{\"1\":{\"4\":2}}],[\"并根据具体应用场景和需求进行优化和调整\",{\"1\":{\"4\":1}}],[\"则向客户端发送\",{\"1\":{\"286\":1}}],[\"则向下移动\",{\"1\":{\"237\":1}}],[\"则不能发送空包\",{\"1\":{\"285\":1}}],[\"则不进行任何发送操作\",{\"1\":{\"284\":1}}],[\"则重新开始定时\",{\"1\":{\"284\":1}}],[\"则重组否则合并\",{\"1\":{\"72\":1}}],[\"则设置报文\",{\"1\":{\"279\":1}}],[\"则扫描完毕\",{\"1\":{\"244\":1}}],[\"则代表所有可达对象都被标记为黑色\",{\"1\":{\"244\":1}}],[\"则跳到下一个链表节点\",{\"1\":{\"243\":1}}],[\"则跳过下面逻辑\",{\"1\":{\"124\":1}}],[\"则触发\",{\"1\":{\"243\":1}}],[\"则需向\",{\"1\":{\"241\":1}}],[\"则需要上百个周期\",{\"1\":{\"231\":1}}],[\"则是直接计算出页个数去全局的\",{\"1\":{\"241\":1}}],[\"则是嵌入到单值键值对的值当中\",{\"1\":{\"116\":1}}],[\"则下一个\",{\"1\":{\"240\":1}}],[\"则会释放堆内存\",{\"1\":{\"237\":1}}],[\"则要麻烦的多\",{\"1\":{\"231\":1}}],[\"则调用\",{\"1\":{\"225\":1}}],[\"则函数继续\",{\"1\":{\"225\":1}}],[\"则添加一个\",{\"1\":{\"218\":1}}],[\"则获取下一个\",{\"1\":{\"200\":1}}],[\"则处理一些信号操作\",{\"1\":{\"200\":1}}],[\"则初始化\",{\"1\":{\"200\":1}}],[\"则使用内核栈\",{\"1\":{\"194\":1}}],[\"则可以将功能点作为功能上下文\",{\"1\":{\"164\":1}}],[\"则可以将其视为不存在\",{\"1\":{\"4\":1}}],[\"则依据架构中定义的组件与交互\",{\"1\":{\"164\":1}}],[\"则表示找不到该冲突任期的序号\",{\"1\":{\"134\":1}}],[\"则称为其追随者\",{\"1\":{\"129\":1}}],[\"则拒绝投票\",{\"1\":{\"124\":1}}],[\"则投票\",{\"1\":{\"124\":1}}],[\"则被嵌入到单值键值对的值当中\",{\"1\":{\"114\":1}}],[\"则释放祖先节点的锁\",{\"1\":{\"73\":1}}],[\"则进入\",{\"1\":{\"72\":1}}],[\"则将数据写入新的channel\",{\"1\":{\"188\":1}}],[\"则将\",{\"1\":{\"72\":2,\"237\":1}}],[\"则将键添加到事务的删除列表中\",{\"1\":{\"4\":1}}],[\"则将键值对插入到事务的数据字典中\",{\"1\":{\"4\":1}}],[\"则根至少有两个子节点\",{\"1\":{\"68\":1}}],[\"则必须刷回磁盘\",{\"1\":{\"64\":1}}],[\"则证明无人使用该页\",{\"1\":{\"64\":1}}],[\"则刷至磁盘\",{\"1\":{\"64\":3}}],[\"则判断空闲列表是否有空闲页\",{\"1\":{\"64\":1}}],[\"则判断双方\",{\"1\":{\"17\":1}}],[\"则\",{\"1\":{\"64\":2}}],[\"则双向又会迅速达成一致\",{\"1\":{\"9\":1}}],[\"则继续在\",{\"1\":{\"4\":1}}],[\"则首先在事务中检索键值对\",{\"1\":{\"4\":1}}],[\"则直接返回\",{\"1\":{\"63\":1,\"225\":1}}],[\"则直接返回页数据\",{\"1\":{\"58\":1}}],[\"则直接break\",{\"1\":{\"51\":1}}],[\"则直接从lsm树中删除键\",{\"1\":{\"4\":1}}],[\"则直接插入到lsm树中\",{\"1\":{\"4\":1}}],[\"则直接将其从\",{\"1\":{\"4\":1}}],[\"则直接将其插入到\",{\"1\":{\"4\":1}}],[\"则从\",{\"1\":{\"4\":1}}],[\"则返回该事务中的键值对\",{\"1\":{\"4\":1}}],[\"则顺序查找最新的\",{\"1\":{\"4\":1}}],[\"继续运行\",{\"1\":{\"200\":1}}],[\"继续看\",{\"1\":{\"200\":1}}],[\"继续使用多次\",{\"1\":{\"200\":1}}],[\"继续来看\",{\"1\":{\"128\":1}}],[\"继续执行\",{\"1\":{\"88\":1}}],[\"继续\",{\"1\":{\"4\":2,\"225\":1}}],[\"还发个鬼啊\",{\"1\":{\"284\":1}}],[\"还能提高应用程序的整体性能\",{\"1\":{\"260\":1}}],[\"还能生成业务代码\",{\"1\":{\"144\":1}}],[\"还定义了几个特殊寄存器来代表一些特殊值\",{\"1\":{\"250\":1}}],[\"还定义了执行器的基本方法\",{\"1\":{\"79\":1}}],[\"还比如\",{\"1\":{\"240\":1}}],[\"还要对程序内存使用做到精准管理\",{\"1\":{\"234\":1}}],[\"还要实践\",{\"1\":{\"4\":1}}],[\"还有一种更加彻底的方式来逃开\",{\"1\":{\"238\":1}}],[\"还有一种\",{\"1\":{\"164\":1}}],[\"还有另外一个\",{\"1\":{\"136\":1}}],[\"还有目前使用最广泛\",{\"1\":{\"56\":1}}],[\"还得一个一个日志的应用\",{\"1\":{\"136\":1}}],[\"还需新增\",{\"1\":{\"227\":1}}],[\"还需要调用\",{\"1\":{\"219\":1}}],[\"还需要判断快照任期是否一致\",{\"1\":{\"136\":1}}],[\"还需要判断父节点是否需要分裂\",{\"1\":{\"71\":1}}],[\"还需更多的打磨与优化\",{\"1\":{\"139\":1}}],[\"还需从磁盘中读取持久化的快照数据\",{\"1\":{\"136\":1}}],[\"还活着\",{\"1\":{\"123\":1}}],[\"还在\",{\"1\":{\"114\":1}}],[\"还未完全理清楚\",{\"1\":{\"89\":1}}],[\"还必须得兄弟节点加独占锁\",{\"1\":{\"73\":1}}],[\"还会保存页的元数据\",{\"1\":{\"69\":1}}],[\"还给出了\",{\"1\":{\"41\":1}}],[\"还可以提供当前的\",{\"1\":{\"264\":1}}],[\"还可以替换另外的中\",{\"1\":{\"219\":1}}],[\"还可以在其它地方也引入责任链\",{\"1\":{\"149\":1}}],[\"还可以发现\",{\"1\":{\"9\":1}}],[\"还可以根据具体需求对合并操作进行优化和扩展\",{\"1\":{\"4\":1}}],[\"还可将数据添加到\",{\"1\":{\"4\":1}}],[\"还是栈上分配\",{\"1\":{\"234\":1}}],[\"还是经典学派\",{\"1\":{\"164\":1}}],[\"还是事件通知\",{\"1\":{\"152\":1}}],[\"还是追随者\",{\"1\":{\"123\":1}}],[\"还是解锁都十分简单\",{\"1\":{\"73\":1}}],[\"还是叶子节点\",{\"1\":{\"69\":1}}],[\"还是\",{\"1\":{\"4\":1,\"228\":1,\"237\":1}}],[\"专业\",{\"1\":{\"4\":1}}],[\"以为通过了全部单测就没有问题了\",{\"1\":{\"281\":1}}],[\"以三次握手为例\",{\"1\":{\"272\":1}}],[\"以至于很多人都忘记了它的存在\",{\"1\":{\"263\":1}}],[\"以至于一个函数中\",{\"1\":{\"223\":1}}],[\"以一个简单函数定义为例\",{\"1\":{\"256\":1}}],[\"以函数\",{\"1\":{\"237\":1}}],[\"以应用程序的视角来看\",{\"1\":{\"237\":1}}],[\"以进程的视角来看\",{\"1\":{\"237\":1}}],[\"以此为契机来深入理解\",{\"1\":{\"236\":1}}],[\"以字节码的方式解释执行的\",{\"1\":{\"218\":1}}],[\"以anymatch为例\",{\"1\":{\"189\":1}}],[\"以数据项作为\",{\"1\":{\"188\":1}}],[\"以下均以\",{\"1\":{\"217\":1}}],[\"以下仅为个人理解\",{\"1\":{\"168\":1}}],[\"以下是更新后的\",{\"1\":{\"4\":1}}],[\"以下是\",{\"1\":{\"4\":1}}],[\"以下是一个简单的伪代码示例\",{\"1\":{\"4\":1}}],[\"以测试体现研发进度\",{\"1\":{\"164\":1}}],[\"以同步生产为例\",{\"1\":{\"159\":1}}],[\"以spi插件为例\",{\"1\":{\"151\":1}}],[\"以重试为例\",{\"1\":{\"150\":1}}],[\"以zookeeper为例\",{\"1\":{\"148\":1}}],[\"以哈希路由为例\",{\"1\":{\"145\":1}}],[\"以后\",{\"1\":{\"137\":1}}],[\"以确保\",{\"1\":{\"92\":1}}],[\"以全表扫描的\",{\"1\":{\"79\":1}}],[\"以独占锁锁住根节点\",{\"1\":{\"73\":1}}],[\"以共享锁锁住根节点\",{\"1\":{\"73\":1}}],[\"以前为\",{\"1\":{\"72\":1}}],[\"以\",{\"1\":{\"64\":2,\"127\":1,\"177\":1,\"187\":1,\"188\":1,\"207\":1,\"218\":2,\"231\":1,\"237\":1}}],[\"以map为例\",{\"1\":{\"28\":1}}],[\"以纯文本协同编辑为例\",{\"1\":{\"24\":1,\"25\":1}}],[\"以便于候选人去更新自己的任期号\",{\"1\":{\"126\":1,\"134\":1}}],[\"以便二者数据达到一致\",{\"1\":{\"9\":1}}],[\"以便在系统发生故障时可以通过日志进行数据恢复\",{\"1\":{\"4\":1}}],[\"以及\",{\"1\":{\"283\":1,\"285\":1}}],[\"以及其它字段\",{\"1\":{\"279\":1}}],[\"以及鼎鼎大名的\",{\"1\":{\"245\":1}}],[\"以及抱着对内存管理的兴趣\",{\"1\":{\"236\":1}}],[\"以及可执行文件\",{\"1\":{\"217\":1}}],[\"以及一些权重\",{\"1\":{\"143\":1}}],[\"以及任期\",{\"1\":{\"136\":1}}],[\"以及增加了一个\",{\"1\":{\"114\":1}}],[\"以及事务阶段来判断是否授予锁\",{\"1\":{\"88\":1}}],[\"以及常见的几种\",{\"1\":{\"19\":1}}],[\"以及如何运行它\",{\"1\":{\"8\":1}}],[\"以及众多案例\",{\"1\":{\"8\":1}}],[\"以支持事务操作\",{\"1\":{\"4\":1}}],[\"以上图片按照\",{\"1\":{\"226\":1}}],[\"以上是加入事务支持的\",{\"1\":{\"4\":1}}],[\"以上示例仍然是一个简化的版本\",{\"1\":{\"4\":1}}],[\"以上代码仅是一个简化版的示例\",{\"1\":{\"4\":1}}],[\"以上代码是一个简化版的\",{\"1\":{\"4\":1}}],[\"以提高性能和效率\",{\"1\":{\"4\":1}}],[\"以接收更多的写入操作\",{\"1\":{\"4\":1}}],[\"你也可以直接阅读\",{\"1\":{\"241\":1}}],[\"你肯定会眼熟\",{\"1\":{\"218\":1}}],[\"你是如何拆解任务的\",{\"1\":{\"162\":1}}],[\"你是否发现了代码\",{\"1\":{\"134\":1}}],[\"你应该也发现了\",{\"1\":{\"136\":1}}],[\"你的任期大\",{\"1\":{\"136\":1}}],[\"你可以将其理解为\",{\"1\":{\"123\":1}}],[\"你可以根据实际需求进行调整和优化\",{\"1\":{\"4\":1}}],[\"你现在是一个数据库专家\",{\"1\":{\"4\":1}}],[\"eglibc\",{\"1\":{\"293\":1}}],[\"eggos\",{\"1\":{\"221\":1}}],[\"eof\",{\"1\":{\"282\":12,\"284\":2,\"285\":2,\"286\":1}}],[\"each\",{\"1\":{\"238\":1}}],[\"eax\",{\"1\":{\"197\":5,\"213\":2}}],[\"escape\",{\"1\":{\"227\":3}}],[\"ep\",{\"1\":{\"225\":6}}],[\"ec76a50bef0b\",{\"1\":{\"295\":1}}],[\"echo\",{\"1\":{\"217\":1,\"291\":3,\"293\":2}}],[\"ecx\",{\"1\":{\"197\":1}}],[\"equalf\",{\"1\":{\"213\":2}}],[\"equal\",{\"1\":{\"208\":4,\"213\":1,\"243\":2,\"244\":1,\"284\":1}}],[\"equals\",{\"1\":{\"13\":1,\"16\":1,\"18\":1,\"172\":1,\"173\":1}}],[\"et\",{\"1\":{\"208\":4}}],[\"etc\",{\"1\":{\"198\":1,\"291\":2}}],[\"etcd\",{\"1\":{\"105\":1,\"119\":1,\"121\":1,\"155\":1}}],[\"eip\",{\"1\":{\"200\":1}}],[\"effectively\",{\"1\":{\"200\":1}}],[\"ebx\",{\"1\":{\"197\":2}}],[\"emit\",{\"1\":{\"218\":1}}],[\"email\",{\"1\":{\"164\":1}}],[\"emplace\",{\"1\":{\"88\":1}}],[\"emptystmt\",{\"1\":{\"225\":1}}],[\"empty\",{\"1\":{\"63\":1,\"64\":2,\"157\":1,\"208\":1,\"282\":2,\"283\":1,\"284\":4,\"285\":12,\"286\":2}}],[\"empty表示空的operation\",{\"1\":{\"32\":1}}],[\"elf\",{\"1\":{\"256\":1}}],[\"elemlist\",{\"1\":{\"225\":3}}],[\"element\",{\"1\":{\"172\":5,\"173\":1,\"283\":1}}],[\"elections\",{\"1\":{\"124\":1,\"131\":1}}],[\"else\",{\"1\":{\"4\":3,\"13\":2,\"16\":1,\"18\":1,\"51\":9,\"64\":2,\"70\":1,\"73\":2,\"129\":1,\"133\":1,\"134\":3,\"136\":1,\"179\":1,\"200\":1,\"219\":4,\"225\":1,\"227\":2,\"243\":2,\"244\":1,\"282\":1,\"284\":1,\"285\":1,\"294\":1}}],[\"evlutionary\",{\"1\":{\"164\":1}}],[\"every\",{\"1\":{\"88\":1}}],[\"evaluate\",{\"1\":{\"79\":1,\"89\":1}}],[\"edge\",{\"1\":{\"283\":1}}],[\"edx\",{\"1\":{\"197\":1}}],[\"edu\",{\"1\":{\"140\":1,\"291\":1}}],[\"ed\",{\"1\":{\"70\":4}}],[\"edition\",{\"1\":{\"60\":1}}],[\"editing\",{\"1\":{\"20\":1,\"39\":1,\"41\":2,\"53\":1}}],[\"ereturn\",{\"0\":{\"225\":1},\"1\":{\"225\":21,\"226\":1}}],[\"err\",{\"1\":{\"133\":1,\"218\":5,\"219\":14,\"223\":3,\"225\":17,\"227\":2,\"238\":7,\"241\":12,\"260\":3}}],[\"errors\",{\"1\":{\"225\":1}}],[\"errorf\",{\"1\":{\"212\":1,\"218\":1,\"238\":1,\"240\":3}}],[\"error\",{\"1\":{\"13\":2,\"16\":1,\"18\":1,\"26\":4,\"47\":2,\"48\":1,\"150\":2,\"157\":3,\"172\":2,\"218\":1,\"223\":7,\"225\":12,\"227\":4,\"229\":1,\"238\":1,\"240\":2,\"260\":1,\"263\":1,\"285\":3}}],[\"erikgrinaker\",{\"1\":{\"119\":1}}],[\"erase\",{\"1\":{\"63\":3,\"64\":1,\"282\":3}}],[\"existing\",{\"1\":{\"291\":1}}],[\"exited\",{\"1\":{\"197\":1,\"257\":1}}],[\"exit\",{\"1\":{\"197\":5,\"200\":1,\"217\":2,\"221\":1,\"257\":1,\"286\":4}}],[\"extra\",{\"1\":{\"200\":1}}],[\"external\",{\"1\":{\"293\":8}}],[\"externalconsole\",{\"1\":{\"291\":1}}],[\"extern\",{\"1\":{\"200\":1}}],[\"extensible\",{\"1\":{\"39\":1,\"41\":2,\"53\":1}}],[\"extends\",{\"1\":{\"146\":2,\"149\":1,\"155\":1,\"157\":1,\"158\":1,\"164\":1}}],[\"extended\",{\"1\":{\"121\":1}}],[\"extend\",{\"1\":{\"4\":2}}],[\"example4\",{\"1\":{\"227\":1}}],[\"example3\",{\"1\":{\"227\":1}}],[\"example2\",{\"1\":{\"227\":3}}],[\"example1\",{\"1\":{\"225\":1}}],[\"examples\",{\"1\":{\"225\":1,\"227\":5}}],[\"example\",{\"1\":{\"191\":1}}],[\"exercise\",{\"1\":{\"164\":1}}],[\"execveat\",{\"1\":{\"294\":2}}],[\"execve\",{\"1\":{\"197\":1,\"199\":1}}],[\"exec\",{\"1\":{\"78\":3,\"79\":10,\"89\":11,\"200\":1,\"218\":1,\"219\":1,\"225\":1,\"291\":1}}],[\"executable\",{\"1\":{\"225\":1}}],[\"execute\",{\"1\":{\"78\":3,\"200\":3}}],[\"executionengine\",{\"1\":{\"78\":3,\"79\":2}}],[\"execution\",{\"1\":{\"59\":2,\"79\":1,\"80\":3}}],[\"executorfactory\",{\"1\":{\"78\":2}}],[\"executorcontext\",{\"1\":{\"78\":1,\"79\":4}}],[\"executor\",{\"1\":{\"58\":1,\"78\":4,\"79\":10}}],[\"exclusive\",{\"1\":{\"88\":1}}],[\"exclude\",{\"1\":{\"26\":1}}],[\"exceptions\",{\"1\":{\"212\":1}}],[\"exception\",{\"1\":{\"78\":1,\"146\":2,\"157\":1,\"170\":1,\"286\":4}}],[\"experimental\",{\"1\":{\"292\":1}}],[\"exploring\",{\"1\":{\"247\":1}}],[\"explicit\",{\"1\":{\"69\":1,\"79\":1,\"93\":1}}],[\"exprinplace\",{\"1\":{\"227\":1}}],[\"exprlist\",{\"1\":{\"225\":1}}],[\"exprstmt\",{\"1\":{\"219\":1}}],[\"expr\",{\"1\":{\"174\":3,\"227\":5}}],[\"exportformat\",{\"1\":{\"227\":1}}],[\"export\",{\"1\":{\"13\":4,\"14\":2,\"16\":1,\"17\":1,\"18\":1,\"25\":3,\"26\":2,\"28\":2,\"47\":2,\"48\":1,\"50\":2,\"224\":2,\"225\":1,\"227\":1,\"292\":2,\"293\":2}}],[\"eep\",{\"1\":{\"225\":3}}],[\"ee\",{\"1\":{\"5\":1}}],[\"e\",{\"1\":{\"5\":1,\"72\":4,\"78\":1,\"119\":1,\"133\":4,\"150\":3,\"157\":3,\"164\":1,\"172\":4,\"181\":5,\"217\":2,\"225\":6,\"227\":7,\"285\":1,\"286\":5,\"291\":1}}],[\"engineering\",{\"0\":{\"301\":1}}],[\"enginelogging\",{\"1\":{\"291\":1}}],[\"env\",{\"1\":{\"237\":2,\"291\":1}}],[\"environment\",{\"1\":{\"291\":1}}],[\"environmentconfigs\",{\"1\":{\"172\":2}}],[\"environments\",{\"1\":{\"172\":1}}],[\"environmentselement\",{\"1\":{\"172\":3}}],[\"environments>\",{\"1\":{\"170\":1}}],[\"environment>\",{\"1\":{\"170\":1}}],[\"enc<<3\",{\"1\":{\"218\":1}}],[\"enc\",{\"1\":{\"218\":3}}],[\"encoding=\",{\"1\":{\"170\":1}}],[\"encode\",{\"1\":{\"133\":3,\"146\":1}}],[\"en\",{\"1\":{\"170\":1}}],[\"entire\",{\"1\":{\"136\":1}}],[\"entryat\",{\"1\":{\"128\":1,\"129\":3,\"131\":1,\"134\":5,\"136\":4}}],[\"entry\",{\"1\":{\"72\":1,\"128\":2,\"134\":3,\"200\":2,\"217\":15,\"251\":1,\"294\":2}}],[\"entriesindex++\",{\"1\":{\"129\":1}}],[\"entriesindex\",{\"1\":{\"129\":5,\"133\":2}}],[\"entriessize\",{\"1\":{\"129\":3,\"133\":1}}],[\"entries\",{\"1\":{\"4\":5,\"14\":2,\"126\":3,\"128\":11,\"129\":8,\"133\":1,\"134\":1,\"136\":14,\"137\":1}}],[\"enable\",{\"1\":{\"88\":2}}],[\"enum\",{\"1\":{\"13\":1}}],[\"endif\",{\"1\":{\"294\":1}}],[\"ending\",{\"1\":{\"268\":1}}],[\"endl\",{\"1\":{\"286\":5}}],[\"ends\",{\"1\":{\"285\":1}}],[\"ended\",{\"1\":{\"283\":3,\"285\":6}}],[\"endblock\",{\"1\":{\"227\":3}}],[\"end\",{\"1\":{\"4\":3,\"27\":2,\"30\":3,\"48\":1,\"50\":1,\"79\":1,\"89\":1,\"227\":1,\"237\":2,\"263\":1,\"282\":2,\"285\":1}}],[\"rw\",{\"1\":{\"294\":1}}],[\"rwmutex\",{\"1\":{\"263\":1}}],[\"rm\",{\"1\":{\"291\":1}}],[\"r9\",{\"1\":{\"250\":2}}],[\"r8\",{\"1\":{\"250\":2}}],[\"r4\",{\"1\":{\"225\":1}}],[\"r3\",{\"1\":{\"225\":3}}],[\"r2\",{\"1\":{\"225\":2}}],[\"r14\",{\"1\":{\"250\":2}}],[\"r13\",{\"1\":{\"250\":2}}],[\"r12\",{\"1\":{\"250\":2}}],[\"r11\",{\"1\":{\"250\":2}}],[\"r10\",{\"1\":{\"250\":2}}],[\"r1\",{\"1\":{\"225\":2}}],[\"rdx\",{\"1\":{\"218\":2,\"250\":1}}],[\"rdi\",{\"1\":{\"218\":47,\"250\":1}}],[\"rbrace\",{\"1\":{\"225\":2}}],[\"rbx\",{\"1\":{\"218\":5,\"250\":1}}],[\"rbp\",{\"1\":{\"212\":2,\"213\":2,\"218\":1,\"250\":1}}],[\"rsts\",{\"1\":{\"285\":1}}],[\"rst\",{\"1\":{\"285\":14}}],[\"rsi\",{\"1\":{\"218\":21,\"250\":1}}],[\"rsp\",{\"1\":{\"212\":1,\"213\":1,\"218\":1,\"250\":1}}],[\"rsedis\",{\"1\":{\"119\":1}}],[\"rt\",{\"1\":{\"285\":4,\"294\":2}}],[\"rto\",{\"1\":{\"284\":1}}],[\"rtti\",{\"1\":{\"212\":1}}],[\"rt0\",{\"1\":{\"200\":28,\"217\":12,\"254\":1}}],[\"rlog\",{\"1\":{\"126\":1,\"128\":14,\"133\":1,\"136\":10}}],[\"rlatch\",{\"1\":{\"73\":2}}],[\"rpc框架在设计时就应该考虑到将框架部分模块功能暴露出去\",{\"1\":{\"149\":1}}],[\"rpc请求失败后\",{\"1\":{\"148\":1}}],[\"rpc\",{\"1\":{\"124\":13,\"125\":1,\"126\":2,\"129\":2,\"132\":1,\"136\":7,\"138\":1,\"139\":1,\"142\":1,\"144\":1,\"150\":1,\"157\":7}}],[\"rpdm5axzq\",{\"1\":{\"119\":1}}],[\"rf\",{\"1\":{\"123\":13,\"124\":48,\"129\":77,\"130\":15,\"131\":24,\"133\":45,\"134\":23,\"136\":81,\"137\":12,\"291\":1}}],[\"ram\",{\"1\":{\"293\":1}}],[\"rax\",{\"1\":{\"213\":1,\"218\":23,\"250\":1}}],[\"raft\",{\"0\":{\"120\":1},\"1\":{\"119\":2,\"121\":6,\"122\":3,\"123\":12,\"124\":11,\"125\":1,\"126\":2,\"127\":1,\"128\":4,\"129\":7,\"130\":2,\"131\":8,\"133\":13,\"134\":2,\"135\":1,\"136\":19,\"137\":2,\"139\":7,\"140\":3}}],[\"random\",{\"1\":{\"231\":2,\"284\":1}}],[\"randomstring\",{\"1\":{\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"26\":1,\"47\":1,\"50\":1}}],[\"rand\",{\"1\":{\"213\":2}}],[\"rangestmt\",{\"1\":{\"227\":1}}],[\"rangeclause\",{\"1\":{\"227\":1}}],[\"range\",{\"1\":{\"4\":3,\"27\":2,\"30\":1,\"44\":1,\"124\":1,\"129\":1,\"131\":1,\"136\":1,\"181\":3,\"183\":3,\"187\":7,\"188\":5,\"189\":3,\"190\":1,\"212\":1,\"213\":1,\"218\":2,\"219\":4,\"225\":3,\"227\":2}}],[\"rcx\",{\"1\":{\"218\":2,\"250\":1}}],[\"rcu\",{\"1\":{\"194\":1}}],[\"rc\",{\"1\":{\"84\":1}}],[\"rr\",{\"1\":{\"84\":1}}],[\"rip\",{\"1\":{\"213\":2,\"250\":2}}],[\"ring是一个带有固定缓存池的环形切片\",{\"1\":{\"188\":1}}],[\"ring\",{\"1\":{\"188\":4}}],[\"rid\",{\"1\":{\"69\":3,\"78\":3,\"79\":5,\"88\":17,\"89\":3}}],[\"right是链表的左右指针\",{\"1\":{\"50\":1}}],[\"right\",{\"1\":{\"47\":3,\"48\":3,\"50\":4,\"51\":20}}],[\"rightk​\",{\"1\":{\"43\":2,\"44\":1,\"47\":1,\"48\":1}}],[\"rules\",{\"1\":{\"174\":1,\"229\":1}}],[\"rule\",{\"1\":{\"174\":1}}],[\"rule1\",{\"1\":{\"43\":1}}],[\"rust\",{\"1\":{\"119\":1,\"177\":1,\"219\":1}}],[\"runqget\",{\"1\":{\"200\":1}}],[\"runqsize\",{\"1\":{\"200\":1}}],[\"runqput\",{\"1\":{\"200\":1}}],[\"running\",{\"1\":{\"225\":1}}],[\"runnable\",{\"1\":{\"200\":1}}],[\"runnext\",{\"1\":{\"199\":1,\"200\":1}}],[\"run\",{\"1\":{\"187\":2,\"200\":3,\"207\":1,\"212\":4,\"213\":1,\"217\":1,\"219\":1,\"225\":1,\"227\":8,\"257\":1,\"268\":1,\"290\":2,\"291\":5,\"293\":1}}],[\"runflushthread\",{\"1\":{\"93\":1}}],[\"runcycledetection\",{\"1\":{\"88\":1}}],[\"runtimeexception\",{\"1\":{\"150\":1,\"172\":3,\"173\":1,\"174\":1}}],[\"runtime\",{\"0\":{\"206\":1,\"217\":1},\"1\":{\"39\":1,\"198\":3,\"199\":7,\"200\":42,\"202\":1,\"203\":1,\"204\":1,\"206\":1,\"207\":9,\"208\":7,\"217\":21,\"228\":1,\"238\":18,\"248\":2,\"251\":6,\"256\":1,\"268\":3}}],[\"rodata\",{\"1\":{\"255\":6}}],[\"ross\",{\"1\":{\"236\":2}}],[\"roundupsize\",{\"1\":{\"208\":1}}],[\"router\",{\"1\":{\"145\":3}}],[\"rocketmq\",{\"1\":{\"152\":2,\"153\":1}}],[\"rockskv\",{\"1\":{\"117\":1}}],[\"rocksdb\",{\"1\":{\"117\":1}}],[\"rolled\",{\"1\":{\"88\":1}}],[\"rollback\",{\"1\":{\"85\":2}}],[\"row\",{\"1\":{\"30\":1}}],[\"rootfs\",{\"1\":{\"294\":1,\"295\":1}}],[\"roots\",{\"1\":{\"243\":19,\"244\":5}}],[\"root\",{\"1\":{\"26\":16,\"28\":1,\"70\":1,\"71\":8,\"72\":8,\"172\":1,\"173\":1,\"225\":4,\"292\":2,\"293\":2,\"294\":2}}],[\"rgatreesplit使用平衡树来优化\",{\"1\":{\"23\":1}}],[\"rga\",{\"0\":{\"23\":1},\"1\":{\"22\":2,\"23\":10,\"24\":1,\"25\":2,\"26\":1,\"27\":4,\"37\":1,\"38\":3,\"39\":1,\"41\":1}}],[\"rga篇\",{\"0\":{\"21\":1}}],[\"r\",{\"1\":{\"5\":1,\"51\":8,\"133\":2,\"181\":6,\"210\":6,\"212\":1,\"237\":3,\"292\":1,\"294\":2}}],[\"reordering\",{\"1\":{\"286\":1}}],[\"re\",{\"1\":{\"283\":1}}],[\"reliable\",{\"1\":{\"270\":1}}],[\"releasem\",{\"1\":{\"200\":1}}],[\"releaseallancestorlocks\",{\"1\":{\"73\":1}}],[\"reqcanceler\",{\"1\":{\"263\":1}}],[\"reqmu\",{\"1\":{\"263\":1}}],[\"req\",{\"1\":{\"260\":2}}],[\"requested\",{\"1\":{\"263\":1}}],[\"requestvotereply\",{\"1\":{\"124\":5,\"130\":1,\"133\":1}}],[\"requestvoteargs\",{\"1\":{\"124\":5,\"130\":3,\"133\":1}}],[\"requestvote\",{\"1\":{\"124\":10,\"129\":1,\"130\":2,\"133\":1,\"139\":1}}],[\"request\",{\"1\":{\"88\":11,\"157\":3,\"260\":1,\"291\":1}}],[\"remain\",{\"1\":{\"284\":3}}],[\"remaining\",{\"1\":{\"243\":1}}],[\"remote\",{\"1\":{\"142\":1,\"285\":3,\"286\":12}}],[\"removebefore\",{\"1\":{\"158\":1}}],[\"remove\",{\"1\":{\"72\":2,\"281\":1}}],[\"rewritten\",{\"1\":{\"227\":1}}],[\"regular\",{\"1\":{\"212\":1}}],[\"regsize\",{\"1\":{\"200\":1}}],[\"registryservice\",{\"1\":{\"155\":4,\"159\":1,\"160\":1}}],[\"registers\",{\"1\":{\"200\":1}}],[\"registerstate<t>\",{\"1\":{\"17\":1}}],[\"registerqueue\",{\"1\":{\"155\":1}}],[\"registertopic\",{\"1\":{\"155\":1}}],[\"registerbroker\",{\"1\":{\"155\":1}}],[\"register\",{\"0\":{\"15\":1,\"16\":1,\"17\":1,\"18\":1},\"1\":{\"11\":2,\"15\":3,\"16\":1,\"17\":1,\"19\":2,\"148\":1,\"198\":1,\"200\":1,\"218\":2}}],[\"revisit\",{\"1\":{\"198\":1}}],[\"reversed\",{\"1\":{\"4\":5}}],[\"reflect\",{\"1\":{\"179\":2,\"208\":2,\"285\":1}}],[\"retx\",{\"1\":{\"285\":3}}],[\"retransmissions\",{\"1\":{\"284\":3,\"285\":2,\"286\":1}}],[\"retransmission\",{\"1\":{\"284\":9}}],[\"retryexception|executionexception\",{\"1\":{\"150\":1}}],[\"retryer\",{\"1\":{\"150\":1}}],[\"retryer=retryerbuilder\",{\"1\":{\"150\":1}}],[\"retryer<object>\",{\"1\":{\"150\":1}}],[\"retryifruntimeexception\",{\"1\":{\"150\":1}}],[\"retryifresult\",{\"1\":{\"150\":1}}],[\"ret+16\",{\"1\":{\"256\":1}}],[\"ret\",{\"1\":{\"180\":2,\"198\":1,\"200\":2,\"203\":1,\"212\":1,\"213\":2,\"217\":2,\"218\":11,\"219\":3,\"256\":1,\"257\":1}}],[\"returntype\",{\"1\":{\"219\":3}}],[\"returnstmt\",{\"1\":{\"225\":1}}],[\"returns\",{\"1\":{\"157\":7,\"262\":1}}],[\"returnedat\",{\"1\":{\"263\":1}}],[\"returned\",{\"1\":{\"89\":1}}],[\"return\",{\"1\":{\"4\":21,\"13\":3,\"14\":2,\"16\":4,\"17\":3,\"18\":4,\"26\":5,\"30\":3,\"34\":3,\"37\":1,\"50\":2,\"63\":4,\"64\":13,\"70\":5,\"71\":7,\"72\":7,\"73\":1,\"78\":1,\"79\":7,\"88\":7,\"89\":5,\"93\":3,\"124\":7,\"128\":8,\"129\":7,\"131\":1,\"133\":4,\"134\":2,\"136\":18,\"137\":2,\"144\":2,\"145\":2,\"146\":3,\"147\":2,\"149\":1,\"150\":3,\"157\":1,\"164\":1,\"170\":2,\"172\":2,\"173\":1,\"177\":4,\"179\":9,\"181\":4,\"187\":2,\"188\":2,\"189\":3,\"190\":4,\"197\":1,\"200\":1,\"208\":1,\"210\":3,\"212\":1,\"213\":1,\"218\":14,\"219\":8,\"223\":1,\"225\":17,\"226\":1,\"227\":10,\"234\":1,\"237\":2,\"238\":3,\"240\":5,\"241\":10,\"243\":5,\"244\":1,\"260\":1,\"262\":6,\"268\":1,\"281\":3,\"282\":2,\"283\":7,\"284\":9,\"285\":6,\"286\":4,\"294\":2}}],[\"represents\",{\"1\":{\"263\":1}}],[\"representation\",{\"1\":{\"218\":1}}],[\"repository\",{\"1\":{\"164\":7}}],[\"repeatable\",{\"1\":{\"84\":1,\"88\":1,\"89\":1}}],[\"reply\",{\"1\":{\"124\":11,\"129\":11,\"130\":2,\"133\":8,\"134\":12,\"136\":8,\"137\":3,\"285\":1}}],[\"replacer\",{\"1\":{\"63\":1,\"64\":8}}],[\"replicate\",{\"1\":{\"23\":1}}],[\"replicated\",{\"1\":{\"8\":3,\"10\":4,\"19\":1,\"20\":2,\"39\":1}}],[\"reinterpret\",{\"1\":{\"69\":4,\"70\":1,\"71\":4,\"72\":1}}],[\"recvmmsg\",{\"1\":{\"294\":2}}],[\"recv\",{\"1\":{\"283\":1,\"285\":1}}],[\"received\",{\"1\":{\"279\":3,\"283\":4,\"284\":2,\"285\":19,\"286\":15}}],[\"receiver\",{\"1\":{\"275\":2,\"279\":2,\"280\":2,\"282\":2,\"283\":2,\"285\":17}}],[\"receiving\",{\"1\":{\"134\":1,\"283\":1}}],[\"recently\",{\"1\":{\"4\":1,\"63\":1,\"263\":1}}],[\"record\",{\"1\":{\"88\":1,\"93\":1,\"94\":1}}],[\"recovery\",{\"1\":{\"59\":2,\"95\":2}}],[\"reconnect\",{\"1\":{\"51\":1}}],[\"reached\",{\"1\":{\"285\":1}}],[\"reassembled\",{\"1\":{\"282\":1,\"283\":1}}],[\"reassembler\",{\"1\":{\"280\":2,\"283\":9}}],[\"real\",{\"1\":{\"39\":1,\"41\":2,\"53\":1}}],[\"readv\",{\"1\":{\"294\":2}}],[\"readall\",{\"1\":{\"260\":1}}],[\"readablebytes\",{\"1\":{\"146\":2}}],[\"readmemstats\",{\"1\":{\"238\":1,\"268\":1}}],[\"readmetadata\",{\"1\":{\"98\":2}}],[\"read|syscall\",{\"1\":{\"218\":1,\"238\":1}}],[\"readbytes\",{\"1\":{\"146\":1}}],[\"readint\",{\"1\":{\"146\":1}}],[\"reader\",{\"1\":{\"146\":2}}],[\"reads\",{\"1\":{\"200\":1}}],[\"readshort\",{\"1\":{\"146\":3}}],[\"readsnapshot\",{\"1\":{\"136\":1}}],[\"readraftstate\",{\"1\":{\"124\":1,\"131\":1,\"133\":1,\"136\":1}}],[\"readone\",{\"1\":{\"98\":4}}],[\"readfilenum\",{\"1\":{\"98\":2}}],[\"readpersist\",{\"1\":{\"124\":2,\"131\":1,\"133\":4,\"136\":1}}],[\"readpos\",{\"1\":{\"98\":2}}],[\"readpage\",{\"1\":{\"64\":1}}],[\"read\",{\"1\":{\"4\":3,\"84\":3,\"88\":3,\"89\":3,\"172\":1,\"173\":1,\"281\":5,\"284\":1,\"286\":1,\"292\":1}}],[\"restricted\",{\"1\":{\"291\":10}}],[\"restore\",{\"1\":{\"200\":1}}],[\"resource=\",{\"1\":{\"170\":1}}],[\"resourceutil\",{\"1\":{\"170\":1,\"172\":1}}],[\"resource\",{\"1\":{\"170\":2}}],[\"responsewriter\",{\"1\":{\"260\":1}}],[\"responseobserver\",{\"1\":{\"157\":5}}],[\"response=dataservice\",{\"1\":{\"144\":1}}],[\"response\",{\"1\":{\"134\":1,\"144\":2,\"157\":4}}],[\"resettimer\",{\"1\":{\"213\":2}}],[\"resetreaderindex\",{\"1\":{\"146\":2}}],[\"reset\",{\"1\":{\"64\":2,\"146\":2,\"262\":2,\"285\":2}}],[\"res\",{\"1\":{\"34\":4,\"174\":3,\"210\":3,\"286\":2}}],[\"resulttype=\",{\"1\":{\"174\":1}}],[\"result=resp\",{\"1\":{\"150\":1}}],[\"result\",{\"1\":{\"4\":11,\"30\":4,\"34\":1,\"78\":4,\"150\":2,\"157\":3,\"219\":2,\"281\":2}}],[\"results\",{\"1\":{\"4\":3,\"219\":1,\"225\":3}}],[\"red\",{\"1\":{\"212\":1}}],[\"redo\",{\"1\":{\"94\":3}}],[\"reduce\",{\"1\":{\"14\":2,\"190\":1}}],[\"redistribute\",{\"1\":{\"72\":4}}],[\"redis\",{\"1\":{\"4\":1,\"56\":1,\"102\":2,\"103\":1,\"104\":3,\"105\":2,\"106\":2,\"110\":2,\"111\":1,\"113\":6,\"117\":1,\"119\":4}}],[\"ai\",{\"0\":{\"296\":1}}],[\"after\",{\"1\":{\"285\":7,\"293\":1}}],[\"a+x\",{\"1\":{\"291\":1}}],[\"a+8\",{\"1\":{\"256\":1}}],[\"a+0\",{\"1\":{\"256\":1}}],[\"a+1\",{\"1\":{\"134\":1}}],[\"am\",{\"1\":{\"255\":1}}],[\"amd64\",{\"1\":{\"200\":15,\"217\":13,\"224\":4,\"225\":3,\"254\":1}}],[\"a3\",{\"1\":{\"218\":3}}],[\"a2\",{\"1\":{\"218\":6}}],[\"avx=1\",{\"1\":{\"212\":1}}],[\"avx2=0\",{\"1\":{\"212\":1}}],[\"avx2\",{\"1\":{\"212\":1}}],[\"available\",{\"1\":{\"200\":1}}],[\"akutz\",{\"1\":{\"191\":1}}],[\"ax\",{\"1\":{\"180\":5,\"200\":26,\"213\":11,\"217\":2,\"250\":1,\"251\":10,\"252\":1,\"253\":6,\"254\":3,\"256\":2,\"257\":1}}],[\"age+0x00\",{\"1\":{\"255\":1}}],[\"age\",{\"1\":{\"87\":1,\"255\":3}}],[\"aggregation\",{\"1\":{\"79\":1}}],[\"agile\",{\"1\":{\"0\":1}}],[\"autocloseable\",{\"1\":{\"170\":1}}],[\"auto\",{\"1\":{\"78\":1,\"88\":6,\"282\":3,\"285\":1}}],[\"automerge\",{\"1\":{\"11\":1,\"22\":1,\"23\":2,\"27\":8,\"38\":1,\"39\":1}}],[\"advanced\",{\"1\":{\"215\":1}}],[\"admin\",{\"1\":{\"157\":1}}],[\"adjustroot\",{\"1\":{\"72\":3}}],[\"addedgeto\",{\"1\":{\"227\":3}}],[\"address\",{\"1\":{\"200\":1,\"218\":1,\"268\":1,\"286\":2}}],[\"addr\",{\"1\":{\"198\":3,\"237\":3,\"238\":5,\"240\":1,\"241\":3,\"243\":6,\"244\":2,\"286\":4}}],[\"addsd\",{\"1\":{\"180\":2}}],[\"addq\",{\"1\":{\"180\":4,\"213\":1,\"253\":1,\"256\":1}}],[\"addable\",{\"1\":{\"179\":2}}],[\"addf\",{\"1\":{\"179\":1}}],[\"addi\",{\"1\":{\"179\":1}}],[\"addint32\",{\"1\":{\"124\":1}}],[\"additem\",{\"1\":{\"51\":1}}],[\"add\",{\"1\":{\"51\":2,\"146\":1,\"150\":1,\"172\":1,\"179\":11,\"180\":6,\"188\":1,\"200\":1,\"210\":3,\"218\":14,\"219\":20,\"256\":5}}],[\"a1\",{\"1\":{\"71\":4,\"218\":8}}],[\"apt\",{\"1\":{\"291\":4,\"292\":1}}],[\"api\",{\"0\":{\"157\":1,\"277\":1},\"1\":{\"69\":1,\"71\":1,\"72\":1,\"103\":1,\"106\":1,\"113\":1,\"156\":1,\"157\":4,\"159\":1,\"160\":1,\"161\":1,\"177\":3,\"183\":1,\"184\":2,\"185\":1,\"186\":1,\"190\":2,\"191\":1,\"197\":4,\"236\":1,\"237\":5,\"241\":1,\"243\":1,\"261\":1,\"263\":1,\"264\":1,\"277\":4,\"286\":1}}],[\"apps\",{\"1\":{\"286\":3}}],[\"approach\",{\"1\":{\"41\":1}}],[\"application\",{\"1\":{\"285\":1}}],[\"applications\",{\"1\":{\"39\":1}}],[\"applications中提出\",{\"1\":{\"23\":1}}],[\"applyinterval\",{\"1\":{\"131\":1}}],[\"applylog\",{\"1\":{\"131\":4,\"132\":1,\"139\":2}}],[\"applymsg\",{\"1\":{\"123\":1,\"124\":1,\"126\":1,\"131\":6,\"133\":1,\"136\":8}}],[\"applych\",{\"1\":{\"123\":1,\"124\":4,\"126\":1,\"131\":7,\"133\":1,\"136\":3}}],[\"apply\",{\"1\":{\"13\":2,\"16\":2,\"18\":2,\"123\":1,\"126\":1,\"164\":1}}],[\"appendentries\",{\"1\":{\"126\":2,\"129\":7,\"133\":1,\"134\":2,\"136\":3,\"137\":2,\"139\":2}}],[\"appendentriesreply\",{\"1\":{\"126\":1,\"129\":3,\"133\":1,\"134\":2,\"137\":1}}],[\"appendentriesargs\",{\"1\":{\"126\":2,\"129\":3,\"133\":1,\"134\":1,\"137\":1}}],[\"appendlogrecord\",{\"1\":{\"93\":1}}],[\"append\",{\"1\":{\"4\":6,\"30\":1,\"31\":1,\"32\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"127\":1,\"128\":2,\"129\":1,\"131\":1,\"133\":1,\"136\":2,\"174\":2,\"181\":3,\"208\":1,\"218\":2,\"219\":2,\"227\":2,\"238\":2,\"241\":1,\"281\":1,\"291\":3,\"294\":1}}],[\"aliyun\",{\"1\":{\"291\":10}}],[\"alignment\",{\"1\":{\"263\":1}}],[\"align\",{\"1\":{\"200\":1,\"208\":1}}],[\"al\",{\"1\":{\"212\":1}}],[\"alginit\",{\"1\":{\"200\":2}}],[\"allow\",{\"1\":{\"292\":1}}],[\"allocator\",{\"1\":{\"245\":1,\"247\":8}}],[\"allocatedsmall\",{\"1\":{\"241\":1}}],[\"allocatedlarge\",{\"1\":{\"241\":1}}],[\"allocated+size+headersize\",{\"1\":{\"240\":1}}],[\"allocated\",{\"1\":{\"238\":2,\"240\":8,\"262\":1,\"268\":1}}],[\"allocatepage\",{\"1\":{\"64\":1}}],[\"alloc\",{\"1\":{\"238\":15,\"239\":1,\"240\":6,\"268\":1,\"294\":1}}],[\"allboolean\",{\"1\":{\"227\":1}}],[\"allerrors\",{\"1\":{\"219\":2}}],[\"allg\",{\"1\":{\"200\":1}}],[\"allgadd\",{\"1\":{\"200\":1}}],[\"allp\",{\"1\":{\"200\":2}}],[\"allmatch与nonematch与之类似\",{\"1\":{\"189\":1}}],[\"allmatch\",{\"1\":{\"177\":2,\"185\":2,\"190\":1}}],[\"all\",{\"1\":{\"88\":1,\"181\":2,\"203\":1,\"263\":1,\"285\":1}}],[\"always\",{\"1\":{\"47\":1}}],[\"arp\",{\"1\":{\"287\":1}}],[\"around\",{\"1\":{\"263\":1}}],[\"article\",{\"1\":{\"215\":1,\"295\":3}}],[\"armclang\",{\"1\":{\"215\":2}}],[\"archprctl\",{\"1\":{\"198\":1}}],[\"arch\",{\"1\":{\"198\":10,\"291\":4,\"294\":7}}],[\"architecture\",{\"1\":{\"53\":1,\"198\":1}}],[\"arg2\",{\"1\":{\"218\":4}}],[\"arg1\",{\"1\":{\"218\":4}}],[\"argp\",{\"1\":{\"200\":4}}],[\"arg\",{\"1\":{\"200\":1,\"218\":3,\"237\":2,\"251\":1}}],[\"argv\",{\"1\":{\"200\":9,\"217\":1,\"234\":1,\"286\":2,\"294\":1}}],[\"argc\",{\"1\":{\"200\":9,\"217\":1,\"234\":1,\"286\":2,\"294\":1}}],[\"argsize\",{\"1\":{\"256\":2}}],[\"args\",{\"1\":{\"124\":11,\"129\":22,\"130\":7,\"133\":11,\"134\":6,\"136\":17,\"137\":3,\"200\":1,\"212\":8,\"213\":11,\"219\":6,\"256\":1,\"291\":1}}],[\"arguments\",{\"1\":{\"69\":2}}],[\"arenas\",{\"1\":{\"239\":1}}],[\"arenas的提案\",{\"1\":{\"236\":1}}],[\"arena\",{\"1\":{\"236\":1,\"239\":1}}],[\"area\",{\"1\":{\"194\":1,\"218\":3,\"236\":1,\"238\":7,\"239\":5,\"240\":7}}],[\"are\",{\"1\":{\"51\":1,\"89\":1,\"181\":1,\"292\":1}}],[\"arraylist<>\",{\"1\":{\"172\":1}}],[\"arrays\",{\"1\":{\"53\":1,\"144\":1,\"164\":2,\"181\":1}}],[\"array<operation<t>>\",{\"1\":{\"28\":1}}],[\"array\",{\"1\":{\"14\":2,\"23\":2,\"28\":2,\"69\":3,\"70\":2}}],[\"awesome\",{\"1\":{\"39\":1}}],[\"accept\",{\"1\":{\"286\":1}}],[\"access\",{\"1\":{\"231\":2,\"263\":1}}],[\"acquirep\",{\"1\":{\"200\":1}}],[\"acquirem\",{\"1\":{\"200\":1}}],[\"acid特性\",{\"1\":{\"83\":1}}],[\"active\",{\"1\":{\"285\":10,\"294\":6}}],[\"activemodules\",{\"1\":{\"200\":3}}],[\"action\",{\"1\":{\"34\":1,\"36\":1,\"37\":1,\"218\":4}}],[\"actor\",{\"1\":{\"28\":2}}],[\"actorid是一个字符串\",{\"1\":{\"28\":1}}],[\"actorid\",{\"1\":{\"28\":2}}],[\"acks\",{\"1\":{\"285\":1}}],[\"acking\",{\"1\":{\"285\":1}}],[\"acknowledged\",{\"1\":{\"285\":1,\"286\":2}}],[\"ackno\",{\"1\":{\"279\":3,\"280\":1,\"283\":20,\"284\":21,\"285\":11,\"286\":2}}],[\"ack\",{\"1\":{\"13\":1,\"16\":2,\"18\":1,\"272\":2,\"279\":1,\"283\":1,\"284\":3,\"285\":16,\"286\":16}}],[\"attch\",{\"1\":{\"291\":1}}],[\"attempts\",{\"1\":{\"285\":3}}],[\"attributes\",{\"1\":{\"69\":1,\"291\":2}}],[\"attribute\",{\"1\":{\"51\":1,\"64\":2,\"69\":6,\"172\":1}}],[\"atoi32\",{\"1\":{\"200\":1}}],[\"atomic\",{\"1\":{\"124\":2,\"200\":1,\"263\":2}}],[\"atomicity\",{\"1\":{\"83\":1}}],[\"at\",{\"1\":{\"26\":2,\"47\":1,\"48\":2,\"50\":6,\"200\":1,\"212\":2,\"227\":1,\"248\":2,\"252\":1,\"263\":2,\"285\":1}}],[\"about\",{\"1\":{\"285\":1,\"291\":1}}],[\"abortreason\",{\"1\":{\"88\":3}}],[\"abortimplicitly\",{\"1\":{\"88\":3}}],[\"aborts\",{\"1\":{\"88\":1}}],[\"aborted\",{\"1\":{\"85\":1,\"88\":3}}],[\"abort\",{\"1\":{\"4\":4,\"88\":6,\"254\":1,\"285\":1}}],[\"ab\",{\"1\":{\"219\":3}}],[\"absolute\",{\"1\":{\"283\":3,\"284\":1}}],[\"abs\",{\"1\":{\"206\":4,\"283\":24,\"284\":15}}],[\"abstractexecutor\",{\"1\":{\"79\":7}}],[\"abstractexpression\",{\"1\":{\"79\":3}}],[\"abstractplannode\",{\"1\":{\"78\":2,\"79\":9}}],[\"abstracttype是\",{\"1\":{\"50\":1}}],[\"abstracttype>\",{\"1\":{\"50\":1}}],[\"abstracttype\",{\"1\":{\"50\":2,\"51\":1}}],[\"abstract\",{\"1\":{\"23\":1,\"39\":1}}],[\"ants\",{\"1\":{\"264\":3,\"266\":1}}],[\"anon|syscall\",{\"1\":{\"238\":1}}],[\"anonymous\",{\"1\":{\"218\":1}}],[\"anon\",{\"1\":{\"218\":1}}],[\"another\",{\"1\":{\"41\":1}}],[\"ancestors\",{\"1\":{\"200\":1}}],[\"anymatch接受一个断言函数fn\",{\"1\":{\"189\":1}}],[\"anymatch\",{\"1\":{\"185\":2,\"189\":1}}],[\"any\",{\"1\":{\"49\":5,\"164\":1,\"227\":1,\"240\":2,\"285\":1}}],[\"an\",{\"1\":{\"20\":1,\"51\":1,\"134\":2,\"181\":1,\"200\":1,\"247\":2,\"263\":1,\"268\":1,\"283\":1,\"285\":3,\"293\":1}}],[\"andq\",{\"1\":{\"200\":1}}],[\"and\",{\"1\":{\"4\":3,\"8\":1,\"10\":1,\"19\":1,\"20\":1,\"26\":3,\"48\":1,\"51\":3,\"69\":1,\"88\":2,\"165\":1,\"174\":1,\"200\":1,\"224\":3,\"225\":3,\"236\":1,\"238\":1,\"247\":1,\"268\":1,\"283\":1,\"285\":7,\"286\":1,\"291\":1,\"292\":1}}],[\"assign\",{\"1\":{\"281\":2}}],[\"assembled\",{\"1\":{\"285\":1}}],[\"assembler\",{\"1\":{\"218\":5,\"258\":1}}],[\"assembling\",{\"1\":{\"283\":1}}],[\"assembly\",{\"1\":{\"218\":2}}],[\"assertequals\",{\"1\":{\"164\":1}}],[\"asserttrue\",{\"1\":{\"164\":1}}],[\"assertsame\",{\"1\":{\"164\":1}}],[\"assert\",{\"1\":{\"5\":11,\"208\":6,\"213\":2,\"241\":3,\"243\":4,\"244\":3}}],[\"ast\",{\"1\":{\"219\":18,\"227\":6}}],[\"asynchronous\",{\"1\":{\"212\":1}}],[\"asyncproducemessage\",{\"1\":{\"157\":1}}],[\"asmlinkage\",{\"1\":{\"294\":4}}],[\"asm2asm\",{\"1\":{\"212\":6,\"213\":1}}],[\"asmcgocall\",{\"1\":{\"204\":1}}],[\"asm\",{\"1\":{\"200\":1,\"210\":1,\"217\":4,\"294\":2}}],[\"asminit\",{\"1\":{\"200\":1}}],[\"ascii\",{\"1\":{\"197\":1}}],[\"aslist\",{\"1\":{\"144\":1,\"164\":2}}],[\"as\",{\"1\":{\"13\":2,\"16\":1,\"18\":1,\"26\":2,\"50\":2,\"51\":1,\"197\":1,\"200\":2,\"218\":15,\"283\":1,\"284\":1,\"292\":2,\"293\":1}}],[\"aa\",{\"1\":{\"5\":2}}],[\"a\",{\"1\":{\"5\":5,\"8\":1,\"10\":1,\"14\":4,\"15\":2,\"20\":1,\"51\":1,\"71\":13,\"72\":22,\"73\":7,\"79\":1,\"84\":5,\"86\":6,\"88\":2,\"131\":1,\"133\":1,\"134\":2,\"136\":1,\"144\":1,\"164\":4,\"165\":1,\"177\":2,\"179\":20,\"181\":4,\"190\":2,\"200\":3,\"217\":15,\"218\":17,\"219\":4,\"221\":1,\"225\":3,\"227\":17,\"234\":5,\"238\":2,\"243\":4,\"247\":2,\"256\":1,\"258\":1,\"263\":2,\"268\":2,\"282\":7,\"283\":1,\"284\":1,\"285\":2,\"286\":2,\"291\":1,\"293\":2,\"294\":1}}],[\"dhcp\",{\"1\":{\"293\":1}}],[\"dmb\",{\"1\":{\"268\":1}}],[\"dpaks\",{\"1\":{\"264\":1}}],[\"dprintf\",{\"1\":{\"133\":1}}],[\"db\",{\"1\":{\"263\":6}}],[\"dbms\",{\"1\":{\"92\":1}}],[\"dynamic\",{\"1\":{\"231\":1}}],[\"dcfaf063e7\",{\"1\":{\"227\":1}}],[\"danscales\",{\"1\":{\"236\":1}}],[\"darwin\",{\"1\":{\"217\":1}}],[\"datasource>\",{\"1\":{\"170\":1}}],[\"dataservice=proxyfactory\",{\"1\":{\"144\":1}}],[\"dataserviceimpl\",{\"1\":{\"144\":1}}],[\"dataservice\",{\"1\":{\"144\":4}}],[\"database\",{\"0\":{\"299\":1},\"1\":{\"56\":1,\"60\":1,\"65\":1,\"75\":2,\"80\":1,\"90\":1,\"95\":2}}],[\"data\",{\"1\":{\"4\":5,\"8\":3,\"10\":4,\"19\":1,\"20\":3,\"23\":1,\"39\":2,\"41\":2,\"53\":1,\"69\":1,\"70\":1,\"94\":1,\"133\":6,\"136\":3,\"144\":2,\"147\":3,\"158\":1,\"197\":1,\"207\":4,\"232\":2,\"237\":1,\"255\":7,\"257\":5,\"260\":4,\"262\":1,\"281\":4,\"282\":10,\"283\":3,\"285\":4}}],[\"d2\",{\"1\":{\"213\":3}}],[\"d1\",{\"1\":{\"213\":3}}],[\"dst\",{\"1\":{\"252\":1}}],[\"ds\",{\"1\":{\"208\":3}}],[\"duplex\",{\"1\":{\"270\":1}}],[\"duse\",{\"1\":{\"212\":2}}],[\"dumper\",{\"1\":{\"227\":3}}],[\"dump\",{\"1\":{\"207\":12,\"208\":1,\"227\":2}}],[\"duration\",{\"1\":{\"263\":1}}],[\"durability\",{\"1\":{\"83\":1}}],[\"during\",{\"1\":{\"200\":1}}],[\"dx\",{\"1\":{\"200\":6,\"213\":2,\"250\":1,\"257\":1}}],[\"dlv\",{\"1\":{\"200\":7}}],[\"dram\",{\"1\":{\"231\":2}}],[\"drain\",{\"1\":{\"189\":1}}],[\"driven\",{\"1\":{\"168\":1,\"175\":1}}],[\"driverconn\",{\"1\":{\"263\":1}}],[\"driver\",{\"1\":{\"151\":1,\"170\":2,\"172\":1,\"263\":1}}],[\"dtd\",{\"1\":{\"170\":3}}],[\"dgraph\",{\"1\":{\"119\":1}}],[\"dowhilestmt\",{\"1\":{\"227\":28}}],[\"dowhile\",{\"0\":{\"227\":1},\"1\":{\"226\":1,\"227\":49}}],[\"download\",{\"1\":{\"292\":1}}],[\"downloads\",{\"1\":{\"291\":1,\"293\":1}}],[\"down\",{\"1\":{\"200\":1}}],[\"doinit\",{\"1\":{\"200\":2}}],[\"double\",{\"1\":{\"137\":1,\"284\":1}}],[\"doespark\",{\"1\":{\"200\":1}}],[\"doesn\",{\"1\":{\"200\":2,\"285\":1}}],[\"does\",{\"1\":{\"134\":1}}],[\"do\",{\"1\":{\"79\":1,\"89\":1,\"227\":12}}],[\"done\",{\"1\":{\"200\":2,\"286\":2}}],[\"don\",{\"1\":{\"51\":1,\"136\":1,\"284\":1}}],[\"dockerfile\",{\"1\":{\"291\":1}}],[\"docker\",{\"1\":{\"290\":2,\"291\":4,\"292\":2,\"294\":2,\"295\":1}}],[\"docs\",{\"1\":{\"191\":2,\"215\":1}}],[\"doctype\",{\"1\":{\"170\":1}}],[\"doc定义不变\",{\"1\":{\"48\":1}}],[\"doc核心数据实际就是op的集合\",{\"1\":{\"28\":1}}],[\"documentexception\",{\"1\":{\"172\":2,\"173\":1}}],[\"document\",{\"1\":{\"28\":1,\"172\":3,\"173\":3}}],[\"doc\",{\"1\":{\"26\":4,\"47\":1,\"48\":2,\"50\":5,\"51\":4,\"204\":1}}],[\"doc<t>\",{\"1\":{\"26\":1,\"28\":1,\"47\":1}}],[\"dfs\",{\"1\":{\"26\":2}}],[\"directories\",{\"1\":{\"293\":1}}],[\"dir\",{\"1\":{\"292\":2}}],[\"dir=`pwd`\",{\"1\":{\"292\":2}}],[\"dirty\",{\"1\":{\"8\":1,\"64\":10,\"84\":1}}],[\"dirty来说\",{\"1\":{\"5\":1}}],[\"dialect\",{\"1\":{\"218\":1}}],[\"digit\",{\"1\":{\"213\":4}}],[\"digits\",{\"1\":{\"213\":6}}],[\"dil\",{\"1\":{\"212\":1}}],[\"di\",{\"1\":{\"200\":17,\"213\":1,\"217\":3,\"250\":1,\"252\":1,\"257\":1}}],[\"discard\",{\"1\":{\"227\":1}}],[\"discovering\",{\"1\":{\"247\":1}}],[\"discover\",{\"1\":{\"103\":1,\"104\":1,\"111\":1,\"112\":1,\"113\":1}}],[\"dis\",{\"1\":{\"218\":4}}],[\"disable\",{\"1\":{\"200\":1}}],[\"distance\",{\"1\":{\"283\":1}}],[\"dist\",{\"1\":{\"224\":1,\"225\":1}}],[\"distinct\",{\"1\":{\"184\":2,\"188\":4}}],[\"distribute\",{\"0\":{\"300\":1},\"1\":{\"161\":1}}],[\"distributed\",{\"0\":{\"100\":1},\"1\":{\"103\":1,\"104\":1,\"105\":3,\"106\":1,\"107\":1,\"118\":1}}],[\"diskqueue\",{\"1\":{\"98\":6,\"153\":1,\"158\":2}}],[\"diskqueue持久化队列设计演进\",{\"0\":{\"96\":1}}],[\"diskmanager\",{\"1\":{\"64\":1,\"93\":1,\"94\":1}}],[\"disktable\",{\"1\":{\"4\":5}}],[\"disk\",{\"1\":{\"4\":1,\"58\":1,\"59\":1,\"64\":8,\"93\":3,\"94\":3}}],[\"dive\",{\"1\":{\"53\":1}}],[\"ddx1471430827125\",{\"1\":{\"215\":1}}],[\"dd\",{\"1\":{\"5\":1}}],[\"d\",{\"1\":{\"5\":1,\"72\":5,\"73\":3,\"133\":4,\"136\":2,\"164\":2,\"219\":2,\"234\":1,\"238\":2,\"241\":1,\"243\":2,\"268\":3,\"291\":1}}],[\"deb\",{\"1\":{\"291\":10}}],[\"debian\",{\"1\":{\"291\":1}}],[\"debug\",{\"1\":{\"200\":1,\"227\":2,\"228\":1,\"281\":1,\"286\":20,\"291\":3}}],[\"demand\",{\"1\":{\"237\":1}}],[\"demo\",{\"1\":{\"16\":1,\"18\":1,\"96\":1,\"170\":1}}],[\"dev\",{\"1\":{\"291\":13}}],[\"devices\",{\"1\":{\"237\":1}}],[\"development\",{\"1\":{\"168\":1,\"170\":2,\"175\":1}}],[\"developer\",{\"1\":{\"164\":1}}],[\"details\",{\"1\":{\"215\":1,\"295\":1}}],[\"detection\",{\"1\":{\"88\":3}}],[\"dead\",{\"1\":{\"123\":1}}],[\"deadlock\",{\"1\":{\"88\":1}}],[\"deno\",{\"1\":{\"102\":1}}],[\"desc\",{\"1\":{\"293\":3}}],[\"descriptions\",{\"1\":{\"291\":1}}],[\"description\",{\"1\":{\"229\":1}}],[\"design\",{\"1\":{\"164\":3,\"204\":1}}],[\"deserialize\",{\"1\":{\"147\":2}}],[\"deserializelogrecord\",{\"1\":{\"94\":1}}],[\"destination\",{\"1\":{\"286\":1}}],[\"destindex++\",{\"1\":{\"26\":1}}],[\"destindex\",{\"1\":{\"26\":4,\"47\":4,\"48\":4}}],[\"destp\",{\"1\":{\"207\":2}}],[\"dest\",{\"1\":{\"207\":9,\"208\":6}}],[\"destroyed\",{\"1\":{\"88\":1}}],[\"deep\",{\"1\":{\"53\":1}}],[\"declare\",{\"1\":{\"219\":1}}],[\"decl\",{\"1\":{\"219\":12}}],[\"decls\",{\"1\":{\"219\":3}}],[\"decode\",{\"1\":{\"133\":4,\"146\":1}}],[\"decides\",{\"1\":{\"51\":1}}],[\"decrement\",{\"1\":{\"13\":6,\"14\":2}}],[\"deletion\",{\"1\":{\"72\":1}}],[\"deletequeueresponse\",{\"1\":{\"157\":1}}],[\"deletequeuerequest\",{\"1\":{\"157\":1}}],[\"deletequeue\",{\"1\":{\"157\":1}}],[\"deleteoldrootpage\",{\"1\":{\"72\":1}}],[\"deletepage\",{\"1\":{\"64\":3}}],[\"deletepageimpl\",{\"1\":{\"64\":2}}],[\"delete函数十分简单\",{\"1\":{\"47\":1}}],[\"deleted\",{\"1\":{\"4\":3,\"26\":1}}],[\"delete\",{\"0\":{\"32\":1,\"35\":1},\"1\":{\"4\":4,\"26\":1,\"27\":2,\"28\":3,\"32\":3,\"35\":2,\"47\":1,\"49\":3,\"51\":2,\"79\":1,\"93\":2,\"94\":1,\"158\":1,\"234\":1}}],[\"del\",{\"1\":{\"4\":2}}],[\"defer\",{\"1\":{\"124\":2,\"129\":2,\"130\":1,\"136\":5,\"188\":1,\"200\":2,\"210\":1,\"227\":2,\"241\":2}}],[\"define0\",{\"1\":{\"294\":1}}],[\"define\",{\"1\":{\"69\":3,\"212\":1,\"219\":3,\"294\":16}}],[\"defaultenvironment\",{\"1\":{\"172\":2}}],[\"default=\",{\"1\":{\"170\":1}}],[\"defaultrlog\",{\"1\":{\"128\":2,\"131\":1,\"136\":1}}],[\"default\",{\"1\":{\"51\":1,\"79\":2,\"89\":1,\"172\":1,\"174\":1,\"218\":1,\"227\":1}}],[\"def\",{\"1\":{\"4\":32,\"30\":2,\"31\":1,\"32\":1,\"34\":2,\"35\":1,\"36\":1,\"37\":1,\"218\":2}}],[\"fwlink\",{\"1\":{\"291\":1}}],[\"f1\",{\"1\":{\"291\":1}}],[\"ftp\",{\"1\":{\"291\":2}}],[\"fully\",{\"1\":{\"285\":3,\"286\":2}}],[\"full\",{\"1\":{\"270\":1}}],[\"funcmain\",{\"1\":{\"219\":3}}],[\"funcmap\",{\"1\":{\"219\":11}}],[\"funcdefine\",{\"1\":{\"219\":6}}],[\"funcdecl\",{\"1\":{\"219\":4}}],[\"funcval\",{\"1\":{\"200\":2}}],[\"funcpc\",{\"1\":{\"198\":1,\"200\":1,\"202\":1,\"203\":1}}],[\"function\",{\"1\":{\"164\":2,\"200\":1,\"202\":1,\"212\":1}}],[\"function<string\",{\"1\":{\"164\":1}}],[\"func\",{\"1\":{\"123\":3,\"124\":5,\"128\":8,\"129\":5,\"130\":2,\"131\":2,\"133\":8,\"134\":2,\"136\":15,\"137\":2,\"177\":4,\"179\":8,\"181\":7,\"183\":4,\"184\":7,\"185\":7,\"187\":5,\"188\":4,\"189\":3,\"190\":5,\"200\":13,\"203\":1,\"206\":2,\"207\":5,\"208\":4,\"210\":2,\"212\":3,\"213\":5,\"217\":3,\"218\":10,\"219\":16,\"225\":6,\"227\":22,\"237\":1,\"238\":6,\"240\":2,\"241\":3,\"243\":11,\"244\":7,\"256\":1,\"257\":2,\"260\":1,\"261\":1,\"262\":6,\"263\":3,\"264\":1,\"268\":4}}],[\"fprint\",{\"1\":{\"227\":2}}],[\"fprintf\",{\"1\":{\"227\":5}}],[\"fp\",{\"1\":{\"200\":1,\"250\":1,\"256\":3}}],[\"fdadapterconfig\",{\"1\":{\"286\":2}}],[\"fdump\",{\"1\":{\"227\":1}}],[\"fd\",{\"1\":{\"198\":1,\"237\":1}}],[\"fsm\",{\"1\":{\"286\":4}}],[\"fset\",{\"1\":{\"219\":5}}],[\"fs\",{\"1\":{\"194\":2,\"198\":5,\"200\":1,\"204\":1,\"294\":1}}],[\"fno\",{\"1\":{\"212\":5}}],[\"fn\",{\"1\":{\"184\":3,\"185\":5,\"189\":5,\"200\":14,\"202\":1,\"219\":10}}],[\"flex\",{\"1\":{\"292\":1}}],[\"flight\",{\"1\":{\"284\":19,\"285\":3,\"286\":2}}],[\"flow\",{\"1\":{\"227\":1}}],[\"float\",{\"1\":{\"181\":1}}],[\"float32\",{\"1\":{\"179\":1,\"181\":2}}],[\"float64\",{\"1\":{\"179\":7,\"180\":2}}],[\"flags\",{\"1\":{\"208\":1,\"237\":1,\"255\":2,\"256\":2,\"294\":1}}],[\"flag\",{\"1\":{\"164\":2,\"285\":2}}],[\"flushallpages\",{\"1\":{\"64\":1}}],[\"flushallpagesimpl\",{\"1\":{\"64\":2}}],[\"flushpage\",{\"1\":{\"64\":4}}],[\"flushpageimpl\",{\"1\":{\"64\":2}}],[\"flush\",{\"1\":{\"4\":9,\"13\":1,\"16\":1,\"18\":2,\"93\":4,\"158\":1}}],[\"features\",{\"1\":{\"292\":1}}],[\"fecther\",{\"1\":{\"160\":1}}],[\"fetch\",{\"1\":{\"218\":5}}],[\"fetcher\",{\"1\":{\"160\":1}}],[\"fetchmessageresponse\",{\"1\":{\"157\":1}}],[\"fetchmessagerequest\",{\"1\":{\"157\":1}}],[\"fetchmessage\",{\"1\":{\"157\":1}}],[\"fetchpage\",{\"1\":{\"64\":10,\"70\":1}}],[\"fetchpageimpl\",{\"1\":{\"64\":2}}],[\"fmt\",{\"1\":{\"136\":1,\"181\":1,\"190\":1,\"200\":4,\"210\":4,\"217\":2,\"218\":3,\"219\":9,\"225\":1,\"227\":16,\"237\":1,\"238\":7,\"240\":3,\"243\":1,\"261\":1,\"262\":1,\"268\":3}}],[\"failure\",{\"1\":{\"286\":2}}],[\"fact\",{\"1\":{\"285\":1}}],[\"factory\",{\"1\":{\"79\":1}}],[\"fatih\",{\"1\":{\"266\":1}}],[\"fatalln\",{\"1\":{\"238\":1}}],[\"fast会从局部变量中拿到数据\",{\"1\":{\"218\":1}}],[\"fast指令会从局部变量中拿到变量值并入栈\",{\"1\":{\"218\":1}}],[\"fast\",{\"1\":{\"218\":13}}],[\"fastrandinit\",{\"1\":{\"200\":1}}],[\"fastjson\",{\"1\":{\"147\":1}}],[\"fanout\",{\"0\":{\"99\":1}}],[\"fall\",{\"1\":{\"288\":1}}],[\"fallthrough\",{\"1\":{\"227\":1}}],[\"fall2020\",{\"1\":{\"60\":1}}],[\"false\",{\"1\":{\"26\":2,\"47\":2,\"48\":2,\"63\":1,\"64\":10,\"71\":1,\"79\":2,\"88\":3,\"89\":3,\"124\":2,\"129\":3,\"130\":2,\"131\":1,\"133\":1,\"136\":2,\"189\":1,\"200\":3,\"212\":3,\"225\":1,\"227\":1,\"240\":2,\"243\":3,\"244\":1,\"283\":1,\"284\":2,\"285\":13,\"286\":5,\"291\":3}}],[\"focal\",{\"1\":{\"291\":10}}],[\"foofunc\",{\"1\":{\"218\":2}}],[\"foo\",{\"1\":{\"218\":8}}],[\"following\",{\"1\":{\"263\":1}}],[\"follower\",{\"1\":{\"123\":5,\"124\":2,\"129\":2,\"133\":3,\"136\":3}}],[\"follwer\",{\"1\":{\"139\":1}}],[\"found\",{\"1\":{\"26\":3,\"37\":1,\"47\":1,\"157\":1,\"174\":1,\"225\":1}}],[\"fork\",{\"1\":{\"228\":1}}],[\"forstmt\",{\"1\":{\"227\":7}}],[\"format=newc\",{\"1\":{\"291\":1,\"294\":1}}],[\"format\",{\"1\":{\"219\":2}}],[\"formatstr\",{\"1\":{\"219\":5}}],[\"foreachfunc\",{\"1\":{\"185\":1,\"189\":1}}],[\"foreach\",{\"1\":{\"185\":2,\"189\":2}}],[\"forallfunc\",{\"1\":{\"185\":1}}],[\"forall\",{\"1\":{\"185\":2}}],[\"force\",{\"1\":{\"92\":1,\"93\":1}}],[\"for\",{\"1\":{\"4\":11,\"14\":2,\"20\":1,\"23\":1,\"26\":1,\"30\":1,\"34\":1,\"39\":1,\"47\":2,\"48\":1,\"51\":1,\"64\":1,\"87\":2,\"88\":7,\"123\":1,\"124\":2,\"129\":4,\"131\":3,\"133\":1,\"134\":3,\"136\":3,\"144\":1,\"172\":1,\"174\":1,\"181\":2,\"187\":3,\"188\":3,\"189\":3,\"190\":1,\"198\":2,\"200\":2,\"212\":1,\"213\":3,\"218\":5,\"219\":4,\"224\":2,\"225\":2,\"227\":8,\"238\":3,\"240\":1,\"241\":2,\"243\":2,\"244\":3,\"263\":1,\"268\":4,\"283\":1,\"284\":3,\"285\":1,\"286\":6,\"291\":1,\"293\":1}}],[\"fixed\",{\"1\":{\"285\":1}}],[\"fixedwait\",{\"1\":{\"150\":1}}],[\"fit\",{\"0\":{\"240\":1},\"1\":{\"240\":5}}],[\"filt\",{\"1\":{\"286\":7}}],[\"filterfunc函数类型用于过滤数据\",{\"1\":{\"181\":1}}],[\"filterfunc\",{\"1\":{\"181\":5,\"184\":2}}],[\"filter\",{\"1\":{\"4\":4,\"13\":1,\"16\":1,\"18\":1,\"149\":1,\"177\":2,\"181\":7,\"184\":2,\"190\":1}}],[\"filling\",{\"1\":{\"284\":1}}],[\"fill\",{\"1\":{\"279\":1,\"284\":2,\"285\":1}}],[\"file\",{\"1\":{\"219\":1,\"225\":1,\"227\":2}}],[\"filesystem\",{\"1\":{\"293\":5}}],[\"files\",{\"1\":{\"172\":1,\"194\":4,\"198\":1,\"237\":1}}],[\"figure\",{\"1\":{\"134\":1,\"136\":1}}],[\"fin\",{\"1\":{\"282\":2,\"283\":22,\"284\":12,\"285\":3,\"286\":1}}],[\"finished\",{\"1\":{\"286\":6}}],[\"finish\",{\"1\":{\"268\":1,\"285\":6}}],[\"finally\",{\"1\":{\"157\":1}}],[\"final\",{\"1\":{\"144\":1,\"146\":1,\"149\":1,\"150\":1,\"164\":1}}],[\"finley\",{\"1\":{\"119\":1}}],[\"findrunnable\",{\"1\":{\"200\":2}}],[\"findbyid\",{\"1\":{\"164\":6}}],[\"findbyemail\",{\"1\":{\"164\":1}}],[\"finds\",{\"1\":{\"134\":1}}],[\"findsiblingnode\",{\"1\":{\"72\":1}}],[\"findpool\",{\"1\":{\"262\":1}}],[\"findpositionbyindex\",{\"1\":{\"47\":2,\"48\":1}}],[\"findparentnode\",{\"1\":{\"72\":1}}],[\"findleafpagebyoperation\",{\"1\":{\"73\":1}}],[\"findleafpage\",{\"1\":{\"70\":3,\"71\":1,\"72\":1}}],[\"findxxx\",{\"1\":{\"69\":1}}],[\"finditembyid\",{\"1\":{\"47\":2,\"48\":4}}],[\"finditembyindex使用\",{\"1\":{\"26\":1}}],[\"finditembyindex\",{\"1\":{\"26\":3}}],[\"find\",{\"1\":{\"26\":1,\"47\":1,\"51\":1,\"64\":4,\"134\":1,\"291\":1,\"294\":1}}],[\"fieldalign\",{\"1\":{\"208\":1}}],[\"field\",{\"1\":{\"113\":1,\"116\":2,\"219\":3}}],[\"fields\",{\"1\":{\"98\":1,\"181\":1,\"227\":1,\"263\":1}}],[\"fifo\",{\"1\":{\"63\":1}}],[\"firstterm\",{\"1\":{\"128\":1}}],[\"firstkey\",{\"1\":{\"71\":3}}],[\"firstop\",{\"1\":{\"36\":10,\"37\":5}}],[\"first\",{\"0\":{\"240\":1},\"1\":{\"30\":1,\"35\":2,\"51\":6,\"71\":1,\"128\":3,\"129\":2,\"133\":1,\"134\":3,\"136\":2,\"240\":3,\"283\":7,\"284\":3,\"286\":4}}],[\"framesize\",{\"1\":{\"256\":1}}],[\"frame\",{\"1\":{\"63\":23,\"64\":30,\"200\":1,\"250\":1}}],[\"frontend=noninteractive\",{\"1\":{\"291\":1}}],[\"front\",{\"1\":{\"47\":1,\"63\":3,\"64\":2,\"227\":1,\"284\":7,\"285\":1}}],[\"from\",{\"1\":{\"14\":2,\"131\":1,\"133\":1,\"170\":1,\"174\":1,\"175\":1,\"183\":3,\"207\":2,\"215\":1,\"227\":1,\"247\":1,\"277\":2,\"286\":16,\"291\":1}}],[\"freeconn\",{\"1\":{\"263\":2}}],[\"freelist\",{\"1\":{\"241\":6}}],[\"free\",{\"1\":{\"8\":1,\"10\":1,\"20\":1,\"64\":22,\"210\":2,\"227\":1,\"233\":1,\"234\":3,\"237\":2,\"239\":1,\"240\":4,\"241\":9,\"242\":2,\"243\":4,\"244\":2,\"263\":1,\"268\":1,\"294\":1}}],[\"frequently\",{\"1\":{\"4\":1}}],[\"f\",{\"1\":{\"5\":1,\"72\":3,\"181\":2,\"219\":5,\"225\":6,\"227\":3,\"291\":1}}],[\"ivpusic\",{\"1\":{\"264\":1}}],[\"ipv4\",{\"1\":{\"279\":1,\"287\":1}}],[\"ip\",{\"1\":{\"250\":1,\"278\":1}}],[\"i8\",{\"1\":{\"219\":9}}],[\"i32\",{\"1\":{\"219\":27}}],[\"images\",{\"1\":{\"293\":2}}],[\"immediate\",{\"1\":{\"218\":3}}],[\"imulq\",{\"1\":{\"253\":1}}],[\"imul\",{\"1\":{\"218\":7}}],[\"imull\",{\"1\":{\"213\":1}}],[\"imul3q\",{\"1\":{\"213\":1}}],[\"impl\",{\"1\":{\"247\":1}}],[\"implementation\",{\"1\":{\"266\":1,\"283\":1}}],[\"implemented\",{\"1\":{\"181\":1}}],[\"implements\",{\"1\":{\"144\":1,\"145\":1,\"147\":1,\"149\":1,\"157\":1,\"164\":1,\"170\":1}}],[\"implement\",{\"1\":{\"136\":1,\"161\":1}}],[\"improved\",{\"1\":{\"179\":1,\"266\":1}}],[\"import\",{\"1\":{\"4\":3,\"200\":2,\"210\":4,\"218\":1,\"219\":4,\"227\":1,\"237\":1,\"257\":1}}],[\"i<\",{\"1\":{\"144\":1}}],[\"i=0\",{\"1\":{\"144\":1}}],[\"ii\",{\"1\":{\"75\":1,\"80\":1}}],[\"itoa\",{\"1\":{\"213\":5}}],[\"itabs\",{\"1\":{\"200\":1}}],[\"itabsinit\",{\"1\":{\"200\":1}}],[\"its\",{\"1\":{\"134\":3,\"285\":2}}],[\"iterator\",{\"1\":{\"78\":1,\"79\":4,\"89\":3}}],[\"iterator>\",{\"1\":{\"63\":1}}],[\"iterations\",{\"1\":{\"51\":1}}],[\"item接口\",{\"1\":{\"181\":1}}],[\"item插入时\",{\"1\":{\"51\":1}}],[\"item是ymap的\",{\"1\":{\"50\":1}}],[\"item之间是分离的\",{\"1\":{\"50\":1}}],[\"item之间通过连续的双向链表连接在一起\",{\"1\":{\"50\":1}}],[\"item在新建时\",{\"1\":{\"48\":1}}],[\"item中之所有没有leftk​\",{\"1\":{\"47\":1}}],[\"item包含了content\",{\"1\":{\"47\":1}}],[\"item的id需要和parent\",{\"1\":{\"26\":1}}],[\"item\",{\"1\":{\"26\":43,\"34\":2,\"47\":21,\"48\":16,\"50\":9,\"51\":8,\"97\":1,\"98\":1,\"99\":1,\"177\":12,\"181\":9,\"183\":4,\"185\":1,\"187\":5,\"188\":7,\"189\":4,\"190\":6,\"219\":2}}],[\"item<t>>\",{\"1\":{\"26\":1}}],[\"item<t>\",{\"1\":{\"25\":2,\"26\":5,\"47\":4,\"48\":3}}],[\"itemsbeforeorigin\",{\"1\":{\"51\":5}}],[\"items\",{\"1\":{\"4\":1,\"51\":1,\"183\":1}}],[\"it\",{\"1\":{\"51\":1,\"63\":2,\"88\":1,\"134\":4,\"164\":1,\"200\":1,\"263\":1,\"285\":1,\"290\":1,\"291\":1}}],[\"i++\",{\"1\":{\"47\":1,\"48\":1,\"129\":1,\"134\":1,\"144\":1,\"238\":2,\"241\":2,\"243\":1,\"244\":1,\"268\":3,\"286\":1}}],[\"i+sstable\",{\"1\":{\"4\":1}}],[\"irgen\",{\"1\":{\"227\":3}}],[\"ir\",{\"1\":{\"47\":5,\"218\":43,\"219\":23,\"227\":38}}],[\"ir​<or​<o<i\",{\"1\":{\"44\":1}}],[\"ir​\",{\"1\":{\"44\":1}}],[\"i的origin\",{\"1\":{\"44\":1}}],[\"ignored\",{\"1\":{\"285\":2}}],[\"ignore\",{\"1\":{\"13\":1,\"16\":1,\"18\":1}}],[\"idlelru\",{\"1\":{\"263\":1}}],[\"idleconnwait\",{\"1\":{\"263\":1}}],[\"idleconn\",{\"1\":{\"263\":1}}],[\"idle\",{\"1\":{\"263\":1,\"268\":1}}],[\"idlemu\",{\"1\":{\"263\":1}}],[\"ident\",{\"1\":{\"219\":3}}],[\"idea\",{\"1\":{\"167\":1}}],[\"id=\",{\"1\":{\"170\":1,\"174\":1}}],[\"idk​\",{\"1\":{\"43\":2,\"44\":1,\"47\":1,\"48\":1}}],[\"idx\",{\"1\":{\"30\":5,\"31\":2,\"36\":2,\"37\":2}}],[\"id可以标识每个op的唯一性\",{\"1\":{\"13\":1}}],[\"id\",{\"1\":{\"4\":17,\"5\":8,\"13\":26,\"14\":1,\"16\":11,\"17\":4,\"18\":11,\"25\":19,\"26\":32,\"28\":2,\"31\":2,\"32\":1,\"36\":4,\"37\":6,\"43\":1,\"47\":18,\"48\":14,\"50\":12,\"51\":8,\"63\":26,\"64\":67,\"69\":11,\"70\":1,\"71\":2,\"72\":2,\"79\":4,\"85\":1,\"88\":12,\"123\":2,\"124\":3,\"126\":2,\"164\":3,\"174\":3,\"194\":1,\"200\":1,\"241\":6}}],[\"iota\",{\"1\":{\"243\":1}}],[\"ioutil\",{\"1\":{\"219\":1,\"260\":1}}],[\"ioexception\",{\"1\":{\"158\":10}}],[\"io\",{\"1\":{\"4\":1,\"62\":2,\"69\":2,\"112\":1,\"119\":2,\"174\":1,\"197\":3,\"294\":4}}],[\"i\",{\"1\":{\"4\":4,\"5\":1,\"26\":3,\"30\":4,\"44\":2,\"47\":17,\"48\":8,\"75\":1,\"80\":1,\"129\":4,\"134\":9,\"145\":2,\"210\":2,\"218\":2,\"219\":2,\"227\":30,\"236\":1,\"238\":5,\"241\":5,\"243\":3,\"244\":3,\"255\":1,\"268\":6,\"285\":1,\"286\":2}}],[\"isn\",{\"1\":{\"283\":12,\"284\":4,\"285\":2}}],[\"isnull\",{\"1\":{\"150\":1}}],[\"isspace\",{\"0\":{\"212\":1},\"1\":{\"212\":20,\"213\":1}}],[\"issue\",{\"1\":{\"198\":1}}],[\"issafety\",{\"1\":{\"73\":1}}],[\"ispresent\",{\"1\":{\"164\":1}}],[\"islockcompatible\",{\"1\":{\"88\":1}}],[\"isleafpage\",{\"1\":{\"70\":1,\"72\":1,\"73\":1}}],[\"isolationlevel\",{\"1\":{\"88\":2,\"89\":3}}],[\"isolation\",{\"1\":{\"83\":1}}],[\"isrootpage\",{\"1\":{\"71\":1,\"72\":1}}],[\"isempty\",{\"1\":{\"70\":1,\"71\":1,\"72\":1,\"158\":1}}],[\"isdirty\",{\"1\":{\"64\":4}}],[\"isdeletedk​\",{\"1\":{\"43\":2,\"44\":1,\"47\":1,\"48\":1}}],[\"isdeleted\",{\"1\":{\"25\":1,\"26\":8,\"47\":5,\"48\":3,\"50\":5}}],[\"is\",{\"1\":{\"4\":5,\"23\":1,\"34\":1,\"47\":2,\"48\":1,\"51\":4,\"64\":10,\"88\":1,\"136\":1,\"172\":2,\"173\":2,\"181\":2,\"200\":3,\"202\":1,\"219\":1,\"227\":2,\"262\":1,\"263\":2,\"266\":1,\"283\":2,\"285\":3,\"294\":2}}],[\"inbound\",{\"1\":{\"285\":3,\"286\":2}}],[\"inplace\",{\"1\":{\"218\":2}}],[\"inputstream\",{\"1\":{\"170\":5,\"172\":5,\"173\":1}}],[\"input\",{\"1\":{\"24\":1,\"45\":1,\"282\":1,\"283\":3,\"285\":2}}],[\"inner\",{\"1\":{\"212\":8,\"227\":3,\"243\":8,\"244\":1}}],[\"indirect\",{\"1\":{\"200\":1}}],[\"index++\",{\"1\":{\"218\":1}}],[\"indexes\",{\"1\":{\"75\":2}}],[\"indexpagetype\",{\"1\":{\"69\":1}}],[\"index\",{\"1\":{\"4\":11,\"30\":1,\"34\":6,\"35\":3,\"36\":3,\"37\":3,\"49\":6,\"59\":1,\"69\":2,\"72\":1,\"79\":2,\"128\":2,\"134\":1,\"136\":17,\"146\":2,\"157\":2,\"158\":1,\"218\":13,\"227\":1,\"282\":28,\"283\":21}}],[\"inherittime\",{\"1\":{\"200\":5}}],[\"invoke\",{\"1\":{\"150\":1}}],[\"invocation\",{\"1\":{\"149\":6,\"150\":4}}],[\"invalid\",{\"1\":{\"72\":1,\"93\":1,\"136\":1,\"146\":2,\"227\":2}}],[\"information\",{\"1\":{\"291\":1}}],[\"info\",{\"1\":{\"144\":1,\"149\":1,\"151\":1,\"237\":2,\"238\":1,\"286\":22,\"291\":1}}],[\"influxdb\",{\"1\":{\"56\":1}}],[\"inline\",{\"1\":{\"93\":4}}],[\"instructions\",{\"1\":{\"212\":1}}],[\"instruction\",{\"1\":{\"200\":1,\"202\":1}}],[\"install\",{\"1\":{\"225\":2,\"291\":4,\"292\":6}}],[\"installed\",{\"1\":{\"224\":2,\"225\":2,\"293\":1}}],[\"installsnapshotreply\",{\"1\":{\"136\":4}}],[\"installsnapshotargs\",{\"1\":{\"136\":4}}],[\"installsnapshot\",{\"1\":{\"136\":7,\"139\":2}}],[\"instanceof\",{\"1\":{\"150\":1}}],[\"instead\",{\"1\":{\"51\":1}}],[\"insertspan\",{\"1\":{\"241\":1}}],[\"insertindex++\",{\"1\":{\"129\":1}}],[\"insertindex\",{\"1\":{\"129\":5,\"133\":2}}],[\"insertintoparent\",{\"1\":{\"71\":3}}],[\"insertintoleaf\",{\"1\":{\"71\":2}}],[\"inserter\",{\"1\":{\"79\":1,\"89\":1}}],[\"insertnewkey\",{\"1\":{\"71\":1}}],[\"insert函数有两个参数\",{\"1\":{\"44\":1}}],[\"insert字段表示是否为插入操作\",{\"1\":{\"28\":1}}],[\"insert|update\",{\"1\":{\"28\":1}}],[\"insert将字符插入到pos位置\",{\"1\":{\"26\":1}}],[\"insert\",{\"0\":{\"36\":1},\"1\":{\"25\":6,\"26\":3,\"27\":1,\"28\":1,\"31\":1,\"34\":2,\"36\":4,\"37\":1,\"47\":3,\"48\":4,\"49\":2,\"50\":2,\"71\":4,\"79\":1,\"84\":1,\"88\":2,\"241\":1,\"282\":1}}],[\"incoming\",{\"1\":{\"285\":1,\"286\":1}}],[\"including\",{\"1\":{\"285\":1}}],[\"include\",{\"1\":{\"59\":1,\"197\":1,\"200\":1,\"210\":3,\"212\":1,\"213\":1,\"237\":4,\"257\":1,\"294\":7}}],[\"incl\",{\"1\":{\"227\":1}}],[\"incubator\",{\"1\":{\"119\":1}}],[\"inc\",{\"1\":{\"31\":1,\"32\":1,\"35\":1,\"36\":1,\"37\":1}}],[\"increment\",{\"1\":{\"13\":6,\"14\":2,\"237\":3}}],[\"intptr\",{\"1\":{\"237\":1}}],[\"int31\",{\"1\":{\"213\":2}}],[\"int32\",{\"1\":{\"123\":1,\"124\":2,\"130\":1,\"133\":1,\"179\":1,\"200\":3,\"208\":2}}],[\"int64\",{\"1\":{\"179\":1,\"184\":2,\"188\":1,\"200\":1,\"218\":2,\"263\":1}}],[\"int\",{\"1\":{\"69\":5,\"70\":1,\"79\":1,\"123\":5,\"124\":7,\"126\":13,\"128\":7,\"129\":4,\"130\":3,\"131\":2,\"133\":5,\"134\":4,\"136\":21,\"137\":1,\"144\":1,\"145\":2,\"146\":2,\"177\":5,\"179\":11,\"180\":3,\"181\":3,\"185\":1,\"188\":1,\"189\":2,\"190\":5,\"197\":4,\"198\":4,\"207\":3,\"208\":3,\"210\":8,\"213\":5,\"218\":5,\"219\":11,\"234\":5,\"237\":7,\"238\":4,\"240\":2,\"241\":3,\"243\":9,\"244\":4,\"256\":3,\"262\":1,\"263\":2,\"268\":1,\"284\":4,\"286\":4,\"294\":4}}],[\"into\",{\"1\":{\"53\":1,\"227\":1,\"237\":1}}],[\"intellisense\",{\"1\":{\"291\":1}}],[\"intel\",{\"1\":{\"248\":2}}],[\"integers\",{\"1\":{\"280\":2}}],[\"integer\",{\"1\":{\"243\":2}}],[\"integration\",{\"1\":{\"51\":1}}],[\"integrated\",{\"1\":{\"26\":1,\"51\":1}}],[\"integrate\",{\"1\":{\"26\":4,\"47\":2,\"48\":3,\"51\":1}}],[\"intention\",{\"1\":{\"28\":1}}],[\"interested\",{\"1\":{\"283\":1}}],[\"intermediate\",{\"1\":{\"218\":1}}],[\"interpret\",{\"1\":{\"174\":1}}],[\"interpreters\",{\"1\":{\"247\":1}}],[\"interpreter\",{\"1\":{\"174\":1}}],[\"interfaces\",{\"1\":{\"181\":1}}],[\"interface\",{\"1\":{\"128\":1,\"131\":1,\"136\":1,\"144\":1,\"145\":1,\"147\":1,\"149\":1,\"155\":1,\"158\":1,\"164\":1,\"179\":4,\"181\":2,\"208\":3,\"218\":5,\"243\":1,\"261\":1,\"262\":2,\"268\":1,\"293\":1}}],[\"interval\",{\"1\":{\"88\":1}}],[\"internal\",{\"1\":{\"69\":4,\"71\":1,\"72\":3,\"200\":1,\"217\":1,\"225\":8,\"227\":35}}],[\"internalpage\",{\"1\":{\"69\":8}}],[\"internals\",{\"1\":{\"53\":1,\"229\":1}}],[\"intergrate\",{\"1\":{\"26\":1}}],[\"interactive\",{\"1\":{\"20\":1}}],[\"introduction\",{\"1\":{\"288\":1}}],[\"intro\",{\"1\":{\"20\":1,\"215\":2}}],[\"in\",{\"0\":{\"218\":1},\"1\":{\"4\":18,\"13\":1,\"30\":1,\"34\":1,\"47\":1,\"51\":3,\"64\":1,\"134\":3,\"136\":1,\"200\":3,\"202\":1,\"204\":1,\"224\":2,\"225\":3,\"227\":2,\"247\":2,\"263\":1,\"266\":1,\"282\":1,\"283\":3,\"284\":22,\"285\":12,\"286\":2,\"293\":1}}],[\"initrd\",{\"1\":{\"291\":3,\"294\":1}}],[\"initramfs\",{\"1\":{\"291\":11,\"294\":6}}],[\"initiate\",{\"1\":{\"286\":1}}],[\"initial\",{\"1\":{\"268\":2,\"284\":4,\"293\":1}}],[\"initialgcthreshold\",{\"1\":{\"243\":1}}],[\"initialize\",{\"1\":{\"131\":1,\"133\":1}}],[\"inittask\",{\"1\":{\"200\":2}}],[\"initsigmask\",{\"1\":{\"200\":1}}],[\"init=runscript\",{\"1\":{\"170\":1}}],[\"init\",{\"1\":{\"4\":9,\"13\":2,\"16\":2,\"17\":2,\"71\":2,\"79\":4,\"200\":2,\"227\":23,\"238\":2,\"291\":6,\"294\":1}}],[\"ifstmt\",{\"1\":{\"225\":1,\"227\":1}}],[\"if+return\",{\"1\":{\"225\":2}}],[\"ifndef\",{\"1\":{\"212\":1}}],[\"ifnode\",{\"1\":{\"174\":5}}],[\"ifnode类中解析test语句\",{\"1\":{\"174\":1}}],[\"if>\",{\"1\":{\"174\":1}}],[\"if\",{\"0\":{\"174\":1},\"1\":{\"4\":25,\"5\":1,\"13\":4,\"16\":3,\"17\":2,\"18\":3,\"26\":12,\"30\":1,\"34\":4,\"36\":1,\"37\":1,\"47\":10,\"48\":9,\"50\":4,\"51\":16,\"63\":3,\"64\":15,\"70\":3,\"71\":5,\"72\":7,\"73\":3,\"78\":1,\"79\":1,\"88\":6,\"89\":4,\"124\":10,\"128\":1,\"129\":17,\"130\":3,\"131\":1,\"133\":9,\"134\":11,\"136\":13,\"137\":3,\"146\":3,\"150\":1,\"157\":1,\"164\":2,\"172\":1,\"173\":1,\"174\":2,\"179\":1,\"181\":1,\"188\":2,\"189\":1,\"200\":17,\"210\":1,\"212\":1,\"213\":3,\"218\":10,\"219\":13,\"223\":1,\"225\":10,\"226\":1,\"227\":16,\"237\":1,\"238\":2,\"240\":3,\"241\":10,\"243\":7,\"244\":3,\"260\":1,\"262\":3,\"281\":1,\"282\":7,\"283\":10,\"284\":13,\"285\":24,\"286\":4,\"294\":1}}],[\"vscode\",{\"1\":{\"291\":1}}],[\"v4\",{\"1\":{\"291\":1}}],[\"vmlinux\",{\"1\":{\"291\":1}}],[\"vm\",{\"1\":{\"194\":2,\"198\":1,\"218\":1,\"243\":28,\"244\":17,\"294\":4}}],[\"volatile\",{\"1\":{\"194\":1}}],[\"votegranted=true\",{\"1\":{\"124\":1}}],[\"votegranted\",{\"1\":{\"124\":4,\"130\":1,\"133\":1}}],[\"votes\",{\"1\":{\"124\":5,\"130\":1,\"133\":1}}],[\"vote\",{\"1\":{\"123\":1}}],[\"votedfor\",{\"1\":{\"123\":5,\"124\":9,\"126\":1,\"130\":5,\"133\":12,\"139\":1}}],[\"void\",{\"1\":{\"13\":4,\"14\":3,\"16\":3,\"17\":2,\"18\":3,\"63\":4,\"64\":2,\"71\":2,\"72\":5,\"79\":2,\"88\":1,\"93\":4,\"94\":2,\"146\":2,\"155\":8,\"157\":1,\"158\":4,\"164\":5,\"170\":1,\"194\":1,\"210\":3,\"237\":8,\"281\":1,\"282\":2,\"283\":1,\"284\":3,\"285\":6,\"286\":3,\"294\":1}}],[\"variadic\",{\"1\":{\"219\":2}}],[\"variables\",{\"1\":{\"174\":2}}],[\"variable\",{\"1\":{\"69\":1,\"204\":1,\"218\":2,\"285\":1}}],[\"vars\",{\"1\":{\"197\":1}}],[\"var\",{\"1\":{\"124\":1,\"133\":1,\"164\":2,\"174\":1,\"181\":2,\"189\":1,\"200\":4,\"203\":1,\"208\":1,\"213\":2,\"227\":1,\"238\":3,\"255\":1,\"260\":1,\"262\":2,\"268\":1}}],[\"val\",{\"1\":{\"70\":2,\"213\":16,\"219\":2,\"294\":1}}],[\"value指令将栈顶值返回\",{\"1\":{\"218\":1}}],[\"value=\",{\"1\":{\"170\":4}}],[\"valuetype>\",{\"1\":{\"69\":1}}],[\"valuetype\",{\"1\":{\"69\":5,\"70\":1}}],[\"value是item\",{\"1\":{\"26\":1}}],[\"value++\",{\"1\":{\"13\":1}}],[\"values\",{\"1\":{\"4\":19,\"14\":2,\"79\":4,\"89\":4}}],[\"value\",{\"1\":{\"4\":20,\"13\":15,\"16\":11,\"17\":8,\"18\":8,\"27\":1,\"28\":1,\"30\":1,\"31\":4,\"34\":1,\"36\":3,\"37\":3,\"49\":1,\"50\":3,\"51\":2,\"69\":2,\"70\":2,\"71\":7,\"79\":1,\"113\":1,\"114\":3,\"116\":1,\"119\":1,\"164\":2,\"208\":2,\"218\":4,\"219\":3,\"225\":2,\"227\":2,\"243\":2,\"255\":2,\"283\":3,\"284\":5,\"285\":3}}],[\"visit\",{\"1\":{\"291\":1}}],[\"visual\",{\"1\":{\"247\":1}}],[\"view\",{\"1\":{\"291\":1}}],[\"vim\",{\"1\":{\"291\":1}}],[\"vi\",{\"1\":{\"181\":4}}],[\"vi通过\",{\"1\":{\"181\":1}}],[\"vi是一个简单的整数切片\",{\"1\":{\"181\":1}}],[\"virtual\",{\"1\":{\"79\":5}}],[\"victim\",{\"1\":{\"63\":2,\"64\":2,\"262\":1}}],[\"viable\",{\"1\":{\"0\":1}}],[\"ve\",{\"1\":{\"285\":1}}],[\"vet\",{\"1\":{\"261\":1}}],[\"verify\",{\"1\":{\"164\":3}}],[\"version=\",{\"1\":{\"170\":1}}],[\"version\",{\"1\":{\"26\":1,\"114\":1,\"146\":4,\"212\":1,\"224\":2,\"277\":1,\"291\":1,\"293\":1}}],[\"vector<value>\",{\"1\":{\"79\":1,\"89\":1}}],[\"vector<const\",{\"1\":{\"79\":2}}],[\"vector<tuple>\",{\"1\":{\"78\":1}}],[\"vectorized\",{\"1\":{\"78\":1}}],[\"vector用来记录不同客户端的\",{\"1\":{\"13\":1}}],[\"vector\",{\"1\":{\"13\":7,\"23\":1,\"26\":8,\"47\":7,\"48\":3,\"50\":3}}],[\"v\",{\"1\":{\"5\":1,\"14\":4,\"69\":5,\"181\":6,\"212\":2,\"213\":2,\"218\":1,\"227\":5,\"238\":4,\"243\":42,\"244\":24,\"277\":1}}],[\"=2\",{\"1\":{\"284\":1}}],[\"=r\",{\"1\":{\"210\":1}}],[\"=>\",{\"1\":{\"13\":1,\"14\":2,\"16\":1,\"18\":1,\"47\":2,\"50\":1,\"51\":1,\"64\":1,\"200\":3}}],[\"==dbg==\",{\"1\":{\"291\":2}}],[\"===\",{\"1\":{\"13\":2,\"16\":2,\"17\":1,\"18\":2,\"26\":4,\"47\":5,\"48\":4,\"51\":1,\"207\":1,\"212\":3,\"227\":1}}],[\"==\",{\"1\":{\"4\":2,\"5\":12,\"13\":1,\"26\":3,\"34\":3,\"37\":1,\"47\":1,\"48\":2,\"51\":16,\"64\":2,\"72\":2,\"73\":2,\"79\":1,\"88\":5,\"89\":1,\"124\":5,\"128\":1,\"129\":2,\"130\":3,\"131\":1,\"133\":4,\"134\":4,\"136\":3,\"157\":1,\"174\":1,\"179\":1,\"200\":8,\"210\":1,\"212\":4,\"218\":13,\"219\":4,\"237\":1,\"240\":1,\"241\":5,\"243\":5,\"244\":2,\"262\":1,\"282\":4,\"284\":2,\"285\":4,\"286\":1,\"294\":4}}],[\"=\",{\"1\":{\"4\":62,\"5\":2,\"13\":14,\"14\":6,\"15\":1,\"16\":9,\"17\":6,\"18\":8,\"25\":3,\"26\":28,\"28\":4,\"30\":6,\"31\":4,\"32\":4,\"34\":5,\"35\":3,\"36\":5,\"37\":5,\"47\":27,\"48\":17,\"50\":18,\"51\":23,\"63\":4,\"64\":16,\"69\":7,\"70\":11,\"71\":12,\"72\":7,\"73\":4,\"78\":2,\"79\":12,\"88\":5,\"89\":7,\"93\":5,\"94\":2,\"123\":10,\"124\":22,\"128\":1,\"129\":47,\"130\":6,\"131\":10,\"133\":18,\"134\":17,\"136\":32,\"137\":10,\"145\":2,\"146\":8,\"149\":1,\"150\":1,\"157\":7,\"164\":9,\"170\":3,\"172\":14,\"173\":3,\"174\":14,\"177\":2,\"179\":1,\"181\":8,\"187\":5,\"188\":10,\"189\":2,\"190\":1,\"197\":4,\"198\":3,\"200\":81,\"202\":4,\"203\":2,\"207\":8,\"208\":5,\"210\":4,\"212\":5,\"213\":15,\"218\":38,\"219\":53,\"223\":1,\"225\":36,\"227\":61,\"234\":2,\"237\":2,\"238\":73,\"240\":13,\"241\":19,\"243\":35,\"244\":14,\"251\":1,\"253\":2,\"257\":2,\"260\":2,\"262\":5,\"264\":1,\"268\":6,\"281\":7,\"282\":22,\"283\":18,\"284\":27,\"285\":17,\"286\":6,\"294\":1}}],[\"ctrl\",{\"1\":{\"293\":1}}],[\"ct\",{\"1\":{\"292\":3}}],[\"ctxt\",{\"1\":{\"200\":2,\"227\":1}}],[\"ctx\",{\"1\":{\"78\":3,\"79\":10,\"89\":11,\"146\":1}}],[\"custom\",{\"1\":{\"293\":1}}],[\"cut\",{\"1\":{\"291\":1}}],[\"cur\",{\"1\":{\"240\":3,\"282\":20}}],[\"curg\",{\"1\":{\"200\":2}}],[\"curvotes\",{\"1\":{\"124\":2}}],[\"currentterm\",{\"1\":{\"123\":5,\"124\":8,\"126\":1,\"129\":6,\"130\":2,\"133\":12,\"134\":1,\"136\":6,\"139\":1}}],[\"current\",{\"1\":{\"4\":12,\"28\":1,\"34\":1,\"47\":1,\"48\":1,\"51\":2,\"284\":5}}],[\"cgroup\",{\"1\":{\"294\":1}}],[\"cgdb\",{\"1\":{\"291\":1}}],[\"cgo\",{\"0\":{\"210\":1},\"1\":{\"210\":4,\"212\":3,\"215\":2}}],[\"cerr\",{\"1\":{\"286\":5}}],[\"central\",{\"1\":{\"241\":8}}],[\"c++菜的要死\",{\"1\":{\"283\":1}}],[\"c++的拥趸者觉得这已经够了\",{\"1\":{\"234\":1}}],[\"c++为了改善一点\",{\"1\":{\"234\":1}}],[\"c++\",{\"1\":{\"234\":1,\"293\":1}}],[\"c++程序员们\",{\"1\":{\"232\":1}}],[\"cfs\",{\"1\":{\"227\":3}}],[\"cfg\",{\"1\":{\"227\":1,\"285\":9}}],[\"cd\",{\"1\":{\"224\":2,\"225\":1,\"227\":2,\"290\":1,\"291\":6,\"292\":3,\"293\":3,\"294\":3}}],[\"cs\",{\"1\":{\"288\":1}}],[\"cs144\",{\"1\":{\"270\":2,\"278\":2,\"287\":1}}],[\"css\",{\"1\":{\"263\":1}}],[\"csdn\",{\"1\":{\"215\":1,\"295\":1}}],[\"csail\",{\"1\":{\"140\":1}}],[\"cnblogs\",{\"1\":{\"266\":1,\"295\":1}}],[\"cn\",{\"1\":{\"215\":2,\"291\":1,\"295\":1}}],[\"cwd\",{\"1\":{\"198\":1,\"291\":1}}],[\"cp\",{\"1\":{\"291\":2,\"294\":1}}],[\"cpio\",{\"1\":{\"291\":7,\"293\":1,\"294\":5}}],[\"cpython\",{\"1\":{\"218\":1}}],[\"cpumask\",{\"1\":{\"294\":9}}],[\"cpus\",{\"1\":{\"294\":23}}],[\"cpuinit\",{\"1\":{\"200\":1}}],[\"cpu\",{\"1\":{\"198\":1,\"200\":6,\"231\":10,\"232\":1,\"286\":2,\"294\":48}}],[\"cppdbg\",{\"1\":{\"291\":1}}],[\"cpp\",{\"1\":{\"79\":10,\"228\":1,\"291\":1}}],[\"cx\",{\"1\":{\"180\":1,\"200\":10,\"213\":4,\"250\":1}}],[\"cycles\",{\"1\":{\"268\":1}}],[\"cycle\",{\"1\":{\"88\":4,\"268\":1}}],[\"cv\",{\"1\":{\"88\":2}}],[\"cvrdt\",{\"1\":{\"10\":1}}],[\"cmpq\",{\"1\":{\"254\":2}}],[\"cmpl\",{\"1\":{\"213\":1}}],[\"cmpb\",{\"1\":{\"212\":1}}],[\"cmd\",{\"1\":{\"200\":1,\"224\":2,\"225\":11,\"227\":35}}],[\"cmu\",{\"1\":{\"56\":1}}],[\"cmu15445\",{\"1\":{\"56\":2,\"60\":1}}],[\"cmrdt\",{\"1\":{\"10\":1}}],[\"crosstool\",{\"0\":{\"292\":1},\"1\":{\"292\":8}}],[\"crafting\",{\"1\":{\"247\":1}}],[\"crash\",{\"1\":{\"131\":1,\"133\":1,\"200\":1}}],[\"crabbing\",{\"0\":{\"73\":1},\"1\":{\"73\":6,\"74\":1}}],[\"crc32\",{\"1\":{\"106\":1}}],[\"createqueueresponse\",{\"1\":{\"157\":1}}],[\"createqueuerequest\",{\"1\":{\"157\":1}}],[\"createqueue\",{\"1\":{\"157\":1}}],[\"createexecutor\",{\"1\":{\"78\":2}}],[\"create\",{\"1\":{\"47\":1,\"48\":1,\"170\":1,\"200\":1}}],[\"creator\",{\"1\":{\"44\":1}}],[\"crdts\",{\"1\":{\"20\":1,\"53\":2}}],[\"crdt\",{\"1\":{\"8\":20,\"9\":6,\"10\":17,\"11\":4,\"15\":1,\"18\":2,\"19\":5,\"20\":2,\"22\":5,\"23\":2,\"27\":2,\"38\":1,\"39\":1,\"41\":4,\"49\":2,\"52\":1}}],[\"cid\",{\"1\":{\"26\":4,\"47\":2,\"50\":2}}],[\"chrisdone\",{\"1\":{\"295\":1}}],[\"chrono\",{\"1\":{\"286\":1}}],[\"chmod\",{\"1\":{\"291\":1}}],[\"ch2\",{\"1\":{\"215\":2}}],[\"chenzhuoyu\",{\"1\":{\"212\":1}}],[\"checks\",{\"1\":{\"263\":1,\"291\":1}}],[\"checker\",{\"1\":{\"227\":1}}],[\"checkbranches\",{\"1\":{\"227\":1}}],[\"checkout\",{\"1\":{\"224\":2}}],[\"checktimers\",{\"1\":{\"200\":1}}],[\"check\",{\"1\":{\"137\":1,\"227\":9}}],[\"checkpoint\",{\"1\":{\"58\":1,\"283\":2}}],[\"ch\",{\"1\":{\"212\":11}}],[\"chicago\",{\"1\":{\"164\":1}}],[\"child\",{\"1\":{\"26\":2,\"73\":6}}],[\"children中的id进行比较\",{\"1\":{\"26\":1}}],[\"children中\",{\"1\":{\"26\":1}}],[\"children\",{\"1\":{\"26\":12,\"79\":5}}],[\"chai2010\",{\"1\":{\"215\":1}}],[\"change\",{\"1\":{\"237\":1}}],[\"channelpool\",{\"1\":{\"263\":1}}],[\"channel记得关闭是个好习惯\",{\"1\":{\"188\":1}}],[\"channels\",{\"1\":{\"181\":1}}],[\"channelhandlercontext\",{\"1\":{\"146\":3}}],[\"channel\",{\"1\":{\"123\":1,\"126\":1,\"153\":1,\"158\":4,\"183\":2,\"186\":1,\"187\":1,\"188\":2,\"190\":1,\"263\":1,\"264\":1}}],[\"chan\",{\"1\":{\"123\":1,\"124\":1,\"126\":1,\"131\":1,\"133\":1,\"136\":1,\"183\":2,\"187\":2,\"188\":2,\"200\":1,\"263\":1}}],[\"char\",{\"1\":{\"93\":3,\"94\":2,\"197\":1,\"212\":4,\"213\":2,\"234\":1,\"286\":2,\"294\":1}}],[\"chatgpt\",{\"0\":{\"2\":1},\"1\":{\"3\":3,\"4\":1,\"5\":1}}],[\"caching\",{\"1\":{\"247\":1}}],[\"cache\",{\"1\":{\"98\":1,\"241\":10}}],[\"callexpr\",{\"1\":{\"219\":2}}],[\"caller\",{\"1\":{\"200\":1}}],[\"callerpc\",{\"1\":{\"200\":2}}],[\"callergp\",{\"1\":{\"200\":2}}],[\"calling\",{\"1\":{\"215\":1}}],[\"callable\",{\"1\":{\"150\":2}}],[\"callable<object>\",{\"1\":{\"150\":1}}],[\"call\",{\"1\":{\"124\":1,\"129\":1,\"136\":1,\"142\":1,\"149\":1,\"150\":1,\"196\":1,\"200\":8,\"204\":1,\"219\":2,\"221\":1,\"251\":1,\"256\":2}}],[\"cat\",{\"1\":{\"283\":1,\"291\":1,\"294\":2}}],[\"catch\",{\"1\":{\"78\":1,\"150\":1,\"157\":1,\"172\":2,\"286\":2}}],[\"catalog\",{\"1\":{\"59\":1,\"79\":1}}],[\"casgstatus\",{\"1\":{\"200\":3}}],[\"cast<internalpage>\",{\"1\":{\"71\":2}}],[\"cast<internalpage\",{\"1\":{\"69\":1}}],[\"cast<leafpage>\",{\"1\":{\"70\":1,\"71\":2,\"72\":1}}],[\"cast<leafpage\",{\"1\":{\"69\":1}}],[\"cast\",{\"1\":{\"69\":2}}],[\"case2\",{\"1\":{\"43\":1,\"47\":1}}],[\"case1\",{\"1\":{\"43\":1,\"47\":1}}],[\"case\",{\"1\":{\"8\":1,\"43\":1,\"48\":1,\"51\":2,\"89\":3,\"200\":1,\"218\":17,\"225\":4,\"227\":20,\"283\":1,\"284\":4,\"285\":7}}],[\"cancelkey\",{\"1\":{\"263\":1}}],[\"candidateid\",{\"1\":{\"124\":4,\"130\":4,\"133\":2}}],[\"candidate\",{\"1\":{\"123\":5,\"124\":2,\"139\":1}}],[\"can\",{\"1\":{\"26\":1,\"47\":1,\"51\":1,\"200\":2,\"240\":3}}],[\"capacity\",{\"1\":{\"281\":6,\"282\":2,\"283\":3,\"285\":2}}],[\"cap=10\",{\"1\":{\"207\":4}}],[\"cap=6\",{\"1\":{\"207\":2}}],[\"cap\",{\"1\":{\"10\":1,\"207\":2,\"208\":6,\"262\":1,\"268\":2}}],[\"cc\",{\"1\":{\"5\":1,\"280\":6}}],[\"c\",{\"0\":{\"209\":1},\"1\":{\"5\":3,\"51\":3,\"69\":1,\"71\":3,\"72\":8,\"73\":9,\"144\":1,\"164\":3,\"165\":1,\"197\":3,\"210\":12,\"212\":6,\"213\":2,\"214\":1,\"215\":1,\"217\":2,\"218\":13,\"219\":2,\"227\":2,\"228\":1,\"232\":1,\"233\":1,\"234\":2,\"237\":5,\"239\":1,\"255\":1,\"257\":2,\"263\":1,\"283\":1,\"286\":11,\"291\":1,\"293\":1,\"294\":3}}],[\"co\",{\"0\":{\"298\":1}}],[\"corresponding\",{\"1\":{\"283\":1}}],[\"correctly\",{\"1\":{\"227\":1}}],[\"corner\",{\"1\":{\"283\":1,\"284\":4,\"285\":6}}],[\"copy\",{\"1\":{\"200\":2,\"207\":3,\"218\":1,\"283\":1}}],[\"cover\",{\"1\":{\"150\":1}}],[\"coalesceorredistribute\",{\"1\":{\"72\":3}}],[\"coalesce\",{\"1\":{\"72\":4,\"241\":1}}],[\"cout\",{\"1\":{\"286\":2}}],[\"count++\",{\"1\":{\"189\":1}}],[\"count就必须全部遍历\",{\"1\":{\"189\":1}}],[\"count\",{\"1\":{\"64\":18,\"185\":2,\"189\":4,\"257\":1,\"282\":6}}],[\"counterstate\",{\"1\":{\"14\":3}}],[\"counter\",{\"0\":{\"12\":1,\"13\":1,\"14\":1},\"1\":{\"10\":7,\"11\":1,\"12\":2,\"13\":2,\"14\":1,\"15\":1,\"19\":1,\"25\":1,\"28\":1,\"263\":1}}],[\"could\",{\"1\":{\"26\":1}}],[\"colobu\",{\"1\":{\"266\":1}}],[\"collect\",{\"1\":{\"247\":1}}],[\"collected\",{\"1\":{\"243\":1}}],[\"collector\",{\"1\":{\"200\":1,\"245\":1,\"247\":1}}],[\"collection\",{\"1\":{\"188\":1,\"235\":1}}],[\"collaborative\",{\"1\":{\"20\":1,\"23\":1,\"39\":1}}],[\"col\",{\"1\":{\"79\":2,\"89\":2}}],[\"column\",{\"1\":{\"79\":2,\"89\":2}}],[\"cola中\",{\"1\":{\"23\":1}}],[\"com\",{\"1\":{\"90\":2,\"119\":12,\"164\":1,\"191\":8,\"212\":1,\"215\":2,\"224\":1,\"266\":4,\"290\":1,\"291\":11,\"292\":1,\"295\":6}}],[\"comes\",{\"1\":{\"51\":1}}],[\"compat\",{\"1\":{\"294\":12}}],[\"comparable\",{\"1\":{\"181\":9}}],[\"comparator\",{\"1\":{\"69\":2}}],[\"compare\",{\"1\":{\"26\":1,\"51\":2}}],[\"compression\",{\"1\":{\"293\":1}}],[\"comprehensive\",{\"1\":{\"8\":1,\"10\":1,\"19\":1,\"20\":1}}],[\"computer\",{\"1\":{\"288\":1}}],[\"computing\",{\"1\":{\"183\":1}}],[\"compiling\",{\"1\":{\"221\":1}}],[\"compiler\",{\"1\":{\"218\":1,\"229\":2,\"291\":1}}],[\"compile\",{\"1\":{\"180\":1,\"200\":1,\"217\":4,\"218\":3,\"225\":8,\"227\":35,\"291\":2}}],[\"complex64\",{\"1\":{\"179\":2}}],[\"commands\",{\"1\":{\"224\":2,\"225\":2}}],[\"commandindex\",{\"1\":{\"131\":2,\"136\":1}}],[\"commandvalid\",{\"1\":{\"131\":2,\"136\":2}}],[\"command\",{\"1\":{\"128\":4,\"131\":3,\"136\":5,\"219\":1}}],[\"common\",{\"1\":{\"59\":1,\"188\":3,\"294\":1}}],[\"commutative\",{\"1\":{\"8\":2,\"10\":2,\"19\":1,\"20\":1}}],[\"commitindex\",{\"1\":{\"126\":2,\"129\":9,\"131\":7,\"134\":5,\"136\":10}}],[\"committed\",{\"1\":{\"89\":1}}],[\"commited\",{\"1\":{\"85\":1}}],[\"commit\",{\"1\":{\"4\":4,\"5\":1,\"27\":1,\"85\":2,\"225\":1}}],[\"conn\",{\"1\":{\"263\":3}}],[\"connrequest\",{\"1\":{\"263\":1}}],[\"connrequests\",{\"1\":{\"263\":1}}],[\"connlru\",{\"1\":{\"263\":1}}],[\"conns\",{\"1\":{\"263\":1}}],[\"connpool\",{\"0\":{\"263\":1}}],[\"connected\",{\"1\":{\"286\":1}}],[\"connecting\",{\"1\":{\"286\":1}}],[\"connections\",{\"1\":{\"263\":4}}],[\"connection\",{\"1\":{\"174\":1,\"270\":1,\"277\":2,\"280\":2,\"284\":1,\"285\":3,\"286\":5}}],[\"connectionwrappers\",{\"1\":{\"145\":7}}],[\"connectionwrapper\",{\"1\":{\"145\":4}}],[\"connect\",{\"1\":{\"286\":5}}],[\"connectmethodkey\",{\"1\":{\"263\":2}}],[\"connector\",{\"1\":{\"151\":1,\"263\":2}}],[\"condbranch\",{\"1\":{\"227\":1}}],[\"cond\",{\"1\":{\"225\":2,\"227\":29}}],[\"condinstallsnapshot\",{\"1\":{\"136\":7,\"138\":1}}],[\"condition\",{\"1\":{\"44\":1,\"227\":5}}],[\"configs\",{\"1\":{\"293\":1}}],[\"configure\",{\"1\":{\"292\":1,\"293\":1}}],[\"configurations\",{\"1\":{\"291\":1}}],[\"configurationelement\",{\"1\":{\"172\":4}}],[\"configurationconfig\",{\"1\":{\"170\":1,\"172\":5}}],[\"configuration>\",{\"1\":{\"170\":1}}],[\"configuration\",{\"1\":{\"170\":1,\"172\":1,\"293\":5}}],[\"configparser\",{\"1\":{\"172\":5}}],[\"config\",{\"1\":{\"170\":4,\"172\":2,\"291\":1,\"293\":1}}],[\"conflictindex\",{\"1\":{\"134\":7,\"137\":2}}],[\"conflictingitems\",{\"1\":{\"51\":7}}],[\"conflicting\",{\"1\":{\"51\":3}}],[\"conflictterm\",{\"1\":{\"134\":7,\"137\":1}}],[\"conflicts\",{\"1\":{\"51\":1}}],[\"conflict\",{\"1\":{\"10\":1,\"20\":1,\"47\":1,\"134\":1}}],[\"concatenate\",{\"1\":{\"281\":1}}],[\"concat\",{\"1\":{\"177\":1,\"183\":3,\"187\":3,\"190\":1}}],[\"concurrency\",{\"1\":{\"59\":2,\"90\":3}}],[\"concepts\",{\"1\":{\"56\":1,\"60\":1,\"65\":1,\"75\":2,\"80\":1,\"90\":1,\"95\":1}}],[\"continually\",{\"1\":{\"268\":1}}],[\"continueok\",{\"1\":{\"227\":1}}],[\"continue\",{\"1\":{\"26\":1,\"124\":2,\"129\":1,\"218\":6,\"219\":4,\"227\":1}}],[\"control\",{\"1\":{\"90\":3,\"227\":1}}],[\"contentlength\",{\"1\":{\"146\":1}}],[\"contentany\",{\"1\":{\"50\":2}}],[\"contentk​\",{\"1\":{\"43\":2,\"44\":1,\"48\":1}}],[\"content\",{\"1\":{\"25\":4,\"26\":12,\"27\":2,\"47\":11,\"48\":8,\"49\":2,\"50\":5,\"146\":7}}],[\"contains\",{\"1\":{\"4\":2,\"63\":2}}],[\"console=ttys0\",{\"1\":{\"291\":3,\"294\":1}}],[\"console\",{\"1\":{\"291\":1}}],[\"consecutive\",{\"1\":{\"284\":3,\"285\":2}}],[\"consumemessageresponse\",{\"1\":{\"157\":1}}],[\"consumemessagerequest\",{\"1\":{\"157\":1}}],[\"consumemessage\",{\"1\":{\"157\":1}}],[\"consumerid\",{\"1\":{\"155\":1}}],[\"consumer\",{\"1\":{\"153\":1,\"160\":2}}],[\"consul\",{\"1\":{\"155\":1}}],[\"consistency\",{\"1\":{\"20\":1,\"83\":1}}],[\"constant\",{\"1\":{\"219\":4}}],[\"constants\",{\"1\":{\"218\":1}}],[\"construct\",{\"1\":{\"78\":1}}],[\"constructor\",{\"1\":{\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"26\":1,\"47\":1,\"50\":2}}],[\"const\",{\"1\":{\"13\":2,\"14\":4,\"16\":1,\"18\":2,\"26\":17,\"47\":10,\"48\":8,\"50\":3,\"51\":6,\"69\":1,\"78\":1,\"79\":12,\"88\":2,\"89\":1,\"94\":1,\"123\":1,\"213\":1,\"218\":1,\"225\":1,\"227\":2,\"234\":1,\"243\":1,\"255\":1,\"281\":8,\"282\":6,\"283\":3,\"284\":3,\"285\":3,\"286\":5,\"294\":1}}],[\"convergent\",{\"1\":{\"8\":2,\"10\":2,\"19\":1,\"20\":1}}],[\"code\",{\"1\":{\"5\":1,\"130\":1,\"175\":1,\"198\":2,\"215\":1,\"218\":6}}],[\"cleanly\",{\"1\":{\"285\":1,\"286\":4}}],[\"cleaning\",{\"1\":{\"263\":1}}],[\"clean\",{\"1\":{\"227\":1,\"285\":5,\"286\":2}}],[\"cleantempnopop\",{\"1\":{\"227\":1}}],[\"cleantemp\",{\"1\":{\"227\":2}}],[\"clear\",{\"1\":{\"4\":5,\"51\":2,\"88\":2,\"200\":1}}],[\"clause\",{\"1\":{\"227\":1}}],[\"clang\",{\"1\":{\"212\":4,\"213\":1,\"219\":3,\"228\":1}}],[\"class0\",{\"1\":{\"241\":1}}],[\"classnotfoundexception\",{\"1\":{\"172\":1}}],[\"classpath\",{\"1\":{\"170\":1}}],[\"classic\",{\"1\":{\"164\":1}}],[\"class<t>\",{\"1\":{\"147\":2}}],[\"class\",{\"1\":{\"4\":9,\"13\":1,\"14\":1,\"16\":1,\"17\":1,\"18\":1,\"23\":1,\"26\":1,\"47\":1,\"50\":2,\"63\":1,\"64\":1,\"69\":4,\"78\":1,\"79\":3,\"93\":1,\"94\":1,\"144\":2,\"145\":1,\"146\":2,\"147\":1,\"149\":2,\"157\":1,\"164\":4,\"170\":3,\"172\":2,\"173\":1,\"174\":1,\"241\":10,\"282\":1,\"283\":1,\"284\":1,\"285\":1}}],[\"cloneflags\",{\"1\":{\"198\":3,\"203\":2}}],[\"clone\",{\"1\":{\"198\":13,\"199\":2,\"203\":3,\"212\":2,\"224\":1,\"290\":1}}],[\"closed\",{\"1\":{\"263\":2,\"286\":2}}],[\"closeidle\",{\"1\":{\"263\":1}}],[\"closescope\",{\"1\":{\"227\":1}}],[\"close\",{\"1\":{\"158\":1,\"187\":1,\"188\":2,\"200\":1,\"263\":2}}],[\"closeable\",{\"1\":{\"155\":1,\"157\":1,\"158\":1}}],[\"clock是一个数字\",{\"1\":{\"28\":1}}],[\"clock去重逻辑\",{\"1\":{\"26\":1}}],[\"clock和vector来实现\",{\"1\":{\"16\":1}}],[\"clock++\",{\"1\":{\"13\":2,\"17\":1}}],[\"clock\",{\"1\":{\"13\":10,\"16\":7,\"17\":5,\"18\":7,\"26\":5,\"28\":1,\"31\":1,\"32\":5,\"35\":6,\"36\":1,\"37\":1,\"43\":1,\"47\":7,\"48\":6}}],[\"clz\",{\"1\":{\"147\":3}}],[\"cluster\",{\"1\":{\"103\":4,\"119\":2}}],[\"cli\",{\"1\":{\"102\":1,\"110\":1}}],[\"clientfilter\",{\"1\":{\"149\":2}}],[\"clientend\",{\"1\":{\"123\":1,\"124\":1,\"131\":1,\"133\":1,\"136\":1}}],[\"client\",{\"1\":{\"50\":1,\"103\":1,\"142\":2,\"144\":1,\"263\":1,\"286\":1}}],[\"client2\",{\"1\":{\"13\":4,\"25\":2}}],[\"client1\",{\"1\":{\"13\":2,\"25\":2}}],[\"clientid\",{\"1\":{\"13\":7,\"14\":9,\"16\":7,\"17\":6,\"18\":9,\"26\":7,\"47\":7,\"48\":2,\"50\":4}}],[\"来告诉对端\",{\"1\":{\"285\":1}}],[\"来实时处理\",{\"1\":{\"284\":1}}],[\"来实现内存管理\",{\"1\":{\"236\":1}}],[\"来实现一个简单的\",{\"1\":{\"218\":1}}],[\"来实现去重\",{\"1\":{\"188\":1}}],[\"来实现wal日志记录\",{\"1\":{\"93\":1}}],[\"来实现\",{\"1\":{\"82\":1,\"157\":1,\"281\":2}}],[\"来实现的\",{\"1\":{\"9\":1,\"242\":1}}],[\"来帮助转换\",{\"1\":{\"283\":1}}],[\"来帮助我们来处理这类问题\",{\"1\":{\"261\":1}}],[\"来负责\",{\"1\":{\"279\":1}}],[\"来保证内存\",{\"1\":{\"264\":1}}],[\"来使用协程池\",{\"1\":{\"264\":1}}],[\"来缓存连接\",{\"1\":{\"263\":1}}],[\"来定义一个变量\",{\"1\":{\"255\":1}}],[\"来操作\",{\"1\":{\"243\":1}}],[\"来存储元数据\",{\"1\":{\"240\":1}}],[\"来降低\",{\"1\":{\"238\":1}}],[\"来分配内存\",{\"1\":{\"238\":1}}],[\"来分配\",{\"1\":{\"237\":1}}],[\"来移动\",{\"1\":{\"237\":1}}],[\"来改善内存的自动管理\",{\"1\":{\"234\":1}}],[\"来为变量\",{\"1\":{\"234\":1}}],[\"来追踪内存使用\",{\"1\":{\"233\":1}}],[\"来一起看看\",{\"1\":{\"226\":1}}],[\"来简化\",{\"1\":{\"225\":1}}],[\"来排列的\",{\"1\":{\"218\":1}}],[\"来排序\",{\"1\":{\"25\":1}}],[\"来选择优化几次\",{\"1\":{\"218\":1}}],[\"来优化这些场景\",{\"1\":{\"262\":1}}],[\"来优化\",{\"1\":{\"218\":1}}],[\"来直接将其编译为可执行文件\",{\"1\":{\"217\":1}}],[\"来运行这个简单的程序\",{\"1\":{\"217\":1}}],[\"来写一个简单的整数转字符串的函数\",{\"1\":{\"213\":1}}],[\"来完成\",{\"1\":{\"212\":1}}],[\"来设置空闲连接数的大小\",{\"1\":{\"263\":1}}],[\"来设置\",{\"1\":{\"200\":1}}],[\"来启动\",{\"1\":{\"200\":2,\"251\":1}}],[\"来调试\",{\"1\":{\"200\":1}}],[\"来执行\",{\"1\":{\"199\":1,\"200\":1}}],[\"来混存数据映射关系\",{\"1\":{\"188\":1}}],[\"来初始化\",{\"1\":{\"183\":1}}],[\"来看一个稍微复杂一点的泛型样例\",{\"1\":{\"181\":1}}],[\"来看看\",{\"0\":{\"192\":1},\"1\":{\"197\":1}}],[\"来看看双方谁的日志比较完整\",{\"1\":{\"130\":1}}],[\"来看看删除操作\",{\"1\":{\"25\":1}}],[\"来验证\",{\"1\":{\"165\":1}}],[\"来验证内部的\",{\"1\":{\"164\":1}}],[\"来迭代保证质量\",{\"1\":{\"165\":1}}],[\"来推出这个架构\",{\"1\":{\"164\":1}}],[\"来推进\",{\"1\":{\"129\":1}}],[\"来转换\",{\"1\":{\"138\":1}}],[\"来撤销这些操作\",{\"1\":{\"94\":1}}],[\"来访问\",{\"1\":{\"86\":1}}],[\"来解决这两个问题的\",{\"1\":{\"85\":1}}],[\"来解决二者之间的插入排序问题\",{\"1\":{\"25\":1}}],[\"来让一个对象出栈\",{\"1\":{\"243\":1}}],[\"来让\",{\"1\":{\"73\":1}}],[\"来获取对应的数据页\",{\"1\":{\"64\":1}}],[\"来表示\",{\"1\":{\"64\":2,\"194\":1,\"208\":1}}],[\"来教我们如何去弄懂数据库原理\",{\"1\":{\"56\":1}}],[\"来体验\",{\"1\":{\"16\":1,\"18\":1}}],[\"来体验一下\",{\"1\":{\"13\":1}}],[\"来提高并发读取的性能\",{\"1\":{\"4\":1}}],[\"来快速判断某个键是否存在于\",{\"1\":{\"4\":1}}],[\"来学习\",{\"1\":{\"3\":1}}],[\"文章和大家分享一下\",{\"1\":{\"205\":1}}],[\"文档的说法\",{\"1\":{\"228\":1}}],[\"文档的根节点\",{\"1\":{\"26\":1}}],[\"文档可能会随着迭代更新\",{\"1\":{\"226\":1}}],[\"文档数据库\",{\"1\":{\"56\":1}}],[\"文档内容\",{\"1\":{\"47\":1}}],[\"文档是操作的集合\",{\"1\":{\"28\":1}}],[\"文档来实现的\",{\"1\":{\"27\":1}}],[\"文档长度\",{\"1\":{\"26\":1,\"47\":1}}],[\"文本\",{\"1\":{\"197\":1}}],[\"文本协议\",{\"1\":{\"147\":2}}],[\"文本协同算法的鼻祖\",{\"1\":{\"8\":1}}],[\"文本会变成132\",{\"1\":{\"48\":1}}],[\"文本最终内容也就不一致了\",{\"1\":{\"25\":1}}],[\"文本内容本质上是插入操作的集合\",{\"1\":{\"25\":1}}],[\"文件构建\",{\"1\":{\"295\":1}}],[\"文件内容如下\",{\"1\":{\"257\":1}}],[\"文件内容\",{\"1\":{\"257\":1}}],[\"文件来声明这个函数\",{\"1\":{\"212\":1}}],[\"文件夹下生成一个\",{\"1\":{\"212\":1}}],[\"文件最大可读字节数\",{\"1\":{\"98\":1}}],[\"文件最大字节数\",{\"1\":{\"98\":1}}],[\"文件列表查询\",{\"1\":{\"4\":1}}],[\"文件的表示\",{\"1\":{\"4\":1}}],[\"文件的合并操作来维护数据的一致性\",{\"1\":{\"4\":1}}],[\"文件的大小或数量来触发合并\",{\"1\":{\"4\":1}}],[\"文件可能包含相同的键\",{\"1\":{\"4\":1}}],[\"文件进行压缩\",{\"1\":{\"4\":1}}],[\"文件中实现\",{\"1\":{\"257\":1}}],[\"文件中定义了\",{\"1\":{\"212\":1}}],[\"文件中\",{\"1\":{\"4\":1}}],[\"文件\",{\"0\":{\"173\":1},\"1\":{\"4\":4,\"207\":1,\"213\":1,\"217\":2,\"257\":1,\"291\":1}}],[\"文心一言的解释是\",{\"1\":{\"3\":1}}],[\"在容器中重新编译内核\",{\"1\":{\"294\":1}}],[\"在完成\",{\"1\":{\"287\":1}}],[\"在互联网普及的今天\",{\"1\":{\"287\":1}}],[\"在代码中是这样发生\",{\"1\":{\"286\":1}}],[\"在代码层面上\",{\"1\":{\"237\":1}}],[\"在收到\",{\"1\":{\"285\":1}}],[\"在刚才的代码中\",{\"1\":{\"285\":1}}],[\"在推入报文到队列之前\",{\"1\":{\"285\":1}}],[\"在队列清空后停止\",{\"1\":{\"284\":1}}],[\"在没有\",{\"1\":{\"284\":1}}],[\"在没有上帝视角的情况下\",{\"1\":{\"164\":1}}],[\"在被设置\",{\"1\":{\"284\":1}}],[\"在初始化时\",{\"1\":{\"281\":1}}],[\"在上面也谈到了\",{\"1\":{\"281\":1}}],[\"在上一篇文章中\",{\"1\":{\"216\":1}}],[\"在上一讲中\",{\"1\":{\"89\":1}}],[\"在介绍\",{\"1\":{\"280\":1}}],[\"在介绍了一系列的前置知识后\",{\"1\":{\"200\":1}}],[\"在粗略介绍\",{\"1\":{\"280\":1}}],[\"在可靠性上做了很多努力\",{\"1\":{\"273\":1}}],[\"在三次握手的过程中\",{\"1\":{\"272\":1}}],[\"在业务中会大量地使用线程池\",{\"1\":{\"264\":1}}],[\"在需要使用的时候无需再次创建\",{\"1\":{\"263\":1}}],[\"在用户态上实现协议是一个很有趣且很有挑战的事情\",{\"1\":{\"278\":1}}],[\"在用\",{\"1\":{\"260\":1}}],[\"在文件中声明了一个\",{\"1\":{\"257\":1}}],[\"在定义符号变量的时候\",{\"1\":{\"255\":1}}],[\"在汇编中\",{\"1\":{\"255\":1}}],[\"在此基础上\",{\"1\":{\"245\":1}}],[\"在此背景下又是如何解决实际问题的\",{\"1\":{\"139\":1}}],[\"在标记阶段\",{\"1\":{\"243\":1}}],[\"在合适的时间触发\",{\"1\":{\"243\":1}}],[\"在合并过程中\",{\"1\":{\"4\":1}}],[\"在前面的基础上\",{\"1\":{\"245\":1}}],[\"在前面的内容中\",{\"1\":{\"245\":1}}],[\"在前面的内存布局中\",{\"1\":{\"237\":1}}],[\"在前面的自动管理处\",{\"1\":{\"242\":1}}],[\"在创建后就不会改变\",{\"1\":{\"237\":1}}],[\"在冯\",{\"1\":{\"231\":1}}],[\"在开发和实践中\",{\"1\":{\"228\":1}}],[\"在编译的过程中会自动对\",{\"1\":{\"219\":1}}],[\"在后文中笔者带领大家来体会\",{\"1\":{\"218\":1}}],[\"在平常写代码的时候\",{\"1\":{\"207\":1}}],[\"在程序链接阶段给开发者打开了一扇窗\",{\"1\":{\"206\":1}}],[\"在程序启动时\",{\"1\":{\"200\":1}}],[\"在写\",{\"1\":{\"205\":1}}],[\"在写操作\",{\"1\":{\"4\":2}}],[\"在调用\",{\"1\":{\"200\":1}}],[\"在绑定\",{\"1\":{\"199\":1}}],[\"在命令行中输入并运行\",{\"1\":{\"197\":1}}],[\"在终端成功输出了\",{\"1\":{\"197\":1}}],[\"在主线程中新建非主线程后\",{\"1\":{\"194\":1}}],[\"在内存中的形态如\",{\"1\":{\"207\":1}}],[\"在内核运行时使用的调用栈\",{\"1\":{\"194\":1}}],[\"在内部通过调用\",{\"1\":{\"69\":1}}],[\"在有些场景下\",{\"1\":{\"206\":1}}],[\"在有了泛型后\",{\"1\":{\"190\":1}}],[\"在有序复制集合上拥有良好的插入\",{\"1\":{\"23\":1}}],[\"在遍历\",{\"1\":{\"189\":1}}],[\"在设计完备的基础上\",{\"1\":{\"186\":1}}],[\"在设计上放弃了共识\",{\"1\":{\"8\":1}}],[\"在正式数据传输之前\",{\"1\":{\"272\":1}}],[\"在正式的流式处理实现之前\",{\"1\":{\"181\":1}}],[\"在正式介绍数据库设计和实现之前\",{\"1\":{\"56\":1}}],[\"在整个程序的生命周期中一直存在\",{\"1\":{\"232\":1}}],[\"在整个参数解析案例完成后\",{\"1\":{\"165\":1}}],[\"在整个调研链路中\",{\"1\":{\"147\":1}}],[\"在引入三方中间件的情况下\",{\"1\":{\"164\":1}}],[\"在引入了\",{\"1\":{\"137\":1}}],[\"在架构上\",{\"1\":{\"155\":1}}],[\"在线\",{\"1\":{\"155\":1}}],[\"在一个窗口中通过\",{\"1\":{\"277\":1}}],[\"在一个简单的\",{\"1\":{\"260\":1}}],[\"在一个使用\",{\"1\":{\"122\":1}}],[\"在一些场景中\",{\"1\":{\"240\":1}}],[\"在一些特殊场景\",{\"1\":{\"210\":1}}],[\"在一些方面做了精简\",{\"1\":{\"153\":1}}],[\"在netty的加持下\",{\"1\":{\"146\":1}}],[\"在客户端通过代理拿到接口并直接调用\",{\"1\":{\"144\":1}}],[\"在发送日志\",{\"1\":{\"137\":1}}],[\"在新建时\",{\"1\":{\"136\":1}}],[\"在快照后\",{\"1\":{\"136\":1}}],[\"在同步发生冲突后\",{\"1\":{\"134\":1}}],[\"在日志同步模块中\",{\"1\":{\"134\":1}}],[\"在日志同步模块也会引发日志\",{\"1\":{\"133\":1}}],[\"在日志同步的过程中\",{\"1\":{\"131\":1}}],[\"在改变后加上\",{\"1\":{\"133\":1}}],[\"在投票模块中\",{\"1\":{\"133\":1}}],[\"在领导者选举中\",{\"1\":{\"130\":1}}],[\"在领导者选举部分\",{\"1\":{\"123\":1}}],[\"在成为协调者后\",{\"1\":{\"124\":1}}],[\"在这一段路的旅程中\",{\"1\":{\"228\":1}}],[\"在这段时间内\",{\"1\":{\"124\":1}}],[\"在这段代码中\",{\"1\":{\"123\":1}}],[\"在这里\",{\"1\":{\"123\":1,\"124\":1}}],[\"在这个简单的\",{\"1\":{\"234\":1}}],[\"在这个测试例子中\",{\"1\":{\"164\":1}}],[\"在这个例子中\",{\"1\":{\"72\":1,\"181\":1,\"243\":1}}],[\"在这个架构下\",{\"1\":{\"58\":1}}],[\"在数据汇总阶段\",{\"1\":{\"189\":1}}],[\"在数据共识性的问题上\",{\"1\":{\"122\":1}}],[\"在数据持久化部分又会对同步做一些优化\",{\"1\":{\"121\":1}}],[\"在数据组织和索引组织上几乎都选择了\",{\"1\":{\"67\":1}}],[\"在单值键值对的\",{\"1\":{\"114\":2}}],[\"在方向不明确\",{\"1\":{\"96\":1}}],[\"在重做期间记录正在活跃的事务\",{\"1\":{\"94\":1}}],[\"在重做期间恢复历史数据\",{\"1\":{\"92\":1}}],[\"在重新启动时\",{\"1\":{\"92\":1}}],[\"在并发量\",{\"1\":{\"260\":1}}],[\"在并发\",{\"1\":{\"82\":1}}],[\"在节点\",{\"1\":{\"72\":1}}],[\"在删除的过程中\",{\"1\":{\"72\":1}}],[\"在基本情况的基础上\",{\"1\":{\"71\":1}}],[\"在对内存\",{\"1\":{\"236\":1}}],[\"在对\",{\"1\":{\"70\":1,\"182\":1}}],[\"在具体的\",{\"1\":{\"69\":1}}],[\"在不同场景中选择合适的淘汰策略\",{\"1\":{\"63\":1}}],[\"在理解\",{\"1\":{\"46\":1}}],[\"在论文中\",{\"1\":{\"124\":1}}],[\"在论文\",{\"1\":{\"41\":1,\"134\":1}}],[\"在optree中查找\",{\"1\":{\"28\":1}}],[\"在opset中找到对应的optree\",{\"1\":{\"28\":1}}],[\"在automerge中\",{\"1\":{\"28\":1}}],[\"在位置0插入字符1\",{\"1\":{\"25\":1}}],[\"在左侧输入框中编辑文本内容\",{\"1\":{\"24\":1,\"45\":1}}],[\"在左侧输入框输入任何内容\",{\"1\":{\"16\":1}}],[\"在其基础上\",{\"1\":{\"18\":1}}],[\"在其论文conflict\",{\"1\":{\"8\":1}}],[\"在通信上\",{\"1\":{\"14\":1}}],[\"在实践中又有了新的沉淀\",{\"1\":{\"216\":1}}],[\"在实际的数据库场景中\",{\"1\":{\"73\":1}}],[\"在实际实现中可能需要处理一些并发控制和数据一致性的问题\",{\"1\":{\"4\":1}}],[\"在实现上其实是非常复杂的\",{\"1\":{\"74\":1}}],[\"在实现上稍微复杂一些\",{\"1\":{\"10\":1}}],[\"在实现上颇为简单\",{\"1\":{\"10\":1}}],[\"在于无冲突可复制\",{\"1\":{\"9\":1}}],[\"在进行读取操作时\",{\"1\":{\"4\":1}}],[\"在进行事务操作时\",{\"1\":{\"4\":1}}],[\"在事务中使用\",{\"1\":{\"4\":1}}],[\"在lsm树中检索键值对\",{\"1\":{\"4\":1}}],[\"在以上示例代码中\",{\"1\":{\"4\":1}}],[\"在以上示例中\",{\"1\":{\"4\":1}}],[\"在读操作\",{\"1\":{\"4\":2}}],[\"在读取操作中\",{\"1\":{\"4\":1}}],[\"在系统栈中新建一个\",{\"1\":{\"200\":1}}],[\"在系统栈中新建\",{\"1\":{\"200\":1}}],[\"在系统运行过程中\",{\"1\":{\"4\":1}}],[\"在系统发生故障时\",{\"1\":{\"4\":1}}],[\"在查询操作时\",{\"1\":{\"4\":1}}],[\"在查找过程中\",{\"1\":{\"4\":1}}],[\"在多线程或多进程环境下\",{\"1\":{\"4\":1}}],[\"在\",{\"1\":{\"4\":4,\"8\":1,\"13\":1,\"38\":1,\"50\":1,\"71\":2,\"73\":1,\"82\":1,\"85\":2,\"89\":1,\"93\":1,\"123\":1,\"124\":1,\"126\":1,\"129\":1,\"131\":1,\"133\":3,\"134\":1,\"136\":1,\"137\":1,\"164\":3,\"179\":2,\"194\":1,\"197\":1,\"198\":4,\"199\":7,\"200\":3,\"202\":1,\"203\":1,\"213\":1,\"217\":1,\"227\":5,\"236\":3,\"238\":1,\"243\":1,\"248\":1,\"257\":2,\"261\":1,\"263\":1,\"278\":1,\"283\":1,\"286\":1,\"291\":1}}],[\"将理论知识巧妙和实践结合\",{\"1\":{\"287\":1}}],[\"将报文推入到其队列后\",{\"1\":{\"285\":1}}],[\"将报文传递给\",{\"1\":{\"285\":1}}],[\"将报文交给\",{\"1\":{\"279\":2}}],[\"将输入\",{\"1\":{\"285\":1}}],[\"将已经确认的报文推出队列\",{\"1\":{\"284\":1}}],[\"将已快照部分日志从切片中删除\",{\"1\":{\"136\":1}}],[\"将重新发送\",{\"1\":{\"284\":1}}],[\"将重组这部分工作抽象为数据流重组器\",{\"1\":{\"282\":1}}],[\"将字节按照序号进行重组得到正确的字节流\",{\"1\":{\"279\":1}}],[\"将字节码生成的\",{\"1\":{\"218\":1}}],[\"将字节码编译为机器码运行\",{\"1\":{\"218\":1}}],[\"将线程完美的封装了起来\",{\"1\":{\"264\":1}}],[\"将一个元素返还给\",{\"1\":{\"261\":1}}],[\"将一个页加入\",{\"1\":{\"63\":1}}],[\"将参数赋值给特定寄存器\",{\"1\":{\"257\":1}}],[\"将参数从\",{\"1\":{\"200\":1}}],[\"将出栈数据拷贝到\",{\"1\":{\"251\":1}}],[\"将引用对象入栈\",{\"1\":{\"244\":1}}],[\"将标记\",{\"1\":{\"243\":1}}],[\"将可达队对象依次标记\",{\"1\":{\"243\":1}}],[\"将拿到的大块内存\",{\"1\":{\"239\":1}}],[\"将全部精力和时间放在核心业务上\",{\"1\":{\"238\":1}}],[\"将内存块放回\",{\"1\":{\"241\":1}}],[\"将内存还给进程\",{\"1\":{\"234\":1}}],[\"将内存表中的数据写入磁盘\",{\"1\":{\"4\":3}}],[\"将这段\",{\"1\":{\"219\":1}}],[\"将生成的机器码写入内存\",{\"1\":{\"218\":1}}],[\"将打包文件链接\",{\"1\":{\"217\":1}}],[\"将目标文件\",{\"1\":{\"217\":1}}],[\"将程序入口\",{\"1\":{\"217\":1}}],[\"将程序运行时候的参数地址\",{\"1\":{\"200\":1}}],[\"将整数转化为字符串\",{\"1\":{\"213\":1}}],[\"将两个切片的数据指针以及拷贝长度作为参数传入\",{\"1\":{\"207\":1}}],[\"将新的连续的字节写入到流中\",{\"1\":{\"282\":1}}],[\"将新的operation插入到store中\",{\"1\":{\"31\":1,\"36\":1}}],[\"将新\",{\"1\":{\"200\":1,\"202\":1}}],[\"将主线程与\",{\"1\":{\"200\":1}}],[\"将返回值存入\",{\"1\":{\"197\":1}}],[\"将系统调用号存入\",{\"1\":{\"197\":1}}],[\"将注意力放在栈和堆中\",{\"1\":{\"194\":1}}],[\"将核心层代码通过\",{\"1\":{\"165\":1}}],[\"将任务项转化为自动化测试\",{\"1\":{\"164\":1}}],[\"将功能点按照功能上下文\",{\"1\":{\"164\":1}}],[\"将功能点分解为不同的功能上下文\",{\"1\":{\"164\":1}}],[\"将功能拆分为一系列任务\",{\"1\":{\"164\":1}}],[\"将行为验证放在接口而非实现上\",{\"1\":{\"164\":1}}],[\"将开发过程变成有序的流程\",{\"1\":{\"164\":1}}],[\"将消息发送到\",{\"1\":{\"159\":1}}],[\"将消息存储到\",{\"1\":{\"159\":1}}],[\"将驱动实现交给其它方\",{\"1\":{\"151\":1}}],[\"将错误信息上升到业务逻辑\",{\"1\":{\"150\":1}}],[\"将请求交给路由层之前必须经过整个链路层\",{\"1\":{\"149\":1}}],[\"将客户端请求的参数\",{\"1\":{\"142\":1}}],[\"将快照数据封装到\",{\"1\":{\"136\":1}}],[\"将其编译为可执行文件\",{\"1\":{\"294\":1}}],[\"将其编译为汇编\",{\"1\":{\"212\":1}}],[\"将其中被确认的报文推出队列\",{\"1\":{\"284\":1}}],[\"将其打包为数据报\",{\"1\":{\"279\":1}}],[\"将其引用对象入栈\",{\"1\":{\"244\":2}}],[\"将其引入\",{\"1\":{\"164\":1}}],[\"将其清理掉\",{\"1\":{\"243\":1}}],[\"将其加入到全局链表并入栈\",{\"1\":{\"243\":1}}],[\"将其标记为可用\",{\"1\":{\"240\":1}}],[\"将其包装为\",{\"1\":{\"238\":1}}],[\"将其拆解为如下三个阶段\",{\"1\":{\"182\":1}}],[\"将其转化为测试用例\",{\"1\":{\"170\":1}}],[\"将其转换成\",{\"1\":{\"4\":1}}],[\"将其称为极限单元测试\",{\"1\":{\"164\":1}}],[\"将其应用到状态机中\",{\"1\":{\"131\":1}}],[\"将其\",{\"1\":{\"129\":1}}],[\"将其翻译为代码\",{\"1\":{\"126\":1,\"240\":1}}],[\"将撤消操作记录到日志中以确保操作不会在重复失败的情况下重复执行\",{\"1\":{\"92\":1}}],[\"将事务\",{\"1\":{\"88\":1}}],[\"将事务中插入或更新的键值对写入lsm树\",{\"1\":{\"4\":1}}],[\"将表字段数据\",{\"1\":{\"79\":1}}],[\"将根节点数据视为叶子节点\",{\"1\":{\"71\":1}}],[\"将数据持久化到磁盘\",{\"1\":{\"133\":1}}],[\"将数据库恢复到某个失败后的状态\",{\"1\":{\"92\":1}}],[\"将数据页刷至磁盘\",{\"1\":{\"64\":1}}],[\"将数据添加到\",{\"1\":{\"4\":1}}],[\"将缓存中所有页到刷到磁盘\",{\"1\":{\"64\":1}}],[\"将页刷到磁盘\",{\"1\":{\"64\":1}}],[\"将item插入到链表中\",{\"1\":{\"51\":1}}],[\"将item插入到content中\",{\"1\":{\"47\":1}}],[\"将isdeleted设置为\",{\"1\":{\"25\":1}}],[\"将插入操作i插入到ops中\",{\"1\":{\"44\":1}}],[\"将o的isdeleted置为true\",{\"1\":{\"43\":1}}],[\"将firstop的pred指向新的operation\",{\"1\":{\"36\":1}}],[\"将最后一个operation的succ指向新的operation\",{\"1\":{\"31\":1}}],[\"将所有不可达的对象全部清理掉\",{\"1\":{\"243\":1}}],[\"将所有直接耦合都视为坏味道的设计取向\",{\"1\":{\"164\":1}}],[\"将所有字符拼接起来\",{\"1\":{\"26\":1}}],[\"将所有sstable的键值对合并成一个列表\",{\"1\":{\"4\":1}}],[\"将1插入到位置0\",{\"1\":{\"25\":1}}],[\"将本地的ops数组返回\",{\"1\":{\"13\":1}}],[\"将\",{\"1\":{\"5\":1,\"63\":1,\"70\":1,\"71\":1,\"72\":2,\"183\":1,\"197\":1,\"200\":17,\"212\":1,\"217\":2,\"225\":2,\"226\":1,\"227\":1,\"240\":2,\"244\":1,\"251\":1,\"262\":1,\"282\":1,\"284\":1}}],[\"将键添加到当前事务的\",{\"1\":{\"4\":1}}],[\"将键值对插入到当前事务的\",{\"1\":{\"4\":1}}],[\"将该事务中删除的键依次从\",{\"1\":{\"4\":1}}],[\"将该事务中插入或更新的键值对依次写入\",{\"1\":{\"4\":1}}],[\"将执行合并操作\",{\"1\":{\"4\":1}}],[\"将多个sstable合并成一个更大的sstable\",{\"1\":{\"4\":1}}],[\"将相应的键添加到\",{\"1\":{\"4\":1}}],[\"的镜像环境了\",{\"1\":{\"291\":1}}],[\"的队列中拿出\",{\"1\":{\"285\":1}}],[\"的包\",{\"1\":{\"285\":2}}],[\"的字段比较少\",{\"1\":{\"285\":1}}],[\"的真正关闭条件\",{\"1\":{\"283\":1}}],[\"的真正长度由\",{\"1\":{\"69\":1}}],[\"的定义中添加了\",{\"1\":{\"282\":1}}],[\"的定义如下\",{\"1\":{\"73\":1}}],[\"的长度不能超过\",{\"1\":{\"281\":1}}],[\"的长度都是节点个数\",{\"1\":{\"129\":1}}],[\"的课程带领下\",{\"1\":{\"278\":1}}],[\"的特点\",{\"1\":{\"271\":1}}],[\"的特性\",{\"1\":{\"129\":1,\"188\":1}}],[\"的资料很多\",{\"1\":{\"270\":1}}],[\"的方法\",{\"1\":{\"264\":1}}],[\"的方式来连接内存块\",{\"1\":{\"241\":1}}],[\"的功能\",{\"1\":{\"264\":1}}],[\"的功能也很简单\",{\"1\":{\"217\":1}}],[\"的标准库中\",{\"1\":{\"263\":1}}],[\"的小内存\",{\"1\":{\"262\":1}}],[\"的具体实现\",{\"1\":{\"262\":1}}],[\"的具体实现可以参考这个commit\",{\"1\":{\"227\":1}}],[\"的使用就是这么简单\",{\"1\":{\"262\":1}}],[\"的编号竟然是\",{\"1\":{\"257\":1}}],[\"的编译器\",{\"1\":{\"219\":1}}],[\"的编译约定\",{\"1\":{\"206\":1}}],[\"的作者有一篇介绍其实现的文章\",{\"1\":{\"264\":1}}],[\"的作者们在选择汇编语言的时候没有选择\",{\"1\":{\"248\":1}}],[\"的作用\",{\"1\":{\"217\":1,\"218\":1}}],[\"的迷雾\",{\"1\":{\"247\":1}}],[\"的大量时间\",{\"1\":{\"244\":1}}],[\"的大小\",{\"1\":{\"114\":1,\"115\":1}}],[\"的大小达到一定阈值时\",{\"1\":{\"4\":1}}],[\"的引用\",{\"1\":{\"243\":1}}],[\"的头节点开始遍历\",{\"1\":{\"243\":1}}],[\"的触发机制\",{\"1\":{\"243\":1}}],[\"的范围是比较广的\",{\"1\":{\"243\":1}}],[\"的状态\",{\"1\":{\"241\":1}}],[\"的机制\",{\"1\":{\"241\":1}}],[\"的关系如下\",{\"1\":{\"241\":1}}],[\"的块内存大小是一样的\",{\"1\":{\"241\":1}}],[\"的架构比较复杂\",{\"1\":{\"241\":1}}],[\"的原数据在左侧\",{\"1\":{\"252\":1}}],[\"的原则\",{\"1\":{\"240\":1}}],[\"的原理\",{\"1\":{\"8\":1}}],[\"的首地址\",{\"1\":{\"240\":1}}],[\"的发生频率\",{\"1\":{\"238\":1}}],[\"的发生\",{\"1\":{\"238\":1}}],[\"的限制\",{\"1\":{\"238\":1}}],[\"的强大能力\",{\"1\":{\"238\":1}}],[\"的强大作用\",{\"1\":{\"218\":1}}],[\"的内容比较多\",{\"1\":{\"237\":1}}],[\"的内存模块其实非常复杂\",{\"1\":{\"245\":1}}],[\"的内存块被大量申请\",{\"1\":{\"241\":1}}],[\"的内存管理是一个真正的工业级实现\",{\"1\":{\"245\":1}}],[\"的内存管理变得容易理解一些\",{\"1\":{\"245\":1}}],[\"的内存管理的两大核心正是\",{\"1\":{\"245\":1}}],[\"的内存管理\",{\"1\":{\"236\":1}}],[\"的内存管理方式\",{\"1\":{\"236\":1}}],[\"的内存\",{\"1\":{\"236\":1}}],[\"的官方\",{\"1\":{\"236\":1}}],[\"的语言\",{\"1\":{\"236\":1,\"242\":1}}],[\"的语境下\",{\"1\":{\"164\":1}}],[\"的高速缓存\",{\"1\":{\"231\":1}}],[\"的指令位置处\",{\"1\":{\"254\":1}}],[\"的指令周期为单位\",{\"1\":{\"231\":1}}],[\"的指针\",{\"1\":{\"71\":1,\"72\":2}}],[\"的支持其实到\",{\"1\":{\"227\":1}}],[\"的效果\",{\"1\":{\"227\":1}}],[\"的构建过程\",{\"1\":{\"224\":1}}],[\"的构造函数\",{\"1\":{\"183\":1}}],[\"的自举其实颇为复杂\",{\"1\":{\"224\":1}}],[\"的源码\",{\"1\":{\"224\":1,\"241\":1}}],[\"的哲学和机制问题\",{\"1\":{\"223\":1}}],[\"的新调用规约\",{\"1\":{\"221\":1}}],[\"的链接看看它们是如何做的\",{\"1\":{\"219\":1}}],[\"的快车\",{\"1\":{\"219\":1}}],[\"的工作就完成了\",{\"1\":{\"241\":1}}],[\"的工作差不多就完成了\",{\"1\":{\"218\":1}}],[\"的工作原理\",{\"1\":{\"25\":1}}],[\"的存在是非常有必要的\",{\"1\":{\"218\":1}}],[\"的存储底座\",{\"1\":{\"107\":1}}],[\"的束缚\",{\"1\":{\"217\":1}}],[\"的能力\",{\"1\":{\"214\":1}}],[\"的黑魔法一定程度上都使用了\",{\"1\":{\"214\":1}}],[\"的性能问题\",{\"1\":{\"212\":1}}],[\"的缺点\",{\"1\":{\"212\":1}}],[\"的影响的\",{\"1\":{\"210\":1}}],[\"的另外一个更加有趣的黑魔法\",{\"1\":{\"209\":1}}],[\"的两个黑魔法技巧已经介绍完毕了\",{\"1\":{\"214\":1}}],[\"的两个黑魔法技巧\",{\"0\":{\"205\":1}}],[\"的开始函数就是\",{\"1\":{\"200\":1}}],[\"的开始项移到\",{\"1\":{\"72\":1}}],[\"的执行流程\",{\"1\":{\"200\":1}}],[\"的本地队列中偷\",{\"1\":{\"200\":1}}],[\"的本地运行队列\",{\"1\":{\"200\":1}}],[\"的本地运行队列中盗取\",{\"1\":{\"199\":1}}],[\"的空闲池中取\",{\"1\":{\"200\":1}}],[\"的栈入栈\",{\"1\":{\"218\":1}}],[\"的栈\",{\"1\":{\"200\":1}}],[\"的栈中\",{\"1\":{\"200\":1}}],[\"的栈顶指针\",{\"1\":{\"200\":1}}],[\"的缓冲里面拿到一个空闲的\",{\"1\":{\"200\":1}}],[\"的入口函数\",{\"1\":{\"200\":2,\"202\":1}}],[\"的入门项目\",{\"1\":{\"49\":1}}],[\"的个数\",{\"1\":{\"200\":3}}],[\"的信号掩码\",{\"1\":{\"200\":1}}],[\"的位置\",{\"1\":{\"200\":1}}],[\"的流程剖析\",{\"1\":{\"200\":2}}],[\"的流程就如图\",{\"1\":{\"58\":1}}],[\"的运行队列\",{\"1\":{\"199\":1}}],[\"的运行流程到此结束了\",{\"1\":{\"200\":1}}],[\"的运行流程\",{\"0\":{\"192\":1}}],[\"的调度\",{\"1\":{\"204\":3}}],[\"的调度运行模型\",{\"1\":{\"199\":1}}],[\"的调用栈实际就是线程调用栈\",{\"1\":{\"200\":1}}],[\"的调用时机其实是很容易把握的\",{\"1\":{\"133\":1}}],[\"的地址拷贝到\",{\"1\":{\"200\":2}}],[\"的地址存储到\",{\"1\":{\"200\":1}}],[\"的地址存储到工作线程的线程局部变量中\",{\"1\":{\"198\":1}}],[\"的地址\",{\"1\":{\"198\":1,\"200\":1}}],[\"的第一条字节码指令\",{\"1\":{\"218\":1}}],[\"的第一个\",{\"1\":{\"200\":1}}],[\"的第\",{\"1\":{\"197\":1}}],[\"的敬畏\",{\"1\":{\"192\":1}}],[\"的函数\",{\"1\":{\"202\":1}}],[\"的函数实际是\",{\"1\":{\"200\":1}}],[\"的函数实现\",{\"1\":{\"180\":1}}],[\"的函数获取\",{\"1\":{\"69\":1}}],[\"的参数et类型在\",{\"1\":{\"208\":1}}],[\"的参数大小\",{\"1\":{\"200\":1}}],[\"的参数在\",{\"1\":{\"200\":1}}],[\"的参数\",{\"1\":{\"179\":1,\"181\":1}}],[\"的类型\",{\"1\":{\"179\":1}}],[\"的类型还有\",{\"1\":{\"19\":1}}],[\"的易用与炫酷\",{\"1\":{\"177\":1}}],[\"的同学\",{\"1\":{\"177\":1,\"217\":1}}],[\"的同时\",{\"1\":{\"86\":1,\"137\":1}}],[\"的需求是这样的\",{\"1\":{\"169\":1}}],[\"的模式来实现一个简单的\",{\"1\":{\"167\":1}}],[\"的一个字条件\",{\"1\":{\"285\":1}}],[\"的一个问题\",{\"1\":{\"238\":1}}],[\"的一个极简版本\",{\"1\":{\"27\":1}}],[\"的一种模式\",{\"1\":{\"164\":1}}],[\"的伦敦学派\",{\"1\":{\"164\":1}}],[\"的经典学派\",{\"1\":{\"164\":1}}],[\"的是架构\",{\"1\":{\"164\":1}}],[\"的深渊\",{\"1\":{\"164\":1}}],[\"的进行\",{\"1\":{\"164\":1}}],[\"的红\",{\"1\":{\"164\":1}}],[\"的用处不大\",{\"1\":{\"164\":1}}],[\"的用例全部通过了\",{\"1\":{\"164\":1}}],[\"的场景\",{\"1\":{\"164\":1}}],[\"的逻辑消息组织单位\",{\"1\":{\"158\":1}}],[\"的树结构十分适合\",{\"1\":{\"155\":1}}],[\"的设计与实现\",{\"1\":{\"152\":1}}],[\"的简单协议\",{\"1\":{\"146\":1}}],[\"的初始值不再是\",{\"1\":{\"136\":1}}],[\"的更新\",{\"1\":{\"134\":1}}],[\"的试探是非常低效了\",{\"1\":{\"134\":1}}],[\"的上层应用来实现\",{\"1\":{\"131\":1}}],[\"的中位数\",{\"1\":{\"129\":1}}],[\"的时间肯定比较长\",{\"1\":{\"244\":1}}],[\"的时间越少肯定越好\",{\"1\":{\"238\":1}}],[\"的时间戳小于当前时间戳\",{\"1\":{\"18\":1}}],[\"的时候一知半解\",{\"1\":{\"260\":1}}],[\"的时候\",{\"1\":{\"189\":1,\"241\":1,\"284\":1}}],[\"的时候不要加锁\",{\"1\":{\"129\":1}}],[\"的下一个待同步日志序号\",{\"1\":{\"129\":1}}],[\"的日志\",{\"1\":{\"127\":1,\"128\":1}}],[\"的日志内容为\",{\"1\":{\"127\":1}}],[\"的值拷贝到\",{\"1\":{\"218\":1}}],[\"的值设为\",{\"1\":{\"127\":1}}],[\"的值类型为\",{\"1\":{\"69\":1}}],[\"的元素按\",{\"1\":{\"117\":1}}],[\"的元素保序\",{\"1\":{\"117\":1}}],[\"的元数据\",{\"1\":{\"64\":2}}],[\"的前面增加了\",{\"1\":{\"114\":1}}],[\"的集合类型分成两类\",{\"1\":{\"113\":1}}],[\"的集合类型转换成单值的键值对\",{\"1\":{\"113\":1}}],[\"的兼容性\",{\"1\":{\"113\":1}}],[\"的哈希计算得到\",{\"1\":{\"106\":1}}],[\"的转换\",{\"1\":{\"106\":1}}],[\"的心脏\",{\"1\":{\"106\":1,\"156\":1}}],[\"的崩溃恢复必须先\",{\"1\":{\"94\":1}}],[\"的处理其实是比较粗糙的\",{\"1\":{\"94\":1}}],[\"的图\",{\"1\":{\"87\":1}}],[\"的锁\",{\"1\":{\"73\":4}}],[\"的最后执行函数是\",{\"1\":{\"200\":1,\"202\":1}}],[\"的最大个数为\",{\"1\":{\"200\":1}}],[\"的最大数量\",{\"1\":{\"200\":1}}],[\"的最大区别\",{\"1\":{\"10\":1}}],[\"的最前面\",{\"1\":{\"72\":1}}],[\"的叶子结点\",{\"1\":{\"72\":1,\"73\":1}}],[\"的兄弟节点\",{\"1\":{\"72\":1}}],[\"的节点数据写入字节流中\",{\"1\":{\"282\":1}}],[\"的节点能够当选领导者\",{\"1\":{\"130\":1}}],[\"的节点\",{\"1\":{\"72\":1,\"282\":3}}],[\"的情况下\",{\"1\":{\"284\":2,\"285\":1,\"286\":1}}],[\"的情况下就会决定发送快照\",{\"1\":{\"136\":1}}],[\"的情况\",{\"1\":{\"72\":1,\"122\":1,\"129\":1,\"137\":1}}],[\"的子节点个数+1\",{\"1\":{\"71\":1}}],[\"的末尾\",{\"1\":{\"71\":1}}],[\"的插入点正好在节点\",{\"1\":{\"71\":1}}],[\"的插入操作\",{\"1\":{\"47\":1}}],[\"的父节点\",{\"1\":{\"71\":3,\"72\":1}}],[\"的父节点子节点个数\",{\"1\":{\"71\":1}}],[\"的父类\",{\"1\":{\"69\":1}}],[\"的含义了\",{\"1\":{\"129\":1}}],[\"的含义\",{\"1\":{\"68\":1}}],[\"的页是脏的\",{\"1\":{\"64\":2}}],[\"的主要作用点在于操作数据页\",{\"1\":{\"64\":1}}],[\"的意义在于\",{\"1\":{\"64\":1}}],[\"的介绍就到这里\",{\"1\":{\"51\":1}}],[\"的介绍也会着重参考这几篇论文\",{\"1\":{\"8\":1}}],[\"的优化\",{\"1\":{\"49\":1}}],[\"的实际案例\",{\"1\":{\"45\":1}}],[\"的实现稍微复杂一些\",{\"1\":{\"284\":1}}],[\"的实现还有很多\",{\"1\":{\"264\":1}}],[\"的实现和机制\",{\"1\":{\"248\":1}}],[\"的实现和基于\",{\"1\":{\"15\":1}}],[\"的实现细节还有很多\",{\"1\":{\"241\":1}}],[\"的实现机制与\",{\"1\":{\"237\":1}}],[\"的实现也比较简单\",{\"1\":{\"213\":1}}],[\"的实现中分别对应\",{\"1\":{\"199\":1}}],[\"的实现文档其实已经被官方文档删除掉了\",{\"1\":{\"27\":1}}],[\"的实现了\",{\"1\":{\"26\":1}}],[\"的实现思路和\",{\"1\":{\"14\":1}}],[\"的实现\",{\"1\":{\"13\":1,\"15\":1,\"22\":1,\"38\":1,\"46\":1,\"49\":1,\"151\":1,\"186\":1,\"228\":1,\"264\":1}}],[\"的o为止\",{\"1\":{\"44\":1}}],[\"的操作都是并发的\",{\"1\":{\"43\":1}}],[\"的delete是在最后一个operation上加入新的lamport\",{\"1\":{\"35\":1}}],[\"的文本内容不一致\",{\"1\":{\"25\":1}}],[\"的文本内容是一致的\",{\"1\":{\"25\":1}}],[\"的基本单位是页\",{\"1\":{\"69\":1}}],[\"的基本单位也是页\",{\"1\":{\"62\":1}}],[\"的基本概念\",{\"1\":{\"19\":1,\"22\":1}}],[\"的基础\",{\"1\":{\"10\":1,\"11\":1,\"258\":1}}],[\"的\",{\"1\":{\"18\":2,\"56\":1,\"70\":1,\"71\":1,\"73\":1,\"88\":1,\"113\":1,\"136\":1,\"164\":1,\"183\":1,\"190\":1,\"199\":1,\"200\":8,\"202\":2,\"219\":1,\"227\":1,\"236\":1,\"238\":1,\"239\":1,\"241\":1,\"242\":2,\"261\":1,\"262\":2,\"284\":1,\"285\":1,\"291\":1}}],[\"的声明周期\",{\"1\":{\"16\":1}}],[\"的唯一性\",{\"1\":{\"13\":1}}],[\"的算法伪代码\",{\"1\":{\"12\":1}}],[\"的核心函数有三个\",{\"1\":{\"283\":1}}],[\"的核心概念和原理后\",{\"1\":{\"241\":1}}],[\"的核心点在\",{\"1\":{\"200\":1}}],[\"的核心点在于最近\",{\"1\":{\"63\":1}}],[\"的核心在于\",{\"1\":{\"200\":1}}],[\"的核心思想是\",{\"1\":{\"168\":1}}],[\"的核心思想是最终一致性\",{\"1\":{\"10\":1}}],[\"的核心逻辑就冲突了\",{\"1\":{\"164\":1}}],[\"的核心是插入操作\",{\"1\":{\"43\":1}}],[\"的核心是ops数组\",{\"1\":{\"13\":1}}],[\"的核心是操作同步\",{\"1\":{\"10\":1}}],[\"的伪代码\",{\"1\":{\"10\":1}}],[\"的数量和等待执行的任务的最大数量\",{\"1\":{\"264\":1}}],[\"的数量默认\",{\"1\":{\"200\":1}}],[\"的数量超过阈值\",{\"1\":{\"4\":1}}],[\"的数字\",{\"1\":{\"181\":1}}],[\"的数据流图如下所示\",{\"1\":{\"279\":1}}],[\"的数据流设计\",{\"1\":{\"153\":1}}],[\"的数据字段\",{\"1\":{\"200\":1}}],[\"的数据分片机制\",{\"1\":{\"119\":1}}],[\"的数据类型\",{\"1\":{\"117\":1}}],[\"的数据结构核心是状态\",{\"1\":{\"10\":1}}],[\"的数据结构核心是操作\",{\"1\":{\"10\":1}}],[\"的数组实则可以任意扩容\",{\"1\":{\"69\":1}}],[\"的魅力\",{\"1\":{\"9\":1}}],[\"的协同算法\",{\"1\":{\"8\":1}}],[\"的键值对合并成一个更大的\",{\"1\":{\"4\":1}}],[\"的专业\",{\"1\":{\"4\":1}}],[\"的解释更加的直观\",{\"1\":{\"3\":1}}],[\"的解释是\",{\"1\":{\"3\":1}}],[\"当客户端数据全部发送完毕\",{\"1\":{\"286\":1}}],[\"当输入流关闭\",{\"1\":{\"285\":1}}],[\"当窗口没有满\",{\"1\":{\"284\":1}}],[\"当作\",{\"1\":{\"284\":1}}],[\"当收到\",{\"1\":{\"282\":1}}],[\"当提交的任务过多则会新建\",{\"1\":{\"264\":1}}],[\"当需要访问数据的时候\",{\"1\":{\"263\":1}}],[\"当需要内存分配对象时\",{\"1\":{\"238\":1}}],[\"当判断回收切片内存过大时\",{\"1\":{\"262\":1}}],[\"当大量的\",{\"1\":{\"261\":1}}],[\"当灰色栈为空时\",{\"1\":{\"244\":1}}],[\"当目前对象个数超过了阈值后\",{\"1\":{\"243\":1}}],[\"当对象个数超过了阈值\",{\"1\":{\"243\":1}}],[\"当对象不再被需要时\",{\"1\":{\"238\":1}}],[\"当对象不再使用时\",{\"1\":{\"238\":1}}],[\"当一个报文数据被推入到重组器后\",{\"1\":{\"282\":1}}],[\"当一个线程申请内存的时候\",{\"1\":{\"241\":1}}],[\"当一定时间内未收到领导者日志后\",{\"1\":{\"123\":1}}],[\"当申请这些内存时\",{\"1\":{\"241\":1}}],[\"当找到一个大小合适且未被使用的内存块时\",{\"1\":{\"240\":1}}],[\"当内存块释放时\",{\"1\":{\"241\":1}}],[\"当内存分配时\",{\"1\":{\"241\":1}}],[\"当内存不再需要的时候\",{\"1\":{\"234\":1}}],[\"当内存表的大小达到阈值\",{\"1\":{\"4\":1}}],[\"当其以进程的形式被创建时\",{\"1\":{\"232\":1}}],[\"当为\",{\"1\":{\"225\":1}}],[\"当进程在用户态运行时\",{\"1\":{\"194\":1}}],[\"当注册数据发生变更时\",{\"1\":{\"148\":1}}],[\"当服务调用出现失败之后需要有容错层的兜底辅助\",{\"1\":{\"143\":1}}],[\"当上层应用觉得日志序号过大\",{\"1\":{\"136\":1}}],[\"当调用\",{\"1\":{\"88\":1,\"241\":1,\"243\":1,\"261\":1}}],[\"当系统检测到死锁时\",{\"1\":{\"87\":1}}],[\"当事务之间存在数据依赖\",{\"1\":{\"87\":1}}],[\"当所以合并操作完成后\",{\"1\":{\"73\":1}}],[\"当更新\",{\"1\":{\"73\":1}}],[\"当寻找一个\",{\"1\":{\"73\":1}}],[\"当有大量\",{\"1\":{\"264\":1}}],[\"当有人拿到数据页\",{\"1\":{\"64\":1}}],[\"当有数据写入时\",{\"1\":{\"4\":1}}],[\"当页被淘汰\",{\"1\":{\"64\":1}}],[\"当缓存池满了需要淘汰时\",{\"1\":{\"63\":1}}],[\"当两个操作的origin一致时\",{\"1\":{\"43\":1}}],[\"当发现\",{\"1\":{\"18\":1}}],[\"当然笔者的实现略显粗糙\",{\"1\":{\"241\":1}}],[\"当然也涉及到初始化序号\",{\"1\":{\"272\":1}}],[\"当然也支持有条件跳转\",{\"1\":{\"254\":1}}],[\"当然也因为它最够简单\",{\"1\":{\"240\":1}}],[\"当然也避免了分裂和撕逼\",{\"1\":{\"228\":1}}],[\"当然也有一些其它的优化\",{\"1\":{\"218\":1}}],[\"当然也有例外\",{\"1\":{\"68\":1}}],[\"当然遇到\",{\"1\":{\"228\":1}}],[\"当然有了定义还不够\",{\"1\":{\"227\":1}}],[\"当然对于一些计算操作\",{\"1\":{\"218\":1}}],[\"当然使用\",{\"1\":{\"214\":1}}],[\"当然我们不是直接去写汇编\",{\"1\":{\"212\":1}}],[\"当然前提是你得对数据结构有一定的理解\",{\"1\":{\"190\":1}}],[\"当然不同的公司有不同的模式\",{\"1\":{\"165\":1}}],[\"当然由于日志暂时还未实现\",{\"1\":{\"124\":1}}],[\"当然它暂时不会沟通别的\",{\"1\":{\"124\":1}}],[\"当然其数据本身还是由\",{\"1\":{\"64\":1}}],[\"当然这涉及到\",{\"1\":{\"274\":1}}],[\"当然这里并不是鼓励大家去写汇编\",{\"1\":{\"197\":1}}],[\"当然这个库只能称为\",{\"1\":{\"190\":1}}],[\"当然这个过程中还伴随着索引\",{\"1\":{\"58\":1}}],[\"当然这也足够了\",{\"1\":{\"43\":1}}],[\"当然如果需要支持富文本\",{\"1\":{\"37\":1}}],[\"当然\",{\"1\":{\"17\":1,\"23\":1,\"79\":1,\"139\":1,\"210\":1,\"219\":1,\"235\":1,\"237\":1,\"241\":1,\"243\":1,\"262\":1,\"264\":1,\"278\":1,\"287\":1}}],[\"当然原理推导\",{\"1\":{\"8\":1}}],[\"当前发送队列\",{\"1\":{\"285\":1}}],[\"当前的\",{\"1\":{\"284\":1}}],[\"当前的重试时间\",{\"1\":{\"284\":1}}],[\"当前已组装的字节序号\",{\"1\":{\"282\":1}}],[\"当前序号\",{\"1\":{\"282\":1}}],[\"当前函数调用栈帧基地址\",{\"1\":{\"250\":1}}],[\"当前函数名称\",{\"1\":{\"207\":1}}],[\"当前栈大小\",{\"1\":{\"243\":1}}],[\"当前对象个数\",{\"1\":{\"243\":1}}],[\"当前地址\",{\"1\":{\"237\":1}}],[\"当前运行的\",{\"1\":{\"200\":1}}],[\"当前运行的线程栈\",{\"1\":{\"200\":1}}],[\"当前程序正在主线程上执行\",{\"1\":{\"200\":1}}],[\"当前任期号\",{\"1\":{\"126\":1,\"134\":1}}],[\"当前任期\",{\"1\":{\"123\":1,\"126\":1,\"133\":1}}],[\"当前节点还未提交\",{\"1\":{\"136\":1}}],[\"当前节点才能投出选票\",{\"1\":{\"130\":1}}],[\"当前节点必须立马成为追随者\",{\"1\":{\"129\":1}}],[\"当前节点在当前任期内给\",{\"1\":{\"123\":1}}],[\"当前节点处于领导者\",{\"1\":{\"123\":1}}],[\"当前节点\",{\"1\":{\"123\":1}}],[\"当前节点需要感知其它节点应用\",{\"1\":{\"13\":1}}],[\"当前查询事务\",{\"1\":{\"78\":1}}],[\"当前\",{\"1\":{\"63\":1,\"200\":2,\"224\":1,\"282\":1}}],[\"当前值\",{\"1\":{\"16\":1}}],[\"当执行删除操作时\",{\"1\":{\"4\":1}}],[\"当写入数据时\",{\"1\":{\"4\":1}}],[\"当\",{\"1\":{\"4\":2,\"16\":1,\"136\":2,\"214\":1,\"225\":1,\"237\":1,\"241\":1,\"243\":1,\"282\":1,\"285\":1}}],[\"中打上断点\",{\"1\":{\"291\":1}}],[\"中还有\",{\"1\":{\"287\":1}}],[\"中定时写入数据\",{\"1\":{\"286\":1}}],[\"中读取数据\",{\"1\":{\"286\":1}}],[\"中无数据发送且也无需发送空包\",{\"1\":{\"285\":1}}],[\"中交付给应用程序\",{\"1\":{\"282\":1}}],[\"中几个重要的实现方法加以说明\",{\"1\":{\"281\":1}}],[\"中移除\",{\"1\":{\"261\":1}}],[\"中如果需要使用汇编函数\",{\"1\":{\"257\":1}}],[\"中对通用寄存器的称呼\",{\"1\":{\"250\":1}}],[\"中对寄存器的命名略有不同\",{\"1\":{\"250\":1}}],[\"中对象作为\",{\"1\":{\"244\":1}}],[\"中存在了大量由\",{\"1\":{\"248\":1}}],[\"中存储\",{\"1\":{\"153\":1}}],[\"中拿到内存\",{\"1\":{\"241\":1}}],[\"中拿出包\",{\"1\":{\"285\":1}}],[\"中拿出\",{\"1\":{\"241\":1}}],[\"中没有提供线程缓存的\",{\"1\":{\"241\":1}}],[\"中没有则淘汰一个页\",{\"1\":{\"64\":2}}],[\"中管理\",{\"1\":{\"241\":1}}],[\"中去拿即可\",{\"1\":{\"241\":1}}],[\"中去拿\",{\"1\":{\"241\":1}}],[\"中记录每个块的大小了\",{\"1\":{\"241\":1}}],[\"中申请内存\",{\"1\":{\"238\":1}}],[\"中使用\",{\"1\":{\"255\":1}}],[\"中使用的\",{\"1\":{\"237\":1}}],[\"中使用二分查找查询指定键的值\",{\"1\":{\"4\":1}}],[\"中执行\",{\"1\":{\"227\":2}}],[\"中实现二者之间的转化\",{\"1\":{\"227\":1}}],[\"中新增测试用例\",{\"1\":{\"227\":1}}],[\"中新增\",{\"1\":{\"227\":1}}],[\"中新增了指向\",{\"1\":{\"71\":1}}],[\"中大量使用了\",{\"1\":{\"227\":1}}],[\"中大量的使用了\",{\"1\":{\"198\":1}}],[\"中是没有\",{\"1\":{\"227\":1}}],[\"中间表示\",{\"1\":{\"229\":1}}],[\"中间码\",{\"1\":{\"227\":1}}],[\"中间层是很有必要的\",{\"1\":{\"218\":1}}],[\"中间件三驾马车\",{\"1\":{\"152\":1}}],[\"中两个有意思的技巧\",{\"1\":{\"216\":1}}],[\"中加入对应的\",{\"1\":{\"213\":1}}],[\"中加入需要被淘汰的页\",{\"1\":{\"63\":1}}],[\"中内联汇编\",{\"1\":{\"210\":1}}],[\"中调用该函数\",{\"1\":{\"213\":1}}],[\"中调用\",{\"1\":{\"210\":1}}],[\"中不同\",{\"1\":{\"257\":1}}],[\"中不可见\",{\"1\":{\"208\":1}}],[\"中不会直接偷\",{\"1\":{\"200\":1}}],[\"中不会实现\",{\"1\":{\"77\":1}}],[\"中虽然是不提倡的\",{\"1\":{\"207\":1}}],[\"中运行\",{\"1\":{\"200\":1}}],[\"中就可以通过线程局部变量来获取\",{\"1\":{\"200\":1}}],[\"中统称为系统栈\",{\"1\":{\"200\":1}}],[\"中维护了\",{\"1\":{\"199\":1}}],[\"中用数据结构\",{\"1\":{\"199\":3}}],[\"中用于保存键值对的字段是\",{\"1\":{\"69\":1}}],[\"中最复杂\",{\"1\":{\"282\":1}}],[\"中最重要的\",{\"1\":{\"281\":1}}],[\"中最常用的数据结构之一\",{\"1\":{\"208\":1}}],[\"中最基本的运行单元\",{\"1\":{\"199\":1}}],[\"中最简单的一个模块\",{\"1\":{\"135\":1}}],[\"中共享内存与字段\",{\"1\":{\"198\":1,\"203\":1}}],[\"中频繁的使用了这行代码\",{\"1\":{\"198\":1}}],[\"中重要的系统调用\",{\"0\":{\"198\":1}}],[\"中断处理函数返回到\",{\"1\":{\"197\":1}}],[\"中添加\",{\"1\":{\"188\":1}}],[\"中提取架构\",{\"1\":{\"164\":1}}],[\"中提出\",{\"1\":{\"41\":1}}],[\"中请求消息\",{\"1\":{\"160\":1}}],[\"中获取\",{\"1\":{\"160\":1}}],[\"中更新了\",{\"1\":{\"136\":1}}],[\"中有\",{\"1\":{\"285\":1}}],[\"中有如下代码\",{\"1\":{\"200\":1}}],[\"中有一个\",{\"1\":{\"200\":1}}],[\"中有其说明\",{\"1\":{\"134\":1}}],[\"中有多少页\",{\"1\":{\"63\":1}}],[\"中上一次同步的日志任期\",{\"1\":{\"126\":1}}],[\"中上一次同步的日志索引\",{\"1\":{\"126\":1}}],[\"中注册自身地址\",{\"1\":{\"112\":1}}],[\"中通过\",{\"1\":{\"93\":1}}],[\"中保存了\",{\"1\":{\"88\":1}}],[\"中也可以通过\",{\"1\":{\"85\":1}}],[\"中指向\",{\"1\":{\"72\":1}}],[\"中删除\",{\"1\":{\"64\":1,\"72\":1}}],[\"中由\",{\"1\":{\"64\":1}}],[\"中文名\",{\"1\":{\"56\":1}}],[\"中文事件笔者不会啊\",{\"1\":{\"24\":1,\"45\":1}}],[\"中插入解决冲突部分\",{\"1\":{\"47\":1}}],[\"中的包\",{\"1\":{\"284\":2}}],[\"中的报文如何被确认\",{\"1\":{\"284\":1}}],[\"中的报文\",{\"1\":{\"284\":1}}],[\"中的报文需要通过接受到的\",{\"1\":{\"284\":1}}],[\"中的字节数\",{\"1\":{\"283\":1}}],[\"中的对象通过自定义\",{\"1\":{\"262\":1}}],[\"中的对象可能会被垃圾回收\",{\"1\":{\"261\":1}}],[\"中的数据入栈\",{\"1\":{\"251\":1}}],[\"中的常见语法\",{\"1\":{\"248\":1}}],[\"中的每一个内存块都是\",{\"1\":{\"241\":1}}],[\"中的初始化\",{\"1\":{\"227\":1}}],[\"中的语句\",{\"1\":{\"227\":1}}],[\"中的任意类型\",{\"1\":{\"208\":1}}],[\"中的私有函数\",{\"0\":{\"206\":1},\"1\":{\"207\":1}}],[\"中的参数拷贝到\",{\"1\":{\"200\":1}}],[\"中的一些选项均不支持\",{\"1\":{\"278\":1}}],[\"中的一些语句执行顺序尝试进行重排序\",{\"1\":{\"227\":1}}],[\"中的一个例子\",{\"1\":{\"251\":1}}],[\"中的一个\",{\"1\":{\"199\":1}}],[\"中的一项\",{\"1\":{\"10\":1}}],[\"中的测试是由不同粒度的功能测试构成的\",{\"1\":{\"164\":1}}],[\"中的消息\",{\"1\":{\"160\":1}}],[\"中的日志数据\",{\"1\":{\"136\":1}}],[\"中的顺序\",{\"1\":{\"114\":1}}],[\"中的三个核心方法伪代码如下\",{\"1\":{\"63\":1}}],[\"中的箭头所示\",{\"1\":{\"58\":1}}],[\"中的查询处理\",{\"1\":{\"58\":1}}],[\"中的设计\",{\"1\":{\"38\":1}}],[\"中的store是一个操作有序数组\",{\"1\":{\"28\":1}}],[\"中的核心算法部分\",{\"1\":{\"27\":1}}],[\"中的\",{\"0\":{\"202\":1},\"1\":{\"15\":1,\"63\":1,\"64\":1,\"79\":1,\"147\":1,\"200\":2,\"206\":1,\"207\":1,\"208\":2,\"212\":1,\"255\":1,\"256\":1,\"279\":2,\"282\":1,\"283\":1,\"284\":1}}],[\"中止一个事务\",{\"1\":{\"4\":1}}],[\"中查询指定键的值\",{\"1\":{\"4\":1}}],[\"中查找数据项\",{\"1\":{\"4\":1}}],[\"中找不到\",{\"1\":{\"4\":1}}],[\"中以进行快速判断是否存在\",{\"1\":{\"4\":1}}],[\"中\",{\"1\":{\"4\":3,\"23\":1,\"27\":1,\"50\":1,\"63\":1,\"64\":2,\"69\":1,\"71\":1,\"72\":2,\"82\":1,\"85\":1,\"113\":1,\"121\":1,\"128\":1,\"136\":1,\"153\":1,\"177\":1,\"179\":1,\"194\":1,\"197\":1,\"198\":3,\"200\":5,\"202\":1,\"213\":1,\"217\":2,\"227\":1,\"233\":1,\"237\":1,\"239\":1,\"241\":1,\"243\":1,\"256\":1,\"257\":2,\"263\":1,\"265\":1,\"279\":2,\"282\":1,\"283\":1,\"286\":1,\"294\":1}}],[\"和窗口大小\",{\"1\":{\"284\":1}}],[\"和垃圾回收\",{\"1\":{\"245\":1}}],[\"和刚才谈到的一样\",{\"1\":{\"241\":1}}],[\"和磁盘\",{\"1\":{\"231\":1}}],[\"和其它工具\",{\"1\":{\"224\":1}}],[\"和机器码生成器\",{\"1\":{\"219\":1}}],[\"和数组切片之间的数据拷贝场景\",{\"1\":{\"207\":1}}],[\"和本地队列中获取\",{\"1\":{\"200\":1}}],[\"和本地时钟组成\",{\"1\":{\"13\":1}}],[\"和多个\",{\"1\":{\"199\":1}}],[\"和各种队列中\",{\"1\":{\"199\":1}}],[\"和泛型是颇为简单的\",{\"1\":{\"190\":1}}],[\"和泛型的强大能力\",{\"1\":{\"186\":1}}],[\"和反射来将其提取为一个函数\",{\"1\":{\"179\":1}}],[\"和日志应用一样\",{\"1\":{\"136\":1}}],[\"和接收时间\",{\"1\":{\"136\":1}}],[\"和上面说的一致\",{\"1\":{\"124\":1}}],[\"和元素\",{\"1\":{\"115\":1}}],[\"和加锁模式加入到队列\",{\"1\":{\"88\":1}}],[\"和客户端\",{\"1\":{\"25\":2}}],[\"和读操作\",{\"1\":{\"4\":1}}],[\"和\",{\"1\":{\"4\":3,\"10\":1,\"12\":1,\"22\":1,\"27\":1,\"28\":1,\"63\":1,\"64\":2,\"69\":7,\"71\":4,\"79\":1,\"82\":1,\"98\":1,\"113\":2,\"114\":2,\"115\":2,\"117\":1,\"123\":1,\"129\":5,\"133\":2,\"134\":1,\"136\":4,\"138\":1,\"139\":2,\"165\":1,\"181\":3,\"194\":1,\"198\":1,\"200\":5,\"203\":1,\"212\":1,\"213\":1,\"218\":1,\"219\":1,\"223\":1,\"224\":1,\"241\":2,\"244\":1,\"245\":1,\"248\":1,\"251\":1,\"255\":1,\"261\":1,\"264\":1,\"272\":1,\"277\":1,\"278\":1,\"279\":2,\"281\":2,\"282\":2,\"283\":3,\"284\":1,\"285\":4}}],[\"和精益创业\",{\"1\":{\"0\":1}}],[\"tgsigqueueinfo\",{\"1\":{\"294\":2}}],[\"tbl\",{\"1\":{\"294\":2}}],[\"tun\",{\"1\":{\"278\":1}}],[\"tup\",{\"1\":{\"79\":6,\"89\":13}}],[\"tuples\",{\"1\":{\"89\":1}}],[\"tuple\",{\"1\":{\"78\":6,\"79\":11,\"82\":2,\"89\":8}}],[\"tcpoverudpsocketadapter\",{\"1\":{\"286\":2}}],[\"tcpstate\",{\"1\":{\"285\":3,\"286\":1}}],[\"tcpsegment\",{\"1\":{\"279\":1,\"283\":1,\"284\":4,\"285\":3,\"286\":2}}],[\"tcpsender\",{\"0\":{\"284\":1},\"1\":{\"279\":6,\"280\":2,\"284\":8,\"285\":4}}],[\"tcpconfig\",{\"1\":{\"284\":1,\"285\":3,\"286\":2}}],[\"tcpconnection\",{\"0\":{\"285\":1},\"1\":{\"279\":6,\"280\":3,\"281\":1,\"284\":1,\"285\":21,\"286\":5}}],[\"tcp发送者\",{\"1\":{\"280\":1}}],[\"tcp接收者\",{\"1\":{\"280\":1}}],[\"tcp连接\",{\"1\":{\"280\":1}}],[\"tcpreceiver\",{\"0\":{\"283\":1},\"1\":{\"279\":6,\"280\":2,\"283\":6,\"284\":1,\"285\":2}}],[\"tcp\",{\"0\":{\"269\":1,\"270\":1,\"271\":1},\"1\":{\"260\":1,\"263\":2,\"270\":7,\"271\":1,\"272\":3,\"273\":5,\"274\":6,\"275\":2,\"277\":3,\"278\":5,\"279\":6,\"280\":6,\"281\":1,\"282\":8,\"283\":5,\"284\":1,\"285\":4,\"286\":15,\"288\":1}}],[\"tcmalloc\",{\"0\":{\"241\":1},\"1\":{\"241\":18,\"243\":5,\"244\":1,\"245\":3,\"247\":1}}],[\"tnumgc\",{\"1\":{\"238\":1}}],[\"tsys\",{\"1\":{\"238\":1}}],[\"twice\",{\"1\":{\"240\":1}}],[\"twitch\",{\"1\":{\"236\":1}}],[\"two\",{\"1\":{\"47\":1,\"90\":1}}],[\"ttys0\",{\"1\":{\"293\":1}}],[\"tty\",{\"1\":{\"291\":1,\"293\":1}}],[\"tty4\",{\"1\":{\"291\":2}}],[\"tty3\",{\"1\":{\"291\":2}}],[\"tty2\",{\"1\":{\"291\":2}}],[\"tty1\",{\"1\":{\"291\":2}}],[\"ttotalalloc\",{\"1\":{\"238\":1}}],[\"tt\",{\"1\":{\"212\":5,\"213\":9}}],[\"ttl\",{\"1\":{\"114\":1}}],[\"tls\",{\"1\":{\"198\":1,\"200\":20,\"204\":1,\"254\":1}}],[\"typ\",{\"1\":{\"179\":2,\"227\":1,\"243\":7,\"244\":2}}],[\"typebyte\",{\"1\":{\"208\":3}}],[\"typelinksinit\",{\"1\":{\"200\":1}}],[\"typeof\",{\"1\":{\"179\":1,\"208\":1}}],[\"type=\",{\"1\":{\"170\":2}}],[\"typename\",{\"1\":{\"69\":2}}],[\"types2\",{\"1\":{\"227\":2}}],[\"types论文详细阐述了协同算法的发展历史\",{\"1\":{\"41\":1}}],[\"types\",{\"1\":{\"8\":1,\"10\":2,\"13\":1,\"19\":1,\"20\":2,\"23\":1,\"39\":2,\"41\":1,\"53\":1,\"181\":3,\"215\":1,\"219\":13,\"227\":1}}],[\"types中正式对\",{\"1\":{\"8\":1}}],[\"type\",{\"1\":{\"8\":1,\"10\":2,\"13\":10,\"14\":1,\"16\":4,\"18\":4,\"25\":3,\"26\":1,\"28\":4,\"47\":1,\"48\":1,\"59\":1,\"69\":1,\"73\":4,\"123\":2,\"124\":2,\"126\":3,\"128\":2,\"130\":1,\"131\":1,\"134\":1,\"136\":5,\"146\":1,\"179\":1,\"181\":1,\"200\":1,\"207\":2,\"208\":6,\"212\":1,\"213\":1,\"218\":1,\"219\":5,\"225\":2,\"227\":1,\"238\":1,\"240\":1,\"243\":4,\"244\":1,\"263\":4,\"291\":1,\"293\":1}}],[\"tdd实践\",{\"0\":{\"166\":1}}],[\"tdd\",{\"0\":{\"168\":1},\"1\":{\"164\":22,\"165\":2,\"167\":2,\"168\":3,\"169\":2}}],[\"tdd学习心得\",{\"0\":{\"163\":1}}],[\"tar\",{\"1\":{\"291\":6,\"292\":3,\"293\":3}}],[\"tap\",{\"1\":{\"278\":1}}],[\"tac\",{\"1\":{\"218\":2}}],[\"tasks\",{\"1\":{\"194\":1}}],[\"task\",{\"1\":{\"187\":1,\"194\":5,\"199\":1,\"227\":1,\"237\":2}}],[\"tail\",{\"1\":{\"184\":2,\"188\":2,\"243\":5,\"244\":1}}],[\"talent\",{\"1\":{\"119\":1}}],[\"take\",{\"1\":{\"88\":1,\"188\":1}}],[\"tables\",{\"1\":{\"212\":1}}],[\"table\",{\"1\":{\"4\":1,\"31\":1,\"59\":1,\"64\":12,\"79\":20,\"88\":4,\"89\":8,\"198\":2}}],[\"t3intsffsmv\",{\"1\":{\"191\":1}}],[\"t3\",{\"1\":{\"87\":2}}],[\"t2\",{\"1\":{\"86\":2,\"87\":4}}],[\"t1\",{\"1\":{\"86\":4,\"87\":4}}],[\"txn\",{\"1\":{\"78\":2,\"88\":33}}],[\"t>\",{\"1\":{\"63\":2,\"64\":2,\"284\":1}}],[\"texinfo\",{\"1\":{\"291\":1}}],[\"textflag\",{\"1\":{\"200\":1,\"257\":1}}],[\"text\",{\"1\":{\"27\":2,\"51\":1,\"180\":2,\"197\":1,\"200\":10,\"212\":2,\"217\":4,\"232\":1,\"256\":4,\"257\":2}}],[\"tell\",{\"1\":{\"285\":1}}],[\"telnet\",{\"1\":{\"277\":2}}],[\"temporaries\",{\"1\":{\"227\":1}}],[\"template\",{\"1\":{\"69\":4}}],[\"teardown\",{\"1\":{\"164\":1}}],[\"term\",{\"1\":{\"123\":2,\"124\":10,\"126\":2,\"128\":5,\"129\":13,\"130\":2,\"133\":9,\"134\":9,\"136\":18}}],[\"testvm\",{\"1\":{\"243\":1,\"244\":1}}],[\"testfree4\",{\"1\":{\"241\":1}}],[\"testout\",{\"1\":{\"227\":1}}],[\"testdump1\",{\"1\":{\"227\":5}}],[\"testdump\",{\"1\":{\"227\":1}}],[\"testnoerr\",{\"1\":{\"225\":3}}],[\"testerr\",{\"1\":{\"225\":4}}],[\"tests\",{\"1\":{\"212\":2,\"213\":2}}],[\"testing\",{\"1\":{\"207\":3,\"208\":1,\"212\":2,\"213\":4,\"227\":2,\"241\":1,\"243\":1,\"244\":1}}],[\"test=\",{\"1\":{\"174\":1}}],[\"testwithxml1\",{\"1\":{\"170\":1}}],[\"test\",{\"1\":{\"5\":1,\"164\":6,\"168\":1,\"170\":1,\"174\":5,\"175\":1,\"206\":2,\"207\":6,\"208\":3,\"212\":7,\"213\":2,\"227\":8,\"294\":4}}],[\"tick\",{\"1\":{\"284\":10,\"285\":8}}],[\"ticker\",{\"1\":{\"124\":6,\"125\":2,\"129\":1,\"131\":2,\"133\":2,\"139\":2}}],[\"title\",{\"1\":{\"174\":2}}],[\"tidis\",{\"1\":{\"119\":2}}],[\"tidb\",{\"1\":{\"107\":1,\"119\":1,\"238\":1}}],[\"tikv\",{\"0\":{\"107\":1},\"1\":{\"103\":5,\"106\":2,\"107\":3,\"113\":3,\"119\":1}}],[\"tinygo\",{\"1\":{\"219\":2,\"221\":1}}],[\"tinybatis\",{\"0\":{\"166\":1},\"1\":{\"167\":1,\"169\":1,\"174\":1}}],[\"tiny\",{\"1\":{\"161\":1,\"190\":1}}],[\"tinymq\",{\"1\":{\"152\":1,\"153\":1,\"155\":3,\"157\":2,\"158\":3,\"160\":1,\"161\":2}}],[\"tinymq设计与实现\",{\"0\":{\"152\":1}}],[\"tinydecoder\",{\"1\":{\"146\":1}}],[\"tinyencoder\",{\"1\":{\"146\":1}}],[\"tinyprotocol\",{\"1\":{\"146\":13,\"147\":1}}],[\"tinyrpc的设计与实现\",{\"1\":{\"141\":1}}],[\"tinyrpc\",{\"0\":{\"141\":1},\"1\":{\"143\":1,\"147\":1,\"149\":1,\"150\":1,\"151\":4}}],[\"tinykv\",{\"1\":{\"119\":1}}],[\"tinyyjs\",{\"0\":{\"49\":1},\"1\":{\"49\":2,\"50\":1,\"51\":2}}],[\"tinyautomerge仍然以operation\",{\"1\":{\"28\":1}}],[\"tinyautomerge\",{\"0\":{\"27\":1},\"1\":{\"27\":3,\"38\":1}}],[\"timeout\",{\"1\":{\"284\":8,\"285\":4}}],[\"timer\",{\"1\":{\"284\":6}}],[\"timeunit\",{\"1\":{\"150\":1}}],[\"time\",{\"0\":{\"218\":1},\"1\":{\"39\":1,\"41\":2,\"53\":1,\"88\":1,\"124\":1,\"126\":2,\"129\":2,\"131\":2,\"136\":1,\"137\":1,\"238\":6,\"263\":2,\"268\":10,\"284\":6,\"285\":8,\"291\":1}}],[\"timestamp\",{\"1\":{\"13\":1,\"20\":1,\"158\":1}}],[\"timestamp的具体实现\",{\"1\":{\"13\":1}}],[\"th\",{\"1\":{\"213\":3}}],[\"than\",{\"1\":{\"188\":1,\"285\":1}}],[\"that\",{\"1\":{\"30\":1,\"51\":2,\"69\":1,\"134\":3,\"181\":1,\"200\":1,\"202\":1,\"284\":2,\"285\":3}}],[\"there\",{\"1\":{\"262\":1}}],[\"their\",{\"1\":{\"227\":1}}],[\"then\",{\"1\":{\"225\":1}}],[\"thenreturn\",{\"1\":{\"164\":1}}],[\"theory\",{\"1\":{\"90\":1}}],[\"these\",{\"1\":{\"47\":1,\"227\":1}}],[\"the\",{\"1\":{\"23\":1,\"26\":6,\"28\":3,\"30\":1,\"47\":6,\"51\":11,\"88\":1,\"134\":4,\"136\":2,\"191\":1,\"198\":2,\"200\":5,\"227\":1,\"235\":1,\"236\":1,\"238\":1,\"247\":3,\"263\":2,\"264\":1,\"268\":2,\"282\":2,\"283\":13,\"284\":5,\"285\":27,\"291\":1,\"293\":1}}],[\"through\",{\"1\":{\"293\":1}}],[\"throughput\",{\"1\":{\"286\":2}}],[\"throws\",{\"1\":{\"146\":2,\"158\":10,\"170\":1,\"172\":1,\"173\":1}}],[\"throw\",{\"1\":{\"13\":2,\"16\":1,\"18\":1,\"26\":4,\"47\":2,\"48\":1,\"150\":1,\"172\":3,\"173\":1,\"174\":1,\"200\":2}}],[\"thrift等\",{\"1\":{\"147\":1}}],[\"three\",{\"1\":{\"218\":1}}],[\"threadcache\",{\"1\":{\"241\":4}}],[\"threads\",{\"1\":{\"200\":1}}],[\"thread\",{\"1\":{\"88\":2,\"198\":2,\"200\":2,\"237\":2,\"241\":1,\"286\":1}}],[\"threshold\",{\"1\":{\"4\":6}}],[\"this\",{\"1\":{\"13\":21,\"14\":19,\"16\":16,\"17\":11,\"18\":16,\"26\":27,\"28\":1,\"47\":21,\"48\":17,\"50\":21,\"51\":34,\"88\":2,\"164\":1,\"174\":3,\"200\":2,\"282\":1,\"283\":1,\"285\":1,\"286\":1}}],[\"t\",{\"1\":{\"5\":1,\"13\":1,\"16\":4,\"17\":4,\"18\":3,\"25\":2,\"26\":4,\"28\":1,\"47\":2,\"48\":2,\"51\":1,\"63\":9,\"64\":15,\"69\":5,\"79\":3,\"88\":1,\"93\":4,\"136\":1,\"147\":4,\"179\":9,\"181\":13,\"183\":14,\"184\":22,\"185\":11,\"187\":9,\"188\":12,\"189\":5,\"194\":1,\"200\":2,\"207\":6,\"208\":5,\"212\":9,\"213\":10,\"227\":9,\"237\":4,\"240\":3,\"241\":4,\"243\":3,\"244\":3,\"248\":2,\"252\":1,\"281\":8,\"282\":9,\"283\":10,\"284\":12,\"285\":5,\"286\":1,\"290\":1,\"291\":3,\"294\":1}}],[\"treat\",{\"1\":{\"284\":1}}],[\"trees\",{\"1\":{\"28\":2,\"75\":2}}],[\"tree\",{\"0\":{\"2\":1,\"3\":1,\"4\":1},\"1\":{\"2\":1,\"3\":1,\"5\":48,\"6\":1,\"23\":1,\"75\":1,\"212\":1,\"217\":1,\"226\":1}}],[\"tricolor\",{\"0\":{\"244\":1},\"1\":{\"244\":1}}],[\"tricky\",{\"1\":{\"210\":1}}],[\"tries\",{\"1\":{\"88\":1}}],[\"track\",{\"1\":{\"268\":1}}],[\"tracereference\",{\"1\":{\"244\":4}}],[\"trace\",{\"1\":{\"227\":2}}],[\"traits\",{\"1\":{\"208\":1}}],[\"tradeoff\",{\"1\":{\"165\":1}}],[\"transport\",{\"1\":{\"263\":1}}],[\"translatemain\",{\"1\":{\"219\":3}}],[\"translateadd\",{\"1\":{\"219\":3}}],[\"transform\",{\"1\":{\"79\":1,\"89\":1,\"106\":1,\"113\":2,\"114\":3,\"117\":2}}],[\"transformation\",{\"1\":{\"8\":1,\"41\":1}}],[\"transactionmanager\",{\"1\":{\"82\":1,\"88\":2}}],[\"transactionstate\",{\"1\":{\"88\":4}}],[\"transactions\",{\"1\":{\"4\":9}}],[\"transaction\",{\"1\":{\"4\":57,\"5\":10,\"58\":1,\"71\":1,\"78\":1,\"88\":4}}],[\"trywakep\",{\"1\":{\"200\":1}}],[\"try\",{\"1\":{\"78\":1,\"150\":1,\"157\":1,\"172\":1,\"174\":1,\"286\":2,\"292\":1}}],[\"true\",{\"1\":{\"25\":1,\"26\":1,\"47\":1,\"63\":1,\"64\":4,\"71\":3,\"78\":1,\"79\":1,\"88\":5,\"89\":2,\"124\":2,\"126\":1,\"129\":2,\"130\":6,\"131\":1,\"133\":2,\"136\":5,\"149\":1,\"174\":1,\"189\":2,\"190\":1,\"200\":4,\"212\":3,\"219\":2,\"225\":2,\"240\":1,\"243\":2,\"282\":3,\"283\":3,\"284\":6,\"285\":8,\"286\":1}}],[\"tmd\",{\"1\":{\"4\":1}}],[\"touch\",{\"1\":{\"293\":1}}],[\"took\",{\"1\":{\"291\":1}}],[\"toolchains\",{\"1\":{\"293\":1}}],[\"toolchain\",{\"1\":{\"293\":21}}],[\"toolchain3\",{\"1\":{\"224\":1,\"225\":1}}],[\"toolchain2\",{\"1\":{\"224\":2,\"225\":2}}],[\"toolchain1\",{\"1\":{\"224\":5,\"225\":3}}],[\"tools\",{\"1\":{\"212\":2,\"225\":1}}],[\"tool\",{\"1\":{\"180\":2,\"217\":8}}],[\"total\",{\"1\":{\"263\":2,\"282\":5}}],[\"totalalloc\",{\"1\":{\"238\":14}}],[\"totalsize\",{\"1\":{\"200\":4}}],[\"tok\",{\"1\":{\"219\":1,\"225\":2}}],[\"tokpos\",{\"1\":{\"219\":1}}],[\"token\",{\"1\":{\"219\":2,\"225\":4,\"227\":5}}],[\"tokenize\",{\"1\":{\"174\":1}}],[\"tokens\",{\"1\":{\"174\":3,\"225\":7,\"227\":3}}],[\"top\",{\"1\":{\"200\":2,\"263\":1,\"266\":1}}],[\"topicinfo\",{\"1\":{\"155\":3}}],[\"topicid\",{\"1\":{\"155\":10}}],[\"topic\",{\"1\":{\"153\":1,\"155\":3,\"157\":1,\"158\":3,\"160\":1}}],[\"tobytearray\",{\"1\":{\"157\":1}}],[\"todo\",{\"1\":{\"89\":1,\"179\":1,\"227\":1}}],[\"tojsonbytes\",{\"1\":{\"147\":1}}],[\"tojson\",{\"1\":{\"49\":1}}],[\"tostring\",{\"1\":{\"49\":1,\"174\":1}}],[\"tostate\",{\"1\":{\"14\":1}}],[\"toarray\",{\"1\":{\"49\":1}}],[\"toydb\",{\"1\":{\"119\":1}}],[\"toy\",{\"1\":{\"27\":1}}],[\"to\",{\"1\":{\"4\":1,\"20\":1,\"26\":1,\"39\":1,\"41\":2,\"51\":8,\"53\":1,\"88\":1,\"124\":1,\"131\":1,\"134\":1,\"179\":1,\"198\":1,\"200\":4,\"207\":2,\"221\":1,\"227\":1,\"236\":1,\"238\":1,\"247\":1,\"258\":1,\"262\":1,\"263\":4,\"283\":1,\"284\":2,\"285\":7,\"286\":17,\"288\":1,\"291\":2,\"293\":2}}],[\"sf\",{\"1\":{\"291\":4}}],[\"sjtu\",{\"1\":{\"291\":1}}],[\"sweep\",{\"0\":{\"243\":1},\"1\":{\"235\":1,\"242\":2,\"243\":12,\"244\":8}}],[\"switchstmt\",{\"1\":{\"227\":2}}],[\"switch\",{\"1\":{\"89\":1,\"218\":2,\"225\":3}}],[\"sram\",{\"1\":{\"231\":3}}],[\"srcp\",{\"1\":{\"207\":2}}],[\"src\",{\"1\":{\"59\":1,\"79\":1,\"207\":9,\"219\":4,\"224\":1,\"225\":9,\"227\":38,\"252\":1,\"291\":5}}],[\"smallobjectsize\",{\"1\":{\"241\":1}}],[\"small\",{\"0\":{\"213\":1},\"1\":{\"213\":13,\"268\":1}}],[\"smaller\",{\"1\":{\"26\":1}}],[\"snapshotindex\",{\"1\":{\"136\":2}}],[\"snapshotterm\",{\"1\":{\"136\":2}}],[\"snapshotvalid\",{\"1\":{\"136\":3}}],[\"snapshot\",{\"1\":{\"136\":28,\"138\":1}}],[\"snapshopt\",{\"1\":{\"136\":1}}],[\"snappy\",{\"1\":{\"4\":1}}],[\"spong\",{\"1\":{\"281\":1}}],[\"sponge\",{\"0\":{\"276\":1,\"279\":1,\"280\":1,\"286\":1},\"1\":{\"278\":5,\"279\":6,\"280\":4,\"281\":2,\"282\":1,\"283\":1,\"286\":3,\"287\":2,\"288\":1}}],[\"spew\",{\"1\":{\"207\":12,\"208\":1}}],[\"specific\",{\"1\":{\"198\":1}}],[\"span\",{\"1\":{\"241\":11}}],[\"sparg\",{\"1\":{\"200\":2}}],[\"spalign\",{\"1\":{\"200\":2}}],[\"space\",{\"1\":{\"200\":1,\"283\":1,\"284\":3,\"285\":1}}],[\"sp\",{\"1\":{\"180\":24,\"200\":36,\"202\":3,\"217\":2,\"250\":2,\"262\":3}}],[\"sprintf\",{\"1\":{\"136\":1}}],[\"splitting\",{\"1\":{\"136\":1}}],[\"split\",{\"1\":{\"51\":1,\"71\":2}}],[\"splice\",{\"1\":{\"26\":1,\"47\":1,\"48\":1}}],[\"say\",{\"1\":{\"257\":6}}],[\"saveancestors\",{\"1\":{\"200\":1}}],[\"save\",{\"1\":{\"200\":3}}],[\"saveraftstate\",{\"1\":{\"133\":1}}],[\"saxreader\",{\"1\":{\"172\":4,\"173\":4}}],[\"sa\",{\"1\":{\"170\":1}}],[\"same\",{\"1\":{\"51\":2,\"200\":1,\"202\":1}}],[\"ssagen\",{\"1\":{\"227\":2}}],[\"ssa\",{\"1\":{\"200\":1,\"218\":18,\"226\":2,\"227\":6,\"229\":1}}],[\"sse\",{\"1\":{\"200\":1}}],[\"ssd\",{\"1\":{\"119\":1,\"231\":1}}],[\"sstable\",{\"1\":{\"4\":73,\"5\":1}}],[\"sstables\",{\"1\":{\"4\":7}}],[\"symbol\",{\"1\":{\"255\":2,\"256\":2}}],[\"symbol+offset\",{\"1\":{\"255\":1}}],[\"sym\",{\"1\":{\"227\":1}}],[\"symabis\",{\"1\":{\"217\":3}}],[\"syn+ack\",{\"1\":{\"272\":2}}],[\"syn\",{\"1\":{\"272\":3,\"279\":1,\"283\":26,\"284\":11,\"285\":5,\"286\":17}}],[\"synopsis\",{\"1\":{\"237\":2}}],[\"syntax\",{\"1\":{\"225\":8,\"226\":1,\"227\":28}}],[\"sync\",{\"1\":{\"98\":1,\"123\":1,\"261\":2,\"262\":2,\"263\":5,\"266\":2,\"268\":1}}],[\"synctimeout\",{\"1\":{\"98\":1}}],[\"syncthreshold\",{\"1\":{\"98\":1}}],[\"sysfs\",{\"1\":{\"291\":1}}],[\"syscalls\",{\"1\":{\"294\":4}}],[\"syscall\",{\"1\":{\"204\":1,\"217\":2,\"218\":3,\"238\":3,\"257\":2,\"258\":1,\"294\":5}}],[\"sysmonstarting\",{\"1\":{\"200\":1}}],[\"sysmon\",{\"1\":{\"200\":3}}],[\"sysv\",{\"1\":{\"198\":1}}],[\"sysvsem\",{\"1\":{\"198\":1}}],[\"sys\",{\"1\":{\"197\":3,\"200\":6,\"202\":1,\"238\":14,\"257\":2,\"291\":3,\"294\":20}}],[\"systemstack\",{\"1\":{\"200\":3,\"204\":1}}],[\"system\",{\"1\":{\"56\":1,\"60\":1,\"65\":1,\"75\":2,\"80\":1,\"90\":1,\"95\":1,\"196\":1,\"204\":1,\"221\":1,\"291\":4,\"293\":8,\"294\":1}}],[\"slab\",{\"1\":{\"247\":5}}],[\"slave\",{\"1\":{\"4\":1}}],[\"slice\",{\"1\":{\"208\":2,\"262\":2}}],[\"slightly\",{\"1\":{\"200\":1}}],[\"slot\",{\"1\":{\"106\":2}}],[\"sleep\",{\"1\":{\"88\":1,\"124\":2,\"129\":1,\"131\":1,\"238\":3,\"268\":4,\"286\":1}}],[\"script\",{\"1\":{\"291\":1}}],[\"scratch\",{\"1\":{\"247\":1}}],[\"scalable\",{\"1\":{\"204\":1}}],[\"scanner\",{\"1\":{\"200\":1}}],[\"scanning\",{\"1\":{\"47\":4,\"48\":3}}],[\"scan\",{\"1\":{\"79\":2}}],[\"schips\",{\"1\":{\"295\":1}}],[\"schedtick\",{\"1\":{\"200\":1}}],[\"scheduler\",{\"1\":{\"204\":1}}],[\"schedule\",{\"1\":{\"200\":6}}],[\"sched\",{\"1\":{\"200\":16,\"202\":9}}],[\"schedinit\",{\"1\":{\"200\":5}}],[\"schema\",{\"1\":{\"79\":11,\"89\":1,\"175\":1}}],[\"school\",{\"1\":{\"164\":3}}],[\"score\",{\"1\":{\"113\":1,\"117\":3}}],[\"sz\",{\"1\":{\"70\":2,\"281\":7,\"282\":6,\"283\":2,\"284\":2,\"285\":2}}],[\"sqlsession\",{\"1\":{\"170\":4}}],[\"sqlsessionfactorybuilder\",{\"1\":{\"170\":2,\"172\":1}}],[\"sqlsessionfactory\",{\"1\":{\"170\":6,\"172\":2}}],[\"sqlsessionfactory可以创建sqlsession\",{\"1\":{\"169\":1}}],[\"sqlsession可以执行mapper中的select语句\",{\"1\":{\"169\":1}}],[\"sql\",{\"1\":{\"56\":2,\"58\":3,\"77\":2,\"79\":1,\"89\":1,\"170\":1,\"174\":3,\"263\":1}}],[\"sock\",{\"1\":{\"286\":5}}],[\"socket\",{\"0\":{\"277\":1},\"1\":{\"277\":4,\"286\":13}}],[\"something\",{\"1\":{\"227\":4}}],[\"sonic\",{\"1\":{\"214\":1,\"215\":1}}],[\"sources\",{\"1\":{\"291\":2}}],[\"source\",{\"1\":{\"183\":3,\"187\":11,\"188\":11,\"189\":6,\"286\":2}}],[\"software\",{\"1\":{\"164\":1}}],[\"so\",{\"1\":{\"51\":1,\"161\":1,\"164\":1,\"165\":1,\"200\":3,\"202\":1,\"263\":1,\"264\":1}}],[\"sort\",{\"1\":{\"4\":1,\"177\":1,\"184\":2,\"190\":1}}],[\"sorted\",{\"0\":{\"117\":1},\"1\":{\"4\":6,\"28\":1,\"102\":1,\"113\":2,\"117\":3}}],[\"support\",{\"1\":{\"215\":1,\"218\":1,\"219\":1,\"293\":1}}],[\"sure\",{\"1\":{\"200\":1,\"285\":1,\"292\":1}}],[\"submitwait\",{\"1\":{\"264\":1}}],[\"submit\",{\"1\":{\"264\":3,\"294\":2}}],[\"subtract\",{\"1\":{\"218\":3}}],[\"subto\",{\"1\":{\"129\":1,\"133\":1}}],[\"subl\",{\"1\":{\"213\":1}}],[\"subr\",{\"1\":{\"212\":3}}],[\"subq\",{\"1\":{\"180\":2,\"200\":1,\"253\":1}}],[\"substr\",{\"1\":{\"282\":1}}],[\"substring\",{\"1\":{\"282\":2,\"283\":1}}],[\"subsql\",{\"1\":{\"174\":7}}],[\"subscribe\",{\"1\":{\"148\":1}}],[\"subset\",{\"1\":{\"51\":1,\"221\":1}}],[\"sub\",{\"1\":{\"103\":1,\"218\":5}}],[\"summarized\",{\"1\":{\"47\":1}}],[\"successfully\",{\"1\":{\"286\":1}}],[\"success\",{\"1\":{\"126\":1,\"129\":3,\"133\":1,\"134\":2,\"144\":1,\"286\":2}}],[\"successor\",{\"1\":{\"47\":1}}],[\"succ\",{\"1\":{\"28\":3,\"31\":2,\"32\":1,\"34\":2,\"35\":1,\"36\":1,\"37\":1}}],[\"sh\",{\"1\":{\"290\":1,\"291\":1}}],[\"shutdown\",{\"1\":{\"285\":10,\"286\":2}}],[\"shrq\",{\"1\":{\"213\":1}}],[\"shrinkong\",{\"1\":{\"85\":1}}],[\"shrinking\",{\"1\":{\"85\":3,\"88\":4}}],[\"shape\",{\"1\":{\"180\":3}}],[\"sharded\",{\"1\":{\"119\":1}}],[\"shares\",{\"1\":{\"294\":1}}],[\"share中所有的abstracttype实例\",{\"1\":{\"50\":1}}],[\"share是一个map\",{\"1\":{\"50\":1}}],[\"share\",{\"1\":{\"50\":8,\"69\":1,\"88\":1,\"198\":5}}],[\"shared\",{\"1\":{\"39\":1,\"41\":2,\"53\":1,\"88\":2}}],[\"short\",{\"1\":{\"146\":3}}],[\"should\",{\"1\":{\"26\":2,\"88\":4,\"134\":3,\"164\":3,\"172\":1,\"173\":1,\"285\":3}}],[\"shift\",{\"1\":{\"26\":2}}],[\"simulate\",{\"1\":{\"268\":4}}],[\"simple\",{\"1\":{\"247\":1,\"295\":1}}],[\"simpleinit\",{\"1\":{\"227\":2}}],[\"simplestmt\",{\"1\":{\"227\":4}}],[\"siz\",{\"1\":{\"200\":10}}],[\"size2class\",{\"1\":{\"241\":1}}],[\"sizeof\",{\"1\":{\"69\":1,\"202\":1,\"207\":2,\"234\":1}}],[\"size\",{\"1\":{\"4\":4,\"63\":4,\"64\":4,\"69\":12,\"71\":5,\"72\":4,\"73\":3,\"93\":2,\"94\":1,\"98\":2,\"114\":1,\"115\":1,\"128\":1,\"129\":4,\"131\":1,\"134\":2,\"136\":2,\"137\":1,\"145\":1,\"158\":1,\"172\":1,\"200\":1,\"208\":1,\"210\":2,\"237\":5,\"238\":7,\"240\":14,\"241\":6,\"251\":1,\"262\":6,\"264\":1,\"268\":3,\"279\":2,\"281\":22,\"282\":14,\"283\":10,\"284\":25,\"285\":10,\"286\":1,\"294\":1}}],[\"si\",{\"1\":{\"200\":9,\"213\":3,\"217\":1,\"250\":1,\"257\":1}}],[\"sigprocmask\",{\"1\":{\"203\":2}}],[\"sigset\",{\"1\":{\"203\":2}}],[\"sigsave\",{\"1\":{\"200\":1}}],[\"sigmask\",{\"1\":{\"200\":2}}],[\"sig\",{\"1\":{\"198\":1,\"203\":2,\"219\":2}}],[\"sighand\",{\"1\":{\"198\":1}}],[\"single\",{\"1\":{\"136\":1}}],[\"since\",{\"1\":{\"51\":1,\"284\":2,\"285\":10}}],[\"sibling\",{\"1\":{\"71\":3,\"72\":4}}],[\"sites\",{\"1\":{\"291\":1}}],[\"site2\",{\"1\":{\"25\":1}}],[\"site1\",{\"1\":{\"25\":4}}],[\"siteid\",{\"1\":{\"25\":1,\"43\":1}}],[\"sbin\",{\"1\":{\"291\":3}}],[\"sbrk\",{\"1\":{\"210\":4,\"232\":1,\"237\":11}}],[\"sb\",{\"1\":{\"180\":2,\"200\":26,\"217\":6,\"250\":1,\"251\":2,\"254\":1,\"255\":8,\"256\":3,\"257\":7}}],[\"sblwwregister<t>\",{\"1\":{\"17\":1}}],[\"sblwwregister\",{\"1\":{\"17\":1}}],[\"sbcounter\",{\"1\":{\"14\":5,\"17\":1}}],[\"s2\",{\"1\":{\"14\":12}}],[\"s1\",{\"1\":{\"14\":12}}],[\"sent\",{\"1\":{\"284\":3,\"285\":3,\"286\":2}}],[\"sendmmsg\",{\"1\":{\"294\":2}}],[\"sending\",{\"1\":{\"286\":1}}],[\"sendinstallsnapshottopeer\",{\"1\":{\"136\":3}}],[\"sendinstallsnapshot\",{\"1\":{\"136\":3}}],[\"sender\",{\"1\":{\"159\":2,\"275\":2,\"279\":1,\"280\":2,\"284\":3,\"285\":28,\"286\":1}}],[\"senderpool\",{\"1\":{\"159\":2}}],[\"senddata\",{\"1\":{\"144\":3}}],[\"send\",{\"1\":{\"136\":1,\"150\":1,\"284\":2,\"285\":20,\"286\":4}}],[\"sendappendentries\",{\"1\":{\"129\":3}}],[\"sendappendentriestopeer\",{\"1\":{\"129\":4,\"133\":1,\"134\":1,\"136\":1,\"137\":1}}],[\"sendrequestvote\",{\"1\":{\"124\":5}}],[\"sendrequestvotetopeer\",{\"1\":{\"124\":4,\"130\":1,\"133\":1}}],[\"seg\",{\"1\":{\"283\":8,\"284\":9,\"285\":16,\"286\":2}}],[\"segments\",{\"1\":{\"284\":22,\"285\":9,\"286\":1}}],[\"segment\",{\"1\":{\"237\":1,\"279\":2,\"283\":4,\"284\":2,\"285\":29,\"286\":5}}],[\"semi\",{\"1\":{\"225\":2}}],[\"semaphore\",{\"1\":{\"198\":1}}],[\"see\",{\"1\":{\"198\":1,\"238\":1}}],[\"seen\",{\"1\":{\"28\":1,\"34\":4}}],[\"security\",{\"1\":{\"291\":2}}],[\"second\",{\"1\":{\"238\":3,\"268\":2}}],[\"seconds\",{\"1\":{\"150\":1,\"291\":1}}],[\"section\",{\"1\":{\"197\":2,\"212\":1}}],[\"series\",{\"1\":{\"268\":1,\"293\":1}}],[\"serialize\",{\"1\":{\"147\":2}}],[\"serializer\",{\"1\":{\"147\":3}}],[\"serialization\",{\"1\":{\"146\":4,\"147\":1}}],[\"servicename\",{\"1\":{\"145\":3}}],[\"service\",{\"1\":{\"119\":1,\"144\":1,\"157\":1,\"164\":4}}],[\"server\",{\"1\":{\"103\":1,\"124\":2,\"129\":2,\"136\":2,\"142\":2,\"286\":1}}],[\"seppo0010\",{\"1\":{\"119\":1}}],[\"seqo\",{\"1\":{\"283\":1}}],[\"seqno\",{\"1\":{\"282\":1,\"283\":31,\"284\":12,\"285\":2}}],[\"seq\",{\"1\":{\"79\":1}}],[\"seqscanexecutor\",{\"1\":{\"79\":5,\"89\":2}}],[\"seqscan\",{\"1\":{\"79\":1}}],[\"seqscanplannode\",{\"1\":{\"79\":5}}],[\"sequence\",{\"1\":{\"13\":1,\"69\":1,\"114\":3,\"283\":1,\"284\":5,\"285\":2}}],[\"selectstmt\",{\"1\":{\"227\":2}}],[\"selectnodemap\",{\"1\":{\"174\":1}}],[\"selectnode\",{\"1\":{\"174\":6}}],[\"selectnodes\",{\"1\":{\"173\":1}}],[\"select>\",{\"1\":{\"174\":1}}],[\"selectone\",{\"1\":{\"174\":2}}],[\"select\",{\"1\":{\"79\":2,\"145\":5,\"174\":1,\"225\":2}}],[\"self\",{\"1\":{\"4\":127}}],[\"search\",{\"1\":{\"30\":2,\"31\":1,\"32\":1,\"47\":1,\"73\":2,\"134\":1}}],[\"settings\",{\"1\":{\"291\":1}}],[\"settls\",{\"1\":{\"200\":4}}],[\"set<node>\",{\"1\":{\"282\":1}}],[\"set<rid>\",{\"1\":{\"88\":1}}],[\"setmaxopenconns\",{\"1\":{\"263\":1}}],[\"setmaxidleconns\",{\"1\":{\"263\":1}}],[\"setmask\",{\"1\":{\"203\":2}}],[\"setop\",{\"1\":{\"227\":3}}],[\"setup\",{\"1\":{\"164\":1,\"165\":1,\"294\":2}}],[\"setindex\",{\"1\":{\"157\":1}}],[\"setresult\",{\"1\":{\"157\":2}}],[\"setqueueconsumer\",{\"1\":{\"155\":1}}],[\"setpersistentlsn\",{\"1\":{\"93\":1}}],[\"setparentpageid\",{\"1\":{\"71\":3}}],[\"setkeyat\",{\"1\":{\"72\":1}}],[\"setsockopt\",{\"1\":{\"294\":2}}],[\"sets\",{\"1\":{\"51\":1,\"285\":1}}],[\"set\",{\"0\":{\"115\":1,\"117\":1},\"1\":{\"13\":1,\"14\":4,\"16\":3,\"17\":1,\"18\":4,\"19\":1,\"26\":1,\"49\":1,\"50\":2,\"51\":8,\"78\":3,\"88\":4,\"102\":2,\"113\":3,\"115\":2,\"117\":3,\"134\":2,\"198\":3,\"200\":1,\"225\":4,\"264\":1,\"268\":2,\"282\":19,\"283\":1,\"285\":5}}],[\"s\",{\"0\":{\"118\":1},\"1\":{\"5\":1,\"47\":1,\"48\":2,\"50\":2,\"86\":1,\"115\":1,\"119\":1,\"136\":1,\"180\":1,\"183\":1,\"184\":7,\"185\":6,\"187\":2,\"188\":4,\"189\":8,\"191\":2,\"197\":2,\"200\":2,\"212\":10,\"217\":5,\"218\":1,\"225\":3,\"227\":38,\"238\":1,\"241\":12,\"257\":4,\"258\":1,\"263\":1,\"283\":1,\"286\":2,\"291\":2}}],[\"still\",{\"1\":{\"286\":2}}],[\"stm\",{\"1\":{\"238\":2}}],[\"stmtlist\",{\"1\":{\"227\":1}}],[\"stmtfmt\",{\"1\":{\"227\":1}}],[\"stmtcontext\",{\"1\":{\"227\":1}}],[\"stmtornil\",{\"1\":{\"225\":2,\"227\":1}}],[\"stmt\",{\"1\":{\"219\":2,\"225\":2,\"227\":41,\"263\":2}}],[\"stw\",{\"1\":{\"235\":1,\"238\":3,\"244\":3}}],[\"stktopsp\",{\"1\":{\"200\":1,\"202\":1}}],[\"stk\",{\"1\":{\"198\":1,\"203\":2}}],[\"steams\",{\"1\":{\"183\":1,\"187\":2}}],[\"steal\",{\"1\":{\"92\":1}}],[\"student\",{\"1\":{\"164\":4}}],[\"studentservice\",{\"1\":{\"164\":1}}],[\"studentserviceimpltest\",{\"1\":{\"164\":1}}],[\"studentserviceimpl\",{\"1\":{\"164\":7}}],[\"studentrepository\",{\"1\":{\"164\":14}}],[\"study\",{\"1\":{\"8\":1,\"10\":1,\"19\":1,\"20\":1}}],[\"stub\",{\"1\":{\"142\":2,\"164\":1}}],[\"stopatentry\",{\"1\":{\"291\":1}}],[\"stopafterattempt\",{\"1\":{\"150\":1}}],[\"stop\",{\"1\":{\"235\":1,\"236\":1,\"238\":1}}],[\"stopstrategies\",{\"1\":{\"150\":1}}],[\"stopflushthread\",{\"1\":{\"93\":1}}],[\"storage\",{\"1\":{\"59\":2,\"200\":2}}],[\"store中\",{\"1\":{\"50\":1}}],[\"store\",{\"1\":{\"26\":9,\"28\":1,\"30\":6,\"31\":3,\"32\":2,\"34\":4,\"35\":2,\"36\":4,\"37\":4,\"50\":2,\"200\":1,\"218\":1,\"283\":1}}],[\"st\",{\"1\":{\"70\":6}}],[\"stdout\",{\"1\":{\"257\":1}}],[\"std\",{\"1\":{\"63\":4,\"64\":3,\"69\":2,\"78\":1,\"79\":7,\"88\":5,\"89\":3,\"281\":1,\"282\":2,\"283\":4,\"284\":4,\"285\":1,\"286\":2}}],[\"stl\",{\"1\":{\"23\":1}}],[\"stay\",{\"1\":{\"285\":1}}],[\"stats\",{\"1\":{\"268\":3}}],[\"static\",{\"1\":{\"210\":2,\"213\":1,\"231\":1,\"237\":1,\"250\":1,\"255\":1,\"291\":1,\"294\":2}}],[\"statements\",{\"1\":{\"227\":1}}],[\"statement\",{\"1\":{\"174\":1,\"227\":3}}],[\"state\",{\"0\":{\"14\":1,\"17\":1},\"1\":{\"10\":7,\"12\":1,\"14\":3,\"15\":1,\"17\":7,\"123\":7,\"124\":4,\"126\":1,\"129\":4,\"131\":1,\"133\":3,\"136\":3,\"194\":2,\"198\":1,\"227\":2,\"241\":3,\"285\":7,\"286\":2}}],[\"stacksize++\",{\"1\":{\"243\":1}}],[\"stacksize\",{\"1\":{\"243\":5,\"244\":2}}],[\"stackmax\",{\"1\":{\"243\":1,\"244\":1}}],[\"stackmin\",{\"1\":{\"200\":1}}],[\"stackinit\",{\"1\":{\"200\":1}}],[\"stack+stack\",{\"1\":{\"200\":2}}],[\"stackguard\",{\"1\":{\"200\":1}}],[\"stackguard1\",{\"1\":{\"200\":2}}],[\"stackguard0\",{\"1\":{\"200\":3}}],[\"stack\",{\"1\":{\"194\":4,\"200\":6,\"203\":1,\"212\":1,\"232\":1,\"237\":1,\"243\":4,\"244\":2,\"250\":1}}],[\"startblock\",{\"1\":{\"227\":4}}],[\"startfn\",{\"1\":{\"200\":1}}],[\"startpc\",{\"1\":{\"200\":1}}],[\"started\",{\"1\":{\"200\":1}}],[\"startnewtree\",{\"1\":{\"71\":3}}],[\"start\",{\"1\":{\"4\":3,\"27\":2,\"30\":2,\"47\":1,\"51\":4,\"124\":2,\"131\":2,\"197\":3,\"200\":2,\"237\":6,\"294\":1}}],[\"startup\",{\"1\":{\"0\":1}}],[\"strconv\",{\"1\":{\"213\":4,\"219\":1}}],[\"strace\",{\"1\":{\"197\":2,\"257\":2}}],[\"streams\",{\"1\":{\"285\":8}}],[\"streambyte\",{\"1\":{\"283\":1}}],[\"streamindex\",{\"1\":{\"283\":1}}],[\"streamreassembler\",{\"0\":{\"282\":1},\"1\":{\"279\":5,\"280\":2,\"282\":7,\"283\":2}}],[\"stream\",{\"0\":{\"182\":1,\"186\":1},\"1\":{\"177\":8,\"182\":1,\"183\":16,\"184\":14,\"185\":6,\"186\":1,\"187\":8,\"188\":4,\"189\":3,\"190\":8,\"191\":2,\"270\":1,\"280\":4,\"281\":4,\"282\":1,\"283\":15,\"284\":4,\"285\":12,\"286\":17}}],[\"streamobserver<producemessageresponse>\",{\"1\":{\"157\":1}}],[\"structure\",{\"1\":{\"283\":1}}],[\"structured\",{\"1\":{\"6\":1}}],[\"structs\",{\"1\":{\"181\":1}}],[\"struct\",{\"1\":{\"123\":1,\"124\":2,\"126\":3,\"128\":2,\"130\":1,\"131\":1,\"134\":1,\"136\":5,\"183\":1,\"194\":16,\"199\":1,\"200\":1,\"207\":2,\"208\":2,\"212\":2,\"213\":2,\"225\":2,\"227\":2,\"237\":8,\"238\":1,\"240\":1,\"243\":3,\"244\":1,\"261\":1,\"263\":4,\"282\":1}}],[\"strikefreedom\",{\"1\":{\"266\":1}}],[\"strict\",{\"1\":{\"85\":1}}],[\"stringer\",{\"1\":{\"225\":5}}],[\"strings\",{\"1\":{\"181\":1,\"225\":2}}],[\"stringbuilder\",{\"1\":{\"174\":2}}],[\"stringify\",{\"1\":{\"18\":1}}],[\"string\",{\"1\":{\"4\":1,\"13\":3,\"14\":2,\"16\":2,\"17\":2,\"18\":4,\"25\":1,\"26\":2,\"28\":1,\"47\":2,\"49\":1,\"50\":6,\"69\":2,\"102\":1,\"113\":1,\"123\":1,\"144\":5,\"145\":2,\"155\":21,\"157\":1,\"158\":5,\"164\":1,\"170\":1,\"172\":1,\"174\":6,\"179\":1,\"207\":3,\"212\":1,\"213\":3,\"218\":18,\"219\":6,\"225\":4,\"227\":6,\"281\":8,\"282\":2,\"283\":2,\"284\":1,\"285\":1,\"286\":1}}],[\"strong\",{\"1\":{\"85\":1}}],[\"str\",{\"1\":{\"4\":1,\"197\":2,\"207\":4,\"208\":1,\"281\":3}}],[\"如默认超时时间\",{\"1\":{\"285\":1}}],[\"如有直接返回\",{\"1\":{\"241\":1}}],[\"如有直接获取空闲页\",{\"1\":{\"64\":1}}],[\"如这里的\",{\"1\":{\"238\":1,\"257\":1}}],[\"如此大量的协程的创建也给调度器带来了极大的压力\",{\"1\":{\"264\":1}}],[\"如此机械的开辟\",{\"1\":{\"234\":1}}],[\"如此往复\",{\"1\":{\"164\":1}}],[\"如状态\",{\"1\":{\"200\":1}}],[\"如初始化栈\",{\"1\":{\"200\":1}}],[\"如不是则直接返回\",{\"1\":{\"124\":1}}],[\"如追随者一定时间内未收到来自领导者的心跳包\",{\"1\":{\"123\":1}}],[\"如日志的同步情况左右着领导者选举\",{\"1\":{\"121\":1}}],[\"如磁盘故障\",{\"1\":{\"92\":1}}],[\"如全表扫描\",{\"1\":{\"79\":1}}],[\"如数据更新\",{\"1\":{\"77\":1}}],[\"如数据列\",{\"1\":{\"59\":1}}],[\"如表遍历\",{\"1\":{\"77\":1}}],[\"如需对\",{\"1\":{\"68\":1}}],[\"如图所示\",{\"1\":{\"87\":1,\"232\":1,\"240\":1,\"241\":1}}],[\"如图中内部节点的第一个空键\",{\"1\":{\"68\":1}}],[\"如图\",{\"1\":{\"68\":1,\"71\":4,\"72\":4,\"73\":3}}],[\"如缓存中没有\",{\"1\":{\"64\":1}}],[\"如缓存管理器\",{\"1\":{\"59\":1}}],[\"如整型\",{\"1\":{\"59\":1}}],[\"如b+树索引页\",{\"1\":{\"59\":1}}],[\"如快照管理器\",{\"1\":{\"59\":1}}],[\"如查询执行器\",{\"1\":{\"59\":1}}],[\"如事务管理器\",{\"1\":{\"59\":1}}],[\"如已在\",{\"1\":{\"58\":1}}],[\"如内存数据库\",{\"1\":{\"56\":1}}],[\"如下面的\",{\"1\":{\"123\":1}}],[\"如下表\",{\"1\":{\"84\":1}}],[\"如下图\",{\"1\":{\"50\":2,\"64\":1,\"68\":1,\"72\":1,\"136\":1,\"194\":1,\"291\":1}}],[\"如下图所示\",{\"1\":{\"43\":1,\"114\":1,\"115\":1,\"116\":1,\"117\":1,\"126\":1,\"127\":1,\"128\":1,\"217\":1,\"218\":1,\"243\":1}}],[\"如下是一个纯文本编辑器\",{\"1\":{\"45\":1}}],[\"如下\",{\"1\":{\"23\":1,\"25\":1,\"32\":1,\"50\":1,\"59\":1,\"69\":2,\"70\":1,\"71\":2,\"72\":2,\"73\":1,\"79\":1,\"86\":2,\"88\":1,\"89\":1,\"107\":1,\"123\":1,\"124\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":2,\"130\":1,\"131\":3,\"133\":1,\"136\":5,\"144\":1,\"148\":1,\"164\":1,\"179\":2,\"181\":2,\"190\":1,\"194\":1,\"198\":1,\"200\":3,\"203\":1,\"207\":2,\"208\":2,\"210\":2,\"212\":1,\"213\":1,\"217\":3,\"218\":4,\"219\":4,\"225\":1,\"227\":2,\"232\":1,\"237\":2,\"238\":2,\"240\":1,\"241\":3,\"243\":2,\"252\":1,\"254\":1,\"256\":1,\"260\":1,\"262\":1,\"263\":1,\"264\":1,\"272\":1,\"273\":1,\"277\":1,\"282\":3,\"283\":1,\"284\":3,\"285\":2,\"291\":2}}],[\"如client1\",{\"1\":{\"13\":1}}],[\"如何随机生成的\",{\"1\":{\"283\":1}}],[\"如何存储页\",{\"1\":{\"241\":1}}],[\"如何实现更好的内存管理方式呢\",{\"1\":{\"241\":1}}],[\"如何管理这一大块内存\",{\"1\":{\"239\":1}}],[\"如何将一个需求拆解为子任务\",{\"1\":{\"164\":1}}],[\"如何止损\",{\"1\":{\"162\":1}}],[\"如何确认无异常\",{\"1\":{\"162\":1}}],[\"如何保证每一步上线都是可回滚\",{\"1\":{\"162\":1}}],[\"如何保证上线变更的兼容性\",{\"1\":{\"162\":1}}],[\"如何保证强最终一致性等等\",{\"1\":{\"10\":1}}],[\"如何推进整体项目的落地\",{\"1\":{\"162\":1}}],[\"如何处理异常情况\",{\"1\":{\"162\":1}}],[\"如何处理了\",{\"1\":{\"129\":1}}],[\"如何解决这个问题\",{\"1\":{\"132\":1}}],[\"如何基于\",{\"1\":{\"119\":1}}],[\"如何通过执行器来执行\",{\"1\":{\"89\":1}}],[\"如何比较\",{\"1\":{\"69\":1}}],[\"如何数据备份\",{\"1\":{\"56\":1}}],[\"如何用索引\",{\"1\":{\"56\":1}}],[\"如何设计测试用例\",{\"1\":{\"162\":1}}],[\"如何设计\",{\"1\":{\"20\":1}}],[\"如何同时满足\",{\"1\":{\"10\":1}}],[\"如上图所示\",{\"1\":{\"34\":1}}],[\"如上\",{\"1\":{\"9\":1}}],[\"如文档共同编辑\",{\"1\":{\"9\":1}}],[\"如写入性能\",{\"1\":{\"4\":1}}],[\"如\",{\"1\":{\"4\":2,\"11\":1,\"64\":1,\"67\":1,\"69\":2,\"77\":1,\"79\":3,\"84\":1,\"122\":1,\"123\":2,\"124\":1,\"129\":1,\"180\":1,\"200\":1,\"206\":1,\"207\":1,\"208\":1,\"233\":2,\"241\":1,\"243\":2,\"253\":1,\"255\":3,\"278\":1,\"279\":1,\"285\":1}}],[\"如果填充后仍然为空\",{\"1\":{\"285\":1}}],[\"如果处于\",{\"1\":{\"285\":2}}],[\"如果报文重试次数超过了\",{\"1\":{\"285\":1}}],[\"如果报文头部中含有\",{\"1\":{\"285\":1}}],[\"如果报文头部含有\",{\"1\":{\"285\":1}}],[\"如果报文头部序号\",{\"1\":{\"284\":1}}],[\"如果定时器没有开启\",{\"1\":{\"284\":1}}],[\"如果新的包被确认\",{\"1\":{\"284\":1}}],[\"如果输出流已经关闭\",{\"1\":{\"284\":1}}],[\"如果包头部序号\",{\"1\":{\"284\":1}}],[\"如果包头部没有\",{\"1\":{\"283\":1}}],[\"如果包长度为\",{\"1\":{\"284\":1}}],[\"如果包的大小小于窗口大小\",{\"1\":{\"284\":1}}],[\"如果该\",{\"1\":{\"283\":1}}],[\"如果该页是脏页\",{\"1\":{\"64\":1}}],[\"如果标记了结束\",{\"1\":{\"282\":1}}],[\"如果后续\",{\"1\":{\"262\":1}}],[\"如果后面的日志是匹配的\",{\"1\":{\"129\":1}}],[\"如果缓存了很大的\",{\"1\":{\"262\":1}}],[\"如果缓存中没有的话\",{\"1\":{\"241\":1}}],[\"如果缓存中已有该页\",{\"1\":{\"64\":1}}],[\"如果请求体的大小是可预测的\",{\"1\":{\"262\":1}}],[\"如果请求者的最后任期大\",{\"1\":{\"130\":1}}],[\"如果请求者的任期小于当前节点任期\",{\"1\":{\"124\":1}}],[\"如果请求者任期大于当前节点人气\",{\"1\":{\"124\":1}}],[\"如果把这些连接保存下来\",{\"1\":{\"260\":1}}],[\"如果每次都创建一个新的连接对象\",{\"1\":{\"260\":1}}],[\"如果一开始就直入主题\",{\"1\":{\"245\":1}}],[\"如果一个服务有多个提供者\",{\"1\":{\"145\":1}}],[\"如果一个新加入集群的追随者\",{\"1\":{\"136\":1}}],[\"如果对象可达\",{\"1\":{\"243\":1}}],[\"如果对象未被标记则表示不可达\",{\"1\":{\"243\":1}}],[\"如果将程序对象视为一个网状图\",{\"1\":{\"243\":1}}],[\"如果将字符删除掉了\",{\"1\":{\"25\":1}}],[\"如果存活则保留\",{\"1\":{\"243\":1}}],[\"如果存在则将事务的状态设置为\",{\"1\":{\"88\":1}}],[\"如果某个\",{\"1\":{\"241\":1}}],[\"如果内存已分配\",{\"1\":{\"240\":1}}],[\"如果开辟的内存仍在使用\",{\"1\":{\"232\":1}}],[\"如果开辟的内存未使用\",{\"1\":{\"232\":1}}],[\"如果使用\",{\"1\":{\"227\":1}}],[\"如果满足则再次跳入到\",{\"1\":{\"227\":1}}],[\"如果满足\",{\"1\":{\"227\":1}}],[\"如果出现类似\",{\"1\":{\"218\":1}}],[\"如果退出失败\",{\"1\":{\"200\":1}}],[\"如果为\",{\"1\":{\"200\":1}}],[\"如果为空树则直接返回\",{\"1\":{\"72\":1}}],[\"如果感到吃力\",{\"1\":{\"200\":1}}],[\"如果数据超过了窗口大小\",{\"1\":{\"281\":1}}],[\"如果数据量很小\",{\"1\":{\"260\":1}}],[\"如果数据量庞大\",{\"1\":{\"135\":1}}],[\"如果数据在高速缓存中\",{\"1\":{\"231\":1}}],[\"如果数量>n环形切片能实现新数据覆盖旧数据\",{\"1\":{\"188\":1}}],[\"如果key不存在\",{\"1\":{\"188\":1}}],[\"如果t的类型约束过多\",{\"1\":{\"179\":1}}],[\"如果再新增一个用于\",{\"1\":{\"179\":1}}],[\"如果再次分裂后\",{\"1\":{\"71\":1}}],[\"如果此时还需要一个用于浮点数的加法函数\",{\"1\":{\"179\":1}}],[\"如果结果为\",{\"1\":{\"174\":1}}],[\"如果测试书写良好\",{\"1\":{\"165\":1}}],[\"如果重构涉及功能上下文的重新划分\",{\"1\":{\"164\":1}}],[\"如果尚不存在架构愿景\",{\"1\":{\"164\":1}}],[\"如果已经存在架构或架构愿景\",{\"1\":{\"164\":1}}],[\"如果已经是\",{\"1\":{\"124\":1}}],[\"如果架构愿景已经比较清晰了\",{\"1\":{\"164\":1}}],[\"如果以后弃用\",{\"1\":{\"155\":1}}],[\"如果服务提供者正在发布\",{\"1\":{\"150\":1}}],[\"如果我们的类没有实现任何接口\",{\"1\":{\"144\":1}}],[\"如果我们在\",{\"1\":{\"73\":1}}],[\"如果待同步日志序号小\",{\"1\":{\"137\":1}}],[\"如果小于等于\",{\"1\":{\"136\":1}}],[\"如果仅靠日志同步请求来\",{\"1\":{\"136\":1}}],[\"如果冲突任期不为\",{\"1\":{\"134\":1}}],[\"如果冲突任期为\",{\"1\":{\"134\":1}}],[\"如果找到了冲突的任期\",{\"1\":{\"134\":1}}],[\"如果找不到则通过遍历\",{\"1\":{\"4\":1}}],[\"如果上一次同步序号仍在日志内\",{\"1\":{\"134\":1}}],[\"如果领导者上一次同步日志序号大于当前节点的日志大小\",{\"1\":{\"134\":1}}],[\"如果领导者不发送请求\",{\"1\":{\"126\":1}}],[\"如果日志发生了完全冲突\",{\"1\":{\"134\":1}}],[\"如果日志完全冲突\",{\"1\":{\"129\":1}}],[\"如果二者日志相差几百\",{\"1\":{\"134\":1}}],[\"如果心跳超时节点会自发成为协调者\",{\"1\":{\"133\":1}}],[\"如果任期相同\",{\"1\":{\"130\":1}}],[\"如果任期小则拒绝\",{\"1\":{\"129\":1}}],[\"如果两份日志最后的条目任期号相同\",{\"1\":{\"130\":1}}],[\"如果两份日志最后的条目的任期号不同\",{\"1\":{\"130\":1}}],[\"如果两个插入操作的origin一致\",{\"1\":{\"43\":1}}],[\"如果同步失败了\",{\"1\":{\"129\":1,\"134\":1}}],[\"如果同步成功则更新该节点的\",{\"1\":{\"129\":1}}],[\"如果集群发生了领导者更换\",{\"1\":{\"129\":1}}],[\"如果收到的报文的长度\",{\"1\":{\"285\":1}}],[\"如果收到\",{\"1\":{\"129\":1}}],[\"如果你之前有其它汇编语言的基本\",{\"1\":{\"248\":1}}],[\"如果你还一知半解\",{\"1\":{\"192\":1}}],[\"如果你已经熟稔于心可以直接选择跳过\",{\"1\":{\"192\":1}}],[\"如果你对\",{\"1\":{\"178\":1}}],[\"如果你的小\",{\"1\":{\"136\":1}}],[\"如果你大\",{\"1\":{\"129\":1,\"133\":1}}],[\"如果你能迅速回答出这几个问题\",{\"1\":{\"56\":1}}],[\"如果超过了默认重试次数\",{\"1\":{\"285\":1}}],[\"如果超过了重试次数\",{\"1\":{\"285\":1}}],[\"如果超过了窗口阈值\",{\"1\":{\"283\":1}}],[\"如果超过了\",{\"1\":{\"282\":1}}],[\"如果超过了半数\",{\"1\":{\"124\":1}}],[\"如果超过了最大数量\",{\"1\":{\"63\":1}}],[\"如果事务\",{\"1\":{\"88\":1}}],[\"如果发生了超时那么重新发送报文\",{\"1\":{\"284\":1}}],[\"如果发生问题\",{\"1\":{\"85\":1}}],[\"如果发现回复者任期大\",{\"1\":{\"124\":1}}],[\"如果发现一个键被标记为删除状态\",{\"1\":{\"4\":1}}],[\"如果子节点是\",{\"1\":{\"73\":1}}],[\"如果节点之间有数据重合\",{\"1\":{\"282\":1}}],[\"如果节点安全\",{\"1\":{\"73\":1}}],[\"如果节点与兄弟节点加起来大于\",{\"1\":{\"72\":1}}],[\"如果节点\",{\"1\":{\"72\":3}}],[\"如果当前的状态不为\",{\"1\":{\"124\":1,\"136\":1}}],[\"如果当前节点未投过票\",{\"1\":{\"124\":1}}],[\"如果当前节点还未收到来自领导者的心跳请求\",{\"1\":{\"124\":1}}],[\"如果当前树不为空\",{\"1\":{\"71\":1}}],[\"如果当前仍是空树\",{\"1\":{\"71\":1}}],[\"如果当前存在事务\",{\"1\":{\"4\":3}}],[\"如果根不是叶节点\",{\"1\":{\"68\":1}}],[\"如果是第一次填充\",{\"1\":{\"284\":1}}],[\"如果是小对象\",{\"1\":{\"241\":1}}],[\"如果是则将其包装为\",{\"1\":{\"225\":1}}],[\"如果是额外进行一些信号处理工作\",{\"1\":{\"200\":1}}],[\"如果是核心类库\",{\"1\":{\"165\":1}}],[\"如果是需求多变的业务代码\",{\"1\":{\"165\":1}}],[\"如果是状态测试\",{\"1\":{\"164\":1}}],[\"如果是状态验证\",{\"1\":{\"164\":1}}],[\"如果是可重复读\",{\"1\":{\"88\":1}}],[\"如果是读未提交\",{\"1\":{\"88\":1}}],[\"如果是查询\",{\"1\":{\"73\":1}}],[\"如果是删除操作\",{\"1\":{\"73\":2}}],[\"如果是插入操作\",{\"1\":{\"73\":1}}],[\"如果是真实环境\",{\"1\":{\"73\":1}}],[\"如果是根节点\",{\"1\":{\"72\":1}}],[\"如果是根节点不必满足半满这个条件\",{\"1\":{\"68\":1}}],[\"如果是一棵空树\",{\"1\":{\"72\":1}}],[\"如果是\",{\"1\":{\"51\":2,\"200\":1,\"203\":1,\"243\":1}}],[\"如果item的\",{\"1\":{\"50\":1}}],[\"如果item已经被集成到文档树中\",{\"1\":{\"26\":1}}],[\"如果不等直接\",{\"1\":{\"254\":1}}],[\"如果不为\",{\"1\":{\"225\":1}}],[\"如果不足两个\",{\"1\":{\"218\":1}}],[\"如果不再是领导者\",{\"1\":{\"129\":1}}],[\"如果不是\",{\"1\":{\"129\":1,\"200\":1}}],[\"如果不是叶子节点\",{\"1\":{\"73\":1}}],[\"如果不安全\",{\"1\":{\"73\":1}}],[\"如果不连续则抛出异常\",{\"1\":{\"47\":1}}],[\"如果不满足\",{\"1\":{\"44\":1}}],[\"如果\",{\"1\":{\"44\":3,\"64\":7,\"72\":2,\"87\":1,\"88\":1,\"130\":2,\"136\":2,\"200\":1,\"225\":1,\"238\":1,\"282\":2,\"283\":3,\"285\":2}}],[\"如果o的clientid小于this的clientid\",{\"1\":{\"51\":1}}],[\"如果o1​与o2​相邻\",{\"1\":{\"43\":1}}],[\"如果operation的\",{\"1\":{\"28\":1}}],[\"如果多个put操作的key相同\",{\"1\":{\"28\":1}}],[\"如果counter相同\",{\"1\":{\"25\":1}}],[\"如果counter不同\",{\"1\":{\"25\":1}}],[\"如果插入意图一致\",{\"1\":{\"25\":1}}],[\"如果相等\",{\"1\":{\"17\":1,\"254\":1}}],[\"如果允许网络延迟\",{\"1\":{\"8\":1}}],[\"如果没有设置\",{\"1\":{\"261\":1}}],[\"如果没有则\",{\"1\":{\"200\":1}}],[\"如果没有则新建\",{\"1\":{\"200\":1}}],[\"如果没有则返回空\",{\"1\":{\"78\":1}}],[\"如果没有空闲页再向进程申请\",{\"1\":{\"241\":1}}],[\"如果没有空闲页\",{\"1\":{\"64\":1}}],[\"如果没有就创建一个\",{\"1\":{\"28\":1}}],[\"如果没有找到\",{\"1\":{\"4\":1}}],[\"如果没有\",{\"1\":{\"4\":1,\"285\":1}}],[\"如果没有事务\",{\"1\":{\"4\":4}}],[\"如果有则执行\",{\"1\":{\"200\":1}}],[\"如果有则调用\",{\"1\":{\"200\":1}}],[\"如果有\",{\"1\":{\"4\":1}}],[\"如果在内存中\",{\"1\":{\"231\":1}}],[\"如果在程序开始阶段\",{\"1\":{\"200\":1}}],[\"如果在发送\",{\"1\":{\"124\":1}}],[\"如果在删除的过程中\",{\"1\":{\"73\":1}}],[\"如果在重组或者合并后\",{\"1\":{\"72\":1}}],[\"如果在\",{\"1\":{\"4\":1,\"285\":1}}],[\"如果您有关于数据库的问题或需要有关存储引擎的信息\",{\"1\":{\"4\":1}}],[\"如键\",{\"1\":{\"4\":1}}],[\"请不要拘泥于细节\",{\"1\":{\"200\":1}}],[\"请求完后协程又得回收\",{\"1\":{\"264\":1}}],[\"请求完毕后就成为了垃圾数据待回收\",{\"1\":{\"260\":1}}],[\"请求来时开启协程\",{\"1\":{\"264\":1}}],[\"请求来说\",{\"1\":{\"262\":1}}],[\"请求体都很大的情况下\",{\"1\":{\"260\":1}}],[\"请求内容\",{\"1\":{\"146\":1}}],[\"请求一样\",{\"1\":{\"136\":1}}],[\"请求给追随者\",{\"1\":{\"136\":1}}],[\"请求时\",{\"1\":{\"130\":1,\"150\":1}}],[\"请求达到节点后\",{\"1\":{\"129\":1}}],[\"请求的时间\",{\"1\":{\"126\":2}}],[\"请求了\",{\"1\":{\"126\":1}}],[\"请求和处理\",{\"1\":{\"125\":1,\"132\":1,\"138\":1}}],[\"请求会被\",{\"1\":{\"124\":1}}],[\"请求参数\",{\"1\":{\"124\":1}}],[\"请求者在发送\",{\"1\":{\"130\":1}}],[\"请求者拿到响应结果后\",{\"1\":{\"124\":1}}],[\"请求者将自己的任期\",{\"1\":{\"124\":1}}],[\"请求者通过\",{\"1\":{\"124\":1}}],[\"请求者\",{\"1\":{\"124\":1}}],[\"请求者任期\",{\"1\":{\"124\":1}}],[\"请求其它节点给自己投票\",{\"1\":{\"124\":1}}],[\"请求\",{\"1\":{\"124\":8,\"126\":2,\"129\":2,\"136\":2,\"139\":1,\"239\":1}}],[\"请求成功后\",{\"1\":{\"88\":1}}],[\"请求锁\",{\"1\":{\"88\":1}}],[\"请求事务管理器获取事务\",{\"1\":{\"58\":1}}],[\"请你先尝试回答如下几个问题\",{\"1\":{\"56\":1}}],[\"请问如何改造上面的\",{\"1\":{\"4\":1}}],[\"请将完整代码给出\",{\"1\":{\"4\":1}}],[\"请将\",{\"1\":{\"4\":1}}],[\"请注意\",{\"1\":{\"4\":1}}],[\"请继续给出伪代码实现\",{\"1\":{\"4\":1}}],[\"请设计一款基于lsm树的存储引擎原型\",{\"1\":{\"4\":1}}],[\"请随时告诉我\",{\"1\":{\"4\":1}}],[\"我选择用\",{\"1\":{\"213\":1}}],[\"我可能并不会使用\",{\"1\":{\"204\":1}}],[\"我可以为您提供关于数据库和存储引擎的基本知识和一般性建议\",{\"1\":{\"4\":1}}],[\"我似乎一直很注重实现和功能完成\",{\"1\":{\"165\":1}}],[\"我想是很难的\",{\"1\":{\"165\":1}}],[\"我觉得有些重构是过度的\",{\"1\":{\"165\":1}}],[\"我成为你的追随者\",{\"1\":{\"136\":1}}],[\"我们运行它\",{\"1\":{\"294\":1}}],[\"我们下一个系列再见～\",{\"1\":{\"287\":1}}],[\"我们必须有序的组装\",{\"1\":{\"282\":1}}],[\"我们必须遍历完\",{\"1\":{\"188\":1}}],[\"我们很轻易的就建立起了\",{\"1\":{\"277\":1}}],[\"我们都能够精准感知系统已有的池化方案\",{\"1\":{\"265\":1}}],[\"我们都能直接去看源码来\",{\"1\":{\"228\":1}}],[\"我们使用\",{\"1\":{\"262\":1}}],[\"我们使用了二分查找算法来在\",{\"1\":{\"4\":1}}],[\"我们使用了列表推导式来生成\",{\"1\":{\"4\":1}}],[\"我们从一个场景出发\",{\"1\":{\"260\":1}}],[\"我们从一个简单的\",{\"1\":{\"217\":1}}],[\"我们分别介绍手动内存管理与自动内存管理的原理\",{\"1\":{\"245\":1}}],[\"我们为\",{\"1\":{\"244\":1}}],[\"我们为每个插入字符都添加一个唯一的标识符\",{\"1\":{\"25\":1}}],[\"我们调用\",{\"1\":{\"243\":1}}],[\"我们首先来谈谈\",{\"1\":{\"243\":1}}],[\"我们现在需要改造它\",{\"1\":{\"242\":1}}],[\"我们刚才实现了两个版本的\",{\"1\":{\"242\":1}}],[\"我们无法使用线程缓存\",{\"1\":{\"241\":1}}],[\"我们无需纠结这个\",{\"1\":{\"124\":1}}],[\"我们先选择一种简单的管理方式\",{\"1\":{\"240\":1}}],[\"我们先来看看\",{\"1\":{\"181\":1}}],[\"我们先来看看其精美的代码设计\",{\"1\":{\"69\":1}}],[\"我们又该如何管理了\",{\"1\":{\"239\":1}}],[\"我们发现\",{\"1\":{\"238\":1}}],[\"我们已经见识到了\",{\"1\":{\"238\":1}}],[\"我们几乎不用关注内存管理\",{\"1\":{\"238\":1}}],[\"我们了解到内存管理的最主要模块是堆内存\",{\"1\":{\"237\":1}}],[\"我们进入真正的正文部分\",{\"1\":{\"236\":1}}],[\"我们见识到了编译原理的魅力\",{\"1\":{\"228\":1}}],[\"我们完成了\",{\"1\":{\"228\":1}}],[\"我们决定在\",{\"1\":{\"227\":1}}],[\"我们新引入一个关键字\",{\"1\":{\"225\":1}}],[\"我们新增了一个判断条件\",{\"1\":{\"134\":1}}],[\"我们直接开搞\",{\"1\":{\"224\":1}}],[\"我们直接用\",{\"1\":{\"113\":1}}],[\"我们尝试运行它\",{\"1\":{\"219\":1}}],[\"我们不再通过\",{\"1\":{\"238\":1}}],[\"我们不仅需要调用\",{\"1\":{\"219\":1}}],[\"我们不能直接删除item\",{\"1\":{\"25\":1}}],[\"我们提前定义一个\",{\"1\":{\"219\":1}}],[\"我们提取出参数\",{\"1\":{\"219\":1}}],[\"我们提到\",{\"1\":{\"134\":1,\"241\":1}}],[\"我们提到是否投出选票还与日志有关\",{\"1\":{\"130\":1}}],[\"我们借助\",{\"1\":{\"219\":1}}],[\"我们实现了一个简单的优化器\",{\"1\":{\"218\":1}}],[\"我们实现了支持并发访问的\",{\"1\":{\"82\":1}}],[\"我们加入一个简单的优化器\",{\"1\":{\"218\":1}}],[\"我们的翻译代码也很简洁明了\",{\"1\":{\"218\":1}}],[\"我们的终极目标是翻译成机器码\",{\"1\":{\"218\":1}}],[\"我们的\",{\"1\":{\"218\":1}}],[\"我们的目标很明确\",{\"1\":{\"177\":1}}],[\"我们以一个\",{\"1\":{\"257\":1}}],[\"我们以\",{\"1\":{\"218\":1}}],[\"我们需引入中间代码\",{\"1\":{\"218\":1}}],[\"我们需要去使用一下该协议\",{\"1\":{\"286\":1}}],[\"我们需要及时的回复\",{\"1\":{\"285\":1}}],[\"我们需要另外的内存管理方式\",{\"1\":{\"236\":1}}],[\"我们需要在\",{\"1\":{\"227\":1}}],[\"我们需要在链接时指定程序入口为\",{\"1\":{\"217\":1}}],[\"我们需要拿到\",{\"1\":{\"219\":1}}],[\"我们需要将\",{\"1\":{\"218\":1}}],[\"我们需要详细来分析它\",{\"1\":{\"200\":1}}],[\"我们需要重构\",{\"1\":{\"136\":1}}],[\"我们需要给\",{\"1\":{\"134\":1}}],[\"我们需要优化同步冲突问题\",{\"1\":{\"134\":1}}],[\"我们需要先来解决这三个状态\",{\"1\":{\"123\":1}}],[\"我们需要一种机制来保证所有事务执行是正确的\",{\"1\":{\"86\":1}}],[\"我们需要一个管理内存与磁盘数据的中介组件\",{\"1\":{\"62\":1}}],[\"我们需要一个map来保存\",{\"1\":{\"14\":1}}],[\"我们需要删除\",{\"1\":{\"73\":1}}],[\"我们需要明确\",{\"1\":{\"68\":1}}],[\"我们需要遍历整个树\",{\"1\":{\"26\":1}}],[\"我们只接触到\",{\"1\":{\"226\":1}}],[\"我们只罗列几个简单的优化实现\",{\"1\":{\"218\":1}}],[\"我们只会实现一个简单的\",{\"1\":{\"218\":1}}],[\"我们只需关心函数是否被调用\",{\"1\":{\"164\":1}}],[\"我们只需实现一个简单的执行器就能领略到数据库执行器的风采\",{\"1\":{\"79\":1}}],[\"我们没有删掉原来的代码\",{\"1\":{\"217\":1}}],[\"我们会选择\",{\"1\":{\"217\":1}}],[\"我们知道\",{\"1\":{\"217\":1}}],[\"我们定义一个\",{\"1\":{\"243\":1}}],[\"我们定义一个简单的\",{\"1\":{\"212\":1}}],[\"我们定义通用对象结构体\",{\"1\":{\"243\":1}}],[\"我们定义了一个简单的\",{\"1\":{\"218\":1}}],[\"我们定义了\",{\"1\":{\"123\":1}}],[\"我们也可以\",{\"1\":{\"264\":1}}],[\"我们也可以在\",{\"1\":{\"210\":1}}],[\"我们也能\",{\"1\":{\"228\":1}}],[\"我们也顺利得到了正确的结果\",{\"1\":{\"219\":1}}],[\"我们也发现了一条黄金铁律\",{\"1\":{\"124\":1}}],[\"我们重新定义了\",{\"1\":{\"208\":1}}],[\"我们经常性地需要拷贝字节切片\",{\"1\":{\"207\":1}}],[\"我们挑重要的代码段说明\",{\"1\":{\"200\":1}}],[\"我们剖析的\",{\"1\":{\"200\":1}}],[\"我们正式进入\",{\"1\":{\"200\":1}}],[\"我们暂时不关注代码段\",{\"1\":{\"194\":1}}],[\"我们依次遍历\",{\"1\":{\"188\":1}}],[\"我们能够非常方便的实现\",{\"1\":{\"186\":1}}],[\"我们还需实现对应的函数来使用它们\",{\"1\":{\"181\":1}}],[\"我们每天验证其返回的数据\",{\"1\":{\"164\":1}}],[\"我们对状态结果并不关系\",{\"1\":{\"164\":1}}],[\"我们主要考虑下面两个核心思想\",{\"1\":{\"150\":1}}],[\"我们抽象一个\",{\"1\":{\"145\":1}}],[\"我们推入了一个\",{\"1\":{\"128\":1}}],[\"我们顺便也给\",{\"1\":{\"128\":1}}],[\"我们再回到\",{\"1\":{\"124\":1}}],[\"我们再来看\",{\"1\":{\"209\":1}}],[\"我们再来看看如何用\",{\"1\":{\"241\":1}}],[\"我们再来看看如何设计和实现\",{\"1\":{\"182\":1}}],[\"我们再来看看\",{\"1\":{\"46\":1}}],[\"我们再来引入一个新的问题\",{\"1\":{\"135\":1}}],[\"我们再来回答刚才提出的问题\",{\"1\":{\"124\":1}}],[\"我们关注的是\",{\"1\":{\"124\":1}}],[\"我们介绍了\",{\"1\":{\"89\":1}}],[\"我们来理一理\",{\"1\":{\"257\":1}}],[\"我们来测试一下\",{\"1\":{\"241\":1,\"244\":1}}],[\"我们来实操一下\",{\"1\":{\"237\":1}}],[\"我们来做一个性能跑分看看\",{\"1\":{\"213\":1}}],[\"我们来解决最后两个问题\",{\"1\":{\"136\":1}}],[\"我们来一起看看\",{\"1\":{\"70\":1}}],[\"我们来看看如何实现\",{\"1\":{\"243\":1}}],[\"我们来看看\",{\"1\":{\"69\":1}}],[\"我们来依次详细介绍这些模块的作用和实现\",{\"1\":{\"59\":1}}],[\"我们一起来看一下其代码结构\",{\"1\":{\"59\":1}}],[\"我们一起来看看\",{\"1\":{\"58\":1,\"280\":1}}],[\"我们就以先整体后局部的方式来详细介绍\",{\"1\":{\"279\":1}}],[\"我们就来依次看看\",{\"1\":{\"245\":1}}],[\"我们就一起来看看三色标记法\",{\"1\":{\"244\":1}}],[\"我们就通过另外一个关键字\",{\"1\":{\"226\":1}}],[\"我们就用\",{\"1\":{\"218\":1}}],[\"我们就能在程序中接管\",{\"1\":{\"238\":1}}],[\"我们就能通过调用\",{\"1\":{\"208\":1}}],[\"我们就能使用该函数了\",{\"1\":{\"207\":1}}],[\"我们就能发现\",{\"1\":{\"129\":1}}],[\"我们就能给出一个简单\",{\"1\":{\"26\":1}}],[\"我们就可以来看看map的基本操作实现了\",{\"1\":{\"29\":1}}],[\"我们将在实现部分详细介绍\",{\"1\":{\"275\":1}}],[\"我们将在后面的实现中详细介绍\",{\"1\":{\"273\":1}}],[\"我们将实现部分详细介绍\",{\"1\":{\"274\":1}}],[\"我们将谈谈如何实现自动内存管理\",{\"1\":{\"242\":1}}],[\"我们将得到的\",{\"1\":{\"219\":1}}],[\"我们将所有\",{\"1\":{\"218\":1}}],[\"我们将使用\",{\"1\":{\"200\":1}}],[\"我们将其改造为行为验证\",{\"1\":{\"164\":1}}],[\"我们将一次插入抽象为一个item\",{\"1\":{\"25\":1}}],[\"我们将深入两种\",{\"1\":{\"22\":1}}],[\"我们看一个最简单的例子\",{\"1\":{\"25\":1}}],[\"我们可以快速的使用\",{\"1\":{\"277\":1}}],[\"我们可以简单的将其分为\",{\"1\":{\"245\":1}}],[\"我们可以测试看看\",{\"1\":{\"227\":1}}],[\"我们可以测试看看解析一个\",{\"1\":{\"227\":1}}],[\"我们可以在命令行中看到生成的\",{\"1\":{\"219\":1}}],[\"我们可以在日志发送前对其判断一次\",{\"1\":{\"137\":1}}],[\"我们可以轻松得到这段代码的\",{\"1\":{\"219\":1}}],[\"我们可以设计出类似下面的\",{\"1\":{\"218\":1}}],[\"我们可以这样做\",{\"1\":{\"217\":1}}],[\"我们可以很方便地在\",{\"1\":{\"210\":1}}],[\"我们可以看到熟悉的\",{\"1\":{\"200\":1}}],[\"我们可以借助环形切片来实现\",{\"1\":{\"188\":1}}],[\"我们可以实现简单的数据过滤和映射\",{\"1\":{\"181\":1}}],[\"我们可以实现泛型来解决这个问题\",{\"1\":{\"179\":1}}],[\"我们可以参考\",{\"1\":{\"151\":1}}],[\"我们可以发现\",{\"1\":{\"64\":1,\"226\":1}}],[\"我们可以通过\",{\"1\":{\"179\":1}}],[\"我们可以通过接入spring来进一步拉低使用门槛\",{\"1\":{\"151\":1}}],[\"我们可以通过字符2\",{\"1\":{\"25\":1}}],[\"我们可以通过插入意图来解决这个问题\",{\"1\":{\"25\":1}}],[\"我们可以扩展出多个变量\",{\"1\":{\"18\":1}}],[\"我们可以按照以下步骤进行\",{\"1\":{\"4\":1}}],[\"我们测试看看效果\",{\"1\":{\"5\":1}}],[\"我们根据指定的大小拆分键值对列表\",{\"1\":{\"4\":1}}],[\"我们在\",{\"1\":{\"4\":1,\"212\":1,\"237\":1,\"282\":1}}],[\"我们引入了\",{\"1\":{\"4\":1}}],[\"我直接单刀直入\",{\"1\":{\"4\":1}}],[\"我会尽力帮助您\",{\"1\":{\"4\":1}}],[\"我是一个ai语言模型\",{\"1\":{\"4\":1}}],[\"擅长各类存储引擎\",{\"1\":{\"4\":1}}],[\"pkey\",{\"1\":{\"294\":5}}],[\"pkg\",{\"1\":{\"238\":1}}],[\"pwritev64v2\",{\"1\":{\"294\":1}}],[\"pwritev2\",{\"1\":{\"294\":1}}],[\"pwd\",{\"1\":{\"224\":1}}],[\"pwd=$\",{\"1\":{\"224\":1}}],[\"p1\",{\"1\":{\"241\":4}}],[\"p2align\",{\"1\":{\"212\":1}}],[\"p2p\",{\"1\":{\"9\":1,\"20\":1}}],[\"pp\",{\"1\":{\"200\":3}}],[\"ppt\",{\"1\":{\"3\":1}}],[\"ptregs\",{\"1\":{\"294\":1}}],[\"ptrtoself\",{\"1\":{\"208\":1}}],[\"ptrdata\",{\"1\":{\"208\":1}}],[\"ptr\",{\"1\":{\"200\":7,\"207\":7}}],[\"ptrsize\",{\"1\":{\"200\":2}}],[\"pc+2\",{\"1\":{\"254\":1}}],[\"pcquantum\",{\"1\":{\"200\":1,\"202\":1}}],[\"pc\",{\"1\":{\"200\":10,\"202\":2,\"232\":1,\"250\":2,\"254\":1}}],[\"pm\",{\"1\":{\"170\":1}}],[\"pdos\",{\"1\":{\"140\":1}}],[\"pd\",{\"0\":{\"107\":1},\"1\":{\"103\":1}}],[\"pdf\",{\"1\":{\"53\":1}}],[\"pid\",{\"1\":{\"194\":2,\"238\":4}}],[\"pika\",{\"1\":{\"115\":2,\"117\":1,\"119\":1}}],[\"pipeline\",{\"1\":{\"103\":1}}],[\"ping\",{\"1\":{\"129\":5,\"132\":1,\"136\":1,\"139\":2}}],[\"pin\",{\"1\":{\"63\":3,\"64\":20}}],[\"pb\",{\"1\":{\"102\":1}}],[\"p=741\",{\"1\":{\"90\":1}}],[\"phase\",{\"1\":{\"90\":1}}],[\"phantom\",{\"1\":{\"84\":1}}],[\"panjf2000\",{\"1\":{\"266\":1}}],[\"panic\",{\"1\":{\"136\":1,\"188\":1,\"219\":3,\"227\":1}}],[\"pairsiz\",{\"1\":{\"243\":1}}],[\"pair\",{\"1\":{\"243\":17,\"244\":1}}],[\"pair<keytype\",{\"1\":{\"69\":1}}],[\"paging\",{\"1\":{\"237\":1}}],[\"pagemap\",{\"1\":{\"241\":5}}],[\"pageheap\",{\"1\":{\"241\":6}}],[\"pagenum\",{\"1\":{\"241\":3}}],[\"pagestart\",{\"1\":{\"241\":1}}],[\"pagesize\",{\"1\":{\"241\":3}}],[\"pages\",{\"1\":{\"63\":2,\"64\":9}}],[\"page\",{\"1\":{\"59\":1,\"64\":102,\"69\":21,\"70\":12,\"71\":12,\"72\":4,\"73\":12,\"98\":1}}],[\"pack\",{\"1\":{\"217\":4}}],[\"packages\",{\"1\":{\"224\":1,\"225\":1}}],[\"package\",{\"1\":{\"200\":3,\"206\":1,\"219\":2,\"225\":3,\"227\":1,\"236\":1,\"239\":1,\"257\":2}}],[\"passage\",{\"1\":{\"285\":1}}],[\"passembly\",{\"1\":{\"257\":1}}],[\"pass\",{\"1\":{\"208\":2,\"212\":4,\"227\":1}}],[\"password\",{\"1\":{\"170\":1}}],[\"payload\",{\"1\":{\"157\":2,\"279\":3,\"283\":4,\"284\":4}}],[\"paper\",{\"1\":{\"121\":1}}],[\"paths\",{\"1\":{\"292\":1}}],[\"path=$gopath\",{\"1\":{\"225\":1,\"227\":1}}],[\"path\",{\"1\":{\"98\":1,\"293\":1}}],[\"paramtype\",{\"1\":{\"219\":2}}],[\"paramname\",{\"1\":{\"219\":2}}],[\"param\",{\"1\":{\"219\":1}}],[\"params\",{\"1\":{\"25\":1,\"174\":1,\"219\":7}}],[\"part\",{\"1\":{\"53\":1}}],[\"parentsub用来表示ymap的\",{\"1\":{\"50\":1}}],[\"parentsub\",{\"1\":{\"50\":4,\"51\":10}}],[\"parent指向父节点\",{\"1\":{\"28\":1}}],[\"parent\",{\"1\":{\"25\":2,\"26\":16,\"28\":1,\"50\":6,\"51\":11,\"69\":1,\"71\":11,\"72\":10,\"194\":1}}],[\"parseint\",{\"1\":{\"219\":1}}],[\"parsefile\",{\"1\":{\"219\":2,\"227\":1}}],[\"parseexpr\",{\"1\":{\"174\":1}}],[\"parseenvironments\",{\"1\":{\"172\":1}}],[\"parser\",{\"1\":{\"174\":4,\"219\":5,\"225\":4,\"227\":7}}],[\"parsemappers\",{\"1\":{\"172\":1}}],[\"parse方法被调用\",{\"1\":{\"164\":1}}],[\"parsedebugvars\",{\"1\":{\"200\":1}}],[\"parsed\",{\"1\":{\"164\":3}}],[\"parse函数是否被调用\",{\"1\":{\"164\":1}}],[\"parseobject\",{\"1\":{\"147\":1}}],[\"parse\",{\"1\":{\"18\":1,\"164\":9,\"172\":5,\"173\":1}}],[\"platforms\",{\"1\":{\"263\":1}}],[\"plan9\",{\"1\":{\"192\":1,\"200\":1,\"212\":5,\"248\":5,\"250\":3,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1,\"257\":2,\"258\":1}}],[\"plantype\",{\"1\":{\"79\":2}}],[\"plan\",{\"1\":{\"58\":1,\"78\":4,\"79\":9,\"89\":5,\"119\":1}}],[\"placeholder\",{\"1\":{\"188\":1}}],[\"placeholdertype\",{\"1\":{\"188\":1}}],[\"place\",{\"1\":{\"47\":1}}],[\"pedro\",{\"1\":{\"164\":2,\"207\":3,\"224\":1,\"286\":23}}],[\"pedrogao\",{\"1\":{\"119\":1,\"161\":1,\"174\":1,\"290\":1}}],[\"peek\",{\"1\":{\"98\":2,\"158\":1,\"281\":7}}],[\"peerid\",{\"1\":{\"124\":5,\"129\":16,\"130\":1,\"133\":3,\"134\":7,\"136\":9,\"137\":2}}],[\"peerstate\",{\"1\":{\"123\":5,\"126\":1}}],[\"peers\",{\"1\":{\"123\":2,\"124\":7,\"129\":3,\"131\":1,\"133\":1,\"136\":3}}],[\"peer\",{\"1\":{\"39\":2,\"41\":4,\"53\":2,\"129\":1,\"136\":2,\"285\":3,\"286\":1}}],[\"permanently\",{\"1\":{\"285\":1}}],[\"performance\",{\"1\":{\"266\":1}}],[\"per\",{\"1\":{\"200\":2}}],[\"persistconn\",{\"1\":{\"263\":1}}],[\"persiststateandsnapshot\",{\"1\":{\"136\":2}}],[\"persist\",{\"1\":{\"133\":15,\"136\":3}}],[\"persisted\",{\"1\":{\"131\":1,\"133\":2}}],[\"persister\",{\"1\":{\"123\":2,\"124\":5,\"131\":3,\"133\":4,\"136\":4}}],[\"persistent\",{\"1\":{\"93\":3}}],[\"peritext\",{\"1\":{\"39\":1}}],[\"port\",{\"1\":{\"293\":1}}],[\"poninter\",{\"1\":{\"250\":1}}],[\"poll\",{\"1\":{\"98\":2,\"158\":1}}],[\"poolconn\",{\"1\":{\"263\":2}}],[\"pooled\",{\"1\":{\"170\":1}}],[\"pools\",{\"1\":{\"65\":1}}],[\"pool\",{\"0\":{\"259\":1,\"261\":1,\"268\":1},\"1\":{\"58\":1,\"64\":2,\"65\":1,\"69\":1,\"70\":2,\"71\":2,\"94\":3,\"260\":2,\"261\":19,\"262\":14,\"263\":2,\"264\":6,\"266\":4,\"268\":4}}],[\"pointer\",{\"1\":{\"198\":3,\"200\":4,\"202\":2,\"203\":4,\"207\":9,\"208\":4,\"218\":2,\"238\":1,\"240\":7,\"241\":3,\"243\":3,\"244\":1,\"250\":2,\"262\":1}}],[\"pointers\",{\"1\":{\"181\":1,\"241\":4}}],[\"points\",{\"1\":{\"51\":1}}],[\"point\",{\"1\":{\"51\":1}}],[\"possible\",{\"1\":{\"291\":1,\"294\":6}}],[\"posts\",{\"0\":{\"297\":1}}],[\"post\",{\"1\":{\"215\":1,\"227\":2,\"295\":1}}],[\"postgresql\",{\"1\":{\"56\":1,\"67\":1,\"84\":1}}],[\"pos++\",{\"1\":{\"34\":1}}],[\"position+1\",{\"1\":{\"44\":1}}],[\"position\",{\"1\":{\"34\":1}}],[\"pos\",{\"1\":{\"26\":7,\"27\":4,\"34\":3,\"47\":6,\"48\":4,\"225\":17,\"227\":9}}],[\"popq\",{\"1\":{\"200\":2,\"251\":4}}],[\"pop\",{\"1\":{\"4\":2,\"63\":1,\"64\":2,\"218\":27,\"241\":1,\"243\":4,\"244\":2,\"251\":1,\"281\":7,\"284\":1,\"285\":1}}],[\"pure\",{\"1\":{\"212\":1}}],[\"pulsar\",{\"1\":{\"152\":2,\"153\":1}}],[\"publishes\",{\"1\":{\"200\":1}}],[\"public\",{\"1\":{\"13\":7,\"14\":6,\"16\":6,\"17\":4,\"18\":6,\"26\":4,\"47\":3,\"48\":1,\"50\":4,\"51\":1,\"63\":2,\"64\":1,\"69\":2,\"78\":1,\"79\":4,\"93\":1,\"94\":1,\"144\":4,\"145\":4,\"146\":3,\"147\":4,\"149\":3,\"155\":1,\"157\":2,\"158\":1,\"164\":7,\"170\":9,\"172\":4,\"173\":2,\"174\":3}}],[\"pub\",{\"1\":{\"103\":1,\"291\":1}}],[\"pushpair\",{\"1\":{\"243\":3}}],[\"pushint\",{\"1\":{\"243\":5,\"244\":2}}],[\"pushssa\",{\"1\":{\"218\":30}}],[\"pushq\",{\"1\":{\"200\":3,\"212\":1,\"213\":1,\"251\":4}}],[\"push\",{\"1\":{\"13\":2,\"16\":1,\"18\":1,\"26\":6,\"63\":1,\"64\":1,\"157\":1,\"158\":1,\"218\":28,\"243\":3,\"251\":1,\"282\":2,\"283\":2,\"284\":1,\"285\":3}}],[\"putbuffer\",{\"1\":{\"262\":3}}],[\"put\",{\"0\":{\"31\":1,\"37\":1},\"1\":{\"4\":11,\"5\":31,\"27\":2,\"28\":1,\"31\":2,\"37\":3,\"261\":3,\"262\":2,\"268\":1}}],[\"python\",{\"1\":{\"218\":7,\"221\":1,\"233\":1}}],[\"py\",{\"1\":{\"5\":1,\"212\":2,\"218\":5}}],[\"p\",{\"1\":{\"5\":1,\"64\":2,\"90\":1,\"164\":4,\"199\":11,\"200\":32,\"217\":2,\"225\":7,\"227\":11,\"240\":5,\"241\":5,\"243\":3,\"244\":3,\"262\":2,\"264\":2,\"266\":1,\"268\":1,\"277\":1,\"295\":3}}],[\"prctl\",{\"1\":{\"198\":9}}],[\"practice\",{\"1\":{\"161\":1}}],[\"preadv64v2\",{\"1\":{\"294\":1}}],[\"preadv2\",{\"1\":{\"294\":1}}],[\"pre\",{\"1\":{\"293\":1}}],[\"prefix=$crosstool\",{\"1\":{\"292\":1}}],[\"prefix\",{\"1\":{\"281\":1,\"293\":1}}],[\"prepend\",{\"1\":{\"227\":1}}],[\"preparestatement\",{\"1\":{\"174\":1}}],[\"preparedstatement\",{\"1\":{\"174\":1}}],[\"prepare\",{\"1\":{\"78\":1}}],[\"preempt\",{\"1\":{\"200\":2}}],[\"preemption\",{\"1\":{\"200\":1}}],[\"present2\",{\"1\":{\"164\":1}}],[\"present\",{\"1\":{\"164\":1,\"294\":8}}],[\"prelogterm\",{\"1\":{\"126\":1}}],[\"prelogindex\",{\"1\":{\"126\":1}}],[\"prevent\",{\"1\":{\"263\":1}}],[\"prevsz\",{\"1\":{\"240\":2}}],[\"prevlogterm\",{\"1\":{\"126\":1,\"129\":5,\"134\":1,\"137\":1}}],[\"prevlogindex\",{\"1\":{\"126\":1,\"129\":9,\"134\":4,\"136\":3,\"137\":5}}],[\"previous\",{\"1\":{\"47\":1,\"48\":1,\"114\":1,\"200\":1,\"202\":1}}],[\"predicatefunc\",{\"1\":{\"185\":2,\"189\":1}}],[\"predicate\",{\"1\":{\"79\":7,\"89\":2}}],[\"pred指向firstop\",{\"1\":{\"36\":1}}],[\"pred指向最后一个operation\",{\"1\":{\"31\":1}}],[\"pred\",{\"1\":{\"28\":2,\"31\":2,\"32\":1,\"36\":3,\"37\":3}}],[\"private|syscall\",{\"1\":{\"218\":1}}],[\"private\",{\"1\":{\"26\":2,\"47\":1,\"48\":1,\"63\":1,\"69\":1,\"79\":2,\"149\":1,\"150\":1,\"164\":1,\"174\":3,\"238\":1,\"282\":1,\"284\":1,\"285\":1}}],[\"print0\",{\"1\":{\"291\":1,\"294\":1}}],[\"printmemusage\",{\"1\":{\"238\":9}}],[\"printf\",{\"1\":{\"197\":1,\"218\":1,\"219\":14,\"234\":1,\"238\":6,\"241\":3,\"243\":1,\"268\":3,\"294\":1}}],[\"println\",{\"1\":{\"181\":1,\"190\":1,\"200\":2,\"210\":2,\"217\":3,\"218\":1,\"219\":7,\"225\":1,\"227\":5,\"237\":1}}],[\"print\",{\"1\":{\"5\":3,\"197\":1,\"219\":1}}],[\"providing\",{\"1\":{\"236\":1,\"239\":1}}],[\"provides\",{\"1\":{\"200\":1}}],[\"proc\",{\"1\":{\"202\":1,\"291\":5}}],[\"procresize\",{\"1\":{\"200\":2}}],[\"procs\",{\"1\":{\"200\":3}}],[\"processing\",{\"1\":{\"268\":1}}],[\"processrequest\",{\"1\":{\"268\":3}}],[\"process\",{\"1\":{\"238\":4,\"294\":4}}],[\"processor\",{\"1\":{\"199\":1}}],[\"procedure\",{\"1\":{\"142\":1}}],[\"programming\",{\"1\":{\"215\":1}}],[\"program\",{\"1\":{\"200\":1,\"291\":1}}],[\"produce\",{\"1\":{\"157\":1}}],[\"producemessageresponse\",{\"1\":{\"157\":5}}],[\"producemessagerequest\",{\"1\":{\"157\":3}}],[\"producemessage\",{\"1\":{\"157\":2}}],[\"producer\",{\"1\":{\"153\":2,\"159\":2}}],[\"product\",{\"1\":{\"0\":1}}],[\"prot\",{\"1\":{\"218\":3,\"237\":1,\"238\":2,\"294\":1}}],[\"protects\",{\"1\":{\"263\":1}}],[\"protector\",{\"1\":{\"212\":1}}],[\"protected\",{\"1\":{\"64\":1,\"79\":1,\"146\":2}}],[\"protobuf\",{\"1\":{\"147\":1,\"157\":1}}],[\"protocol\",{\"1\":{\"146\":1}}],[\"proxy\",{\"1\":{\"103\":1,\"104\":4,\"105\":5,\"106\":1,\"110\":1,\"111\":3,\"113\":1,\"119\":1,\"144\":1}}],[\"project\",{\"1\":{\"65\":1,\"75\":1,\"80\":1,\"90\":1,\"95\":1,\"295\":1}}],[\"proposed\",{\"1\":{\"291\":2}}],[\"prop就是map中的某个key\",{\"1\":{\"28\":1}}],[\"prop字段略微有点特殊\",{\"1\":{\"28\":1}}],[\"property\",{\"1\":{\"28\":1}}],[\"prop\",{\"1\":{\"28\":3,\"30\":7,\"31\":4,\"32\":3,\"36\":3,\"37\":2}}],[\"prompt\",{\"1\":{\"6\":1,\"293\":1}}],[\"而使宿主机资源不够\",{\"1\":{\"294\":1}}],[\"而输出流没有结束时\",{\"1\":{\"285\":1}}],[\"而修复方法也很简单\",{\"1\":{\"262\":1}}],[\"而下面是\",{\"1\":{\"257\":1}}],[\"而下面的两种情况是允许的\",{\"1\":{\"43\":1}}],[\"而第二个是\",{\"1\":{\"255\":1}}],[\"而那些既不在栈中\",{\"1\":{\"243\":1}}],[\"而图的搜索需要一个起点\",{\"1\":{\"243\":1}}],[\"而无法发挥线程缓存的作用\",{\"1\":{\"241\":1}}],[\"而无需为每种类型都写一个\",{\"1\":{\"179\":1}}],[\"而无需与其它节点协商\",{\"1\":{\"9\":1}}],[\"而块的头部\",{\"1\":{\"240\":1}}],[\"而此时\",{\"1\":{\"240\":1}}],[\"而此时程序仍然运行\",{\"1\":{\"238\":1}}],[\"而真实的场景远比这复杂\",{\"1\":{\"238\":1}}],[\"而进程地址空间\",{\"1\":{\"237\":1}}],[\"而人的精力总是有限的\",{\"1\":{\"234\":1}}],[\"而它们的管理方式可以分为两大类\",{\"1\":{\"233\":1}}],[\"而剩下的堆区则是程序内存管理的最主要战场了\",{\"1\":{\"232\":1}}],[\"而内存分配显然是一个很棘手的问题\",{\"1\":{\"237\":1}}],[\"而内存\",{\"1\":{\"231\":1}}],[\"而磁盘存储被用来保存大量数据\",{\"1\":{\"231\":1}}],[\"而到\",{\"1\":{\"225\":1}}],[\"而指令数量直接影响到了程序执行效率\",{\"1\":{\"218\":1}}],[\"而汇编是目前对机器码最好的解释码\",{\"1\":{\"218\":1}}],[\"而即时编译会在程序运行时\",{\"1\":{\"218\":1}}],[\"而最近一段时间\",{\"1\":{\"216\":1}}],[\"而二者之间的语法差异其实是比较大的\",{\"1\":{\"212\":1}}],[\"而用户态权限受限\",{\"1\":{\"196\":1}}],[\"而线程则与其它线程共享进程的资源和地址空间\",{\"1\":{\"199\":1}}],[\"而线程则共享其地址空间与资源\",{\"1\":{\"194\":1}}],[\"而线程必须得与进程共享地址空间和资源\",{\"1\":{\"194\":1}}],[\"而栈相对较小\",{\"1\":{\"194\":1}}],[\"而非\",{\"1\":{\"279\":1}}],[\"而非主线程则共享主线程的地址空间和资源\",{\"1\":{\"194\":1}}],[\"而非关注代码\",{\"1\":{\"162\":1}}],[\"而当程序使用内存时\",{\"1\":{\"237\":1}}],[\"而当进程陷入内核时\",{\"1\":{\"194\":1}}],[\"而当前事务还未提交\",{\"1\":{\"85\":1}}],[\"而如果定义数组和字符串\",{\"1\":{\"255\":1}}],[\"而如果是\",{\"1\":{\"243\":1}}],[\"而如果是删除\",{\"1\":{\"73\":1}}],[\"而如果在磁盘中\",{\"1\":{\"231\":1}}],[\"而如果需要再支持一个新类型\",{\"1\":{\"179\":1}}],[\"而t并不是一个固定的类型\",{\"1\":{\"179\":1}}],[\"而经典学派是没有架构设计\",{\"1\":{\"164\":1}}],[\"而对于foreach\",{\"1\":{\"189\":1}}],[\"而对于模块内怎么实现\",{\"1\":{\"164\":1}}],[\"而对于行为验证而言\",{\"1\":{\"164\":1}}],[\"而对于死锁检测\",{\"1\":{\"88\":1}}],[\"而只能验证功能是否按照某种方式实现\",{\"1\":{\"164\":1}}],[\"而从头撸一遍\",{\"1\":{\"139\":1}}],[\"而上层应用不知道\",{\"1\":{\"136\":1}}],[\"而任期代表着话语权\",{\"1\":{\"136\":1}}],[\"而追随者只需回复自己的任期即可\",{\"1\":{\"136\":1}}],[\"而一旦日志\",{\"1\":{\"127\":1}}],[\"而沟通的方式是\",{\"1\":{\"124\":1}}],[\"而不是由工程师手动判断\",{\"1\":{\"225\":1}}],[\"而不是这个函数返回的结果\",{\"1\":{\"164\":1}}],[\"而不是通过协商来保证最终一致性\",{\"1\":{\"10\":1}}],[\"而不可重读等问题实际上出现的并不多\",{\"1\":{\"84\":1}}],[\"而串行化能够解决它们\",{\"1\":{\"84\":1}}],[\"而执行器的作用就是按照查询计划来执行查询操作\",{\"1\":{\"77\":1}}],[\"而且寄存器的使用也与\",{\"1\":{\"257\":1}}],[\"而且黑色\",{\"1\":{\"244\":1}}],[\"而且必须\",{\"1\":{\"244\":1}}],[\"而且阈值也会随着运行情况而改变\",{\"1\":{\"243\":1}}],[\"而且十分的经典\",{\"1\":{\"242\":1}}],[\"而且这些页是连续的\",{\"1\":{\"241\":1}}],[\"而且没有触发任何\",{\"1\":{\"238\":1}}],[\"而且它的原理很简单\",{\"1\":{\"238\":1}}],[\"而且用途更多\",{\"1\":{\"237\":1}}],[\"而且很多时候\",{\"1\":{\"234\":1}}],[\"而且是一个完全自举的编译器实现\",{\"1\":{\"219\":1}}],[\"而且带来的很大的性能提升\",{\"1\":{\"214\":1}}],[\"而且通过了测试\",{\"1\":{\"213\":1}}],[\"而且\",{\"1\":{\"212\":1}}],[\"而且在堆里面\",{\"1\":{\"194\":1}}],[\"而且还保留了这些数据类型的特征\",{\"1\":{\"117\":1}}],[\"而且执行\",{\"1\":{\"89\":1}}],[\"而且锁的粒度可能很大\",{\"1\":{\"73\":1}}],[\"而且有着良好的生态\",{\"1\":{\"41\":1}}],[\"而叶子结点的值类型与\",{\"1\":{\"69\":1}}],[\"而已\",{\"1\":{\"64\":1}}],[\"而这两个工具本身都是在调用\",{\"1\":{\"277\":1}}],[\"而这些细节有时候又很重要\",{\"1\":{\"242\":1}}],[\"而这些函数除了数据类型不同\",{\"1\":{\"179\":1}}],[\"而这个暂停就是上文谈到的\",{\"1\":{\"238\":1}}],[\"而这个内存是可以直接读写的\",{\"1\":{\"237\":1}}],[\"而这个\",{\"1\":{\"237\":1}}],[\"而这个接口由\",{\"1\":{\"157\":1}}],[\"而这段内存是不受\",{\"1\":{\"210\":1}}],[\"而这\",{\"1\":{\"199\":1}}],[\"而这恰好也是本文主题\",{\"1\":{\"56\":1}}],[\"而这一版的实现\",{\"1\":{\"48\":1}}],[\"而恰好也有这么一门课程\",{\"1\":{\"56\":1}}],[\"而生效的是a\",{\"1\":{\"50\":1}}],[\"而言\",{\"1\":{\"50\":1,\"237\":1}}],[\"而insert函数有了些许变化\",{\"1\":{\"48\":1}}],[\"而index也是动态变化的\",{\"1\":{\"33\":1}}],[\"而origin连线只会一直指向操作创建时的左边字符\",{\"1\":{\"43\":1}}],[\"而prop实际就是firstop\",{\"1\":{\"37\":1}}],[\"而delete略有不同\",{\"1\":{\"28\":1}}],[\"而是移动到\",{\"1\":{\"262\":1}}],[\"而是选择了\",{\"1\":{\"248\":1}}],[\"而是由\",{\"1\":{\"243\":1}}],[\"而是对象之间的相互引用\",{\"1\":{\"243\":1}}],[\"而是按照页的首地址算出来的\",{\"1\":{\"241\":1}}],[\"而是最小化\",{\"1\":{\"217\":1}}],[\"而是用虽然少见但有效的方式去解决\",{\"1\":{\"214\":1}}],[\"而是使用\",{\"1\":{\"212\":1,\"238\":1}}],[\"而是被\",{\"1\":{\"200\":1}}],[\"而是再次判断本地队列和全局队列\",{\"1\":{\"200\":1}}],[\"而是转移到\",{\"1\":{\"200\":1}}],[\"而是在汇编层面上去理解系统调用\",{\"1\":{\"197\":1}}],[\"而是在完成功能的前提下演进而来的\",{\"1\":{\"164\":1}}],[\"而是彼此组合\",{\"1\":{\"184\":1}}],[\"而是可以直接给出分层代码\",{\"1\":{\"164\":1}}],[\"而是通过\",{\"1\":{\"164\":1}}],[\"而是需要严格的测试和验证来保证自己的正确性\",{\"1\":{\"165\":1}}],[\"而是需要验证返回值\",{\"1\":{\"164\":1}}],[\"而是需要进行转换操作\",{\"1\":{\"113\":1}}],[\"而是慢慢测试迭代\",{\"1\":{\"164\":1}}],[\"而是一种更加高级的抽象\",{\"1\":{\"219\":1}}],[\"而是一种功能迭代模式\",{\"1\":{\"164\":1}}],[\"而是一个处理结果\",{\"1\":{\"185\":1}}],[\"而是一个整数向量n\",{\"1\":{\"10\":1}}],[\"而是直接通过缓存拿到\",{\"1\":{\"241\":1}}],[\"而是直接按照页来分配\",{\"1\":{\"241\":1}}],[\"而是直接从\",{\"1\":{\"217\":1}}],[\"而是直接新增了一个\",{\"1\":{\"217\":1}}],[\"而是直接看代码\",{\"1\":{\"200\":1}}],[\"而是直接在调用时指定泛型参数的类型即可\",{\"1\":{\"181\":1}}],[\"而是直接在\",{\"1\":{\"153\":1}}],[\"而是直接使用成品\",{\"1\":{\"139\":1}}],[\"而是将\",{\"1\":{\"212\":1}}],[\"而是将其包装为了\",{\"1\":{\"136\":1}}],[\"而是将最后一个operation的succ指向新的lamport\",{\"1\":{\"32\":1}}],[\"而是\",{\"1\":{\"136\":1}}],[\"而是追随者主动告诉领导者冲突的日志序号和任期\",{\"1\":{\"134\":1}}],[\"而是拿出一个值来试探\",{\"1\":{\"129\":1}}],[\"而是参考了\",{\"1\":{\"117\":1}}],[\"而是希望通过剖许\",{\"1\":{\"56\":1}}],[\"而是content中未删除的item的下标\",{\"1\":{\"47\":1}}],[\"而是统一存储在doc中的content列表\",{\"1\":{\"47\":1}}],[\"而是给出规则\",{\"1\":{\"43\":1}}],[\"而是引入墓碑机制\",{\"1\":{\"25\":1}}],[\"而产生不一致的原因是\",{\"1\":{\"25\":1}}],[\"而同步时\",{\"1\":{\"10\":2}}],[\"而双方之所以能够丝滑的达成一致\",{\"1\":{\"9\":1}}],[\"而\",{\"1\":{\"8\":1,\"10\":3,\"19\":1,\"35\":1,\"64\":2,\"69\":1,\"73\":2,\"84\":1,\"87\":1,\"113\":2,\"114\":1,\"116\":1,\"117\":1,\"127\":1,\"133\":2,\"136\":2,\"168\":1,\"179\":1,\"180\":1,\"188\":1,\"189\":1,\"206\":1,\"226\":1,\"228\":1,\"231\":1,\"232\":1,\"243\":1,\"255\":1,\"260\":1,\"278\":1,\"284\":1,\"285\":1,\"294\":1}}],[\"而在说明具体实现时\",{\"1\":{\"280\":1}}],[\"而在真实的场景中\",{\"1\":{\"238\":1}}],[\"而在最后的一行输出中\",{\"1\":{\"238\":1}}],[\"而在整个设计\",{\"1\":{\"190\":1}}],[\"而在整个责任链路中\",{\"1\":{\"149\":1}}],[\"而在重组\",{\"1\":{\"73\":1}}],[\"而在\",{\"1\":{\"8\":1,\"177\":1,\"179\":1,\"200\":1,\"219\":1}}],[\"而文心一言的解释更加适合做\",{\"1\":{\"3\":1}}],[\"而忽视了从起点出发前\",{\"1\":{\"0\":1}}],[\"综合来看\",{\"1\":{\"3\":1}}],[\"一一对应\",{\"1\":{\"283\":1}}],[\"一直失败\",{\"1\":{\"257\":1}}],[\"一直以来我们都在享受\",{\"1\":{\"192\":1}}],[\"一群固执老古董们\",{\"1\":{\"248\":1}}],[\"一次\",{\"1\":{\"262\":1}}],[\"一次性的扫描就可以通过栈来分为多次\",{\"1\":{\"244\":1}}],[\"一次编译\",{\"1\":{\"218\":1}}],[\"一\",{\"1\":{\"243\":1}}],[\"一段时间后\",{\"1\":{\"240\":1}}],[\"一些\",{\"1\":{\"234\":1}}],[\"一门语言的语法翻译也不是一件易事\",{\"1\":{\"219\":1}}],[\"一般遇到这种内存大量开辟且迅速消亡的场景\",{\"1\":{\"260\":1}}],[\"一般都是\",{\"1\":{\"255\":1}}],[\"一般都是被动触发的\",{\"1\":{\"243\":1}}],[\"一般用来申明全局函数和变量\",{\"1\":{\"250\":1}}],[\"一般用于设置线程局部变量\",{\"1\":{\"198\":1}}],[\"一般称为\",{\"1\":{\"250\":1}}],[\"一般分为内核态和用户态两个运行态\",{\"1\":{\"196\":1}}],[\"一千个读者就有一千个哈姆雷特\",{\"1\":{\"168\":1}}],[\"一定要加上\",{\"1\":{\"294\":1}}],[\"一定程度上\",{\"1\":{\"223\":1}}],[\"一定程度上补偿了这种损耗\",{\"1\":{\"218\":1}}],[\"一定会依赖\",{\"1\":{\"164\":1}}],[\"一定记得\",{\"1\":{\"64\":1}}],[\"一头扎进去难免一叶障目\",{\"1\":{\"152\":1}}],[\"一类是\",{\"1\":{\"113\":1}}],[\"一步步将语言向下演化\",{\"1\":{\"227\":1}}],[\"一步步推出架构\",{\"1\":{\"164\":1}}],[\"一步步学习先进的设计理念并付诸行动\",{\"1\":{\"96\":1}}],[\"一步一步推导演进持久化磁盘队列的设计与实现\",{\"1\":{\"96\":1}}],[\"一下\",{\"1\":{\"70\":1}}],[\"一颗\",{\"1\":{\"68\":2}}],[\"一旦将报文推入\",{\"1\":{\"284\":1}}],[\"一旦超时\",{\"1\":{\"284\":1}}],[\"一旦确定\",{\"1\":{\"179\":1}}],[\"一旦发现\",{\"1\":{\"131\":2}}],[\"一旦发现当前状态不为\",{\"1\":{\"129\":1}}],[\"一旦发现任期大的节点\",{\"1\":{\"124\":1}}],[\"一旦当选\",{\"1\":{\"125\":1}}],[\"一旦领导者出现了宕机\",{\"1\":{\"125\":1}}],[\"一旦计算机故障就容易引起运行其内的数据库丢失数据\",{\"1\":{\"92\":1}}],[\"一旦你调用了\",{\"1\":{\"64\":1}}],[\"一旦\",{\"1\":{\"64\":1,\"284\":1}}],[\"一经删除后\",{\"1\":{\"63\":1}}],[\"一致性和持久性\",{\"1\":{\"92\":1}}],[\"一致性\",{\"1\":{\"83\":1}}],[\"一致性等\",{\"1\":{\"58\":1}}],[\"一致\",{\"1\":{\"51\":1,\"131\":1,\"136\":1}}],[\"一样了\",{\"1\":{\"105\":1}}],[\"一样访问每个\",{\"1\":{\"105\":1}}],[\"一样\",{\"1\":{\"18\":1,\"129\":1}}],[\"一个是正常的\",{\"1\":{\"283\":1}}],[\"一个输入流\",{\"1\":{\"279\":1}}],[\"一个输出流\",{\"1\":{\"275\":1,\"279\":1}}],[\"一个简单版的三色标记算法就被实现出来了\",{\"1\":{\"244\":1}}],[\"一个简单的字节码样例大致如下\",{\"1\":{\"218\":1}}],[\"一个简单的服务注册结构图如下\",{\"1\":{\"148\":1}}],[\"一个简单的\",{\"1\":{\"13\":1,\"218\":1,\"243\":1}}],[\"一个程序长时间暂停服务肯定是不被允许的\",{\"1\":{\"244\":1}}],[\"一个块返回\",{\"1\":{\"241\":1}}],[\"一个高素质的工程师不仅能合理完成业务需求\",{\"1\":{\"234\":1}}],[\"一个极简的\",{\"1\":{\"219\":1}}],[\"一个基于泛型的流式处理库已实现完毕\",{\"1\":{\"190\":1}}],[\"一个完整的rpc架构分为了以下几个核心组件\",{\"1\":{\"142\":1}}],[\"一个节点可以在这三种状态中切换\",{\"1\":{\"123\":1}}],[\"一个节点会存在如下\",{\"1\":{\"123\":1}}],[\"一个集群的节点个数往往是\",{\"1\":{\"122\":1}}],[\"一个集群中有且只有一个领导者\",{\"1\":{\"122\":1}}],[\"一个事务访问数据库时\",{\"1\":{\"85\":1}}],[\"一个事务执行过程中看到的数据\",{\"1\":{\"84\":1}}],[\"一个事务提交之后\",{\"1\":{\"84\":1}}],[\"一个事务还没提交\",{\"1\":{\"84\":1}}],[\"一个事务的执行不应影响其他事务的执行\",{\"1\":{\"83\":1}}],[\"一个\",{\"1\":{\"79\":1,\"89\":1,\"136\":1,\"153\":1,\"158\":2,\"160\":1,\"199\":1,\"213\":1,\"227\":1,\"261\":1,\"275\":1,\"279\":1,\"281\":1,\"282\":1}}],[\"一个具体的\",{\"1\":{\"69\":1}}],[\"一个内部节点有\",{\"1\":{\"68\":1}}],[\"一个页很快就会被用完\",{\"1\":{\"241\":1}}],[\"一个页\",{\"1\":{\"64\":1}}],[\"一个key上的value可能会被多个客户端操作\",{\"1\":{\"50\":1}}],[\"一个item属于一个abstracttype\",{\"1\":{\"50\":1}}],[\"一个列表item会包括一个或者多个operation\",{\"1\":{\"34\":1}}],[\"一个列表用于存储在事务中删除的键\",{\"1\":{\"4\":1}}],[\"一个操作数或者两个操作数\",{\"1\":{\"218\":1}}],[\"一个操作\",{\"1\":{\"14\":1}}],[\"一个字\",{\"1\":{\"4\":1}}],[\"一个字典用于存储在事务中插入或更新的键值对\",{\"1\":{\"4\":1}}],[\"一个标识符用于唯一表示该事务\",{\"1\":{\"4\":1}}],[\"一个老生常谈的话题\",{\"1\":{\"3\":1}}],[\"一大堆外行或者并没有深刻理解软件工程的从业者\",{\"1\":{\"0\":1}}],[\"什么是\",{\"0\":{\"3\":1}}],[\"lh\",{\"1\":{\"294\":1}}],[\"ln\",{\"1\":{\"291\":4}}],[\"llir\",{\"1\":{\"221\":1}}],[\"ll\",{\"1\":{\"219\":2,\"283\":2}}],[\"llvm\",{\"1\":{\"219\":7}}],[\"lbb1\",{\"1\":{\"213\":2}}],[\"lbb0\",{\"1\":{\"212\":1}}],[\"ld\",{\"1\":{\"197\":1,\"294\":1}}],[\"ls\",{\"1\":{\"291\":4,\"294\":3}}],[\"lsn\",{\"1\":{\"69\":2,\"93\":12,\"94\":1}}],[\"lsmtree\",{\"1\":{\"4\":16,\"5\":2}}],[\"lsm\",{\"0\":{\"2\":1,\"3\":1,\"4\":1},\"1\":{\"2\":1,\"3\":1,\"4\":17,\"5\":48}}],[\"lisp\",{\"1\":{\"235\":1,\"242\":1}}],[\"listen\",{\"1\":{\"285\":8,\"286\":1}}],[\"listening\",{\"1\":{\"277\":2,\"286\":1}}],[\"listexpr\",{\"1\":{\"225\":1}}],[\"lists\",{\"1\":{\"198\":1}}],[\"list<token>\",{\"1\":{\"174\":1}}],[\"list<topicinfo>\",{\"1\":{\"155\":1}}],[\"list<mappernode>\",{\"1\":{\"172\":1}}],[\"list<mapperconfig>\",{\"1\":{\"172\":1}}],[\"list<environmentconfig>\",{\"1\":{\"172\":1}}],[\"list<queueinfo>\",{\"1\":{\"155\":2}}],[\"list<brokerinfo>\",{\"1\":{\"155\":1}}],[\"list<object>\",{\"1\":{\"146\":1}}],[\"list<connectionwrapper>\",{\"1\":{\"145\":4}}],[\"list<string>\",{\"1\":{\"144\":2}}],[\"list<frame\",{\"1\":{\"63\":2,\"64\":1}}],[\"list的实现稍微复杂一点\",{\"1\":{\"33\":1}}],[\"list\",{\"0\":{\"33\":1,\"114\":1},\"1\":{\"4\":2,\"27\":2,\"28\":2,\"35\":1,\"50\":1,\"51\":1,\"63\":4,\"64\":9,\"102\":1,\"113\":1,\"114\":6,\"115\":1,\"117\":1,\"194\":1,\"200\":1,\"219\":3,\"225\":1,\"291\":2}}],[\"library\",{\"1\":{\"293\":1}}],[\"libtool\",{\"1\":{\"292\":2}}],[\"libncurses5\",{\"1\":{\"291\":1}}],[\"libsponge\",{\"1\":{\"280\":1}}],[\"lib\",{\"1\":{\"200\":2}}],[\"lingering\",{\"1\":{\"286\":1}}],[\"linger\",{\"1\":{\"285\":6}}],[\"linecomment\",{\"1\":{\"225\":1}}],[\"lines\",{\"1\":{\"47\":1}}],[\"linkid=830387\",{\"1\":{\"291\":1}}],[\"linkmode=internal\",{\"1\":{\"217\":2}}],[\"link\",{\"1\":{\"217\":4,\"243\":7,\"244\":2}}],[\"linkname来链接\",{\"1\":{\"208\":1}}],[\"linkname\",{\"1\":{\"206\":1,\"207\":2,\"208\":1}}],[\"linker\",{\"1\":{\"200\":1}}],[\"linuxjournal\",{\"1\":{\"295\":1}}],[\"linuxrc\",{\"1\":{\"291\":2}}],[\"linux\",{\"0\":{\"289\":1},\"1\":{\"193\":1,\"194\":3,\"197\":3,\"199\":2,\"200\":6,\"203\":3,\"204\":1,\"217\":11,\"218\":1,\"224\":4,\"225\":3,\"237\":1,\"247\":2,\"257\":1,\"290\":4,\"291\":8,\"292\":1,\"293\":7,\"294\":4}}],[\"limited\",{\"1\":{\"286\":2}}],[\"limit\",{\"1\":{\"77\":1,\"79\":1,\"285\":1}}],[\"launch\",{\"1\":{\"291\":1}}],[\"large\",{\"1\":{\"268\":1}}],[\"language\",{\"1\":{\"229\":1}}],[\"latest\",{\"1\":{\"225\":1}}],[\"latch\",{\"1\":{\"64\":2,\"88\":9}}],[\"laying\",{\"1\":{\"200\":1}}],[\"label\",{\"1\":{\"227\":1}}],[\"labs\",{\"1\":{\"140\":1}}],[\"labgob\",{\"1\":{\"133\":2}}],[\"labrpc\",{\"1\":{\"123\":1,\"124\":1,\"131\":1,\"133\":1,\"136\":1}}],[\"lab\",{\"1\":{\"119\":1,\"140\":1,\"224\":1,\"225\":1,\"227\":5}}],[\"lastsweetop\",{\"1\":{\"215\":1}}],[\"lastpoll\",{\"1\":{\"200\":1}}],[\"lastincludedterm\",{\"1\":{\"136\":15}}],[\"lastincludedindex+1\",{\"1\":{\"136\":2}}],[\"lastincludedindex+len\",{\"1\":{\"136\":1}}],[\"lastincludedindex\",{\"1\":{\"136\":46,\"137\":7,\"138\":2}}],[\"lastincludeterm\",{\"1\":{\"136\":1}}],[\"lastincludeindex\",{\"1\":{\"136\":5,\"137\":3}}],[\"lastindexofterm\",{\"1\":{\"134\":4}}],[\"lastlogindex\",{\"1\":{\"130\":3}}],[\"lastlogterm\",{\"1\":{\"130\":4}}],[\"lastterm\",{\"1\":{\"128\":1,\"130\":3,\"136\":1}}],[\"lastapplied++\",{\"1\":{\"131\":1}}],[\"lastapplied\",{\"1\":{\"126\":2,\"131\":12,\"136\":6}}],[\"lastreceivedfromleader\",{\"1\":{\"126\":2,\"129\":2,\"131\":1,\"136\":1,\"137\":1}}],[\"lastclock\",{\"1\":{\"26\":3,\"47\":2,\"48\":2}}],[\"last\",{\"1\":{\"15\":1,\"30\":2,\"31\":5,\"32\":3,\"34\":2,\"50\":1,\"128\":2,\"129\":4,\"130\":2,\"134\":2,\"136\":3,\"213\":1,\"283\":1,\"284\":2,\"285\":10}}],[\"lamport\",{\"1\":{\"13\":1,\"16\":1,\"20\":1,\"28\":1,\"31\":1,\"32\":2,\"35\":2,\"36\":1,\"37\":1,\"43\":1}}],[\"lwwregister\",{\"1\":{\"18\":1}}],[\"lww\",{\"0\":{\"15\":1,\"16\":1,\"17\":1,\"18\":1},\"1\":{\"11\":2,\"15\":2,\"16\":1,\"17\":1}}],[\"l\",{\"1\":{\"5\":1,\"114\":1,\"128\":18,\"129\":4,\"136\":20,\"180\":1,\"200\":2,\"217\":1,\"277\":2}}],[\"lossytcpoverudpsocketadapter\",{\"1\":{\"286\":3}}],[\"lossytcpoverudpspongesocket\",{\"1\":{\"286\":2}}],[\"love\",{\"1\":{\"236\":1,\"238\":1}}],[\"lower\",{\"1\":{\"227\":1,\"282\":4}}],[\"low\",{\"1\":{\"219\":1}}],[\"lo\",{\"1\":{\"200\":4}}],[\"load\",{\"1\":{\"172\":1,\"218\":15}}],[\"loadint32\",{\"1\":{\"124\":1}}],[\"london\",{\"1\":{\"164\":1}}],[\"long>\",{\"1\":{\"164\":1}}],[\"long\",{\"1\":{\"157\":1,\"158\":4,\"164\":1,\"194\":1,\"198\":2,\"213\":1,\"237\":2,\"282\":4,\"294\":9}}],[\"lotusdb\",{\"1\":{\"119\":1}}],[\"lotusdblabs\",{\"1\":{\"119\":1}}],[\"look\",{\"1\":{\"200\":1}}],[\"lookup\",{\"1\":{\"70\":4,\"73\":1}}],[\"loopdepth++\",{\"1\":{\"227\":1}}],[\"loopdepth\",{\"1\":{\"227\":2}}],[\"loop\",{\"1\":{\"79\":1,\"124\":1,\"125\":1,\"129\":1,\"132\":1,\"139\":1,\"227\":2}}],[\"localhost\",{\"1\":{\"277\":1}}],[\"local\",{\"1\":{\"31\":3,\"36\":3,\"37\":3,\"200\":3,\"285\":1}}],[\"lockosthread\",{\"1\":{\"200\":1}}],[\"locking\",{\"1\":{\"90\":1}}],[\"locked\",{\"1\":{\"88\":2}}],[\"lockexclusive\",{\"1\":{\"88\":1}}],[\"lockupgrade\",{\"1\":{\"88\":1}}],[\"lockmode\",{\"1\":{\"88\":1}}],[\"lockmanager\",{\"1\":{\"82\":1,\"88\":5}}],[\"lock<std\",{\"1\":{\"88\":3}}],[\"lockshared\",{\"1\":{\"88\":4}}],[\"locks\",{\"1\":{\"87\":1}}],[\"lock并指向age最后一个operation\",{\"1\":{\"32\":1}}],[\"lock\",{\"1\":{\"4\":1,\"63\":3,\"64\":6,\"88\":20,\"124\":4,\"129\":4,\"130\":2,\"131\":1,\"136\":5,\"200\":6,\"241\":2}}],[\"login\",{\"1\":{\"293\":1}}],[\"logic\",{\"1\":{\"47\":1}}],[\"logf\",{\"1\":{\"241\":1}}],[\"logfilter\",{\"1\":{\"149\":2}}],[\"loggerfactory\",{\"1\":{\"149\":1}}],[\"logger\",{\"1\":{\"149\":1}}],[\"logging\",{\"1\":{\"95\":1,\"291\":1}}],[\"logsize\",{\"1\":{\"129\":3,\"134\":1}}],[\"logentry\",{\"1\":{\"126\":1,\"128\":6,\"129\":1,\"136\":6,\"137\":1}}],[\"logrecovery\",{\"1\":{\"94\":2}}],[\"logrecord\",{\"1\":{\"93\":1,\"94\":1}}],[\"logmanager\",{\"1\":{\"64\":1,\"93\":3}}],[\"log\",{\"1\":{\"4\":1,\"6\":1,\"58\":1,\"64\":1,\"69\":1,\"93\":7,\"94\":5,\"126\":3,\"128\":3,\"129\":16,\"130\":5,\"131\":3,\"133\":11,\"134\":13,\"136\":25,\"137\":6,\"139\":1,\"144\":1,\"149\":2,\"150\":1,\"157\":2,\"238\":1,\"241\":3}}],[\"lfu\",{\"1\":{\"4\":1,\"63\":1}}],[\"lrureplacer\",{\"1\":{\"63\":9,\"64\":1}}],[\"lru\",{\"1\":{\"4\":1,\"59\":1,\"63\":10,\"64\":1,\"70\":1}}],[\"lz4\",{\"1\":{\"4\":1}}],[\"lessfunc\",{\"1\":{\"184\":1}}],[\"lexer\",{\"1\":{\"174\":1}}],[\"ledisdb\",{\"1\":{\"119\":1}}],[\"let\",{\"1\":{\"15\":1,\"26\":2,\"47\":4,\"48\":5,\"51\":4,\"268\":1}}],[\"level\",{\"1\":{\"4\":2,\"219\":1}}],[\"left开始\",{\"1\":{\"51\":1}}],[\"left会被初始化为item\",{\"1\":{\"51\":1}}],[\"left与right是操作之间的左\",{\"1\":{\"43\":1}}],[\"leftk​\",{\"1\":{\"43\":2,\"44\":1,\"48\":1}}],[\"left\",{\"1\":{\"4\":2,\"26\":1,\"44\":1,\"47\":3,\"48\":5,\"50\":5,\"51\":26,\"283\":1}}],[\"leaq\",{\"1\":{\"180\":2,\"200\":5,\"213\":2,\"217\":1,\"257\":1}}],[\"leadercommit\",{\"1\":{\"126\":2,\"129\":4}}],[\"leaderid\",{\"1\":{\"123\":3,\"124\":1,\"126\":2,\"129\":8,\"133\":3,\"136\":6,\"137\":2}}],[\"leader\",{\"1\":{\"123\":6,\"124\":2,\"126\":9,\"129\":5,\"134\":1,\"136\":5,\"139\":3,\"165\":1}}],[\"leaf\",{\"1\":{\"69\":8,\"70\":2,\"71\":8,\"72\":3}}],[\"leafpage\",{\"1\":{\"69\":7}}],[\"learnt\",{\"1\":{\"236\":1,\"238\":1}}],[\"learn\",{\"1\":{\"6\":1,\"291\":1}}],[\"least\",{\"1\":{\"4\":2,\"63\":1,\"285\":1}}],[\"lean\",{\"1\":{\"0\":1}}],[\"len=5\",{\"1\":{\"207\":2}}],[\"len=10\",{\"1\":{\"207\":4}}],[\"len=6\",{\"1\":{\"207\":2}}],[\"length\",{\"1\":{\"26\":9,\"28\":2,\"30\":1,\"34\":2,\"47\":6,\"48\":2,\"146\":7,\"237\":2,\"281\":6,\"283\":1,\"284\":3,\"285\":1}}],[\"len\",{\"1\":{\"4\":8,\"5\":5,\"30\":1,\"31\":1,\"32\":1,\"34\":1,\"37\":1,\"124\":1,\"128\":3,\"129\":3,\"133\":1,\"134\":1,\"136\":3,\"207\":3,\"208\":2,\"218\":3,\"219\":1,\"225\":2,\"262\":1,\"268\":1,\"281\":14,\"284\":3,\"294\":1}}],[\"学习资源\",{\"1\":{\"8\":1}}],[\"学习从未如此轻松\",{\"1\":{\"5\":1}}],[\"学习\",{\"0\":{\"4\":1}}],[\"学\",{\"0\":{\"2\":1}}],[\"mk\",{\"1\":{\"293\":1}}],[\"mkdir\",{\"1\":{\"291\":2,\"292\":1,\"293\":2}}],[\"mknode\",{\"1\":{\"227\":1}}],[\"mtu\",{\"1\":{\"274\":1}}],[\"mb\",{\"1\":{\"219\":4,\"231\":1}}],[\"mno\",{\"1\":{\"212\":2}}],[\"mcall\",{\"1\":{\"204\":1}}],[\"mcommoninit\",{\"1\":{\"200\":3}}],[\"m0+m\",{\"1\":{\"200\":1}}],[\"m0\",{\"1\":{\"200\":31}}],[\"ms\",{\"1\":{\"284\":2,\"285\":3}}],[\"msvc\",{\"1\":{\"228\":1}}],[\"msse4\",{\"1\":{\"212\":1}}],[\"mstartm0\",{\"1\":{\"200\":1}}],[\"mstart1\",{\"1\":{\"200\":4}}],[\"mstartfn\",{\"1\":{\"198\":1,\"200\":2,\"203\":1}}],[\"mstart\",{\"1\":{\"198\":4,\"200\":5,\"203\":4}}],[\"msg<>\",{\"1\":{\"255\":1,\"257\":2}}],[\"msg<>+8\",{\"1\":{\"255\":1}}],[\"msg<>+0x06\",{\"1\":{\"257\":1}}],[\"msg<>+0x00\",{\"1\":{\"257\":2}}],[\"msg<>+0\",{\"1\":{\"255\":1}}],[\"msg\",{\"1\":{\"131\":4,\"136\":3,\"197\":1,\"255\":1,\"257\":6}}],[\"msgs\",{\"1\":{\"131\":4}}],[\"mman\",{\"1\":{\"237\":1}}],[\"mmap\",{\"1\":{\"218\":3,\"237\":7,\"238\":7,\"247\":3}}],[\"mm\",{\"1\":{\"194\":5,\"237\":4}}],[\"mybatis\",{\"1\":{\"167\":1,\"170\":4,\"172\":1}}],[\"mysql\",{\"1\":{\"56\":1,\"67\":1,\"84\":1,\"151\":1,\"164\":1}}],[\"mv\",{\"1\":{\"227\":1,\"294\":1}}],[\"mvc\",{\"1\":{\"164\":1}}],[\"mvp\",{\"1\":{\"0\":1}}],[\"mq\",{\"1\":{\"152\":9,\"156\":1,\"157\":2,\"158\":1,\"161\":1,\"164\":1}}],[\"mprotect\",{\"1\":{\"294\":1}}],[\"mp\",{\"1\":{\"119\":1,\"191\":2,\"198\":3,\"203\":5}}],[\"mount\",{\"1\":{\"291\":2}}],[\"most\",{\"1\":{\"263\":1}}],[\"mostly\",{\"1\":{\"227\":1}}],[\"more\",{\"1\":{\"240\":2,\"285\":1,\"291\":1}}],[\"modify\",{\"1\":{\"263\":1}}],[\"mod\",{\"1\":{\"257\":1}}],[\"mod=mod\",{\"1\":{\"227\":1}}],[\"mode\",{\"1\":{\"227\":1}}],[\"model\",{\"1\":{\"78\":3}}],[\"module\",{\"1\":{\"219\":2}}],[\"modulesinit\",{\"1\":{\"200\":1}}],[\"moduledataverify\",{\"1\":{\"200\":1}}],[\"mov\",{\"1\":{\"218\":23,\"252\":4}}],[\"movb\",{\"1\":{\"212\":1,\"213\":2,\"252\":1}}],[\"movl\",{\"1\":{\"197\":6,\"200\":2,\"213\":3,\"217\":4,\"257\":2}}],[\"movsd\",{\"1\":{\"180\":5}}],[\"movq\",{\"1\":{\"180\":11,\"200\":32,\"212\":1,\"213\":1,\"217\":1,\"251\":1,\"252\":1,\"256\":3,\"257\":1}}],[\"move\",{\"1\":{\"79\":1,\"218\":1,\"281\":1,\"284\":1,\"286\":2}}],[\"movelasttofrontof\",{\"1\":{\"72\":1}}],[\"moveallto\",{\"1\":{\"72\":1}}],[\"mockito\",{\"1\":{\"164\":7}}],[\"mock\",{\"1\":{\"164\":6}}],[\"mongodb\",{\"1\":{\"56\":1}}],[\"mimode\",{\"1\":{\"291\":1}}],[\"microsoft\",{\"1\":{\"291\":1}}],[\"mirrors\",{\"1\":{\"291\":10}}],[\"milliseconds\",{\"1\":{\"285\":1,\"286\":1}}],[\"millisecond\",{\"1\":{\"268\":2}}],[\"misc\",{\"1\":{\"292\":1}}],[\"mis\",{\"1\":{\"263\":1}}],[\"mib\",{\"1\":{\"238\":42}}],[\"mit\",{\"1\":{\"140\":1}}],[\"midebuggerserveraddress\",{\"1\":{\"291\":1}}],[\"mid\",{\"1\":{\"70\":4}}],[\"might\",{\"1\":{\"51\":1}}],[\"minframesize\",{\"1\":{\"200\":1}}],[\"mini\",{\"1\":{\"293\":3}}],[\"minigc\",{\"1\":{\"247\":1}}],[\"ministmt\",{\"1\":{\"227\":1}}],[\"minimal\",{\"0\":{\"217\":1},\"1\":{\"293\":1}}],[\"minimum\",{\"1\":{\"0\":1}}],[\"minit\",{\"1\":{\"200\":1}}],[\"minint\",{\"1\":{\"129\":1}}],[\"min\",{\"1\":{\"47\":1,\"73\":1,\"129\":1,\"284\":1}}],[\"minclient\",{\"1\":{\"47\":1}}],[\"mutator\",{\"1\":{\"245\":1}}],[\"mutex>\",{\"1\":{\"88\":3}}],[\"mutex\",{\"1\":{\"63\":1,\"64\":1,\"123\":1,\"263\":3}}],[\"munmap\",{\"1\":{\"237\":2}}],[\"mu\",{\"1\":{\"63\":1,\"123\":1,\"124\":9,\"129\":9,\"130\":3,\"131\":2,\"136\":10,\"137\":1,\"263\":2}}],[\"must\",{\"1\":{\"13\":1,\"48\":1,\"188\":1,\"200\":4,\"213\":1}}],[\"multilib\",{\"1\":{\"291\":1}}],[\"multilwwregister<t>\",{\"1\":{\"18\":1}}],[\"multilwwregister\",{\"1\":{\"18\":3}}],[\"multiverse\",{\"1\":{\"291\":10}}],[\"multiply\",{\"1\":{\"218\":3}}],[\"multi\",{\"0\":{\"18\":1},\"1\":{\"11\":1,\"19\":1,\"119\":1}}],[\"m\",{\"0\":{\"203\":1},\"1\":{\"5\":1,\"68\":5,\"71\":6,\"181\":4,\"194\":1,\"198\":5,\"199\":19,\"200\":45,\"203\":5,\"219\":14,\"238\":8,\"240\":9}}],[\"menuconfig\",{\"1\":{\"291\":2,\"292\":1,\"293\":1}}],[\"mexit\",{\"1\":{\"200\":1}}],[\"mechanism\",{\"1\":{\"136\":1}}],[\"messagestream\",{\"1\":{\"160\":1}}],[\"messagetobyteencoder<tinyprotocol>\",{\"1\":{\"146\":1}}],[\"message\",{\"1\":{\"123\":1,\"126\":1,\"157\":1,\"161\":1}}],[\"me\",{\"1\":{\"123\":5,\"124\":5,\"129\":3,\"130\":1,\"131\":1,\"133\":1,\"136\":2,\"215\":1}}],[\"method\",{\"1\":{\"263\":1,\"293\":1}}],[\"methods\",{\"1\":{\"98\":1}}],[\"meta\",{\"1\":{\"151\":1}}],[\"metafile\",{\"1\":{\"98\":1}}],[\"metadata\",{\"1\":{\"79\":7,\"89\":5}}],[\"memstats\",{\"1\":{\"238\":2,\"268\":1}}],[\"memclrnoheappointers\",{\"1\":{\"202\":1}}],[\"memmove\",{\"0\":{\"207\":1},\"1\":{\"200\":1,\"206\":1,\"207\":19}}],[\"memory\",{\"1\":{\"198\":1,\"231\":3,\"236\":2,\"237\":1,\"238\":4,\"239\":1,\"247\":4}}],[\"mem\",{\"1\":{\"170\":1,\"210\":3,\"237\":2,\"238\":5}}],[\"member\",{\"1\":{\"69\":1,\"113\":1,\"115\":2,\"117\":1}}],[\"memtable\",{\"1\":{\"4\":49,\"5\":4}}],[\"means\",{\"1\":{\"28\":2}}],[\"merged\",{\"1\":{\"282\":6}}],[\"merge\",{\"1\":{\"4\":4,\"6\":1,\"14\":1,\"17\":2,\"282\":3}}],[\"mask\",{\"1\":{\"294\":8}}],[\"master\",{\"1\":{\"4\":1}}],[\"mavx\",{\"1\":{\"212\":1}}],[\"malg\",{\"1\":{\"200\":1}}],[\"malloc\",{\"1\":{\"200\":1,\"233\":1,\"234\":3,\"237\":2,\"241\":9,\"242\":2,\"243\":3,\"247\":1}}],[\"mallocinit\",{\"1\":{\"200\":1}}],[\"mac\",{\"1\":{\"217\":2}}],[\"macos\",{\"1\":{\"212\":1}}],[\"mach\",{\"1\":{\"200\":1}}],[\"machine\",{\"1\":{\"199\":3,\"200\":1}}],[\"macthindex\",{\"1\":{\"129\":1}}],[\"marksuper\",{\"1\":{\"266\":1}}],[\"markobject\",{\"1\":{\"244\":4}}],[\"markroots\",{\"1\":{\"244\":3}}],[\"markall\",{\"1\":{\"243\":2}}],[\"marked\",{\"1\":{\"243\":7,\"244\":2,\"292\":1}}],[\"mark\",{\"0\":{\"243\":1},\"1\":{\"235\":1,\"242\":2,\"243\":14,\"244\":5}}],[\"marktemp\",{\"1\":{\"227\":1}}],[\"martin\",{\"1\":{\"164\":1}}],[\"marc\",{\"1\":{\"8\":2}}],[\"magicnumber\",{\"1\":{\"146\":3}}],[\"magic\",{\"1\":{\"146\":3}}],[\"man\",{\"1\":{\"215\":1}}],[\"manager\",{\"1\":{\"58\":5,\"62\":1,\"64\":9,\"69\":1,\"70\":2,\"71\":2,\"93\":3,\"94\":6}}],[\"manifesto\",{\"1\":{\"0\":1}}],[\"may\",{\"1\":{\"47\":1}}],[\"makes\",{\"1\":{\"285\":1}}],[\"makeslicepointer\",{\"1\":{\"262\":1}}],[\"make\",{\"1\":{\"28\":2,\"79\":1,\"124\":2,\"129\":3,\"131\":2,\"133\":1,\"136\":1,\"137\":1,\"187\":1,\"188\":3,\"200\":3,\"207\":3,\"208\":1,\"218\":2,\"219\":2,\"224\":1,\"225\":1,\"227\":2,\"238\":4,\"241\":1,\"262\":1,\"283\":1,\"284\":1,\"291\":6,\"292\":2,\"293\":1,\"294\":1}}],[\"mattn\",{\"1\":{\"191\":1}}],[\"materialization\",{\"1\":{\"78\":1}}],[\"math\",{\"1\":{\"14\":2}}],[\"matchindex\",{\"1\":{\"126\":3,\"129\":15,\"134\":4,\"136\":4}}],[\"matches\",{\"1\":{\"30\":1}}],[\"match\",{\"1\":{\"13\":1,\"26\":1,\"47\":1,\"48\":1}}],[\"maps\",{\"1\":{\"200\":2}}],[\"map和filter函数的实现可以说是既简洁又明确\",{\"1\":{\"181\":1}}],[\"mapfunc函数类型用于数据映射\",{\"1\":{\"181\":1}}],[\"mapfunc\",{\"1\":{\"181\":6,\"184\":1}}],[\"mapperelement\",{\"1\":{\"173\":2}}],[\"mappernode\",{\"1\":{\"172\":3,\"173\":2}}],[\"mappernodes\",{\"1\":{\"172\":3}}],[\"mapperconfiginputstream\",{\"1\":{\"172\":2}}],[\"mapperconfig\",{\"1\":{\"172\":3}}],[\"mapperconfigs\",{\"1\":{\"172\":4}}],[\"mapperparser\",{\"1\":{\"172\":4,\"173\":1}}],[\"mapper\",{\"0\":{\"173\":1},\"1\":{\"172\":1,\"173\":1}}],[\"mappers\",{\"1\":{\"172\":1}}],[\"mapperselement\",{\"1\":{\"172\":2}}],[\"mappers>\",{\"1\":{\"170\":1}}],[\"mappingtype\",{\"1\":{\"69\":3}}],[\"map<page\",{\"1\":{\"64\":1}}],[\"map<frame\",{\"1\":{\"63\":1}}],[\"map<objid\",{\"1\":{\"28\":1}}],[\"map<string\",{\"1\":{\"13\":1,\"14\":4,\"18\":1,\"26\":1,\"50\":2,\"174\":1}}],[\"map\",{\"0\":{\"18\":1,\"29\":1},\"1\":{\"13\":1,\"14\":4,\"18\":8,\"19\":1,\"26\":1,\"27\":1,\"28\":3,\"35\":2,\"50\":2,\"51\":8,\"63\":8,\"150\":1,\"177\":2,\"181\":7,\"184\":2,\"188\":3,\"190\":1,\"218\":4,\"219\":4,\"237\":1,\"238\":2,\"263\":5}}],[\"mainstarted\",{\"1\":{\"200\":2}}],[\"mainpc\",{\"1\":{\"200\":2,\"251\":1}}],[\"maintaining\",{\"1\":{\"88\":1}}],[\"main\",{\"0\":{\"202\":1},\"1\":{\"5\":1,\"144\":1,\"179\":1,\"180\":31,\"181\":2,\"190\":2,\"197\":1,\"200\":40,\"210\":2,\"217\":30,\"218\":1,\"219\":16,\"225\":2,\"227\":11,\"231\":1,\"234\":1,\"237\":1,\"238\":3,\"251\":3,\"256\":3,\"257\":9,\"286\":2,\"291\":11,\"294\":1}}],[\"maxobjects\",{\"1\":{\"243\":5,\"244\":1}}],[\"maxopcount\",{\"1\":{\"28\":1}}],[\"maxstacksize\",{\"1\":{\"200\":2}}],[\"maxmcount\",{\"1\":{\"200\":1}}],[\"maxbytesfileread\",{\"1\":{\"98\":1}}],[\"maxbytesperfile\",{\"1\":{\"98\":1}}],[\"maxclient\",{\"1\":{\"47\":1}}],[\"maximum\",{\"1\":{\"28\":1,\"282\":1,\"283\":1}}],[\"max\",{\"1\":{\"4\":2,\"14\":2,\"47\":1,\"69\":5,\"71\":2,\"72\":3,\"73\":2,\"284\":1,\"285\":3}}],[\"过\",{\"1\":{\"283\":1,\"285\":1}}],[\"过程相对简单一些\",{\"1\":{\"241\":1}}],[\"过程如下\",{\"1\":{\"212\":1}}],[\"过程中\",{\"1\":{\"124\":1}}],[\"过去的代码开发过程中\",{\"1\":{\"165\":1}}],[\"过去二十年时间\",{\"1\":{\"0\":1}}],[\"过度曲解\",{\"1\":{\"0\":1}}],[\"过分追求速度\",{\"1\":{\"0\":1}}],[\"敏捷宣言\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
